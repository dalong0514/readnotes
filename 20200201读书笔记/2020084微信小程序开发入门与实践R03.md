# 2020084微信小程序开发入门与实践R03.md

## 记忆时间

2020-03-07/

## 10. 电影

### 1. 逻辑脉络

利用 wx.request 和后端服务交互。使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中；tabBar 控件和嵌套模版的使用。tabBar 在 app.json 里设置，跳转到带 tabBar 的页面，需要用 wx.switchTab 方法。

### 2. 摘录及评论

本章我们编写了一个类似「豆瓣影评」的小功能，所有数据来自于豆瓣开放的 API。通过编写这部分的功能，我们将学习如何使用 wx.request 获取真实的网络数据，并将这些数据「填充」到小程序中。此外，本章中最重要的内容是多层嵌套模板的使用技巧，多层嵌套模板的优势将在本章中得到体现。此外本章还指出了很多小程序的「坑」，希望可以帮助开发者节约宝贵的时间。

电影部分同文章部分属于同一级别，我们在本章的开始部分使用小程序提供的 tab 选项卡来实现电影模块和文章模块的切换。需要注意的是，我们不需要自己编写代码实现 tab 选项卡。小程序提供了现成的 tab 选项卡，我们只需要在 app.json 中配置一些参数即可实现 tab 选项卡的效果。

tab 选项卡的配置是通过 app.jon 文件中的 tabBar 选顼来实现的。在配置 tab 选项卡之前，我们新建一个页面 movie 页面（位于 pages/movie 目录下）。或者直接在 app.json 的 pages 选项下新增 ρages/move/move 并保存，这将直接在 pages/move 目录下新建 movie 页面的 4 个页面文件。接着配置文章和电影页面的 tab 选项卡，代码如下：

黑色加粗部分是新增的代码。tabbar 配置项有以下几个属性：1）color 未选中时的 tab 选项卡文字颜色。2）selectedColor 选中时 tab 选项卡文字颜色。3）backgroundColor，tab 选项卡背景颜色。4）borderstyle，tab 选项卡上边框的颜色，注意它只支持 black 和 white 两个取值，默认是 black。5）list，tab 选项卡列表，是一个数组，接受一组 object 对象，我们在后面会具体给出每个对象的属性。6）position 可选值有 bottom 和 top，默认为 bottom，指定选顼卡位于底部还是顶部。

1『小程序里的对象，对应于 python 里的字典。』

再来具体看看 list 这个数组。list 数组的每一项都是一个 object 对象，每个 object 对象代表一个 tab 选项，最少必须有两个 tab 选项，而最多只能有 5 个 tab 选项。tab 选项卡出现的顺序由数组中 object 的顺序来决定。object 对象包含以下几个属性：1）pagePath，每个 tab 选项的页面路径。注意，用于 pagepath 的路径必须预先已在 app.json 的 pages 中定义。2）text，tab 选项卡上出现的文字。3）iconPath，tab 选项卡上的图片路径，图片大小限制为最大 40KB，建议尺寸为 81x81px。4）selectedlconPath，选中是的图片路径，图片大小限制为最大 40kb，建议尺寸为 81x81 px。

这里要特别注意，对于 pagePath、iconPath 和 selectedlconPath 这几个路径，一定不要以「/」开头。即使它们看起来是绝对路径也不要在路径前面加「/」 。在 pagePath 前面加「/」将导致错误。如果在 iconPath 前加「/」 ，虽然在模拟器中不会出现问题，但将项目在真机上预览时（在开发工具的「项目」里点击「预览」时）开发工具将报如图 10-2 所示的错误。

此时，我们保存并运行代码，会发现页面停留在 welcome 页面，点击「开启小程序之旅」，页面没有反应。如果在 welcome.js 的 navigateTo 中设置了 fail 函数，点击「开启小程序之旅」就将进入 navigateTo 的 fail 函数中。

为什么会出现这样的情况？我们在 4.112 小节中介绍 redirecTo 和 navigateTo 时，提到过这两个方法只能用于不帯 tab 选顼卡的页面。此时要跳转的 post 页面已经被设置成了带选项卡的页面，所以无论使用 redirecTo 还是 navigateTo 都不能成功跳转，必须使用 4.11.2 小节中我们提到的另外一个导航方法 wx.switchTab 方法，才能成功跳转到帯有 tab 选项卡的页面。修改 welcome.js 页面的 onTapJump 方法。

以上代码仅仅是将原先所调用的 wx.NavigateTo 修改成了 wx.switchTab。保存并运行代码，此时再次点击 welcome 页面的「开启小程序之旅」，可以成功打开 post 页面。此时的 post 页面底部出现了ー个 tab 选项卡，如图 10-3 所示。

可以通过点击「文字」和「光影」进行文章和电影页面的切换。需要特别注意的是，wx.redirecTo 和 wx.navigateTo 无法跳转到带有 tab 选项卡的页面；同理，使用 wx.switchTab 也无法跳转到不带 tab 选项卡的页面。它们各司其职，不能滥用。开发者还可以尝试ー下 tab 选项卡在页面上部的布局，将 app.json 中 tabBar 配置下的 position 由 「bottom」修改为「top」，tab 选项卡将出现在页面的上部，如图 10-4 所示。可以看到在上部的 tab 选项卡是不包含 tab 图标的，即使你设置了 tab 的图标也不会出现。

### 10.2 电影页面介绍

电影模块部分总共有以下几个展示模块：1）电影首页展示正在热映、即将上映和豆瓣 top250 三种类型的电影。2）每种电影只展示最前面 3 部。3）每种电影有一个「更多」按钮，点击将打开一个新页面，展示该类型下所有的电影。4）支持电影搜索功能。5）点击任意一部电影都将打开电影详情页面。

开发者可以参考本书彩页中的设计图，直观且详细地了解各个功能模块。所有电影数据均来自于豆瓣电影开放 API，以下是豆瓣电影 API 文档的地址：[豆瓣 Api V2（测试版） | douban-api-docs](https://douban-api-docs.zce.me/)

1『原书的链接失效了，上面的是搜索到的有关豆瓣 API 的信息，API 是数据挖掘里一个重要的数据源。具体技术还要去深入了解。发现豆瓣官方 API 已经关闭了。[zce/douban-api-proxy: 一个豆瓣 API 的反向代理，旨在解决豆瓣屏蔽小程序请求问题（豆瓣接口 403 问题）](https://github.com/zce/douban-api-proxy)』

对于电影页面的编写，我们将大量使用 template 模板，甚至是使用多层次嵌套模板。图 10-5 解释了电影模块中所有页面及模板的结构关系。开发者不需要现在马上看明白上面的结构关系图，只需要在后续章节中时时回顾一下此图即可。箭头中没有标注包含数量的表示只包含个模板。

我们大概解释一下以上关系调用图：电影功能部分总共有 3 个页面，分别是电影首页、更多电影和电影详情页面以及 1 个电影搜索模块（电影搜索不是单独的一个页面，位于电影首页）。以电影首页为例：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板由 n 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含 1 个 stars-tpl 模板。我们基本可以人以上 3 个示意图中完全解析出模板的嵌套关系：电影首页由 3 个 movie-list-tpl 模板构成，每个 movie-list-tpl 模板又由 3 个 movie-tpl 模板构成，而每个 movie-tpl 模板又包含了 1 个 stars-tρl 模板。从图 10-5 中我们可以看到，嵌套模板的使用可以避免编写重复代码，大量的 wxml 代码将被复用。如果你已经忘记了 template 模板的使用，请回顾一下本书第 5 章的内容。

### 10.3 编写豆瓣星星评分组件：stars-tpl 模板

当点击 tab 选项卡的「光影」选项时将跳转到电影首页。在 10.3-10.5 这 3 节中，我们将连续编写 3 个模板。对于这些模板，我们只需要大概浏览一下它们的骨架结构，对于 {{}} 中所绑定的数据，无须太过关心。当这 3 个模板被编写完成并在电影首页中传入数据调用时自然会明白每个份所绑定的数据意义。

在 10.2 节中，我们分析了电影首页的模板构成。下面我们首先编写电影首页所需要的几个模板，这里从最小的模板（stars-tpl 模板）开始编写。在 movie 目录下新建一个 stars 文件夹，并在该文件夹下新建两个文件：stars-tpl.wxml 和 stars-tpl.wxss。随后在 stars-tpl.wxml 中新增以下代码：

```
<template name="starsTpl">
  <view class="stars-container">
    <view class="stars">
      <block wx:for="{{stars}}" wx:for-item="i">
        <image wx:if="{{i===1}}" src="/images/icon/wx_app_star.png"></image>
        <image wx:elif="{{i===0.5}}" src="/images/icon/wx_app_star@half.png"></image>
        <image wx:else="{{i===0}}" src="/images/icon/wx_app_star@none.png"></image>
      </block>
    </view>
    <text class="star-score">{{score}}</text>
  </view>
</template>
```

stars 模板是需要从外部传入一些数据才可以正常使用的，所以我们现在无法直接预览 stars 模板的效果。stars 模板接收一个数组作为参数，这里先给出接收数组的形式：[1,1,1,0,0] 表示 3 星评价，[1,1,1,1,1] 表示 5 星评价，[1,1,1,0.5,0] 表示 3 星半。注意，模板中 3 个 image 组件的使用技巧在前面的已提过，条件渲染不仅仅可以使用 wx:if 和 wx:else，还可以多层次地使用 if else if else......3 个 image 组件中的 if else 展示了这种多层次条件的用法。

block 标签将循环评分数组，循环一定会执行 5 次，出现 5 颗星星，但会根据数据组中当前位的取值是 1、0.5 还是 0 来决定当前的星星图片是满星、半星还是空星。这样评分组件的星级就实现。同时 {{star}} 还需要绑定一个评分的分数，这个分数也需要由外部传入。接着，我们在 stars-tpl.wxss 中编写 stars 模板的样式。

以上就是 stars-tpl 模板的全部代码，我们暂且放下，接着编写其他模板的代码，最后再将这些模板组装起来。

### 10.4 编写 movie-tpl 模板

接着我们编写电影首页中需要用到的另外一个模板：movie-tpl。模板的示意图请参考图 10-7。在 pages 的 movie 目录下新建一个 single-movie 目录，用来存放 movie-tpl 模板。在 /pages/movie/single-movie 目录下新建两个文件：movie-tpl.wxml 和 movie-tpl.wxss 文件。首先在 movie-tpl.wxml 中编写 movie-tpl 模板的骨架代码：

```
<import src="../stars/stars-tpl.wxml"></import>
<template name="movieTpl">
  <view class="movie-container" catchtap="onMovieTap" data-movie-id="{{movieId}}">
    <image class="movie-img" src="{{coverageUrl}}"></image>
    <text class="movie-title">{{title}}</text>
    <template is="starsTpl" data="{{stars:stars,score:average}}"></template>
  </view>
</template>
```

在以上代码的顶部我们使用 import 引入了在 10.3 节中定义 stars-tpl 模板。Moive-tpl 模板由一张电影海报、电影标题以及 stars-tpl 模板构成。对于整个 movie-tpl 模板，我们在其容器上注册了一个事件 onMovieTap，并绑定了当前电影的 id 号 —— movield。

需要注意的是，stars-Tpl 模板的 data 属性，该属性将 stars 数组和 score 评分传入 stars-Tpl 中（请开发者回顾一下 10.3 节中的 tars-Tpl 定义），那么 movie-tpl 模板中的 stars 数组和 score 评分又是从哪里来的呢？答案依然是从外部传入的。在 10.5 节中编写 movie-list-tpl 时将看到如何传入这两个参数。接着编写 move-tpl 模板的样式。注意，在样式的顶部我们依然需要引入 stars-tpl 模板所使用的样式。

### 10.5 编写 movie-list-tpl 模板

直接被电影首页调用的模板是 movie-list-tpl 模板，movie-list-tpl 模板中引用了 movie-tpl 模板，而 movie-tpl 模板中又引用了 stars-tpl 模板。这就是我们所说的 3 层模板嵌套关系。首先在 pages/movie 目录下新建 movie-list 目录，接着在 movie-list 目录下新建两个文件：movie-list-tpl.wxml 和 movie-list-tpl.wxss 文件。下面编写 movie-list-tpl 模板的骨架。在 movie-list-tpl.wxml 中添加以下代码：

```
<import src="../single-movie/movie-tpl.wxml"></import>
<template name="movieListTpl">
  <view class="movie-list-container">
    <view class="inner-container">
      <view class="movie-head">
        <text class="slogan">{{categoryTitle}}</text>
        <view class="more" catchtap="onMoreTap" data-category="{{categoryTitle}}">
          <text class="more-text">更多</text>
          <image class="more-img" src="/images/icon/wx_app_arrow_right.png"></image>
        </view>
      </view>
      <view class="movies-container">
        <block wx:for="{{movies}}" wx:for-item="movie">
          <template is="movieTpl" data="{{...movie}}"></template>
        </block>
      </view>
    </view>
  </view>
</template>
```

1『上面引入的文件错了，应该是：\<import src="../single-movie/single-movie.wxml">\</import>』

同样，我们在代码的开头部分使用 import 引入 movie-tpl 模板，并在 block 标签中使用 move-tpl 这个模板。注意 template 标签中的 data 属性，我们在这里将 movie-tpl 模板所需要的数据传进去。接着编写 movie-list-tpl 模板的样式。在 movie-list-tpl.wxss 文件中编写以下代码：

注意在代码的开头部分使用 import 引入 movie-tpl 模板所使用的 movie-tpl 模板的样式文件 movie-tpl.wxss。

### 10.6 电影首页的骨架与样式

在我们编写好 3 个 template 组件后，电影首页的骨架编写将变得非常简单，只需要在电影首页中引用 movie-list-tpl 模板即可。

在 movie.wxml 页面中添加以下代码：

```
<import src="movie-list/movie-list-tpl.wxml" />

<view class="container" wx:if="{{containerShow}}">
  <view class="movies-template">
    <template is="movieListTpl" data="{{...inTheaters}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...comingSoon}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...top250}}"/>
  </view>
</view>
```

注意，在代码开头部分使用 import 引入了 movie-list-tpl 模板。同时在本段代码中使用了 3 次 movie-list-tp 模板，分别代表 inTheaters正在热映、comingSoon 即将上映和 top250 经典电影 3 种类型的电影。接着编写电影首页的样式。在 move.wxss 文件中添加以下代码：

### 10.7 豆瓣电影 API 分析

在编写电影首页的 js 调用豆瓣 API 之前，我们首先应当对豆瓣电影 API 有一个直观的认识和了解。所谓开放 APl，是指某些公司、企业将自己公司所持有的数据、用户数据选择性地开放给开发者调用，让开发者可以使用数据并围绕这些数据构建自己的应用，从而帮助公司、企业完善其平台和生态。

目前，绝大多数的开放 API 都属于 RESTFUl 风格的 APl，比如豆瓣 API、github 开发者 API 等。豆瓣 API（V2 版）就属于这类 API，其 API 权限有 3 种：公开、高级和商务。所有开发者无须申请即可调用公开权限的 APl，但只有部分 API 是公开权限的，一些高级接口无法调用，且公开 API 具有 40 次 / 分钟的访问限制。如果开发者在调试代码时遇到豆瓣返回错误信息，就有可能是因为已经超过允许访问的次数。这个时候唯一的办法就是稍等片刻。高级权限和商务权限需要开发者向豆瓣发邮件申请。

本书中所调用的豆瓣 API 均为公开 API，所以要注意访问频率限制的问题。在 Orange Can 项目中总共使用了以下几个豆瓣电影 API：1）获取正在热映的电影。2）获取即将上映的电影。3）获取豆瓣 top250 电影。4）电影搜索。5）获取电影条目信息（电影详情数据）。以获取豆翔瓣 top250 的 API 地址为例，一个完整的获取豆瓣 top250 电影的 API 地址为：

1『官方接口已关闭。』

在以上 APl 中，我们向豆瓣请求 top250 电影中的前 15 条电影信息。start=0 和 count=15 是查询参数，可根据需求自行调整，但要注意每次加载最多只能获取 20 条数据，count 超过 20 是没有意义。开发者可直接在浏览器中输入以上 URL 地址，豆瓣将返回我们需要的数据，返回数据的类型是 JSON 类型，如图 10-9 所示。关于其他几个 API 接口的使用方法，我们将放在后续实例编码中讲解。

### 10.8 电影首页的 js 编写

电影首页 js 的编码工作主要做以下 3 件事情：1）调用豆瓣 APl 获取电影数据。2）处理豆瓣电影数据。3）绑定豆瓣电影数据。

首先在 app.js 中的 globalData 中加入ー个全局变量 doubanBase，用来记录豆瓣 APl 的基地址。因为所有豆瓣的 API 访问都需要这个基地址，所以我们将它单独放在全局变量中，并在其他需要的地方获取这个全局变量。

```
  // 全局变量
  globalData: {
    userInfo: null,
    doubanBase: "https://api.douban.com",
  }
```

接着编写 move.js 中的代码。首先在 movie.js 中新增 Page 方法，并在 Page 方法的参数中定义 data 初始化数据及页面 onLoad 函数。

1『怪不得不加 page 方法前，进入电影页面显示不出来，console 里显示「onhide: 页面被隐藏」。』

1『上面的 api 替换成 GitHub 的，「https://api.github.com/search/repositories?q=language:python&sort=stars」。』

在 onLoad 函数中，主要拼接了 3 个不同的豆瓣 API，分别用来获取正在热映、即将上映和豆瓣 top250 电影的数据。这 3 个 API 唯一的区别在于 URL 路径中的一小段路径 /v2/movie/key 中的 key 不同:「正在热映」的 key 是 in_theaters，「即将上映」的 key 是 coming_soon，「top250」的 key 是 top250。注意，我们使用 "?start=0&count=3" 指定仅获取每种类型电影的前 3 条数据，因为在我们的业务需求中只需要每种类型的前 3 条数据。

在 data 属性中，预先定义了 3 个对象：inTheaters、comingSoon 和 top250。这 3 个对象将用于数据绑定，开发者可回顾一下代码清单 10-9。在代码清单 10-9 中，分别将这 3 个对象绑定到了 template 模板上。在代码清单 10-12 的末尾部分，调用了 3 次 this.getMovieListData 方法。这个方法的作用就是根据传入的 urI 获取和处理数据。在 10.9 节中，我们将编写这个方法。

### 10.9 wx.request 发送 http/https 请求

目前我们还没有编写 getMovieListData 方法，现在在 movie.js 的页面中添加这个方法。getMovieListData 接受 3 个参数：url、settedKey 和 categoryTitle。url 被用来访问并获取豆瓣电影数据，settedKey 被用来作为不同类型电影数据绑定的 key，categoryTitle 被用来作为电影的分类标题，最终将被显示在 move-list-tpl 的标题上（参考代码清单 10-7）。

getMovieListData 的核心代码是 wx.request 方法的使用，是小程序提供的发送 http 和 https 请求的方法，类似于传统 Javascript 编程中所使用的 ajax 方法。

wx.request(object) 方法用于发送 http / https 请求，并接受服务器返回的请求结果。Object 参数包含以下几个属性用于配置请求参数：1）url，String 类型，开发者服务器接口地址。2）data，Object 或者 String 类型，请求的参数。3）header，Object 类型，设置请求的 header。注意，在 header 中不能设置 referer，因为在小程序中 referer 是一个固定格式的值，格式固定为 https://servicewechat.com/{appid}/{version}/page-frame.html，其中 {appid）为小程序的 appid、{version} 为小程序的版本号，版本号为 0 表示开发版。4）method，String 类型，默认为 GET，有效值为 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT。注意，method 的取值必须大写。

请求参数：5）dataType，String 类型，默认为 json。如果设置了 dataType 为 json，就会尝试对响应的数据做一次 JSON.parse。6）success，Function 类型，收到开发者服务成功返回的回调函数。函数会被传入一个 res 参数开发者可通过 res.data 来获取服务器返回的内容。7）fail，Function 类型，接口调用失败的回调函数。8）Complete，Function 类型，接口调用结束的回调函数（调用成功、失败都会执行）。

开发者可能注意到，在代码清单 10-13 中，我们在设置 header 的 content-type 时给出了一个奇怪的参数值：json。既没有给出常见的 application/json, 也没有直接省略掉 content-type 这个选项（官方文档中明确指出 content-type 的默认值是 "application/json")。原因是以下几个选项都无法正确调用豆瓣 API：1）不设置 content-type；2）content-type: 'application/json'；3）content-type:''。

在目前的 13040 版本中，如果将 content-type 设置为以上几个取值，那么豆瓣 API 将返回如图 10-10 所示的错误信息。经过反复调试发现，content-type 可以被指定为任意不为空的字符串：1）content-type:'json'；2）content-type:'xxxxxx'；3）content-type:'appli'。只要 content-type 不为空或者是 application/json, 就可以正确调用豆辦 API 并获取到豆瓣的返回数据。为了让 content-type 看起来合理一些，在 Orange Can 项目中ー律使用 content-type:json 的形式作为 content-type 的取值。

对于 wx.request，还有以下几个注意事项：1）url 中不能有端口。2）wx.requeste 的默认超时时间和最大超时时间都是 60s。3）wx.request 的最大并发数是 5。

3『

[RequestTask | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html)

```
wx.request({
  url: 'test.php', //仅为示例，并非真实的接口地址
  data: {
    x: '',
    y: ''
  },
  header: {
    'content-type': 'application/json' // 默认值
  },
  success (res) {
    console.log(res.data)
  }
})
```

』


1『

一些公开 api：[public-apis/public-apis: A collective list of free APIs for use in software and web development.](https://github.com/public-apis/public-apis)

https://autocomplete.clearbit.com/v1/companies/suggest?query=segment

https://api.github.com/search/repositories?q=language:python&sort=stars

报错：https://api.github.com 不在以下 request 合法域名列表中。

需要进小程序账号里，在开发者设置里，服务器域名里添加 request 合法域名。但添加的域名一定要是备案过的，否则不行。

』

### 10.10 设置 wx.request 的超时时间

很多开发者可能想知道如何在小程序中设置超时时间，答案是在 app.json 文件中配置这个超时时间。在 app.json 中除了我们之前讲到的 pages、window、tabBar 等常用的配置项外，还有一个 networkTimeout 配置项。networkTimeout 配置项用来配置各类网络请求的超时时间：1）request，wx.request 的超时时间，单位为毫秒，默认值为 60000。2）connectSocket，wx.connectSocket 的超时时间，单位为毫秒，默认值为 60000。3）uploadFile，wx.uploadFile 的超时时间，单位为毫秒，默认值为 60000。4）downloadFile，wx.downloadFile 的超时时间，单位为毫秒，默认值为 60000。

我们可以在 app.json 中添加以下代码来设置各类请求的超时时间；当然，如果目前位置只使用 wx.request 请求，只设置 request 这个配置项也是可以的。如果服务器在 20 秒内没有响应，那么 wx.request，将进入 fali 函数。

### 10.11 处理返回的电影数据

在代码清单 10-13 中，我们使用 wx.request 来获取豆瓣 APl 所提供的电影数据。需要注意的是，wx.request 是一个异步方法，且小程序只提供了异步发送 http / https 请求的方法，没有同步版本。所以，不要尝试使用以下方法来获取 wx.request 的返回值：

    var result=wx.request(object)

对于同步的方法，可以使用以上方式来获取返回结果；但对于异步方法，只能在异步方法所提供的回调函数中进行返回结果的处理。比如在 wx.request 中，就只能在 wx.request 所提供的 success 回调函数中处理豆瓣的返回结果。回顾一下代码清单 10-13，在 success 回调函数中，我们使用 res.data 来获取豆瓣 API 的返回结果，接着调用了一个 processDoubanData 方法来处理豆瓣 API 的返回数据，从豆瓣加载回来的数据格式如图 10-11 所示。开发者可自行使用 Postman 或者 Fiddler 来调用豆瓣 API 查看返回的数据格式。目前，我们还没有实现 processDoubanData，下面来编写这个函数。

这个函数接收 3 个参数，第一个参数 moviesDouban，就是我们从豆瓣获取来的电影数据，processDoubanData 的主要功能就是处理 moviesDouban；第二个、第三个参数在之前已经解释过，这里只是简单地传入到 processDoubanData 中，在最后才绑定到 setData 方法中。

for 循环将遍历所有豆瓣电影的数据，并将豆瓣的数据格式转化成我们需要的命名格式，temp 就是一个临时保存转化后电影数据的变量。最后将所有豆瓣电影数据处理完后调用 js 的 Aray.push 方法将 temp 加入 movies 数组中，最终形成我们需要的电影数据数组。

在 for 循环中处理豆瓣电影数据时，调用了一个 util.convertToStarsArray 方法将豆瓣的评分格式转化成我们需要的数组格式一一形如 [1,1,0,0,0] 的形式（开发者可回顾一下 10.3 节）。豆瓣 API 返回的关于评分的数据格式为 50（表示 5 星）、35（表示 3 星半）、00 (0 星或者还没有星级），util.convertToStarsArray 的任务就是将这些 50、35、00 等星级的简写形式转化成 [1,1,1,1,1]、[1,1,1,0.5,0] 和 [0,0,0,0,0] 等需要的数组形式，以方便 stars-tpl 模板使用。

在 util.js 中加入一个 util.convertToStarsArray 函数。记住，util 是一个模块，添加完方法后需要使用 module.exports 输出。随后，要想在 movie.js 中引用 util，还需要在 move.js 顶部引用 util 模块。完成以上代码的补充后，我们才能够在 movie.js 中调用 util.convertToStarsArray(subject.rating.stars) 方法。

### 10.12 绑定处理后的电影数据

在代码清单 10-15 的最后我们使用了以下代码进行数据绑定：

```
    var readyData = {};
    readyData[settedKey] = {
      categoryTitle: categoryTitle,
      movies: movies
    }
    this.setData(readyData);
```

这是一种动态设置数据绑定 key 的方法。由于我们并不知道当前处理的数据是哪一种电影类型（inTheaters、comingSoon、top250），因此将当前所处理的电影数据类型通过 settedKey 一路传递到 processDoubanData 方法中，并通过 readyData[settedKey] 生成一个包含 settedKey 的 Javascript 对象。

假设当前处理的数据是 inTheaters 类型，那么以上代码在最终调用 this.setData(readyData) 时相当于以下形式：

```
this.setData({
    inTheaters:{
        categoryTitle: '正在热映',
        movies: movies
    }
})
```

如果当前处理的数据是 comingSoon 类型，那么以上代码在最终调用 this.setData 时相当于以下形式；这样的写法实际上考验的是开发者对 Javascript 动态属性的理解。此时，保存并运行代码，电影首页显示如图 10-12 所示的样式。如果数据没有正确加载，请参考下节的内容。

### 10.13 http 和 https 在小程序中的使用说明

为了保证数据的安全性，小程序中强制要求使用 https 且所访问的 https 地址必须在小程序的后台账号中被加入到可信域名中。图 10-13 是小程序开发账号的 https 可信域名配置的示意图。该配置项位于小程序账号的「设置」→「开发设置」选项中。理论上，小程序是不允许使用 http 请求来获取数据的，也不允许访问未在可信域名列表中配置的 https 地址。以上限制的前提条件是：在真机上。

如果是在客户端的开发工具中，有以下几种方法可以不需要遵守以上两个规则。

第一种方法。如果在创建小程序项目时选取的是无 appid（必须拥有小程序账号才可以获得），那么开发工具不会限制你访问 https，更不会比对可信域名列表。这种方法的缺点就是：当你偶尔想真机预览下小程序时，还需要重新新建项目并填入 appid。

第二种方法。如果在创建小程序项目时填入了 appid 那么默认情況下小程序将强制你使用 https 且会将你所访问的 https 地址与可信域名列表做比对。如果你试图在一个配置了 appid 的小程序项目客户端开发工具中访问 http 地址，那么开发工具会报错，如图 10-14 所示。无论你使用 http 或者使用不在可信域名列表里的 https 地址都将提示图 10-14 所示的错误（可信域名列表不能够设置 http，所以试图访问 http 地址一样会提示不在可信域名列表中）。解决的办法是，在可信域名列表中配置你要访问的 https 域名。

第三种方法。小程序在开发工具侧边栏的「项目」选项卡中提供了「开发环境不校验请求域名以及 TLS 版本」的选项，勾选这个选项你可以随意在开发工具中使用 http 或者未加入 https 可信列表的 https 地址。

1『解决之前「域名不合法」的问题。获取了 github 接口里的信息。』

以下是一些建议：1）如果你没有 appid，那么只能选择无 appid。2）如果你有 appid，那么建议在新建项目时填写这个 appid，并在开发期间勾选「开发环境不校验请求域名以及 TLS 版本」，待正式发布或者需要真机预览时再去小程序账号中配置你所使用的 https 地址。如果项目中没有使用网络请求，那么真机预览时也不需要配置 https 的可信域名列表。3）如果你在 Orange Can 项目中遇到无法访问的问题，可以参考上面所描述的内容。

### 10.14 跳转到更多电影页面

之前，我们完成了电影首页的编写。电影首页总共展现了 3 种类型的电影，共 9 部。如果我们需要査看每种类型的全部电影，就需要编写「更多电影」这个页面。「更多电影」是通过点击电影首页的「更多」按钮来打开新页面的，如图 10-15 所示。首先新建 more-movie 页面。在 app.jon 文件的 pages 数组下新增 more-movie 页面的路径，如下代码所示：

添加以上代码后保存项目，将自动生成 more-movie 页面的 4 个页面文件。我们首先实现跳转到 more-movie 页面的代码。通过图 10-15 可以看到，「更多」按钮是位于 movie-list-tpl 模板中的。我们回顾一下 movie-list-tpl.wxml 中的代码。

在 movie-list-tpl.wxml 中的 \<view class="more"> 标签上，我们已经注册了ー个 onMoreTap 事件，且在这个标签上也已经绑定了一个 data 数据：data-category="{{categoryTitle}}"。实现跳转到 more-movie 页面的关键就在于实现这个 onMoreTap 函数，并在 onMoreTap 函数中使用 wx.navigateTo 方法跳转到 more-movie 页面中去。同时，我们还必须将 categoryTitle 这个变量同时传递到 more-movie 页面里去，从而使 more-movie 页面能够准确地加载「更多」的电影数据。

在 movie.js 中新增以下代码，以实现 onMoreTap 方法。开发者可能会觉得奇怪，「更多」按钮是位于 movie-ilst-tpl 模板中的，但应这个按钮的 js 方法却要写在另外一个页面的 js 文件 movie.js 中。这确实是非常奇怪也难以理解的。关于这个问题，我们已经在前面的内容中讲解过：小程序只实现了模板化，而没有实现组件化，模板是不具备运行 Javascript 代码能力的。所以，我们只能将模板的业务逻辑编写在其他页面的 js 文件中，再将处理好的业务数据传递到模板中。

```
  // 跳转到更多页面
  onMoreTap: function (event) {
    var category = event.currentTarget.dataset.category;
    wx.navigateTo({
      url: "more-movie/more-movie?category=" + category
    })
  },
```

### 10.15 编写 movie-grid-tpl 模板

如同我们在实现电影首页页面时所做的，我们首先来编写「更多电影」页面所需要的模板 movie-grid-tpl 模板。图 10-16 展示了 movie-grid-tpl 模板的实际效果图。这个模板将像「九宫格」一样放入很多的电影（真实的数据远不止 9 部电影），以展示更多电影的效果。在 /pages/move 下新建一个 movie-grid 目录，并在目录下新建 movie-grid-tpl.wxml 和 movie-grid-tpl.wxss 文件。我们首先来编写 movie-grid-tpl 模板的骨架。在 movie-grid-tpl.wxml 文件中加入以下代码：

```
<import src="../single-movie/single-movie.wxml" />
<template name="movieGridTpl">
  <view class="grid-container">
    <block wx:for="{{movies}}" wx:for-item="movie" wx:key="movieId">
      <view class="single-view-container">
        <template is="movieTpl" data="{{...movie}}" />
      </view>
    </block>
  </view>
</template>
```

我们可以看到 movie-grid-tpl 的骨架代码非常简单。为什么这么几句代码就可以实现复杂的「九宫格」效果。模板再次发挥了巨大的复用作用。很明显 movie-grid-tpl 仅仅起到的是组织布局的作用，而核心的骨架代码已经被封装在了 movie-tpl 模板中。我们在 movie-grid-tpl 中的 block 标签中循环调用 movie-tpl 模板，以实现显示多部电影的目的。

在之前编写的 movie-list-tpl 里，我们已经使用过了 movie-tpl，这里再次使用 movie-tpl 就体现了模板的优势，它避免了我们重复编写 wxml 代码。笔者认为用好模板将大大简化代码，提高代码的可阋读性与可维护性。接着编写 movie-grid-tpl 模板的样式代码。在 movie-grid-tpl.wxss 文件中加入以下样式代码；同样要注意引入 move-tpl.wxss 文件。

### 10.16 编写「更多电影」页面

在编写完 more-movie 页面所需要的核心 template 模板后，我们来编写 more-move.wxml 文件。令人吃惊的是，你几乎不需要编写任何代码，只需要在 more-movie.wxml 页面中引入 movie-grid-tpl 模板即可。在 more-movie.wxml 页面中加入以下代码：

```
<import src="../movie-grid/movie-grid-tpl.wxml" />
<template is="movieGridTpl" data="{{movies}}" />
```

接着编写 more-movie 页面的样式。在 more-movie.wxss 文件中加入以下代码：

```
@import "../movie-grid/movie-grid-tpl.wxss";
```

几乎不需要编写代码，我们就完成了 more-movie 页面的骨架和样式代码的编写工作。接着我们还需要编写 more-movie 页面的 js 代码。more-movie 页面的 js 代码所需要完成的工作几乎同 move 电影首页的 js 代码相同。依然遵守着获取数据 → 处理数据 → 绑定数据的步骤。实际上，获取数据 → 处理数据 → 绑定数据的流程几乎是小程序 js 文件编写的通用思路与步骤。在 more-movie 页面中添加以下代码：

首先，我们在 data 中设置 movies 绑定变量的初始化值。movies 变量将最终被用作 wxml 的数据绑定变量。接着，在 onLoad 函数中接收由 movie 电影首页传递过来的 category 分类。根据分类的不同拼接不同数据访问 APl 的地址。这里我们没有在 API 的 URL 后面附带 start 和 count 参数，如果不附带这两个参数，那么默认将一次加载 20 条电影数据。

为了避免反复编写 wx.requestl 的复杂结构，我们在 util 模块中编写了ー个 http 方法，作为所有豆辦 API 调用的公共方法，当我们需要访问豆瓣 API 时，不需要重复调用 wx.request 方法，只需要调用这个封装好的 http 方法即可。util.http 方法接收两个参数：第一个参数是需要访问的 API 地址；第二个参数是一个回调函数，用来处理豆瓣 API 的返回结果。

processDoubanData 方法同 move 电影首页中的 processDoubanData 类似，都是用来处理豆瓣的返回数据，并在处理完成后将处理的数据进行绑定。由于在 more-movie 页面中我们已经明确了电影类型，因止此 processDoubanData 的编写简単了很多，只需要明确处理「正在热映」「即将上映」和「top250」3 种类型中的一种即可。下面来看看 utilhttp 方法是如何编写的。在 util.js 文件中加入 http 方法。

1『还是要提醒下，封装完方法后记得在最下面的输出 module 里把该方法输出。』

将所有调用豆瓣 API 的操作封装成一个函数的好处是，一旦调用操作和流程发生变化，只需要修改这个函数即可。比如，header 的 content-type 支持 application/json 取值，无须在多处修改，只需要修改 util.http 方法即可。编写完 http 方法后，记得使用 module.exports 方法将 http 方法暴露出去，以供其他页面 / 模块访问。保存并运行项目，再次点击「更多」按钮，页面将从 movie 电影首页跳转到 more-movie（更多电影）页面，且 more-movie 页面正确地呈现出 20 部电影，如图 10-17 所示。

### 10.17 实现页面下拉刷新的「三部曲」

下拉刷新是 APP 上经典的一个动作。本节我们将学习如何在小程序中实现下拉刷新数据的功能。在小程序中，不需要自己实现下拉刷新代码编写。小程序已经为我们准备好了下拉刷新的相关配置和 API。

实现一个页面的下拉刷新操作需要分为 3 步：1）步骤 01 在页面的 json 文件中配置 enablePulLDownRefresh 选项，打开下拉刷新开关。2）步骤 02 在页面的 js 文件中编写 enablePulLDownRefresh 函数，完成自己的下拉刷新逻辑。3）步骤 03 编写完下拉刷新逻辑代码后，主动调用 wx.stopPulLDownRefresh 函数停止当前页面的下拉刷新。我们首先来完成第一步。在 more-movie.json 文件中加入以下代码：

当在 more-movie.json 中加入以上代码后，more-movie 页面的下拉刷新就开启了。此时下拉 more-movie 页面将出现下拉效果。由于下拉刷新的等待标示默认是白色，因此你无法明显地看到下拉刷新的等待状态标示。我们可以修改等待标示的默认颜色，在 more-movie.json 文件中添加一个配置项。

```
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark"
}
```

这样当再次下拉刷新 more-movie 页面时，我们将看到等待标示，如图 10-18 所示。当然，你也可以在 app.json 的 window 配置项中配置 backgroundTextStyle:"dark" 选项，这将导致所有页面的下拉刷新等待标示都变成 dark。同理，你也可以在 app.json 的 window 配置项中配置 enablePulldownRefresh:true 选项，这将导致所有页面都开启下拉刷新。

接着我们来完成第二步。当页面打开下拉刷新开关后，每当用户下拉页面都将触发执行页面的 enablePulldownRefresh 函数。这就是小程序给我们编写下拉刷新逻辑的函数。在 more-movie.js 文件中编写 enablePulldownRefresh 函数。（备注，参考项目里的源码这段不一样）

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl + "?star=0&count=20";
    util.http(refreshUrl, this.processDoubanData);
  },
```

整个函数的代码非常简单，仅仅是再一次访问了豆瓣 API 并重新获取了最新的第 1 到第 20 条数据。注意，在函数中我们获取当前豆瓣 APl 的 URL 地址时使用了 this.data.requestUrl（这个变量是在 onLoad 函数中保存下来的）。所以，我们修改一下 more-movie 页面的 onLoad 函数，在 onLoad 函数中将当前访问的 URL 地址记录一下。

编写完以上代码后，我们可以反复尝试下拉刷新 more-move 页面。当然，从 UI 上是无法直接看到刷新效果的，因为豆瓣的电影数据不可能更新得非常频繁。我们可以尝试打开 Network 面板，观察一下每次下拉刷新后是否有向豆瓣发送请求，如果有请求发向豆瓣，就说明 onPulldownRefresh 函数成功触发了。图 10-19 所示的示意图显示了 3 次下拉刷新 more-movie 页面后 Network 面板的请求发送情况。

最后，我们来完成下拉刷新「三部曲」中的第三步，主动停住页面刷新状态。停住页面刷新状态非常简单，在合适的时机调用 wx.stopPulLDownRefresh 方法即可。

我们需要考虑的是在什么时候调用 wx.stopPulLDownRefresh()。当然应该是在处理完豆瓣返回数据并再次调用 this.setData 重新绑定数据后调用 wx.stopPulLDownRefresh() 函数。在 more-movie.js 页面的 processDoubanData 方法中调用 wx.stopPullDownRefresh() 即可。完成以上代码后，more-move 页面的下拉刷新操作就全部完成了。下拉刷新三部曲是笔者总结的编写下拉刷新功能时的常见思维步骤，以供开发者参考。

1『牢记下拉三部曲。』

### 10.18 在模拟器中可执行下拉刷新但在真机中无法执行下拉刷新的常见错误

在开启下拉刷新开关时，我们需要在页面的 json 文件中设置 enablePullDownRefresh 选项为 true。如果不小心将 enablePullDownRefresh 选项设置成了字符串 "true"，而非 Boolean 类型的 true，就将导致在模拟器中可执行下拉刷新但在真机上（仅测试 iOS 系统）无法执行下拉刷新的现象。虽然官方文档明确地指出 enablePullDownRefresh 配置选顼的值类型是 Boolean，但真机行为同开发工具中行为不一致显然是不能接受的，这将增加测试成本，并有可能引起严重的 bug。

### 10.19 json 中的 backgroundColor 配置的是哪里的颜色

官方文档中对 backgroundColor 这个配置项的解释是「配置窗口的背景色」，但这个文档中并没有明确解释窗口是什么、处于小程序的哪个部位。很多开发者都尝试设置 backgroundColor，但均无法看到设置效果，这会让人误以为这个配置选项是无效的，造成这个误解的主要原因是开发工具模拟器中的小程序和真机上小程序在执行下拉动作时有一些区别。

开发工具模拟器中的小程序是无法向下拉动的（如果不设置下拉刷新），但在真机上，无论你是否设置下拉刷新，导航栏以下的页面部分都可以向下拉动。拉动后，在导航栏和页面中间会有块儿「空白」，backgroundColor 可以设置这块儿空白的颜色。在模拟器中，可以通过设置下拉刷新看到这块儿区域。我们可以做一个测试来看看效果，在 more-movie.json 文件中增加一个 backgroundColor 配置选项。

```
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundTextStyle": "dark",
  "backgroundaColor": "black"
}
```

增加以上配置选项后，再次下拉刷新 more-movie.js 页面，我们将看到如图 10-20 所示的刷新效果。注意图中框起来的页面部分。这个部分的颜色将变成我们在 more-movie.json 文件中设置的 backgroundColor 颜色：黑色。

真机上的小程序存在一个问题，当配置导航栏颜色后，由于在真机上，即使不设置页面的下拉刷新，也会存在一个下拉的动作，露出一块儿白色的区域。这块儿白色的区域非常难看，我们可以通过设置页面的 backgroundColor 属性来配置这块儿区域的颜色。首先在 app.json 中配置全局的窗口背景颜色。

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#4A6141",
    "navigationBarTitleText": "大龙的书屋",
    "navigationBarTextStyle": "black",
    "backgroundColor": "#4A6141"
  },
```

接着，将 welcome 页面的窗口颜色单独配置。通过以上设置将使小程序在真机上，即使下拉页面，也不会出现「空白」。

```
{
  "navigationBarBackgroundColor": "#ECC0A8",
  "backgroundColor": "#ECC0A8"
}
```

### 10.20 实现上滑加载更多数据

上滑加载更多数据又是另一个经典的 APP 操作。在本节中，我们将在小程序的 more-movie 页面中实现这个经典的操作。目前的 more-movie 页面只能显示最多 20 条数据，因为豆瓣 API 最多只允许我们一次加载 20 条数据，若想显示更多的电影数据，则需要实现分步加载。在传统的 Web 网页上，我们通常是通过分页来实现显示更多数据。在移动端，更常见的操作是不考虑页码，通过不断地上滑页面来实现加载更多数据。

实现上滑加载更多的关键点在于何时触发「加载更多」这个操作。很明显，当页面「触底时」就可以执行「加载更多」这个操作了。小程序在页面的 Page 中提供了ー个 onReachBottom 函数。onReachBottom 将在每次页面上滑触底后触发执行。所以，我们只需要编写小程序提供的 onReachBottom 函数即可实现 more-movie 页面的上滑加载更多数据的功能。在 more-movie.js 页面中新增 onReachBottom 函数。

```
  // 实现上滑加载更多操作
  onReachBottom: function (event) {
    var totalCount = this.data.movies.length;
    //拼接下一组数据的URL
    var nextUrl = this.data.requestUrl + "?start=" + totalCount + "&count=20";
    util.http(nextUrl, this.processDoubanData)
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

以上代码是实现上滑加载更多操作的核心代码。在 onReachBottom 函数中，我们拼接了一个 nextUrl 作为取下一组电影数据的 URL。start 指定起始电影的条数，该数值等于当前页面已经绑定的电影条目条数，count 指定了最多取 20 条（当然不指定 count 也是可以的，因为默认最多取 20 条）。

现在的问题是，我们如何知道当前已经显示了多少条电影条目呢？此时，我们需要调整下思路。我们将 this.data.movies 这个数组视作一个保存当前页面所有电影数据的数组。每当新增加 20 条数据后，我们都需要将新增的 20 条数据追加到这个 this.data.movies 数组中。

数据可以通过合并的形式追加到 this.data.movies 数组中，那么如何将新增的电影数据在 UI 上追加到已显示的电影后面呢？回顾一下我们在关于文章评论的 7.16 节中是如何将新的评论追加到已存在评论后面的。再次强调，要使用数据绑定的思维，而不要使用习惯的 DOM 思维来考虑问题。没有追加，只有重新绑定和渲染整个 this.data.movies 数组。所以，我们要做的就是将新加载的电影数据与已存在的电影数据合并在一起，并更新 this.data.movies。修改 more-movie.js 文件中的 processDoubanData 函数。

1『这里的 this 应指向 Page() 对象。』

黑色加粗部分标记出了新增以及修改的代码。加粗部分代码将每次新增加的电影数据同已存在的电影数据合并在一起，并再次使用 this.setData 进行数据更新。this.setData 在做数据更新的同时也更新了 this.data.movies 这个变量，以确保 this.data.movies 变量永远记录的是当前页面的全部电影数据。

还有一个小问题是我们要考虑的，即当 more-movie 页面多次加载数据后如何处理下拉刷新这个操作。假设我们已经加载了 5 次共 100 条电影数据，那么此时去下拉刷新 more-movie 页面，理论上应该更新全部的 100 条数据，但是对于豆瓣电影没有必要这样处理。我们简化一下处理流程。无论 more-move 页面有多少条电影数据，每当执行下拉刷新操作时都清空所有已存在的电影数据，重新加载最新的前 20 条数据。根据以上思路，修改 onPullDownRefresh 函数。

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl +
      "?star=0&count=20";

    //刷新页面后将页面所有初始化参数恢复到初始值
    this.data.movies = [];
    util.http(refreshUrl, this.processDoubanData);
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

黑色加粗部分为新增加的代码。当下拉刷新触发 onPullDownRefresh 函数后将 this.data.movies 清空。完成以上代码后，现在每当我们在 more-movie 页面上滑触底后页面都将触发 onReachBottom 事件，从而实现加载更多电影数据。

1『新增代码解答了之前「源码不一致」的疑惑。』

3『

javascript 语言中 this 关键字的用法，this 代表着当前的对象，它在程序中随着执行的上下文随时会变化。var that=this 用法的一个例子：[微信小程序开发日记：重要的var that=this - 简书](https://www.jianshu.com/p/1ab0b8c4c078)。

[深入理解 JavaScript 中的 this 关键字 - Rain Man - 博客园](https://www.cnblogs.com/rainman/archive/2009/05/03/1448392.html)

在 JavaScript 中 this 变量是一个令人难以摸清的关键字，this 可谓是非常强大，充分了解 this 的相关知识有助于我们在编写面向对象的 JavaScript 程序时能够游刃有余。结论：this 所指的就是直至包含 this 指针的上层对象。调用形式是普通函数，this 指向全局对象 window；调用形式是对象的方法，this 指向该对象；调用形式是构造函数，this 指向新构造的对象。

1、一般用处。对于 this 变量最要的是能够理清 this 所引用的对象到底是哪一个，也许很多资料上都有自己的解释，但有些概念讲的偏繁杂。而我的理解是：首先分析 this 所在的函数是当做哪个对象的方法调用的，则该对象就是 this 所引用的对象。

```
var obj = {};
obj.x = 100;
obj.y = function() { alert( this.x ); };
obj.y();    //弹出 100
```

这段代码非常容易理解，当执行 obj.y() 时，函数是作为对象 obj 的方法调用的，因此函数体内的 this 指向的是 obj 对象，所以会弹出 100。

```
var checkThis = function() {
    alert( this.x); 
};
var x = 'this is a property of window';

var obj = {};
obj.x = 100;
obj.y = function(){ alert( this.x ); };

var obj2 = obj.y;

obj.y();   //弹出 100
checkThis();    //弹出 'this is a property of window
obj2();    //弹出 'this is a property of window
```

这里为什么会弹出 'this is a property of window'，可能有些让人迷惑。在 JavaScript 的变量作用域里有一条规则「全局变量都是 window 对象的属性」。当执行 checkThis() 时相当于 window.checkThis()，因此，此时 checkThis 函数体内的 this 关键字的指向变成了 window 对象，而又因为 window 对象又一个 x 属性（ 'this is a property of window'），所以会弹出 'this is a property of window'。上面的两个示例都是比较容易理解的，因为只要判断出当前函数是作为哪个对象的方法调用（被哪个对象调用）的，就可以很容易的判断出当前 this 变量的指向。

1（obj2();  为什么显示那个结果没弄明白。）

2、this.x 与 apply()、call()。通过 call 和 apply 可以重新定义函数的执行环境，即 this 的指向，这对于一些应用当中是十分常用的。

```
function changeStyle( type , value ){
    this.style[type] = value;
}

var one = document.getElementById( 'one' ); 
changeStyle.call(one , 'fontSize' , '100px'); //正确用法
changeStyle('fontSize' , '300px');  //出现错误，因为此时 changeStyle 中 this 引用的是 window 对象，而 window 并无 style 属性。
```

注意 changeStyle.call() 中有三个参数，第一个参数用于指定该函数将被哪个对象所调用。这里指定了 one，也就意味着，changeStyle 函数将被 one 调用，因此函数体内 this 指向是 one 对象。而第二个和第三个参数对应的是 changeStyle 函数里的 type 和 value 两个形参。最终我们看到的效果是 Dom 元素 one 的字体变成了 20px。

```
function changeStyle( type , value ){
    this.style[ type ] = value;
}

var one = document.getElementById( 'one' ); 
changeStyle.apply( one , ['fontSize' , '100px' ]); //正确用法
changeStyle('fontSize' , '300px');  //出现错误，原因同示例三
```

apply 的用法和 call 大致相同，只有一点区别，apply 只接受两个参数，第一个参数和 call 相同，第二个参数必须是一个数组，数组中的元素对应的就是函数的形参。

3、无意义（诡异）的 this 用处。

```
var obj = {
    x : 100,
    y : function(){
        setTimeout(
            function(){ alert(this.x); }    //这里的 this 指向的是 window 对象，并不是我们期待的 obj，所以会弹出 undefined
         , 2000);
    }
};

obj.y();
```

如何达到预期的效果：

```
var obj = {
    x : 100,
    y : function(){
        var that = this;
        setTimeout(
            function(){ alert(that.x); }
         , 2000);
    }
};

obj.y();    //弹出100
```

4、事件监听函数中的 this。

```
var one = document.getElementById( 'one' );
one.onclick = function(){
    alert( this.innerHTML );    //this 指向的是 one 元素，这点十分简单。
};
```

以上可以归纳为：this 所指的就是直至包含 this 指针的上层对象。

』

### 10.21 动态设置导航栏 loading 图标

我们在前面实现了 more-movie 页面的下拉刷新电影数据与上滑加载更多电影数据的操作，但是整个加载数据的过程体验并不是那么好，总觉得缺少了点什么。拿上滑加载更多电影数据来看，从触发加载数据到数据显示，整个过程没有等待提示，当数据加载完成后「突然」就显示了出来。虽然我们建议目前的小程序不要使用太多的特效，但是必要的等待提示是用户最基本的心理预期，还是可以加上的。

在前面的章节中，我们学习过 wx.showToast 提示。wx.showToast 将在页面的中间位置显示一个模态或者非模态（showToast 的 mask 属性决定是模态还是非模态）的提示框。笔者认为，对于 loading 状态提醒，用这种置于页面中心位置的侵入式提醒体验并不好。Loading 并不需要很强的信息通知，用户不需要阅读文字，只需要能够感觉到正在加载即可，所以使用「侵入式」的 wx.showToast 并不是太合适。我们希望有一个「非侵入式」的 loading 状态提醒，只让用户从心理上感觉到页面正在加载即可。

小程序提供的一个 API 方法 wx.showNavigationBarLoading() 非常适合用于 loading 状态提醒。通常来说，wx.showNavigationBarLoading 和 wx.hideNavigationBarLoading 是成对出现的。一个负责显示 loading 状态图标，一个负责隐藏 loading 状态图标。图 10-21 显示了导航栏 loading，状态图标的效果。

考虑一下，我们需要在 more-movie 页面的哪些操作中调用 wx.showNavigationBarLoading 显示 loading 状态图标，又需要在什么地方调用 wx.hideNavigationBarLoading 隐藏状态图标。基本上，每次去豆瓣取数据时就应该显示 loading 状态，当数据处理完豆瓣电影数据并使用 this.setData 更新电影数据后应该调用 wx.hideNavigationBarLoading 方法隐藏 loading 状态。

具体到 more-movie 页面，我们可以在 onload 初始化加载电影数据时、onReachBottom 滑动加载更多电影数据时以及 onPullDownRefresh 下拉刷新电影数据时调用 wx.showNavigationBarLoading 显示 loading 状态图标，而在 processDoubanData 中处理完豆瓣数据后调用 wx.hideNavigationBarLoading 隐藏状态图标。在以上几方法中分别添加 wx.showNavigationBarLoading 与 wx.hideNavigationBarLoading 方法。

```
  onPullDownRefresh: function (event) {
    var refreshUrl = this.data.requestUrl +
      "?star=0&count=20";

    //刷新页面后将页面所有初始化参数恢复到初始值
    this.data.movies = [];
    util.http(refreshUrl, this.processDoubanData);
    //显示loading状态
    wx.showNavigationBarLoading();
  },
```

添加完以上代码后，开发者注意观察一下当正在加载数据时和数据加载完成后导航栏 loading 图标的显示和隐藏效果。这里要特別说明以下 3 点：

第一，下拉刷新时可以不使用导航栏的 loading 状态图标，因为下拉刷新本身在页面的窗体部分就有一个 loading 状态图标，如图 10-18 所示。

第二，在以上代码中，我们没有考虑数据加载失败的情况。如果数据加载失败，程序就无法进入 processDoubanData 方法中，从而导致无法执行 wx.hideNavigationBarLoading 方法，导航栏的 loading 图标一直显示。Orange Can 只是一个示例项目，如果完全模拟真实项目，需要写太多同小程序无关的代码，所以建议开发者在真实的项目中注意容错处理。「永远不要相信外部环境」是每个开发者要时刻牢记于心的真理。开发者可以尝试将隐藏 loading 图标的代码放在 wx.request 请求的 complete 函数中，这样无论数据加载是否成功都将隐藏 loading 图标。

2『永远不要相信外部环境，这句话的细节是什么。做一张金句卡片。』

第三，在 lonload 数中调用 wx.showNavigationBarLoading 函数设置页面导航栏是有风险的，原因我们已在 6.9.2 小节中解释过。当前版本没有问题，并不代表未来版本不会有问题，何况在 onReady 页面生命周期之后再操作界面元素是官方文档中明确说明的。所以建议开发者最好还是在页面的 onReady 函数中动态设置导航栏 loading 状态，同官方文档的要求保持一致。下面给出在 more-movie 页面的 onReady 函数中设置 loading 状态的代码，开发者可自行选择是否使用以下代码，毕竟在 130400 版本中在 onLoad 函数中设置 loading 状态也是没有问题的。

```
  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    wx.setNavigationBarTitle({
      title: this.data.navigateTitle
    });
    wx.showNavigationBarLoading()
  },
```

从设置 loading 状态标示这个小示例中我们应该能体会到小程序到底简单在什么地方。你无须过多考虑 loading 应该怎么去提示，小程序已经帮你「安排」好了。虽然这些固化的 API 让程序显得很没有个性，但是小程序的特性就是用完即走。有时候牺牲一些个性化与美观度，换来更高的开发效率与更低的开发成本是值得开发者考虑的。当然，如果你不满意小程序的 loading，完全可以自行编码来实现自己理想的 loading 状态机制。

### 10.22 电影搜索

在本节中，我们将实现电影搜索功能。电影搜索的效果图，如图 10-22 所示。我们并没有选择使用一个新的页面来编写电影搜索的功能，电影搜索位于 movie 电影首页。当激活搜索时，电影首页的资讯面板信息被隐藏，电影搜索面板被显示；相反，当退出电影搜索时电影搜索面板被隐藏，而电影资讯面板将被显示。

下面我们在电影首页中实现这个显示与隐藏的效果。在 move.wxml 中添加并修改以下代码：

```
<import src="movie-list/movie-list-tpl.wxml" />
<import src="movie-grid/movie-grid-tpl.wxml" />

<view class="search">
  <icon type="search" class="search-img" size="13" color="#405f80"></icon>
  <input type="text" placeholder="乘风破浪、西游伏妖篇" 
  placeholder-class="placeholder" bindfocus="onBindFocus" value="{{inputValue}}"
  bindconfirm="onBindConfirm"/>
  <image wx:if="{{searchPanelShow}}" src="/images/icon/wx_app_xx.png" class="xx-img" catchtap="onCancelImgTap"></image>
</view>

<view class="container" wx:if="{{containerShow}}">
  <view class="movies-template">
    <template is="movieListTpl" data="{{...inTheaters}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...comingSoon}}" />
  </view>
  <view class="movies-template">
    <template is="movieListTpl" data="{{...top250}}"/>
  </view>
</view>

<view class="search-panel" wx:if="{{searchPanelShow}}">
    <template is="movieGridTpl" data="{{...searchResult}}"/>
</view>
```

首先我们添加了一个 \<view class="search"> 容器，在该容器的内部实现了一个 inpute 的搜索栏， placeholder 属性设置了 input 的默认占位文字；placeholder-class 属性指定了 placeholder 样式类的类名，该样式将在随后被添加到 move.wxss 文件中。bindfocus 事件将实现鼠标或者手指激活 input 时显示搜索面板，bindconfirm 事件将实现提交搜索信息的功能。xx-img 将实现点击后关闭（隐藏）搜索面板。

同时，在 \<view class="container" wx:if="{{containerShow}}"> 这个电影资讯面板上增加一个属性 wx:if="{{containerShow}}"，这个属性也是用来控制电影资讯面板显隐状态的标识位。

最后，我们增加了一个 \<view class="search-panel" wx:if="{{searchPanelShow}}">。这个面板就是电影搜索面板，主要用来显示搜索结果。可以看到，在电影搜索面板中并没有编写任何代码，我们再一次地使用了 move-grid-tpl 模板。所以，我们在代码的顶部再次引用了 movie-grid-tp 模板。

添加完电影搜索的骨架代码后，我们来编写电影搜索的样式。在 move.wxss 文件中添加以下同电影搜索相关的样式：

记得在代码的顶部引用 move-grid-tpl 模板的样式。当编写完以上代码后，保存并运行项目，发现电影首页的电影内容「消失」了。由于我们没有正确地在 movie 页面的 js 文件中设置搜索面板同电影资讯面板的显隐控制变量，因此电影资讯面板默认被隐藏了。下面在 movie.js 的 data 变量中设置 searchPanelShow 与 containerShow 的默认值。


```
  /**
   * 页面的初始数据
   */
  data: {
    inTheaters: {},
    comingSoon: {},
    top250: {},
    containerShow: true,
    searchPanelShow: false,
    searchResult: {},
  },
```

黑色加粗部分是新增代码。除了设置「containerShow: true」让电影资讯面板显示、「searchPanelShow: false」让搜索面板隐藏外，我们顺便将搜索结果的初始化变量 searchResult 也加入 data 変量中。此时保存并运行代码，将出现如图 10-23 所示的效果。

以上代码实现了搜索面板与电影面板的初始化状态。现在，当用户激活 inpu 搜索栏准备输入关键字开始搜索时，我们需要显示搜索面板并隐藏电影资讯面板。已经注册在 input 组件上的 onBindfocus 事件将实现这个显隐切换效果。在 movie.js 中添加 onBindfocus 事件响应函数。

```
  // 切换面板
  onBindFocus: function (event) {
    this.setData({
      containerShow: false,
      searchPanelShow: true
    })
  },

```

当用户激活 input 组件后将执行 onBindfocus 函数。这将隐藏电影资讯面板，并显示搜索面板，准备接受用户输入，如图 10-24 所示。用户通过点击图 10-24 中 input 搜索框右侧的 X 图片，可以关闭搜索面板并再次打开电影资讯面板。在 move.js 中添加点击 X 图片的事件响应函数 onCancelImgTap。

```
  // 隐藏搜索代码
  onCancelImgTap: function (event) {
    this.setData({
      containerShow: true,
      searchPanelShow: false,
      searchResult: {},
      inputValue: ''
    }
    )
  },
```

在上述代码中，我们除了切换两个面板的显隐状态外，同时清空搜索结果 searchResult，保证下次再次进入搜索面板时，搜索面板不会记录上一次的搜索结果。将 inputValue 的值设置为空字符串将保证 input 组件所记录的用户输入值也一并被清空。

需要注意的是，input 组件的输入文本是无法设置字体的，因为在小程序中 input 组件是一个 native 组件，字体必须使用系统字体，所以无法设置 font-family。在真机上运行时，它也将被设置为真机系統的默认字体。

当用户输入关键字并按键盘上的「回车」或者点击真机上的「完成」后，小程序将触发 input 的 bindconfrn 事件，并执行已经注册在 input 上的事件响应函数 onBindConfrn。在 movie.js 文件中添加 onBindConfrn 事件响应函数：

```
  // 响应搜索事件
  onBindConfirm: function (event) {
    var keyWord = event.detail.value;
    var searchUrl = app.globalData.doubanBase +
      "/v2/movie/search?q=" + keyWord;
    this.getMovieListData(searchUrl, "searchResult", "");
  },

```

onBindConfirm 的代码非常简单，首先获取到用户的输入值 keyWord，这个值稍后将被附加到豆辧电影搜索 API 的 URL 地址中。豆瓣电影的搜索 API 地址为 /v2/movie/ search?q={keyword}，我们只需要将获取到的 keyWord 附加在 APl 地址中并调用 this.getMovieListData 方法即可。this.getMovieListData 方法早在编写 movie 页面的电影数据显示时已经编写好，这里只需要调用即可。this.getMovieListData 接收 3 个参数，searchUrl 是豆瓣 API 的数据访问地址，"searchResult" 指定将处理完毕的豆瓣数据绑定到 searchResult 变量上，以提供给 wxml 显示数据。

    <template is="movieGridTpl" data="{{...searchResult}}"/>

### 10.23 电影详情页面

下面我们来编写电影详情页面。先思考一下电影详情页面的入口在哪里。任何一个显示电影封面（见图 10-25）的地方都应该能够点击进入到电影详情页面，这些入口遍布在电影首页、电影搜素、更多电影等多个地方。好在我们是使用 template 模板构建的电影页面结构体系，所有的电影单体元素都集中在 movie-tpl 这个 template 模板里。也就是说，只需要在 move-tpl 模板上注册相应的点击事件即可。

在 10.4 节中，我们已经在代码清单 10-5 中注册了 move-tpl 的点击事件 onMovieTap。现在要做的就是在每个包含 move-tpl 的页面中编写 onMovieTap 事件响应函数，并在事件响应函数中将页面跳转到 move-detail 页面。

首先，新建 move-detail 页面并注册这个页面。在 app.json 的 pages 数组下注册 move-detail 页面。保存后开发工具将自动在 pages/movie/ movie-detail 目录下新建 move-detail 页面的 4 个页面文件。在以下两个使用过 move-tpl 模板的页面 js 文件中编写 onMovieTap 事件响应函数：movie.js 和 more-movle.js。

```
  // 跳转到详细页的事件函数
  onMovieTap: function (event) {
    var movieId = event.currentTarget.dataset.movieId;
    wx.navigateTo({
      url: "movie-detail/movie-detail?id=" + movieId
    })
  },
```

```
  onMovieTap: function (event) {
    var movieId = event.currentTarget.dataset.movieId;
    wx.navigateTo({
      url: '../movie-detail/movie-detail?id=' + movieId
    })
  },
```

注意以上两段代码所设置的 wx.navigateTo 的 urI 参数值是不同的。我们同时还将所点击电影的 id 号附加在 url 中，传递到 move-detail 页面中。movie-detail 只有知道电影的 id 号才能够正确地加载电影详情数据。

从以上两段代码，我们也可以再次看出小程序模板的缺陷：模板不能运行自己的业务逻辑代码。onMovieTap 的业务逻辑本应当属于模板自身的业务逻辑，但由于模板不可以运行 js 代码，因此只能将本属于模板的业务逻辑编写在调用模板的页面 js 代码中。在 Orange Can 项目中，我们幸运地只在两个页面引用了 move-tpl 模板，但如果有十几个地方引用了 move-tpl 模板，就不得不在这十几个地方一次编写上述代码。

当然，可以将模板的业务代码编写成一个类似于 url 一样的模块，并在其他页面里引用这个模块，但 onMovieTap 里的代码终究还是属于 movie-tpl 的，无论放在什么地方都不如放在模板自己的业务逻辑文件中。编写完以上代码后，无论是在 movie 页面、more-movie 页面还是是在电影搜索的结果页面上，点击任意电影都将跳转到 movie-detaile 电影详情页面。接下来，我们需要编写 movie-detail 电影详情页面的骨架与样式。电影详情页面的效果如图 10-26 所示。

### 10.24 电影详情页面的骨架和样式

本节我们开始着手编写 move-detail 电影详情页面的骨架与样式代码。在 move-detail.wxml 文件中添加以下代码：

注意，在 move-detail 页面中我们同样使用了 stars-tpl 模板，记得在代码的顶部引入这个模板文件。

骨架代码中并没有什么新鲜的知识，唯一值得关注的是我们使用了一个 scroll-view 组件。这组件用于横向展示多张演员图片，这些演员图片会「突破」手机尺寸的限制，在横向出现滚动条。图 10-27 展示了 scroll-view 的横向滚动效果图。scroll-view  组件的 scroll-x 和 scroll-y 分别设置组件的横向和纵向是否出现滚动条，如果想使用横向 scroll-view，就请设置 scroll-x="true"。

scroll-view 组件的横向排布要注意以下几个要点：1）如果 scroll-view 下排列的多个子元素是块级元素（比如 view），就直接对 scroll-view 设置 display:flex 和 flex-direction:row，不会使子元素自动成为水平排列。如果不使用 scrol-view 而将容器元素换成 view，那么设置 display:flex 和 flex-direction:row 是可以使子元素自动成水平排列的。2）如果想让 scroll-view 下的 view 元素水平排列，一种可行的方法是将子元素 view 设置为 inline-block 或者 inline-flex。3）子元素有可能会出现换行的情况，需要在容器上设置 white-space:nowrap。

我们会在后面的章节中详细讲解 scroll-view 的一些高级用法，现在我们只需要掌握这些 scroll-view 的简单用法即可。这里顺便提一下，scroll-view 中的 bindscrolltolower 事件也可以用来实现加载更多数据（类似于 Page 页面的 onReachBottom）。当 scroll-view 滚动到底部或者右边时将触发这个事件，实现原理请参考 more-movie 页面的 onReachBottom 函数。

实际上 Orange Can 项目最初在编写 more-movie 页面加载更多数据时也是使用的 scroll-view 的 bindscrolltolowerg 事件，但微信在 130400 版本更改了一些规则，官方文档中是这样描述的：在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动是无法触发 onPullDownRefresh 的。

在 130400 版本之前，scroll-view 的滚动同 onPullDownRefresh 下拉刷新事件是不冲突的，但版本更新后若使用 scroll-view 则在 scroll-viev 组件中下拉页面是无法触发 onPullDownRefresh 函数的。正是基于这个原因，笔者最后没有使用 scrolll-view 来实现 move-grid-tpl 模板，而是改为使用普通的 view，并使用 Page 的 onReachBottom 函数实现了加载更多数据的功能。

除此之外，scroll-view 还有以下几个需要注意的地方：1）请勿在 scroll-view 中使用 textarea、map、canvas、video 组件。2）scroll-into-view 的优先级高于 scroll-top。3）在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动是无法触发 onPullDownRefresh 的。4）若要使用下拉刷新，请使用页面的滚动，而不是 scroll-view，这样也能通过点击顶部状态栏回到页面顶部（经过测试发现，必须点击手机的状态栏而非小程序的导航栏才能返回页面顶部。请在豆瓣 top250 的「更多电影」页面测试此特性），如图 10-28 所示。

关于 scroll 的更详细介绍和高级用法请参考 13.2 节，本节我们仅使用 scroll-view 的基本功能。接着编写 movie-detail 页面的样式。将以下代码添加到 move-detail.wxss 文件中：

同样记得在代码的顶部引入 stars-tpl 模板的样式文件。-webkit-filter:blur(20px) 实现了图片模糊的效果。由于现在并没有编写页面的逻辑文件，因此我们暂时无法看到页面的显示效果。

### 10.25 编写电影详情页面的业务逻辑代码

现在编写 move-detail 电影详情页面的业务逻辑代码在 movie-detail.js 文件中添加以下代码：

整个代码逻辑非常简单，仅仅是获取数据并处理数据。豆瓣 API 获取电影详情数据的 URL 为 /v2/movie/subject/{subjectID}。需要注意的是，豆瓣的许多电影由于年代久远而导致数据有所缺失，这会造成很多「空值」情况。有些空值只会让数据无法显示，但程序不会报错；有些空值则会直接导致程序终端运行。对于第二种空值，我们一定要做容错处理。

导致程序终端的空值多是由于对象是 null 而我们却尝试去读取空对象的属性，这样的行为导致程序报错，无法继续运行。如果是字符串 null，那么绑定一个空字符串程序是不会报错的。豆瓣电影的数据结构非常复杂，无法一次将所有的属性都做容错处理，所以建议遇到错误时再回头编写容错代码。比如上述代码中对 directors 的属性处理就属于容错性处理。在以上代码中，又调用了两个 util 函数：util.convertToCastString 和 util.convertToCastInfos。现在在 util 模块中编写这两个函数。

1『bug 是永远消除不完的，一定要有管理 bug 的思维。』

### 10.27 设置电影页面的导航栏标题

所有配置或者是动态设置导航栏标题的方法在之前的章节中已详细讲解过，本节就不赘述了。下面直接给出配置代码。

首先，配置 movie 电影首页的导航栏标题，在 movie.json 文件中新增以下代码；接着，设置 more-movie 更多电影页面的导航栏标题。在 more-move.js 页面中添加以下代码，以保证 more-move 页面的导航栏标题被设置为当前电影的电影分类。将 category 电影类型暂时保存在 data 变量中，再在 more-movie.js 的 onReady 函数中读取这个变量并动态设置导航栏标题。最后，我们还需要将电影详情页面的导航栏标题动态设置为当前显示电影的电影标题。在 move-detail.js 文件的 processDoubanData 中新增一小段代码。编写完以上代码后，3 个电影页面的导航栏标题就全部设置完成了。

## 11. 设置

### 1. 逻辑脉络

小程序中众多的 APl，这些 API 包括获取用户基本信息、获取系统信息、获取网络状态、获取当前位置信息与速度信息、使用做信内置地图查看当前位置、使用监听罗盘数据接口制作一个建议的指南针、经典小功能摇一摇、二维码扫描以及下载文档并预览文档等。

### 2. 摘录及评论

### 11.1 设置页面

一个项目是不可能将小程序全部功能都使用到的，所以我们特意在 Orange Can 顼目增加了一个「设置」页面。这个页面将集成很多零散的小程序功能，比如获取用户微信信息、系统信息、网络状态、指南针、获取当前位置、摇一摇、扫描二维码等功能。不同于文章和电影页面，「设置」页面的功能类似于小程序 API 的示例集合，虽然没有实际意义，但是对于了解和学习这些 API 的使用方法有极大帮助。

首先，在 app.json 的 pages 数组下新建 setting（设置）页面的路径。setting 同 post 和 movie 一样，也属于 tab 选项栏中的一项，将 setting 页面加入到 tab 选项卡中。这样，Orange Can 项目的 tab 选项卡将有 3 个选项：post、move 和 setting。来看看 setting 页面的效果图，如图 11-1 所示。顶部显示当前用户的微信头像、微信昵称等信息；下面紧跟着的分别是缓存面板、设备面板、APl 面板以及其他杂项面板。每个面板下包含若干种小程序常用功能，点击可执行或演示相应的功能。下面编写 setting 页面的骨架结构。

我们没有直接将每个面板的子项内容编码在 wxml 文件中。由于每个面板下的子项较多，且有可能经常添加子项，因此没有直接将子项「硬编码」在 wxml 文件中，而是选用了一种「配置式」的编写方法。每个项目下的子项内容都将在 js 文件中「配置」，然后通过数据绑定和列表渲染动态的填充到 wxml 中。目前，由于我们还没有编写 setting 的 js 文件，列表渲染的各个数组都是「空值」状态，因此 setting 页面不会显示任何内容。接着，编写 setting 页面的样式，在 setting.wxss 文件中加入以下代码：

最后，编写 setting.js 文件，在 js 里加入我们的配置。以上代码在 setting.js 的 data 变量下加入了 4 个数组，分别对应 wxml 中的缓存面板数组、设备面板数组、API 面板数组以及其他杂项面板数组。每个数组子项都包含 iconurl、title 和 tap 三个属性。iconurl 代表子项图标的图片路径，title 代表子项的标题名，tap 是点击子项后所执行函数的函数名。

这样，如果以后我们想新增一个子项，只需要在 js 文件中增加配置即可。编写完以上代码后，保存并运行项目，setting 页面将呈现如图 11-2 所示的效果。顺便在 setting.json 文件中加入导航栏标题的配置。

### 11.2 获取用户基本信息

目前 setting 页面的顶部还是空白的，我们需要在小程序中获取用户的基本资料，并显示在 setting 页面的顶部。小程序提供了ー个 wx.getUserInfo(OBJECT) 方法来获取用户的信息。用户信息分为用户基本信息和用户 openId、Unionld。基本信息是明文的，而 openId 和 Unionld 是加密数据。这两种类型的数据都由 wx.getUserInfo(OBJECT) 方法返回。

用户基本信息包括以下 7 项：1）avatarUrl 用户微信头像的 URL 地址。2）City 城市。3）country 国家。4）gender 性别，1 表示男，2 表示女，0 表示未知。5）language 语言区域。6）nickname 昵称。7）province：省份。

在小程序中，用户的基本信息可以轻易获得，他们是明文的、不加密的。但 openId 和 Unionld 是加密的。什么是 openId 和 Unionld 呢？可以将 openId 和 Unionld 理解为用户在微信应用中的 id 号。他们的区别是：openId 只代表用户在某个徽信应用下的 id 号；而 Unionid 是跨应用的，同一用户在同一开发者的多个应用里，Unionld 是唯一的。

官方文档对于 Unionid 的描述非常清楚：如果开发者拥有多个移动应用、网站应用和公众账号（包括小程序），可通过 Unionid 区分用户的唯一性，因为只要是同一个微信开放平台账号下的移动应用、网站应用和公众账号（包括小程序），用户的 Unionid 就是唯一的。换句话说，同用户在同一个微信开放平台下的不同应用中，Unionld 是相同的。所以，openId 不能跨应用，如果要在多应用间统一用户身份，请使用 Unionld。这里要注意，在小程序中使用 Unionld 首先需要前往微信开放平台绑定小程序。详情请参考官方文档。

在小程序中获取用户的基本信息是非常简单的，但想拿到 openId 和 Unionid 却不是那么容易。本节先来学习如何获取用户的基本信息，获取加密信息在后面的章节中讲解。下面来看 wx.getUserInfo(OBJECT) 方法的使用。wx.getUserInfo(OBJECT) 的 OBJECT 参数有 3 个回调函数：success、fail 和 complete。在这 3 个回调函数中，重点介绍 success。

success 方法的返回值有以下 5 个：1）userInfo，用户基本信息对象，不包含 openId 等敏感信息。2）rawData，不包含敏感信息的基本信息字符串，通常用来计算签名，防止从微信返回的用户信息被簒改。3）signature，使用 sha1(rawData+ sessionkey) 得到字符串，用于校验用户信息。4）encryptedData，包括敏感数据在内的完整用户信息的加密数据。5）iv，加密算法的初始向量。

如果不是非常了解微信的加解密及身份认证机制，建议开发者先不要太过于纠结 signature、encryptedData、iv 这 3 个返回值，目前还不需要使用这 3 个参数。在后面的章节中会具体讲解这 3 个返回值的概念以及使用方法，本节只需要使用 userInfo 返回值。

现在，我们在 Orange Can 项目中获取用户的明文信息。首先，在 app.js 文件中的 globalData 对象下新增一个全局变量 g_userInfo，用来记录用户的基本信息。当我们需要在其他页面使用用户信息时，读取这个全局变量即可。

解释一下上述代码。为了避免每次启动小程序时都要在做信服务器中加载用户的基本信息，我们将用户信息保存到缓存中。这样，每次启动小程序时先去看看缓存有没有数据，如果没有，就调用 wx.getUserInfo 获取用户信息并保存到缓存和全局变量 g_userInfo 中；如果有，就直接将用户信息保存到全局变量 g_userInfo 里。

田心的开发者可能注意到，我们并不是直接调用 wx.getUserInfo(OBJECT) 方法，而是先调用 wx.login，在 wx.login 调用成功后再继续调用 wx.getUserInfo。之所以在 wx.login 调用成功后才调用 wx.getUserInfo，是因为官方文档明确指出了获取用户信息需要先调用 wx.login。同时，在官方的示例项目中也是先调用 wx.login。至于 wx.login 有什么作用，我们会在后面的章节中讲到，开发者可「依葫芦画瓢」，照做即可。

事实上，如果你只想获取用户的明文基本信息，那么不调用 wx.login，直接调用 wx.getUserInfo 也可以获取用户信息。所以，是否在调用 wx.getUserInfo 前调用 wx.login 请开发者自行決定。当第一次运行以上代码并调用 wx.getUserInfo(OBJECT) 时，小程序会弹出如图 11-3 所示的提示窗口，让用户选择是否授权获取用户的基本信息。用户点击「允许」后，才会执行 wx.getUserInfo 的 success 回调函数，如果点击「拒绝」，将执行 fail 回调函数。

有些开发者在测试时可能永远不会弹出这个授权窗口。因为如果当前项目没有 appld，那么用户信息是由微信模拟的信息，并没有进行真实的获取用户信息流程，所以不会出现这个窗口，且开发工具会有一个警告提示，如图 11-4 所示。

当然，这个用户数据也是真实的用户数据，因为你在使用开发工具时必须扫描二维码登录，这样开发工具就能知道你的微信身份，自然可以模拟返回你的用户数据。但模拟数据相比于真实的用户数据缺少 3 个属性，即 signature、encrypteddata 和 iv。也就是说，模拟数据只有明文信息而没有加密信息。

将用户信息保存到缓存中有一个缺点，就是没办法实时更新用户信息（比如用户更改了自己的微信资料），但这是具体业务的问题，需要开发者在实际项目编写中灵活处理。现在，可以在 setting 页面中通过访问 g_userInfo 全局变量获取并显示用户的基本信息，需要在 setting 页面的 onLoad 方法中添加以下代码。注意，在使用全局变量前，需要先调用 getapp() 方法获取小程序的 App 对象。保存并运行代码，setting 页面将正确显示用户的头像、昵称等信息。

1『

按作者的源码发现无法获取用户的基本信息，那么微信新版里的获取方法应该更新成了自动生成的那个 wx.getSetting 方法，它返回的是一个全局变量 userInfo。将作者的源码删掉，setting.js 里调用的数据改为 userInfo 即可显示用户的信息。

```
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function () {
    this.setData({
      userInfo: app.globalData.userInfo
    })
  },
```

』

### 11.3 数据缓存的异步操作

为了可以在真机上清除数据缓存，我们在设置里增加一个清除数据缓存的选顼。当用户点击这个选项时，首先会弹出一个 modal 模态窗口，如果用户点击「确定」，就可以清除用户的数据缓存。在 5.8.2 小节中，我们提到过所有缓存类 API 除了有一组同步方法外，还有一组异步方法。在本小节中，尝试使用异步的 wx.clearStorage 方法清除用户的数据缓存。setting 页面有许多选项需要使用 modal 窗口让用户确认操作，所以我们在 setting.js 文件中添加个显示 modal 的公共方法。

showModal 方法只是对 MINA 框架提供的 wx.showModal做了一次封装，设置了通用的颜色。showModal 方法还接收了一个回调函数 callback，用户点「确定」后执行这个回调函数。接着编写清除数据缓存的事件响应函数。从 data 中的 cache 配置来看，清除数据缓存的的事件响应函数为 clearCache。下面在 setting.js 文件中新增一个 clearCache 方法。

显然，异步缓存操作方法在写法上比同步要麻烦一些。要注意的是，以上只是一个简单的异步函数操作示例，所以看起来并不是那么「烦琐」，但在真实的项目中，往往有着非常复杂的业务逻辑。在 js 中，异步非常容易形成所谓的「回调地狱」，也就是在回调函数中连续嵌套调用回调函数，这会让代码的可阅读性変得非常糟糕。异步函数又一直存在着难以调试的问题。

关于同步和异步的选择，需要根据实际情况来決定，笔者的建议是优选选择同步方法。当同步方法的体验和效率太差或者同步方法无法解決问题时再考虑使用异步方法。至此，完成了 setting 页面的第一个小功能。

### 11.4 获取系统信息

系统信息的显示需要新建一个 device 子页面。下面在 app.json 文件的 pages 数组下新增 device 页面的路径。当我们点击「系统信息」时，setting 页面要跳转到 device 子页面，需要在 setting.js 中新增一个「系统信息」的点击事件响应函数。

```
  //显示系统信息
  showSystemInfo: function () {
    wx.navigateTo({
      url: 'device/device'
    });
  },
```

点击「系统信息」后，页面将跳转到 device 子页面。下面来编写 device 子页面的骨架和样式。在 device.wxml 和 device.wxss 中分别加入骨架代码和样式代码。MINA 框架所提供的获取系统信息的 API 是 wx.getSystemInfo 以及 wx.getSystemInfoSync 方法。前者是同步方法，后者是异步方法。选择同步还是异步，请根据自己的实际情况来考虑。

以下是 wx.getSystemInfo 方法可以获取的系统信息：1）model：手机型号。2）pixeRatio：设备像素比。3）windowWidth：窗口宽度。4）windowHeight：窗口高度。5）language：微信设置的语言。6）version：微信版本号。7）system：操作系统版本。8）platform：客户端平台。wx.getSystemInfo 的使用非常简单，在 device.js 文件中新增以下代码：

保存并运行代码，点击「系统信息」后将打开如图 11-5 所示的 device（系统信息）页面。要注意的是，在开发工具中以上信息多是模拟器模拟的参数。可以尝试在开发工具中调整当前机型，比如图 11-6 显示了当选择机型为 Nexus 6 时的系统信息。

### 11.5 获取网络状态

MINA 框架提供了 wx.getNetworkType 作为获取当前网络状态的接口。获取网络状态是一个异步方法，方法回调函数中可以接收一个 res 参数，使用 res.networkType 可以获得当前移动设备的网络状态。网络状态的可能取值有 6 种：2g、3g、4g、Wifi、none、unknown。在 setting.js 文件中添加以下事件响应函数：

```
  //网络状态
  showNetWork: function () {
    var that = this;
    wx.getNetworkType({
      success: function (res) {
        var networkType = res.networkType
        that.showModal('网络状态', '您当前的网络：' + networkType);
      }
    })
  },
```

要注意的是，在开发工具中网络状态是由开发者自己设定的，如图 11-7 所示。

### 11.6 获取当前位置信息与当前速度信息

### 11.7 使用微信内置地图查看位置信息

### 11.8 监听罗盘数据制作一个简易指南针

### 11.9 在小程序中实现摇一摇

### 11.10 扫码

### 11.11 获取小程序页面二维码

## 12. 开放接口

### 1. 逻辑脉络

12、微信开放接口。详细地介绍用户登录、用户信息校验、解析用户加密数据获取 openId、模板消息以及最重要的微信支付。

### 2. 摘录及评论

本章我们将学习微信开放接口。毫不夸张地说，微信的开放接口是微信类产品最有价值的一部分。没有微信开放接口，小程序的价值将大打折扣。即使你不是一个微信开发者或者你的小程序无须使用微信开放接口，但理解微信开放接口的设计原理对提升架构方面的知识也很有好处。关于开放接口这块儿，微信官方文档写得并不够详尽，本章将详细地介绍用户登录、用户信息校验、解析用户加密数据获取 openId、模板消息以及最重要的微信支付。

### 12.1 准备工作

调用微信小程序的开放接口要求开发者必须拥有小程序账号。拥有小程序账号的开发者拥有一个 appld，如果你的 Orange Can 现在没有 appld，请将 appld 加入 Orange Can 项目中。目前小程序开发工具没有提供加入 appld 的快捷方式，所以请开发者新建一个带有 appld 的项目并将目录指向 Orange Can 的文件目录。

本章内容需要使用小程序的 appSecret，小程序的 appld 和 appSecret 均可以在小程序账户的「设置」→「开发设置」→「开发者 ID」中获得。本章要实现的功能还需要调用服务器接口。本书中的服务器代码均采用 PHP 编写，并部署在本地的 Apache 服务器中。本章会给出所有 PHP 示例代码，你也可以下载我们提供的 PHP 示例代码，并部署在本地或网络服务器上。以下 url 地址是用户登录接口的示例地址：

http://localhost:8080/wxopen/wxlogin.php

1『把作者的源码放到 XAMPP 里的 htdocs 文件夹里，然后通过端口访问：http://192.168.64.2/2020084wxserver/wxLogin.php。』

注意，如果在项目中填写了 appld 且服务器在本地，那么调用本地 http 接口时一定要勾选「项目」中的「开发环境不校验请求域名以及 TLS 版本」，否则无法访问服务器。

为了简化代码，本章的代码（小程序和 PHP 中的代码）都没有做过多异常处理，只能作为演示功能的示例代码。Orange Can 并不是真实的项目，请各位开发者以理解功能原理为主要目的。如果要开发自己的真实项目，请考虑各种调用失败的情况并加强安全性。

注意，本章的代码依然用于 setting 页面，每个功能都将作为 setting 页面的一个子项，本章 setting 相关的子项配置已经在 11.1 的代码清单 11-5 中添加完毕。同时，本章大多数代码的运行结果与之前的章节不同，之前的章节我们都会使用 UI 效果展示运行结果，而本章大部分示例代码都将以 console.log 的方式输出到控制台中，请开发者自行在「Console」面板中査看代码的运行结果。

### 12.2 用户登录

用户登录是小程序中获取用户加密信息、使用模板消息、客服消息、微信支付等接口的先决条件。只有用户在小程序中登录了，我们才能获取用户在当前小程序中的 openId 以及本次登录会话的 session\_key。openId 是使用一系列微信小程序开放接口的必要参数。关于 openId 的相关内容我们在 11.2 节中已经具体讲解过，这里就不再赘述。

首先，我们要了解什么是微信小程序登录，有什么作用？微信小程序登录是为了让开发者的服务器获取用户的 openId 以及 session\_key 的令牌。请不要将微信小程序的用户登录理解为传统意义上的登录。虽然从大的方向上讲，登录都是为了确认用户的身份、拿到用户的唯一身份标识，但是微信小程序的登录流程和传统的账号密码流程不太一样。当你进入小程序后，不需要输入任何账号密码，开发者服务器就可以获取你的 openId 标识。微信小程序的登录流程远比传统的账号密码登录要复杂。

微信小程序提供了 wx.login(OBJECT) 方法用于用户登录。wx.login 方法的主要目的是拿到用户的 openId 和用户本次登录的 session\_key。openId 是用户对于当前小程序的身份标识，类似于我们自己产品里的用户 id 号，只不过在微信里有自己的用户账户体系，你可以使用这个 openId 作为用户的身份标识。当然，也可以建立一套自己的用户标识，不过当你需要调用微信开放接口（比如支付、发送模板消息）时，还是必须知道用户的 openId。session\_key 是本次用户登录的会话密钥，通常用来对用户的通信数据进行加解密。

到目前为止，如果对于 openId 和 session\_key 的概念还很模糊，不知道这两者的用处，没有关系，在后面的小节中我们将陆续讲解和使用这两个参数。在本小节中，首先要在开发者服务器拿到 openId 和 session\_key。微信开放 API 中有很多概念不是那么好理解，必须用实例代码进行演示讲解。图 12-1 所示为获取 openId 和 session\_key 的流程图。这张图非常重要，可能你现在还看不明白在阅读本小节后面的内容时可时时回顾一下。

要获取 session\_key 和 openId，首先需要在小程序中调用 wx.login，并获取 code；随后将 code 发送到开发者服务器，并同 appid 和 appsecret 一起发送到微信服务器，微信服务器会返回我们需要的 session\_key 和 openId。

下面编写具体的代码，实现上述流程并最终拿到 session\_key 和 openid。首先，在 /pages/setting/open-api 下新建 login 目录及 login 页面的 4 个文件用来演示用户登录的代码和效果。在 app.jon 文件的 pages 数组下新增 login 页面。接着，在 login.wxml 中增加一个 button 按钮。

```
<!--pages/setting/open-api/login/login.wxml-->
<button class="btn" type="primary" loading="{{loading}}" disabled="{{disabled}}" bindtap="onTap">
  用户登录
</button>
```

1『上面是微信自动生成的按钮代码。』

在 button 按钮上注册了ー个事件 onTap，后面将在 onTap 函数中调用 wx.login(OBJECT) 方法。在 setting.js 文件中添加 login 事件响应函数，点击 setting 页面的「用户登录」选项后，将跳转到 login 页面。

```
  login: function () {
    wx.navigateTo({
      url: '/pages/setting/open-api/login/login'
    });
  },
```

做完以上准备工作后，点击 setting 页面的「用户登录」子项，将跳转到如图 12-2 所示的页面。下面编写 login 页面的按钮响应时间 onTap。在 login.js 中添加 onTap 事件响应函数。

1『

书里的代码，控制台显示返回信息：code:001Yx0ra27sjFJ0u9hpa2I30ra2Yx0rC

然后找了下官方文档：[wx.login(Object object) | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html)，根据文档改进的代码如下。经验证也能返回 code。

』

用户在 login 页面点击「用户登录」后，将执行 onTap 函数。我们在 onTap 函数中调用了 wx.login 方法，这个方法没有参数，只有回调函数。success 回调函数是当微信服务器成功返回结果时调用的函数。

先来看 success 回调函数返回参数的参数说明：1）errMsg，错误消息。2）code，开发者需要将 code，发送到开发者服务器后台，使用 code 换取 session\_key。3）api，将 code 换成 openId 和 session\_key。重点是返回值 code。code 是一把钥匙，是得到 openId 和 session\_key 的关键。code 有效期只有 5 分钟，如果在 5 分钟之内还没有用 code 换取 openId 和 session\_key，那么就不能再使用了。

可不可以直接在小程序内部用 code 去微信服务器换取 openId 和 session\_key 呢？理论上是可以的，但这完全没有意义。无论出于安全性还是实用性，都应该将 code 发送到开发者服务器由开发者服务器获取 openId 和 Session\_key。

所以，我们在 wx.login 的 success 回调函数中再次发起了一个 wx.request 请求，将 code 发送到了本地服务器中。在编写服务器 PHP 代码前，首先来学习如何使用 code 调用微信服务器获取 openId 和 session\_key。微信提供了一个 https 接口用于 code 换取 openId 以及 Session\_key。接口地址如下：[auth.code2Session | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html)。

需要以下 4 个参数才能正确调用该接口：1）appid，小程序唯一标识。2）secret，小程序的 app secret。3）js\_code，登录时获取的 code。4）grant\_type 填写为 authorization\_code。

appid 和 secret 均来自于微信小程序账号，是 2 个固定的字符串；js\_code 是我们在小程序客户端调用 wx.login 时返回的 code；grant\_typel 固定为 authorization_code 即可。下面编写服务端代码。先给出服务器 PHP 代码的目录示意图，如图 12-3 所示。

首先，编写一个 PHP 的类 WXLogin，位于 wxLoginClass.php 中，wxLoginClass.php 文件位于根目录的 class 目录下。WXLogin 主要负责用 code 换取 openId 和 session-key。

以上代码需要 PHP 开启 curl 支持。在代码中，我们 include 了一个 config.php 的配置文件，config.php 文件位于根目录下，该配置文件主要用于存放小程序的 appid 以及 appsecret。

请开发者自行将 appid 和 appsecret 替换为自己的 appid 和 secret。看到 config.php 中的代码后，开发者可能就会明白为什么不能在小程序客户端中换取 openId 和 session\_key。因为调用换取接口需要敏感数据 appid 和 appsecret，特别是 secret，一定不可以放在客户端中。

有了 config.php 和 wxLoginClass.php，就可以编写 wxlogin.php 接口文件了，该文件位于根目录下；接口代码很简单，接收小程序客户端传来的 code 值，并通过 WXLogin 类调用微信服务器，最终拿到 openId 和 session\_key。

要特别注意，以上代码为了演示效果，所以将拿到的 openId 以及 session\_key 返回到了客户端。但在真实的项目中，将 session\_key 和 openId 返回客户端是极其危险的，也完全没有必要。因为需要使用 session\_key 和 openld 的场景都会被放置在服务器进行，所以将这两个参数返回小程序中没有任何意义，反而会增加数据泄露的风险。

以上完成了用户登录的全部服务器端代码。运行客户端小程序，点击 login 页面的「用户登录」按钮后，console 的显示结果如图 12-4 所示结果。

1『

发现无法获取 openId 和 session\_key。可能是 PHP 没开启 curl 支持，查找了方法：[PHP 开启 cURL 功能 - CSDN博客](https://blog.csdn.net/u010596115/article/details/53173427)。在 XAMPP 里，/Users/Daglas/.bitnami/stackman/machines/xampp/volumes/root/etc/php.ini，即挂起的 lampp 盘的根目录下的 etc 文件夹里，搜 php_curl.dll 把其前面的分号 ; 去掉，然后重启服务器 Apache。验证是够开始后直接写一个 php 文件，打印语句「phpinfo();」看看结果即可。

发现还是解决不了问题，然后尝试用作者书里的 wx.login() 代码，运行成功，说明自己参看官方文档修改的代码有问题，具体什么问题待确认。

』

注意，除了 openId 和 session\_key，服务器还返回了ー个 expires\_in 参数。这个参数的数值官方并没有在文档中提到，笔者猜测这个数值是 session\_key 的失效时间戳，单位推测为秒，换算为天是 30 天。由于失效期太长，目前没有验证过，所以以上结论仅是推测（在开发工具目前的最新版本中，这个过期时间已被更改为 7200，单位未知，推测单位是秒，也就是 2 小时）。

session\_key 肯定是有失效期的。要注意的是，在 session\_key 的有效期内，开发者最好不要重复调用 wx.login 接口、不断用 code 换取 session\_key，而应该将 session\_key 保存在服务器中。等到 session\_key 失效后，再重新获取新的 session\_key。

那么如何知道 session\_key 是否已经过期呢？小程序提供了ー个 wx.checkSession(OBJECT) 用来校验 session\_key 是否过期。只有在 session\_key 确实过期后，才会再次调用 wx.login。当然，Orange Can 是一个示例项目，并不会在服务器记录 session\_key，所以每次操作都会重新调用 wx.login 接口换取新的 session\_key。wx.checkSession 的使用非常简单，下面直接给出示例代码。

这里还要注意，wx.login 得到的 code 只能使用一次，一旦你使用 code 换取了 openid 和 session\_key，这个 code 就会马上失效，不能再次使用。当然，如果 5 分钟内这个 code 还没有被使用，那么也会失效。虽然我们拿到了 openId 和 session\_key，但并没有使用。拿到 openId 和 session\_key 是用户登录要做的事情，其作用会在后续章节中逐步介绍。

### 12.3 用户信息校验

在 12.2 节中，我们学习了如何调用 wx.login 获取当前用户的 openId 以及本次登录的 session\_key，本小节将介绍 session\_key 的使用。在 11.2 节中，我们调用 wx.getUserInfo 接口拿到了用户的明文基本信息数据和用户加密数据，并使用了明文数据。下面回顾一下 wx.getUserInfo 返回的数据：1）userInfo，用户基本信息对象，不包含 openId 等敏感信息。2）rawData，不包含敏感信息的基本信息字符串，通常用来计算签名，防止从微信返回的用户信息被簒改。3）signature，使用 sha1(rawData+ sessionkey) 得到字符串，用于校验用户信息。4）encryptedData，包括敏感数据在内的完整用户信息的加密数据。5）iv，加密算法的初始向量。

在之前的 11.2 节中，我们使用了 userInfo 对象，包括 userInfo 和 rawData 在内的明文数据都可能存在被簒改的风险。如何知道明文数据是否被簒改了呢？这个时候 rawData 和 singature 就可以发挥作用了。rawData 和 singature 用于校验用户数据到底有没有被簒改过（没有绝对安全的网络，数据极有可能被抓包或者通过其他方式改）。通常来说，想要实现这个校验必须在服务器编码才能进行。这需要小程序将获取的 rawData 和 signature 一并提交到服务器，由服务器完成校验工作。

校验的基本原理是：rawData 是用户原始明文数据，signature 是使用 sha1(rawData+sessionkey) 得到的字符串。理论上讲，如果数据没有被簒改，那么 signature 等于 sha1(rawData+sessionkey) ；如果 rawData 或者 signature 被修改了，那么 signature 必然不再等于 sha1(rawData+sessionkey)。

是否存在 signature 和 rawData 同时被修改的情况呢？理论上是不可能的，因为 session\_key 并不在网络上传输，簒改者不知道这个变量，被簒改且校验通过的概率很小。有可能从 signature 中推算出 session\_key 吗？理论上讲，这是不可能的。因为 sha1 算法是不可逆的，无法在已知 rawData 和 signature 的情况下推算出 session\_key。不知道 session\_key 就无法通过同时修改 rawData 和 signature 达到「欺骗校验的目的」。如果知道了 session\_key，只需要修改 rawData 并重新用 session\_key 计算一下新的 sha1(rawData+sessionkey) 就又可以让新的 rawData 等于新的 sha1(rawData+sessionkey) 了。这样，开发者就无法知道 rawData 是被修改过的。

这也是为什么官方文档一再强调，不要在网络上传输 session\_key，而应该将其保存在服务器上使用，以降低 session\_key 被泄露的风险。session\_key 有点类似于我们在数据库中保存用户密码时所使用的「盐」（salt）。在数据库保存用户密码时，并不是直接将用户的密码以明文的方式存放在数据库表中，通常都会使用 SHA-1 或者 MD5 算法将用户密码和 salt 随机字符串拼接在一起，重新计算一下再存入数据库中。被重新使用 SHA-1 或 MD5 算法计算的用户密码谁都不知道是什么，开发者也只能比对每次登录时输入的密码和数据库保存的密码是否一致，判断是否为合法用户，却无法知道密码到底是什么。用户数据校验的流程图如图 12-5 所示。

需要说明的是，在 12.2 节中，我们明确说明服务器是没有保存 session\_key 的。因为我们需要拿到 session\_key 才能进行用户数据校验，所以在上述流程图再一次重复了用户的登录流程。在真实的流程中，用户登录在 session\_key 的有效时间内只应该执行一次，session\_key 也应当被保存在服务器中。其实小程序只需要使用 wx.request 将 rawData 和 signature 发送到服务器即可，服务器无须使用 code 换取 session\_key，直接做 SHA-1 签名比对即可。如图 12-6 所示为服务器已保存 session\_key 的用户数据校验流程。

对比图 12-5 和图 12-6，很明显可以看出，服务器保存 session\_key 后整个流程变得更加简单，完全不需要再与微信服务器交互。服务器管理 session\_key 的过程非常复杂，为了降低代码的复杂度，我们没有在服务器中保存 session\_key。我们后续的所有开放 API 调用流程都将重复完整的流程，因为单独完整的流程更加有利于开发者理解每个开放 API。

下面实现校验用户数据的功能。当用户点击 setting 页面的「校验用户信息」选项时，页面将跳转到一个子页面；当用户在子页面中点击 button 按钮时，将调用服务器接口并验证用户信息。新建一个 check 子页面。在 app.json 的 bages 数组下新增 check 页面的路径。接着，在 setting.js 文件中编写点击子项的事件响应函数，将页面导航至 check 子页面。

在 check.wxml 中添加一个 button。下面是点击 button 后所执行的 onTap 事件响应函数。在 check.js 中新增 onTap 函数：

请将上述代码与图 12-5 结合在一起看。首先，登录并拿到 code 码，然后调用 wx.getUserInfo 接口到 rawData 和 signature，再使用 wx.request，将这 3 个参数发送到服务器中，服务器会进行数据校验工作并返回校验结果。下面是服务器  wxCheckUserInfo.php 的编码。

在以上代码中，首先使用 code 调用微信服务器换取 session\_key，随后使用 session\_key 和 signature 校验用户发送过来的 rawData，最后返回校验结果。其中，login 已经在 12.2 节用户登录时编写完成，这里只需要复用这个类即可。图 12-7 所示是最终返回到小程序中的校验结果。

我们可以简单测试校验不通过的情况，请在代码清单 12-12 中将 rawData 稍微修改一下，比如在调用 wx.request 时在 rawData 后面拼接一个字符串。在发送到服务器的 rawData 字符串后面附加了ー个字符串 LOL。再次运行代码将呈现如图 12-8 所示的输出结果。

建议开发者在客户端使用用户明文数据时使用 rawData，而不要使用 userInfo。因为数据验证的是 rawData 有没有被簒改，而不是验证 userInfo 是否被簒改。至于微信能否确保 userInfo 和 rawData 的一致性，这个不得而知。建议开发者使用 rawData 作为用户的基本信息。

### 12.4 解析用户加密数据获取 openId 及 UnionId

在 12.3 节中我们完成了用户明文数据的校验工作，本节将学习解密用户的非明文用户信息。调用 wx.getUserInfo 后将返回 encryptedData 和 iv 两个数据。encryptedData 是包括敏感数据在内的完整用户信息的加密数据，iv 用于解密这个数据。整个解密用户数据的过程同 12.3 节中用户信息校验的流程基本相同。不同的是，我们提交到服务器的数据是 encryptedData 和 iv，而不是 signature 和 rawData。

首先，在 appjson 中注册 decrypted 子页面。在 setting.js 页面中添加 decrypted 函数，用于跳转到 decrypted 子页面。在 decrypted.wxml 中添加一个 button。下面编写用户数据解密的核心代码，在 decrypted.js 文件中编写 onTap 事件响应函数。

以上代码将 code（用于获取 session\_key）、encryptedData 和 iv 三个参数发送到了 wxdecryptuserinfo.php 中。服务器如何解密 encryptedData 数据呢？解密时需要 session\_key、iv、小程序的 Appld 三个变量参与。session\_key 由 code 可以换取到，iv 由小程序客户端提交，Appld 本身就是一个固定的已知变量。具体的解密算法较为复杂，但微信官方提供了包括 C++、Nodejs、PHP 和 Python 四种语言的解密 SDK，我们只需要使用官方提供的 SDK 即可，无须自己编写解密算法。目前，官方没有提供 JAVA 和 C# 版本的 SDK，开发者可自行翻译。4 种语言解密 SDK 的下载地址为。

每种语言的接口名称都是一致的，请选择适合自己的语言。服务器的解密工作主要使用官方提供的 SDK 进行解密。我们选择 PHP 版本的 SDK。PHP 版本的 SDK 主要包含以下 4 个文件：wxBizDataCrypt.php、pkcs7Encoder、errorCode、demo.php。

3『[服务端获取开放数据 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)』

wxBizDataCrypt.php 是 SDK 的接口类，在内部调用了 pkcs7Encoder，pkcs7Encoder 提供基于 PKCS7 算法的加解密接口；errorcode.php 是错误码说明；demo.php 是使用解密 SDK 的示例，我们无须关心解密的细节。（当然，如果有兴趣，开发者也可以看看源码研究学习下）

下面我们编写 wxDecryptUserInfo.php，该页面向小程序提供接口实现用户数据的解密，wxDecryptUserInfo.php 内部主要调用微信提供的 SDK 进行数据解密。首先，将微信提供的 3 个用于解密的 PHP 文件放在如图 12-9 所示的位置。在 wxDecryptUserInfo.php 中编写以下代码：

数据解密的代码同样首先使用 code 换取 session\_key，接着实例化微信提供的 WXBizDataCrypt，实例化 WXBizDataCrypt 需要 appid、session\_key 这两个参数，然后调用 WXBizDataCrypt 实例的 decryptData 方法实现数据的解密。最后判断 errCode 的取值，如果 errCode 为 0，就认为解密成功，将 data 返回小程序中。

以下是小程序最终得到的返回结果的数据示例结构。微信在数据的末尾添加了一个 watermark 水印字段，此字段可以用来校验应用数据的有效性。1）appld，敏感数据归属 appld，开发者可校验此参数与自身 appld 是否一致。2）timestamp，敏感数据获取的时间戳，开发者可以用于数据时效性校验。

1『无法获得解密信息，去官网下了最新的 SDK，不过只有 wxBizDataCrypt.php、errorCode、demo.php 三个文件，替换掉即可抓取到解密信息。』

### 12.5 模板消息

不同于前几节的示例代码，本节内容的示例代码需要以下 4 个条件才能成功运行：1）在真机上运行小程序（开发工具中拿不到 formeId）2）开发者服务器位于外网。3）外网地址已经加入小程序账号的可信域名列表中。4）服务器接口需要提供 https 支持（因为在真机上只能调用 https 接口）。

笔者一直认为，小程序应该充分借助微信的优势提升开发者的开发效率、降低开发成本并提升用户体验，比如可以借助微信消息体系向用户推送各类通知。信息触达率高是微信的一项优势，借助微信的信息触达渠道远比自建信息渠道要好得多。微信订阅号可以一天群发一条消息，微信服务号一个月可以群发 4 条消息。和微信订阅号、服务号不同，小程序不可以主动向用户群发消息。这几乎切断了小程序的媒体属性，不利于开发者推广小程序。

笔者分析限制微信小程序群发能力的原因有以下 4 点：1）在微信上的产品一向是极为克制的，从不盲目添加功能，凡是对用户体验有影响的功能般都不会轻易开放。毕竟群发消息会对用户造成一定打扰。2）在本书开始部分分析过，小程序主打的是用完即走的服务，在微信看来不应该具有媒体属性。3）一定程度上是为了保护服务号，不让小程序对现有的产品体系造成太大冲击。4）小程序现在处于萌芽状态，不能在微信上贸然开放太多功能。要知道泼出去的水是收不回来的，即使收回来也要付出较大代价。从策略上来看，先不给你，以后看情况再给你远比先给了你，再收回要高明很多。毕竟小程序的生态没有太多案例可以借鉴，一切都要「摸着石头过河」。

虽然小程序不可以主动向用户群发消息，但是微信提供了一个模板消息。需要注意的是，模板消息具有以下 4 个特点：1）用户接收的模板消息位于微信消息的服务通知中，多个模板消息会被折叠进服务通知里。2）模板消息是被动的，只有用户本人在小程序中有一定交互行为后，服务器才能够向用户推送模板消息。3）模板消息有两种跳转功能，一种是可以进入发送模板的小程序里，这是模板消息的默认跳转，前提条件是必须是线上已发布的小程序；另一种是可以指定一个模板消息的跳转页面，跳转到小程序的内部，这种跳转在体验版或开发版中都可以成功跳转。4）要成功发送模板消息，必须要有一个 formld 的 id 号，但经过测试发现开发工具中无法获取 formld，也就是说在开发工具中不能产生模板消息。只有在真机中才能拿到 formld，而 formld 是发送模板消息的关键。这也是为什么章节开头时提出一定要在真机中运行本示例。

上面我们提到了模板消息是被动的，只有用户本人在小程序中有一定交互行为后，服务器才能够向用户推送模板消息。下面来解释一下用户的什么行为オ能让服务器可以向小程序推送一条模板消息。1）用户在小程序内完成过支付行为，7 天内可允许开发者向用户推送有限条数的模板消息（一次支付可下发一条，多次支付可发条数独立，互相不影响）。2）当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息时，7 天内可允许开发者向用户推送有限条数的模板消息（一次提交表单可发一条，多次提交可发条数独立，相互不影响）。

在本示例中，以用户提交表单的行为编写模板消息示例代码。在编写代码前，首先要对模板消息发送的全部流程有一个清晰的认识。图 12-10 所示为用户提交表单类模板消息的完整流程。要注意的是，微信支付的模板消息与用户提交表单的模板消息流程不太一样，请不要混淆。

以上流程是建立在已经在小程序中拿到了 formld 且 formld 没有被使用的前提下。请开发者先大致浏览以上流程图，在后面具体编码时再回过头来对比这张流程图。发送模板消息需要知道用户的 openId（不知道 openId 就不知道到底发送给哪个用户）。这里要强调下，获取 openId 的流程不是必须的。如果用户已经在小程序中登录，服务器也保存了 openId 和 session\_key，就没有必要再使用 code 换取 openId。

此之外，发送模板消息的流程还需要一个 access\_ token。access\_token 在微信服务号或者订阅号里经常被作为令牌使用，这里也被移植到了小程序中。access_ token 也是有失效期的，开发者应该在真实的项目中像管理 session\_key 一样管理 access\_token。获取 access\_token 同样需要携带微信小程序的 openId 和 appsecret 调用微信服务器。

流程图中没有标示出 formId 的获取过程，那么 formId 是怎么来的呢？当用户提交表单时，表单提交函数的 event 事件对象中将包含一个 formId，这个 formId 只能使用一次，有效期为 7 天，一旦使用 formId 推送了一条模板消息，这个 formId 就不可以再次使用。如果还想推送模板消息，就只能等用户再一次提交表单并产生新的 formId。

最后还有一个问题，模板的格式怎么定义？先来看示例代码最终推送的模板消息示意图，如图 12-11 所示。小程序提供了许多种类型的模板，每个模板都有一个模板编号。可以在小程序公众账号「模板消息」的「模板库」中选择模板和获取模板编号，如图 12-12 所示。示例代码中选择的是「购买成功通知」模板，这个模板的详情如图 12-13 所示。

我们需要关注模板中的两个关键点：模板 ID 和关键词。模板 ID 表示需要向开发者发送哪种类型的模板消息。关键词是这个模板消息可以发送的内容，比如购买成功通知模板包含购买地点、购买时间、物品名称和交易单号 4 个关键词。在后面的示例代码中我们将看到模板 ID 和关键词的使用方法。

如果在小程序提供的模板库中没有你想要的模板，那么可以向微信团队提出新模板申请。申请新模板有一些约束，请参考以下文档接口说明。该文档中有一个「审核说明」，详细描述了申请新模板的一些要求。了解以上内容后，开始编写 Orange Can 项目中的模板消息示例代码。首先，在 app.json 的 pages 数组中注册 tpl-message 模板消息子页面。在 setting.js 页面中编写跳转到 tpl-message 模板消息子页面的函数 tplMessage。在 tpl-message.wxml 中编写模板消息页面的骨架代码。在继续编写模板消息核心业务逻辑代码前，先插入一节介绍模板消息页面中的 formId 表单。

### 12.6 form 表单及 picker 组件

在 12.5 节的模板消息页面中，使用 \<form> 标签构建了一个表单。form 表单有什么作用呢？form 表单中有 3 个 input 和 1 个 picker 组件，假如想获取这 4 个组件的用户输入值，怎么办呢？一种笨办法是在每个组件的 binchang、bindconfirm 等事件中获取该组件的用户输入值，比如我们之前多次使用的 input 组件就是通过此类组件的特殊事件获得的。

假如页面的表单元素非常多，这样一个一个获取太过于烦琐。form 标签的作用就是让开发者可以一次性获取所有表单组件输入值。form 表单有以下 3 个重要属性：1）report-submit，Boolean 类型。是否返回 formId 用于发送模板消息。2）bindsubmit，EventHandle 类型。指定一个响应函数，当 form 表达内部类型为 submite 的 button 被点击时，将触发这个响应函数。3）bindreset，EventHandle 类型。指定一个响应函数，当 form 表达内部类型为 reset 的 button 被点击时，将触发这个响应函数。

当用户点击 form 表达内部类型为 submit 的 button 后，将执行 bindsubmit 属性所指定的响应函数。在响应函数的 event 事件对象中将可以获取 form 下所有表单元素的用户输入值。注意，form 表单只会提交 6 种类型组件的用户输入值：\<switch/>、 \<input/>、 \<checkbox/>、  \<slider/>、\<radio/>、  \<picker/>。

同时，report-submit 属性也是一个非常重要的属性。如果此属性为 true，那么触发 bindsubmit 后，event 事件对象中将包含一个 formId，这就是要用于发送模板消息所需要的 formId。要注意的是，经过笔者测试，在开发工具中 formId 是一个 mock 字符串：the formId is mock one。这并非是一个可以使用的 formId。只有在真机上才能获取真实的 formId。

下面介绍 picker 组件。小程序的表单类元素有很多，但其用法和属性都比较简单，官方文档中的说明也比较清楚。建议开发者在用到某个表单组件时具体査阅。Picker 组件是从底部弹起的滚动选择器，现在支持 3 种选择器，通过 mode 属性来区分，分别是普通选择器、时间选择器和日期选择器，默认是普通选择器。下面来看 picker 组件的真机效果图如图 12-14 所示。

mode= selector 时，picker 为普通选择器。这是一种自定义类型的选择器，如果需要自定义选择内容，请使用这种类型的选择器。这种类型的选择器有以下 5 种属性：1）range，数组类型。mode 为 selector 时，range 属性才有效。2）range-key，String 类型。当 range 是一个 Object Array 时，通过 range-key 指定 Object 中 key 的值作为选择器的显示内容。3）value Number，类型，默认值为 0。value 的值表示选择了 range 中的第几个（下标从 0 开始）。4）bindchange，EventHandle 类型。value 改变时触发 change 事件。5）disabled，Boolean 类型，默认值为 fale。表示是否禁用。

Mode 为 time 时，picker 为时间选择器。这种模式的 picker 用于选择时间，具有以下 5 个属性：1）value，String 类型。表示选中的时间，格式为「hh:mm」。2）start，String 类型。表示有效时间范围的开始，字符串格式为「hh:mm」。3）end，String 类型。表示有效时间范围的结束，字符串格式为「hh: mm」。4）bindchange，EventHandle 类型。value 改变时触发 change 事件。5）disabled，Boolean 类型，默认值为 false。表示是否禁用。

当 mode 为 date 时，这种模式的 picker 用于选择日期，具有以下 6 个属性：1）value，String 类型，默认值是 0。表示选中的日期，格式为「YYYY-MM-DD」。2）start，String 类型。表示有效日期范围的开始，字符串格式为「YYYY-MM-DD」。3）end，String 类型。表示有效日期范围的结束，字符串格式为「YYYY-MM-DD」。4）fields，String 类型。默认值是 day，有效值为 year、month、day，表示选择器的粒度。5）bindchange，EventHandle 类型。当 value 改变时触发 change 事件。6）disabled，Boolean 类型。默认值是 false。表示是否禁用。

以上有 3 种类型的属性文档都讲述的非常明白，我们只对几个存在误区理解的属性做一些解释。首先是 value 属性，picker 的 value 和 input 的 value 不同。picker 的 value 不是显示在组件上的文本，而是定义 picker 默认的选择顼目，比如将 value 设置为「2017-11-18」，那么打开 picker 时默认将停留在 2017-11-18 这个选项上。其次是 stat 和 end 属性，start 和 end 属性只有当 mode 为 time 和 mode 为 date 时才有。这两个属性并不是指定 pickers 组件的最大选择范围，而是指定可选范围。举个例子，将 start 设置为 2017-1-1, end 设置为 2020-12-31, 还是可以看到超出这个时间范围的年月日，但却无法选择这些超出范围的日期。

### 12.7 发送模板消息

下面继续编写模板消息功能。在之前的章节中，我们编写了 tpl-message 页面的骨架和样式，现在这个页面如图 12-15 所示（购买时间选项将在编写 tpl-message.js 文件后出现）。在模板消息页面，我们需要采集一些用户的输入值，这些输入值将被提交到服务器中用于发送模板消息，购买地点、购买时间、物品名称和交易订单号刚好对应「购买成功通知」消息模板的 4 个关键词。接着编写 formSubmit 函数，点击页面的 Submit 按钮后将执行此函数。注意，这个事件响应函数名称由 form 标签的 bindsubmit 属性定义，开发者可回顾一下 tpl-message.wxml 中的代码。在 tpl-message.js 文件中编写以下代码：

首先，调用 wx.login 方法得到了 code。接着，使用 wx.request 方法调用服务器接口。注意，代码中的 wx.request 的 url 设置的是一个示例 url。前面我们讲过本节的示例必须在真机上运行才能获取 formId，真机运行必须调用 https 接口。除此之外，接口所在的域名必须加入小程序账号的可信域名列表中。同时要注意，我们将 code 附加在了这个 urI 的 query 参数中。

1『原来 ? 的意思是，后面的信息附加到 urI 的 query 参数中。』

这里我们使用的是 POST 请求，而不是 GET 请求。POST 的数据在 wx.request 的 data 中。data 包含两个属性，即 formId 和 formData。formDatae 的取值来自于 event.detail.value，包含用户输入的购买地点、购买时间、物品名称和交易单号 4 个值。以上是小程序中的全部代码，接着我们需要编写服务器的 PHP 代码。

首先，在 config.php 中增加两个配置项，一个是 TOKENURL，用于获取 access_token 的地址，另一个是 TPLMSGURL，是微信服务器发送模板消息的 URL。获取 access\_token 是一个 HTTP GET 请求，需要附带小程序的 appid 以及 appsecret；发送模板消息是一个 HTTP POST 请求，需要 access\_token (access\_token 将附加在接口 url 的 query  参数中）以及模板消息的一系列参数（位于 POST 的 body 中）。注意将 WXAPPID 和 WXAPPSECRET 换成自己小程序的 appid 和 appsecret。

接着新增一个 http.php 文件，位于根目录的 class 文件夹下 http.php 文件包含两个方法，即 curl_post 和 curl_get 用于发送 http 请求。最后，编写 wxTPLMessage.php 文件的代码，wxTPLMessage.php 位于根目录下。

wxTPLMessage.php 是处理小程序提交模板消息内容的核心代码。首先，代码从 URL 的 query 参数和 http body 中分别获得 code 和模板消息内容。请开发者在岡读代码时再回顾一下图 12-10 的流程图。拿到 code 后还是先调用 login，不同于前几节，此次 login 是为了获取用户的 openId。接着，使用小程序的 openId 和 secret 去微信服务器换取 access\_token。最后，将 openId、access\_token 及客户端发送来的模板消息内容提交到微信服务器，如果数据正常，那么微信会向指定 openId 的微信用户发送一条消息。

我们重点看一下 \$tplMSG 关联数组下的元素。1）Touser，指定模板接收者的 openId。2）template_id，模板消息的 id 号，这个编号可以直接从小程序公众号账号中获取。3）page，page 指定了用户在收到模板消息后点击模板消息将跳转的小程序页面。4）data，模板消息的内容，我们选择的模板拥有 4 个关键词，每个关键词中包含 value 和 color 两个属性，分别指定该关键词的内容以及关键词的显示颜色。5）emphasis\_keyword，只能指定一个关键词，这个关键词将被「强调」。被强调的关键词将在模板消息中居中、放大、加重。

真机上接收的模板消息效果图如图 12-16 所示。模板消息是实现产品完整闭环逻辑的重要环节，请开发者对这个功能给予足够重视。

1『2020 年 01 月 10 日起，新发布的小程序将不能使用模板消息，请开发者迁移至订阅消息功能。』

### 12.8 微信支付

微信支付是开放接口中最为重要的接口。小程序的微信支付基本同微信 JSAPI 中的微信支付相同。如果你有 JSAPI 中开发微信支付的经验，小程序的支付相当简单。本小节我们来实现小程序中的微信支付。首先来看做信小程序的支付流程图（见图 12-17），该图来自于官方 API 文档。

支付流程看似比较复杂，但微信提供了ー个 SDK，使用 SDK 基本上不需要编写太多支付相关的代码。事实上，在真实项目中，支付相关的代码复杂的不是支付本身，而是我们自己的业务逻辑。下面来看完成一次支付的流程。这个流程是微信支付的最简流程。流程中不包括开发者自己的业务逻辑。

1）首先，小程序客户端调用开发者自己的服务器，将一系列订单信息发送到服务器，比如商品的 id 等信息。2）开发者服务器接收被购买商品的信息后，调用微信服务器的统一下单 APl，生成一个预付单，并将预付单信息返回开发者服务器。统一下单 APl 需要用户的 openId。如果你已经在服务器中保存了 openId（之前几节我们已经反复给出了获取。openId 的示例代码），就不再需要获取用户的 openId 了；如果你没有当前支付用户的 openId，那么需要在第一步中携带 code，以方便在这一步中使用 code 换取用户的 openId。本小节示例中，我们假设服务器没有用户的 openId。3）开发者服务器需要对预付单的信息签名，并将预付单信息和签名一起返回小程序客户端。

4）小程序客户端在收到预付单信息及签名后，再调用 wx.requestPayment，将预付单信息和签名一起提交到微信服务器。5）微信服务器会验证这些预付单信息，如果验证通过，那么小程序将拉起支付界面（在开发工具中，这一步首先会弹出一个二维码，开发者扫描这个二维码将在开发者的微信中拉起支付界面）。6）支付完成后，微信会主动调用开发者服务器将支付结果推送到开发者服务器中，开发者可根据支付结果处理自己的业务逻辑。这一步需要开发者有自己的外网服务器，否则微信无法推送通知。

以上 6 个步骤中，第二步是关键。下面我们实现这 6 个步骤，在 Orange Can 项目中完成一次小程序的支付。首先，在 Orange Can 项目中新增一个页面 wx-pay。在 app.json 的 pages 数组下新增该页面的路径。接着，在 setting.js 中编写跳转到 wx-pay 支付页面的跳转函数。在 wx-pay.wxml 中增加一个按钮用来触发微信支付。

以上准备工作做好后，就可以编写客户端支付的相关代码了。在 wx-pay.js 中新增 ont ap 事件响应函数，用户点击【微信支付）按钮后，将触发 onTap 函数。回顾一下我们之前总结的 6 个步骤，在正式拉起支付界面前，需要向自己的服务器请求预支付订单信息。只有获取预支付订单信息，才能在小程序中拉起支付界面。由于预支付订单的生成必须知道用户的 openId，因此再一次调用了 wx.login 获取 code，将 code 发送到自己的服务器中。由于本项目不是真实项目，因此在这一步中没有提交任何商品信息，开发者在开发真实项目时可以将自己商品的信息同 code 一起发送到服务器中。

要特别注意的是，服务器的接口地址 urI 一定不要使用 localhost，而应该使用 127.0.0.1。具体原因是服务器中的微信 SDK 在获取客户端 IP 时可能会将 localhost 获取成 "::1" 这样的字符串（可能是开启了 IPv6 支持引起的），这个字符串是微信 SDK 不允许的。当然，在真实的运行环境中不存在这个问题。建议开发者在调试时使用 127.0.0.1。

代码的 wx.request 的 success 中将接收服务器返回的预支付订单信息。获取预支付订单信息后，调用 wx.requestPayment(OBJECT) 即可拉起微信支付界面。在继续编写调用 wx.requestPayment(OBJECT) 前，我们先来编写服务器代码，没有服务器代码是无法返回预支付订单信息的。

小程序支付的服务器部分基本上不需要编写任何代码，微信已经提供了一整套 SDK 供我们调用。微信支付服务的 SDK 提供了 Java、C# 和 PHP 三个版本。SDK 包下载地址为：

3『整个支付逻辑应该变了，做这个模块的时候再好好研究。[【微信支付】微信小程序支付开发者文档](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_10&index=1#)』

下载并解压 sdk 包。我们需要使用 SDK 包根目录下 Iib 文件夹里的 5 个文件：Wxpay.Api.php、Wxpay.Config.php、Wxpay.Data.php、Wxpay.Exception.php、Wxpay.Notify.php。其中，Wxpay.Api.php 是 SDK 接口，Wxpay.Config.php 是配置文件，Wxpay.Data.php 定义了一组微信支付中需要用到的基本对象，最后两个文件分别是错误异常类及接收回调通知的处理类。

### 12.9 真实的微信小程序登录状态维护

在本章之前所有示例中，我们反复调用 wx.login 获取 code，并将 code 发送到开发者服务器换取 openId 和 session\_key。正如在前几个章节中反复强调的，在 session\_key 的有效时间内（未过期），开发者应该自行维护 session\_key 而不是重复获取。同时，openId 最好不要作为用户的 id 被传递到小程序客户端。开发者应当自己生成令牌作为自己业务的用户 id，而不应当使用微信的 openId。我们来看一下微信官方建议的登录以及登录状态维护指导流程，如图 12-18 所示。

第一步还是应当让用户在客户端登录，并向开发者服务器发送登录请求，同时携带 code 码。开发者服务器在收到 code 码后，协同 appid、appsecret 以及 code 码向微信服务器换取当前用户的 session\_key 和 openId。

获取到 session\_key 和 openId 后不要将这两个变量发送回客户端。此时应自己生成一个令牌（随机字符串，也就是图中描述的 3rd\_session）作为用户 session\_key 和 openId 的键，将令牌（键）和 session\_key、openId（值）保存到服务器的 Redis 或者 Memcache 中。

同时，这个自己生成的令牌应当具有一定时效性，时效性一定要小于 30 天。开发者可根据自己小程序的安全性要求自行调整这个令牌的有效期。对于微信中的令牌字符串的要求有一些建议，请查看图 12-18 中 3rd\_session 的说明。开发者应当将自己生成的令牌发送到小程序并存入小程序的缓存中，每次请求服务器时都携带这个令牌，服务器接收令牌后在 Redis 中查找用户真实的 openId 和 session\_key。

以上流程只是一个指导性的流程，在真实的顼目中还有很多変化和细节，但在总体思路上应当遵守上述流程。

## 13. 杂项

### 1. 逻辑脉络

实际开发过程中总结的经验以及对部分微信组件的理解。wx:key 的使用场景。

### 2. 摘录及评论

本章是一些笔者在开发小程序的实际过程中，总结的一些经验以及对部分微信组件的理解。如果你只想开发简单的小程序，则本章的内容没有太大的价值，但如果你想在小程序中做出一些高级的操作效果，或者是稍微复杂一些的业务，那么本章将给你一些思路。

### 13.1 wx:key

Orange Can 项目编写到这里，开发者可能会发现项目的 Console 中满屏的都是如图 13-1 所示的警告信息。这些警告信息都是由于我们使用 wx:for 循环造成的。如果想消除这个警告信息，那么可以在每个使用 wx:for 循环的地方加入ー个 wx:key 属性。官方文档中对 wx:key 的解释为：如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（比如 \<input/> 中的输入内容，\<switch/> 的选中状态），需要使用 wx:key 指定列表中顼目的唯标识符。

1『高磊的小程序视频课里有提到这个概念。』

wx:key 的值以两种形式提供：字符串代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变；保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一字符串或者数字，比如当数据改变触发渲染层重新渲染时，会校正带有 key 的组件，框架会确保他们被重新排序而不是重新创建，以确保使组件保持自身的状态并提高列表渲染时的效率。如果不提供 wx:key，会报一个警告信息。如果明确知道该列表是静态的或者不必关注其顺序，可以选择忽略。

官方的解释并不那么容易理解，简单来说，如果想消除这个警告信息，那么可以使用 wx:key 属性。wx:key 的取值有两种形式：如果 for 循环数组中的子项是一个唯一不重复的字符串或者数字，那么使用 wx: key="*this" 即可；如果 for 循环的子项是一个复杂的 Object 对象，那么可以使用这个 Object 对象下某一个属性名作为 wx:key 的取值，前提条件是这个属性是一个唯一的字符串或数字，且不能被动态改变。

以 Orange Can 项目中电影数据为例，豆瓣电影数据的 id 号非常适合做 for 循环的 key 值。开发者可自行将豆瓣电影数据的 id 号作为 wx:key 的取值添加到每一个使用 wx:for 循环的标签上。消除警告并不是最终目的，还要理解 wx:key 的作用到底是什么。可以在 setting 页面下编写一个事例看看 wx:key 的作用。在 app.json 的 pages 数组下新增 wx-key 页面用来演示 wx:key 标签属性的使用方法。

在 setting.js 中新增跳转到 wx-key 页面的跳转函数。下面编写一个小 demo，在 wx-key.wxml 中增加以下代码；接着，在 wx-key.js 文件中添加以下代码；wx-key 页面默认有两组 switch 组件和 3 个 button。首先来解释 Switch 按钮的功能。点击 Switch 按钮后将触发 switch 事件响应函数，switch 图数以随机方式重新排列 objectArray，然后执行数据绑定，更新被打乱顺序的数组。这将使页面 UI 上的 6 个元素随机重新排列。而 Add to the front 按钮将新增一个 switch 开关，并置于 objectArray 数组的首部，这将不断在页面 UI 的 switch 组的「顶部」新增 switch 开关。

我们来看一个「奇怪」的现象。随机将 0-5 号 switch 组件的其中一个开关「打开」，比如将 3 号开关打开。打开后 3 号开关将呈现绿色的样式。此时不断点击 Add to the front 按钮或者 switch 按钮，会发现绿色开关始终处于固定不变的位置，但开关后面的数字在不断变化。这显然是不合理的，我们打开 3 号开关，3 号开关的状态被设置为「打开」，但页面被 setData 更新后，3 号开关的状态不再是「打开」了，这样的结果在真实项目中将造成很大的「bug」。

我们的目的是打开 3 号开关，那么无论页面如何变动（渲染），3 号开关始终应当保持被打开的状态，而其他开关应该保持未打开的状态，这样的业务逻辑才是合理的。那么如何解決这个问题呢？这时就是 wx:key 发挥作用的时候了。当数据改变触发渲染层重新渲染时，会校正带有 key 的组件，框架会确保他们被重新排序而不是重新创建，以确保组件保持自身的状态并提高列表渲染时的效率。

下面来看具体的效果。在第一个 switch 组件中添加一个 wx:key="unique" 属性。注意 unique 是 objectArray 子对象的其中一个属性，我们将这个属性的属性名称作为 wx:key 的键。保存代码并再次运行项目，此时再打开一个开关，并不断点击 Switch 或者 Add to the front 按钮，发现打开的开关会不断「跳动」，且被打开的开关和开关后面的数字始终是对应的。比如打开 3 号开关，无论如何重排、添加，3 号开关始终会保持打开的状态。所以，对于ー些带有状态的组件（比如 input 和 switch），再做列表渲染时应当考虑加入 wx:key。

示例中的第二个 switch 组件列表与第一个 switch 组件列表所展示的功能基本一样，只不过它描述了 wx:key 取值的另一种方法，使用 \*this 为 wx:key 提供键。因为第二个 switch 组件的数据来源是组数字而不是一组 object 对象，对于数字和字符串类型的数据，可以使用 \*this。

### 13.2 scroll-view 组件：在 js 中控制滚动条

在电影详情页面中，我们介绍了 scroll-view 的基本用法。scroll-view 组件的用法很多，除了可以用来实现一些复杂的滚动效果外，也最能体现如何使用数据绑定的方法模拟操作 dom 的效果。

先来看 scroll-view 的全部属性和事件列表：1）scroll-x，Boolean 类型，默认值为 false，允许横向滚动。2）scroll-y，Boolean 类型，默认值为 false，允许纵向滚动。3）upper-threshold，Number 类型，默认值为 50，距顶部 / 左边多远时（单位 px) 触发 scrolltoupper 事件。4）ower-threshold，Number 类型，默认值为 50，距底部 / 右边多远时（单位 px），触发 scrolltolower 事件。5）scroll-top，Number 类型，设置竖向滚动条位置。6）scroll-left，Number 类型，设置横向滚动条位置。7）Scroll-into-view，String 类型，值为某子元素 id 就滚动到该元素，元素顶部对齐滚动区域顶。8）bindscrolltoupper 事件，滚动到顶部 / 左边时会触发 scrolltoupper 事件。9）bindscrolltolower 事件，滚动到底部 / 右边时会触发 scrolltolower 事件。10）bindscroll 事件，滚动时触发，可以从事件的 event 参数中获取滚动的位置以及滚动偏移量。具体参数格式为（省略）；11）deltaX，deltaY。

scroll-view 的基本功能是提供一个可控制横向、纵向滚动条的容器，基本使用方法非常简单。scroll-view 最主要的功能是当滚动条滚到到底部或右边、上部或左边时，会触发 bindscrolltoupper 和 bindscrolltolower 事件。开发者可在这两个事件中编写自己的业务逻辑。比如上滑加载更多数据就可以使用 scroll-view 组件，当 scrol-view 组件滚动到底部时，在 bindscrolltolower 事件响应函数中编写加载更多数据的业务代码，并重新绑定数据即可实现加载更多数据的功能。如果想控制触发 bindscrolltoupper 和 bindscrolltolower 事件的「敏感度」，就可以使用 upper-threshold 和 lower-threshold 两个属性。这两个属性可以让开发者指定距离底部 / 右边、顶部 / 左边还有多远时触发 bindscrolltoupper 和 bindscrolltolower 事件。

除此之外，scroll-view 还提供了一个 bindscrol 事件。只要 scroll-view 组件被滚动，就会触发这个事件。如果想实现一个 scroll-view 组件和另一个组件联动的效果，那么可以考虑整个事件。例如，左边是商品分类列表，右边是分类子项，当滚动右边的分类子项时，左边的分类列表会起联动。

以上几个属性都比较好理解，这一节主要演示 scroll-top、scroll-left 和 scrol-into-view 这 3 属性的用法和效果。在 dom 结构的 Web 网页中，使用 Javascript 操作滚动条是非常简单的，但在小程序中没有办法用「获取一个组件，再操作组件」的思想编程。再次强调，我们只有数据绑定这一种方式，一定要「忘掉」传统网页里经典的 DOM 编程方式。

那么如何实现使用 js 控制滚动条的位置？小程序提供的 scroll-view 组件有 3 个属性用于在 js 中控制滚动条滚动到指定的位置：croll-top、scroll-left 和 scroll-into-view。下面编写一个小示例，看看如何在 js 中控制 scroll-view 的滚动条。

在 app.json 的 page 数组下新增一个 scroll-view 页面。接着，在 setting.js 中新增点击「scroll-view 高级用法演示」按钮跳转到 scrol-view 页面的跳转方法。

在 scroll-view 页面中添加了两组 scroll-view 组件，一组垂直方向，一组水平方向。当然，这里并不是为了演示 scroll-view 组件的基本用法，重点要看看 scroll-into-view、scroll-top 两个属性的作用。

编写完以上 js 代码后，scroll-view 页面将呈现如图 13-3 所示的效果。可以看到，一组 scrol-view 是垂直方向的，一组 scroll-view 是水平方向的，这两组  scroll-view 下都有若干子元素。控制  scroll-view 组件滚动条方向的属性是 scrol-x 和 scroll-y，垂直方向的 scroll-view 一定要设置一个高度，滚动条将在高度限定的范围内滚动。

注意页面中有两个按钮：click me to scroll into view 和 click me to scroll，这两个按钮将控制垂直方向 scroll-view 的滚动情况，开发者可以先点击这两个按钮看一下效果。每次点击左边的按钮，垂直 scroll-view 将滑动一个方块的距离；每次点击右边的按钮，垂直 scroll-view 下的子元素将移动 10。这就是 scroll-into-View 和 scroll-top 的效果。

scroll-into-view 指定一个 scroll-view 内某子元素的 id，被指定的子元素的顶部将对齐滚动区域的顶部。所以当我们在 js 中不断变换 scroll-into-view 的取值时，就会出现「一格一格跳动」的效果。每变换一次，scrol-into-view 就会被指定一个新的子元素 id，同时这个子元素将被移动到 scroll-view 的顶部。

scroll-top 指定的是垂直滚动条的位置，每次点击 click me to scroll 按钮都会将 scroll-top 的值增加 10，这样滚动条的位置就会向下移动 10，scroll-view 的子元素也将一起向下移动 10。

如果开发者足够细心会发现一个有趣的现象，如果一直点击 click me to scroll into view 按钮，子元素会「循环」滚动，因为 scroll-into-view 只和其指定的元素 id 有关系。但是如果一直点击 click me to scroll，就不会出现「循环」效果。因为 js 中的 scrolltop 会被一直增加，甚至超过 scroll-view 的高度（200+）。超过高度后，即使 scrolltop 被累加到 1000+，scroll-view 也不可能再往下滚动了。

除此之外，当我们不断点击 click me to scroll into view 和 click me to scroll 两个按钮时，upper、lower 和 scroll 这 3 个事件响应函数也会不断执行，并向 Console 面板中不断输出信息。请开发者注意观察 Console 面板。upper 是当页面滚动到顶部时触发的事件响应函数；lower 是当页面滚动到底部时触发的事件响应函数；scroll 当页面滚动时就会触发，无论我们用鼠标滚轮滚动，还是使用 scroll-into-view 或 scroll-top 滚动，只要滚动条动了，scroll 函数就会被触发。

### 13.3 深入理解小程序的单向数据绑定机制

在上一节的示例中，如果你足够仔细就会发现，当我们不断点击 click me to scroll 按钮让滚动条角触底后，再用鼠标滚轮将 scrol-view 滚动返回到顶部，再次点击 click me to scrol 按钮滚动条并不会向下移动 10，而是直接滚动到 scrol-view 组件的底部，这是为什么呢？

因为不断点击 click me to scroll 按钮将使 js 中的 scrolltop 累加到一个等于或者超出 score-view 组件最大高度的值（200+）。此时，使用鼠标将滚动条调回顶部将改变组件中的 scroll-top 属性值，让其恢复为 0 （0 代表滚动条在顶部）。但请注意，js 中的 scrolltop 变量并不会恢复到 0，此时 js 中的 scrolltop 変量依然是一个较大的数值，当再次点击 click me to scroll 按钮时，scrollTop 由于不是从 0 开始的，依然是滚动条在底部时的取值（200+），因此当其再次累加 10 后，将直接让滚动条从顶部跳到 scroll-viev 的底部。

从这个现象开发者应该理解了什么是小程序的单向数据绑定。可以通过控制 js 变量实现更新页面 UI（比如更新 scrollTop 变量将使滚动条不断滚动），但却不能通过鼠标拖动滚动条更新 js 中的 scrollTop 变量。一个方向的更新是可以的，但反过来却不可以，这就是单向数据绑定。逻辑层上的数据变更可以反映到 UI 层上，但 UI 层上的数据变更却不会自动反馈到 js 逻辑层中。

再举个例子，回顾一下之前多次使用的 input 组件。我们经常在 input 组件的 value 属性上绑定一个 js 变量，当操作 js 变量的取值时，input 组件的输入内容会被 js 変量改变。如果反过来呢？用户在 input 组件中输入内容时 js 中被绑定的变量会自动根据内容的变更而改变吗？并不会。像这样的情況在小程序中比比皆是，因为小程序只实现了单向数据绑定。这和著名的 MVVM 框架 AngularJS 不同，AngularJS 可以双向数据绑定，当我们更改了 UI 上的某个属性值时，JS 中被绑定的变量也会同样被更新。

当然，双向数据绑定也有缺点，就是性能较差。所以没有绝对优秀的解決方案，每个不同的解決方案有其优势也同时会存在缺点。寄生在微信中的小程序本身性能就无法比拟原生 App，所以为了保证性能，暂时不支持双向数据绑定也可以理解。

### 13.4 深入理解 scroll-view 组件的 bindscrolltolower、lower-threshold 属性

下面我们对 scroll-view 页面的代码做一些变更，变更的目的是更好地理解 bindscrolltolower 事件和 lower-threshold 属性。在 scroll-view.js 的 lower 函数中增加以下代码：

修改代码后，每当 scroll-view 组件触发 scrolltolower 事件时，都会将 scrolltop 重置为 0。此时我们不断点击 click me to scroll 按钮时，scorll-view 组件的滚动条将可以实现「循环」滚动。因为当滚动条滚动到距底部一定距离时（这个距离是 50 像素，后面我们会解释为什么是 50 像素）将触发 scrolltolowera 事件，这将导致 scrolltop 变量重置为 0，下ー次点击 click me to scroll 按钮时，scrolltop 将从 0 开始累加。

下面解释为什么距离底部 50 像素时会触发 scrolltolowers 事件。在 scroll-view 组件中有一个 ower-threshold 属性，当距底部 / 右边一定距离时（单位为 px）会触发 scrolltolower 事件，这个属性的默认值是 50 像素。我们可以修改这个属性，将其指定为 0，这样滚动条只有滚动到底部才会触发 scrolltolower 事件。

水平方向的 scroll-view 属性和事件的用法几乎和垂直方向的 scroll-view 组件一模一样，这里就不再赘述。但要注意水平方向 scroll-view 的 CSS 样式，关于水平方向 scroll-view 的注意事项我门已经在电影详情页面中详细讲解过。

scroll-view 的这些高级属性对于实现一些复杂效果非常有帮助，如果你想实现类似以下两种 App 中常见的功能效果，可以考虑使用 scroll-view 组件。其中，一个示例来自于 App「饿了么」，另个示例来自于小程序「猫眼电影」，如图 13-4 和图 13-5 所示。控制页面滑动是以上两张图中所实现效果的难点。scroll-view 组件可以帮助你实现这种效果。