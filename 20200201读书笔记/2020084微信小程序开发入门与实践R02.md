# 2020084微信小程序开发入门与实践R02.md

## 记忆时间


## 06. 文章详情页面

### 1. 逻辑脉络

详情页面的编码工作，不同页面间参数的传递技巧，页面跳转的方法、动态设置导航栏标题等，以及如何解决元素的垂直居中。

### 2. 摘录及评论

### 6.1 跳转到文章详情页面

首先新建文章详情页面。在 app.json 的 pages 数组下新增页面路径。保存后，开发工具会自动生成 post-detail 页面的 4 个文件。首先要实现的是从 post 文章页面通过点击跳转到 post-detail 详情页面。在 post.wxml 中的 block 代码块里注册一个事件，仅在 template 上增加了一个 catchtap，然后在 post.js 添加 onTapToDetail 方法。添加完 onTapToDetail 函数后，保存运行，并在文章列表页面点击任意一篇文章。没有任何反应，页面也没有跳转。为什么会这样？

```js
  // 跳转到列表详细页面
  onTapToDetail(event){
    wx.navigateTo({
      url: 'post-detai/post-detail',
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

### 6.2 不要在 template 上注册事件

看起来似乎是事件函数并没有响应。此时我们可以在 wxml 面板中看一下现在页面的骨架结构，如图 6-1 所示。注册事件的 template 消失了。在前面章节中我们讲过，template 标签仅仅是一个占位符，在编译后会被 template 的模板内容替换。所以，在 template 上注册事件是无效的。那么在 block 标签上注册可以吗？来试试，将 catchtape 的事件注册到 lblock 标签上。同样不可以，因为 block 也会在编译后「消失」。

那么，我们只有在 template 的外部增加一个 view，将 template 给包裏起来，并将 catchtap 事件注册到 vew 组件上。保存后，点击 5 篇文章中的任意一篇，就可以正确地跳转到 post-detail 文章详情页面了。

```js
  <block wx:for="{{postList}}" wx:for-item="item" wx:for-index="idx">
    <view catchtap="onTapToDetail">
      <template is="postItemTpl" data="{{...item}}"/>
    </view>
  </block>
```

1『用 catchtap 或者 catch:tap 都可以。』

### 6.3 页面间传递参数的 3 种方式

我们实现了从文章列表页面跳转到文章详情页面。要正确展示文章详情页面的内容，首先需要将文章的 id 号由 post 页面传递到 post-detail 页面，这样，post-detail 页面才能知晓它要显示哪篇文章。这涉及页面间的参数传递与通信。目前，在 MINA 框架中有以下几种参数传递方式：1）使用全局变量（关于全局变量，本书后面的章节中会讲到）。2）使用缓存。3）通过页面导航 url 的 query 参数传递。

1『优先使用「通过页面导航 url 的 query 参数传递」，这个方法一定要掌握。』

基本上参数的传递只有以上 3 种方式，其他的比如像事件信号的传参方式（一个页面 emit 发送信号，一个页面 on 监听信号，这种在 AngularJS 里很常见的传参方式，小程序是不能天然支持的），其实都是这些基本思路的变种。

全局变量我们将在后面讲到，至于缓存的传参方式，开发者在学习完缓存后应该很容易想到。其实，使用缓存数据库存储 data.js 初始化数据，又在 post.js 中读取缓存数据，这其实就是页面间的参数传递。仔细想想，是不是这样？1）和 2）两种都涉及全局变量，笔者个人不推荐这种污染全局的传参方式，而且我们的需求仅仅是两个页面间传递参数，完全不需要干抗全局。所以，选用方法 3 来做页面间的参数传递。

组件的自定义属性。再来整理下思路。要将 postId 由 post 页面传递到 post-detail 页面，首先需要在 post.js 中获取到 postId，随后再将 postId 附加到代码清单 6-2 中的 wx.navigateTo 的 url 中。要想在 post.js 中获取到 postId，就必须知道当前点击的文章是哪一篇文章。我们首先将 postId 绑定到每一篇文章的 wxml 中，使 postId 成为文章 wxml 的一个属性。注意，postId 已在 5.13 小节中加入到 data.js 文件里。绑定 postId 的方法很简单，就如同绑定文章的 date、title 等属性一样。post.js 文件的代码无须任何改动，只需要对 post.wxml 文件做一下改动即可。

以上代码中，我们在 view 里增加了一个属性 data-post-id="{{item.postId}}"，先来看看以上代码有什么效果。保存并运行代码后，打开调试中的「Wxml」这个面板，文章页面的骨架如图 6-2 所示。从图 6-2 中可以很明显地看到，每篇文章的 id 号都被绑定在了该文章的 view 容器上，剩下的工作就是，如何在 post.js 中获取当前点击的文章的 id 号。通过 dataset 获取组件自定义属性修改。修改 post.js 文件中的 onTapToDetail 函数如下：

1『学会在「wxml」面板里看信息，此时里面数据绑定的变量已经变成了具体的实际数据了。』

```
  onTapToDetail(event){
    var postId = event.currentTarget.dataset.postId;
    console.log(postId);
    wx.navigateTo({
      url: 'post-detail/post-detail?id='+postId,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

上述代码中，我们通过 event.currentTarget.dataset.postId，这段代码成功地拿到了当前文章的 postId。event 事件对象是由 MINA 框架在调用 onTapToDetail 函数时传递的参数。在 event 事件对象中，有一个 currentTarget 代表事件绑定的当前组件。

重点是 dataset 对象，dataset 对象里包含当前组件中所有属性名以 data-开头的自定义属性值。我们在代码清单 6-5 中的 view 上绑定了 data-post-id，所以通过 dataset.postId 将可以拿到当前组件的 postId。

组件自定义属性名有以下规则：1）必须以 data-开头。2）多个单词由连字符「-」链接。3）单词中最好不要有大写字母，如果有大写字母，除单词第一个字母外，其余大写字母将被转化成小写。4）在 js 中获取自定义属性值时，多个单词将被转化驼峰命名。

1『

上面作者的表述有误，dataset.xxxx，xxxx 是指组件里自定义属性名，即 data- 后面的名称。书里因为用的是 data-post-id，可能中间有连号的原因识别不了，换成 data-postid 后，使用 dataset.postid 即可读取属性值。要学会使用语句「console.log(event.currentTarget.dataset)」来查看点击事件所能获得的信息。

好好看官方的这份文档，作为附件 02：[事件 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F)，算是彻底弄明白冒泡和非冒泡事件的概念了。目前的理解用非冒泡事件 catch:tap 就足够了，冒泡事件（往外层容器传递）bind:tap 还没遇到过应用的场景。（2020-03-10）

```
productList: (event => {
    var type = event.currentTarget.dataset.label;
    wx.navigateTo({
      url: `/pages/product/product?type=${type}`,
    })
  }),

  productList: function(event){
    var type = event.currentTarget.dataset.label;
    wx.navigateTo({
      url: `/pages/product/product?type=${type}`,
    })
  },
```

顺便提下，上面的两种写法是等价的，第一种目前的理解是把 event 直接当做参数传递给后面 {} 包裹的函数里。

』

看起来很复杂，但举几个例子就非常清楚了，如表 6-1 所示。在获取到 postId 后，我们将 postId 附加在导航 url 的 query 参数中：url: 'post-detail/post-detail?id='+postId。获取页面参数值。再来看看如何在 post-detail 页面中获取 postId，在 post-detail.js。文件中添加以下代码：

```
  onLoad: function (options) {
    var postId = options.id;

  },
```

接受 post 页面传递参数的方法是通过 post-detail 页面 onLoad 函数里的 options 参数来获取。options 参数是由框架传递的。注意，这里 options.id 中的「id」必须同代码清单 6-6 中 navigateTo 中 url 的 query 参数名称保持致。

1『var postId = options.id，微信框架里 options 对象的属性名 id 一定要跟其父页面里，跳转函数导航 url 里的 query 参数（? 后面的）保持一致。比如在父页面 post.js 里用的是 testid，「url: 'post-detail/post-detail?testid='+postId」，那么在子页面里也得用这个名称「var postId = options.testid」。』

### 6.4 编译时设置初始化页面及参数

现在我们主要的代码编辑工作集中在 post-detail 这个页面。但每当保存刷新小程序后，项目都将从欢迎页面启动。我们不得不依次点击启动页面、文列表，才能进入到文章详情页面以预览文章详情的效果，这相当的麻烦。当然可以按照 4.1 小节中的方法，将 post-detail 页面设置为 app.json 中 pages 数组的第一项，但 post-detail 还需要传入ー个 postId 的参数才可以正确地运行，且手动来回更改 pages 数组非常麻烦。

小程序在 122100 版本中增加了编译选项，在此版本中，官方提供了一个「自定义编译」功能，可用于定义小程序的启动页面，如图 6-3 所示。122100 版本后，「编译」这里变成了两个选项，请仔细查看。上面一个图标是默认编译，下面的图标是自定义编译，点击下面的图片将弹出如图 6-4 所示的界面。

启动页面一栏中将路径设置为 post-detail 页面的启动路径：pages/post/post-detail/post-detail，页面自定义参数类似于 url 中的 query 参数，设置 id=2 将可以在页面中通过 onLoad 函数中的 options.id 获取到这个值。设置完成后，必须勾选【使用以上条件编译】这个选项。

保存刷新页面，项目将直接进入 post-detail 页面，不再出现 welcome 启动页。同时，我们发现，以这种方式打开的 post-detail 页面无法再返回到 post 页面，因为不是通过 post 页面导航到 post-detail 顶面的。可以通过「&」连接多个页面参数，比如 id=2&name="MR.L"，同时将两个参数传递到 post-detaill 页面中。有了以上功能，就可以非常方便地调试 post-detail 页面。如果想恢复默认的启动页，只需去掉【使用以上条件编译】选项即可。

### 6.5 读取文章详情数据

现在，我们已经在文章详情页面中拿到了文章的 postId，接下来需要根据这个 postId 去缓存数据库中读取文章详细数据，并将数据用于构建文章详情页面。所有对于缓存数据库的操作，我们都会放在 DBPost 这个对象中，在 DBPost.js 中增加和修改部分代码。注意，以上代码只标注出了相关修改和增加代码，并非全部代码。首先修改 constructor 构造函数，增加一个构造参数 postId，并将 postId 保存到 this 变量中。接着增加一个方法 getPostItemById() 用于获取指定 id 号的文章数据。

1『构造函数是对象实例化的时候自动运行的。』

```
class DBPost {
  // 构造函数里的传入参数从原来的 url 改成 postId
  constructor(postId) {
    this.storageKeyName = 'postList';
    this.postId=postId;
  }

  // 得到全部文章信息
  getAllPostData() {
    var res = wx.getStorageSync(this.storageKeyName);
    if (!res){
      res = require('../data/data.js').postList;
      this.execSetStorageSync(res);
    }
    return res;
  }

  // 本地缓存，保存/更新
  execSetStorageSync(data) {
    // 书里是 get 更改为 set，但发现 get 也能存入数据，疑问
    wx.getStorageSync(this.storageKeyName, data);
  }

  //获取指定id号的文章数据
  getPostItemById() {
    var postsData = this.getAllPostData();
    var len = postsData.length;
    for (var i=0;i<len;i++) {
      if (postsData[i].postId == this.postId) {
        return {
          // 当前文章在缓存数据库中的序号
          index: i,
          data: postsData[i]
        }
      }
    }
  }

};

export {DBPost}
```

DBPost.js 修改完毕后，我们尝试在 post-detail.js 中获取指定 id 号的文章数据，并使用 this.setData 绑定该数据。

```
  onLoad: function(options) {
    var postId = options.id;
    this.dbPost = new DBPost(postId);
    // 因为 getPostItemById() 返回的是个对象
    this.postData = this.dbPost.getPostItemById().data;
    this.setData({
      post: this.postData
    });
  },
```

1『之前把上面的代码写进 post.js 里了，导致错误，找了很久才发现这个错误；注意，this.setData 传入的对象，其键「post」是跟 post-detail.wxml 数据绑定的数据名要一致。』

注意上述代码中，在使用 new 实例化 DBPost 后，将 dbPost 这个对象保存在了变量 this 中，这样以后如果要再次使用 DBPost，则不需要再重新实例化这个对象，只需要使用 this.dbPost 即可弓用这个对象。

### 6.6 文章 id 号的数据流向图

我们来疏理一下，post-detail.js 是如何从初始化数据中拿到文章 id 号，并最终通过 id 号来获取到文章详情数据的，参见图 6-5 所示。文章 id 号最初是存在于 data.js 中的，通过一系列的事件操作，它最终会被传递到 post-detail.js 中。一旦 post-detail.js 拿到文章的 id 号，该页面就可以根据 id 号来获取文章详情数据了。

1『数据的流向很清晰：data.js 里初始化数据进入缓存，post.js 从缓存里读取数据，post.js 绑定数据到 post.wxml 里，post.wxml 里通过 catchtap 事件回到 post.js 里，在 post.js 里通过导航 URL 到 post-detail.js，post-detail.js 使用  id 号读取数据到缓存，缓存数据里筛选出文章详细数据回 post-detail.js 然后给与展现。』

### 6.7 编写文章详情页面

在代码清单 6-9 中，我们获取了文章的 postId，并通过 DBPost 查询到了该文章的相关数据，随后我们用 this.setData 函数做了文章数据的数据绑定。下面，我们来编写文章详情页面的骨架和样式。在 post-detail.wxml 中加入以下页面骨架代码：

还是要注意代码中 {{post.title}} 中的数据绑定语法一定要正确，否则无法读取数据。保存并运行代码，post-detail 页面将显示这些文章数据，但整个页面的样式是错乱的，因为还没有编写 post-detail 页面的 wxss 文件。保存并刷新页面后，文章详情页面将正确地显示出来，如图 6-6 所示。

### 6.8 垂直居中问题的经典解决方法

我们在编写 CSS 时，很多时候都会面临如何将两个元素垂直居中对齐的问题。比如在代码清单 6-11 中如何将作者名称（author）和作者头像（avatar）垂直居中对齐。我们在 3.4 小节中学习了 flex，这里就来看看如何使用们 flex 解決这个问题。

```
.author-box {
  display:flex;
  flex-direction: row;
  align-items: center;
}

.avatar {
  height: 50rpx;
  width: 50rpx;
}

.author {
  font-weight: 300;
  margin-left: 20rpx;
  color: #666;
}
```

以上代码摘自 post-detail.wxss。解决思路如下：将 avatar 和 author 用一个容器包裹起来（author-box），使用 display:flex 将该容器设置为们 flex 盒子模型，使用 flex-direction: row 指定 flex 的方向为 row。关键的代码是 align-items: center，这将使 flex 盒子里的元素在交叉轴方向上居中。在本例中主轴是水平方向（因为设置了 flex-direction 为 row），所以交叉轴是垂直方向，align-items: center 将控制垂直方向居中。关于 flex 及轴的概念已经在 3.4 小节中详细讲解过，开发者可自行回顾一下关于主轴和交叉轴的概念。

开发者可以对比一下，welcome 页面中是如何使头像、文字和按钮这 3 个元素水平居中的。welcome 页面中设置了 flex-direction: column，所以主轴是垂直方向，align-items: center 将控制水平方向上的居中。小程序对于 flex 的支持相当完善，建议多使用 flex 进行元素布局。

1『flex 框架很重要。产品库里的设备详细页面，也是用的 flex 布局。』

### 6.9 动态设置导航栏标题

使用两种方法分别设置 post 页面和 post-detail 页面的导航栏文字。使用配置文件配置导航栏标题。第一种方法是使用 app.json 或者页面的 json 文件来配置导航栏标题。如果是在 app.json 中进行配置，则它是全局行为，项目所有的页面将显示同一个标题；而如果是在页面的 json 文件中配置标题，则只会影响当前配置页面。我们之前在 app.json 的 window 属性中通过设置 navigationBarbackgroundColor 实现了指定导航栏的颜色。window 还有以下 2 个属性用于配置导航栏文本：1）navigationBarTextStyle 指定导航栏标题文字的颜色，只支持 black/white，默认值为 black。2）navigationBarTitleText 指定导航栏标题文字。在 app.json 中对 window 属性增加以上两个配置项，代码如下：

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#ecc0a8",
    "navigationBarTitleText": "大龙的书屋",
    "navigationBarTextStyle": "black"
  },
```

保存运行后可以看到，所有页面的导航栏都增加了「文字」这两个字，它的颜色为白色。这并不是我们想要的，我们希望不同页面显示不同的导航栏标题。下面来解决这个问题。我们之前讲过，window 这个配置项既可以在 app.json 中配置，也可以在 window 中配置（其他配置项只能在 app.json 中配置）。

使用 wx.setNavigationBarTitle(Object) 设置导航条。在某些情况下，我们希望导航栏的文字可以根据页面内容的不同而有所変化。比如在文章详情页面中，我们希望导航栏可以实时显示当前文章的标题，不同的文章显示不同的标题文字。来看看如何实现这个功能。小程序提供了 wx.setNavigationBarTitle(Object) 来动态设置导航栏标题。小程序官方文档中指出，页面的导航栏标题必须在页面生命周期的 onReady 之后来设置，否则无效。原文如下：对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置。我们遵照官方文档的说明，在 post-detail.js 中加入以下代码：

```
  onReady: function () {
    wx.setNavigationBarTitle({
      title: this.postData.title,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  }
```

按照文档的描述，我们在页面生命周期函数 onReady 中调用了 wx.setNavigationBarTitle(Object) 方法。它接收一个 object 参数，其中 title 属性被设置为当前文章的标题。保存运行代码，发现页面的导航栏文字变成了文章的标题。这里需要指出，在 122100 版本之前，wx.setNavigationBarTitle(Object) 方法确实只能在页面的 onReady 函数里设置。如果尝试在页面的 onLoad、onShow 函数里调用 wx.setNavigationBarTitle(Object) 方法，文章的标题将出现一闪而过的情况。这种情况是符合官方文档说明的：「对界面的设置如 wx.setNavigationBarTitle 请在 onReady 之后设置」。因为 onReady 在 onShow 发生之后才触发，onShow 将标题设置完毕后，onReady 会重新渲染页面并覆盖导航栏的标题，这就是我们说的「一闪而过」的情况。

但在最新的 130400 版本里，无论是在页面的 onLoad 或者 onShow 函数中调用 wx.setNavigationBarTitle(Object) 方法，都可以成功地设置导航栏标题，并不会出现一闪而过的情况。但无论如何，还是建议开发者按照官方文档所描述的，在 onReady 函数里进行界面的设置操作，以免官方在未来再次改动底层的运行机制时造成代码无法运行。

## 07. 收藏、评论、点赞与计数功能

### 1. 逻辑脉络

通过实现收藏、评论、点赞与计数功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

1）组件条件渲染 wx:if, wx:elif 和 wx:else，其中 wx:if 和 wx:elif 的值为条件变量，wx:else 不需要设置值。根据条件值是否为 true 判断应该显示哪个组件。2）交互式反馈 API：wx.showToast、wx.hideToast、wx.showModal 和 wx.showActionSheet。3）善用本地缓存。4）控制 UI 元素的显示与隐藏的另一种方式是使用 hidden 属性。它的值也是 bool 类型的变量。和 wx:if 用法比较：在需要频繁切换的情景用 hidden 更好；在运行时条件不大可能改变时用 wx:if 更好。5）input 组件的用法。官方教程：input 组件。6）敏感操作需要获得用户主动授权。一定要处理用户拒绝授权的场景。

3『[input | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/input.html)』

### 2. 摘录及评论

本章通过编写几乎所有内容型应用都会附带的「评论」「点赞」「读计数」「收藏」等功能，来学习使用小程序的交互反馈组件、缓存的应用、图片选择和预览、屏蔽关键字、录音、拍照以及播放录音等功能。

### 7.1 收藏、评论、点赞、计数功能准备工作

我们先来编写收藏、评论和点赞的功能按钮。阅读计数是一项被动功能，无须用户有意识地主动触发。在 post-detail.wxml 中新增一段工具栏代码。

```
<view class="tool">
  <view class="tool-item" catchtap="onUpTap" data-post-id="{{post.postId}}">
     <image animation="{{animationUp}}" wx:if="{{post.upStatus}}" src="/images/icon/wx_app_liked.png" />
     <image animation="{{animationUp}}" wx:else src="/images/icon/wx_app_like.png" />
    <text>{{post.upNum}}</text>
  </view>
  <view class="tool-item comment" catchtap="onCommentTap" data-post-id="{{post.postId}}">
    <image src="/images/icon/wx_app_message.png"></image>
    <text>{{post.commentNum}}</text>
  </view>
  <view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
    <image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
    <image wx:else src="/images/icon/wx_app_collect.png" />
    <text>{{post.collectionNum}}</text>
  </view>
</view>
```

黑色加粗部分为新增代码。在 post-detail.wxml 页面的 container 中添加了一段 \<view class="tool"> 的相关代码。该代码实现了收藏、评论和点赞 3 个功能按钮。每个功能按钮都绑定了对应的点击事件，注意 view 组件上的 catchtap 属性。除此之外，我们还在每个功能按钮上使用 data-post-id 绑定了当前文章的 id。post.upNum、post.commentNum 和 post.collectionNum 等数据已经在 5.13 小节中全部添加到了 data.js 文件中，接着编写 3 个功能按钮的样式。保存刷新后，3 个功能按钮将出现在 post- detail 页面的正下方，如图 7-1 所示。

```
/*点赞和评论*/
.tool{
  height: 64rpx;
  margin: 20rpx 28rpx 20rpx 0;
  display: flex;
  justify-content: center;
}
.tool-item{
  align-items: center;
  margin-right: 30rpx;
  display: flex;
}

.tool-item image{
  height: 30rpx;
  width:30rpx;
  margin-right: 10rpx;
}

.comment image{
  transform: scale(.85);
}
```

### 7.2 文章收藏功能

我们首先来实现文章收藏功能。文章收藏功能需要记录两个变量值：1）自己是否收藏了文章。如果自己收藏了，那么需要将收藏的图片更换为已收藏。2）所有用户收藏文章的总数量。需要注意的是，由于我们的数据库只在本地，无法多次收藏同篇文章，所以收藏数量永远只能在初始数量的基础上 +1 或者 -1，分别对应取消收藏和点击收藏两种状态。但在真实的项目中，这个收藏数量却是要受到所有用户取消、收藏文章动作影响的。同样的情况也会出现在「文章点赞」这个功能里。

当页面从 post 跳转到 post-detail 时，我们就需要知道该文章是否已被用户收藏。在 data.js 中，我们使用 collectionStatus 这个属性表示文章是否已被收藏，这个变量的类型是 Boolean。那么如何根据 collectionStatus 这个变量的取值来动态切换收藏图标呢？熟悉传统 Web 开发的读者很容易想到用 jQuery 获取 image 标签，再动态地设置 image 的 src 属性。再次强调，小程序没有 DOM，一切都是数据绑定，请抛弃 DOM 的思维方式。

条件渲染：wx:if 与 wx:else。collectionStatus，只有两种取值：true 或者 false。我们需要做的是，当 collectionStatus 为 false 时，显示图 7-2 未收藏状态的图标，而当 collectionStatus 为 true 时，显示图 7-3 收藏状态的图标。以上需求是不是就是编程中非常经典的 if else？如果 wxml 组件也像 js 代码一样有 if else 就可以解决动态显示收藏图片的问题。下面来看看如何实现这个功能。小程序提供了 wx:if 与 wx:else 来实现条件渲染。当变量为 true 时，执行 wx:if，否则将执行 wx:else。修改收藏按钮的 wxml 代码如下：

```
<view class="tool-item" catchtap="onCollectionTap" data-post-id="{{post.postId}}">
<image wx:if="{{post.collectionStatus}}" src="/images/icon/wx_app_collected.png" />
<image wx:else src="/images/icon/wx_app_collect.png" />
<text>{{post.collectionNum}}</text>
</view>
```

上述代码中我们添加了两个 images 组件，分别是收藏和未收藏图片。这两个 image 组件各有一个 wx:if 和 wx:else 属性。当 post.collectionStatus 为 true 时将显示 wx_app_collected.png 图片而当 post.collectionStatus 为 false 时将显示 wx\_app\_collect.png 图片。由于我们已经在 data.js 文件中将部分文章的收藏状态设置为 true，因此保存并运行项目，发现所有 collectionStatus 为 true 的文章，其收藏图片都将显示 wx\_app\_collected.png，如图 7-4 所示。

wx:if 与 wx:else 的条件渲染在小程序中被大量使用，不仅仅被用来做图片的更换，还可以用来控制元素的显示和隐藏。wx:if 可以被单独使用，并不一定要同 wx:else 一起使用。除此之外，条件渲染还可以做多级别的 if else，如代码清单 7-4 的示例代码所示。

如果变量 length 的取值大于 5，那么将显示数字 1。如果变量 length 的取值大于 2 且小于等于 5，那么将显示数字 2。以上条件都不满足，就显示数字 3。你还可以添加更多的 elif 分支，以实现更多级别的条件判断。

实现收藏点击功能。在 7.2.1 小节中，我们仅仅是在 post-detail 页面加载时读取了该文章对于当前用户是否为收藏状态，并正确地设置和显示了这个状态。在这个小节中，我们将实现用户点击图片进行文章的收藏和取消收藏功能。首先我们继续完善 DBPost 这个数据库操作类。在 DBPost 类中添加一个方法，用以处理文章的收藏操作。该方法中调用了 DBPost 类的 updatePostData 方法，这个方法我们还没有编写。在 DBPost 类中添加 updatePostData 方法。该方法是处理点赞、评论、收藏、阅读的核心方法。

1『数据库操作类 DBPost 的概念很重要，一定要有做一个操作类作为接口来预数据库（缓存）交互。』

```
  //更新本地的点赞、评论信息、收藏、阅读量
  updatePostData(action, newComment) {
    const itemData = this.getPostItemById();
    let postData = itemData.data;
    let allPostData = this.getAllPostData();
    switch (action) {
      case "collect":
        if (!postData.collectionStatus) {
          postData.collectionStatus = true;
          postData.collectionNum++;
        } else {
          postData.collectionStatus = false;
          postData.collectionNum--;
        }
        break;
      case "up":
        if (!postData.upStatus) {
          postData.upStatus = true;
          postData.upNum++;
        } else {
          postData.upStatus = false;
          postData.upNum--;
        }
        break;
      case "comment":
        postData.comments.push(newComment);
        postData.commentNum++;
        break;
      case "reading":
        postData.readingNum++;
        break;
      default:
        break;
    }
    allPostData[itemData.index] = postData;
    this.execSetStorageSync(allPostData);
    return postData;
  }

  collect() {
    return this.updatePostData('collect');
  }

  up() {
    return this.updatePostData('up');
  }
```

我们目前仅处理 collect 这一种操作，后续我们将继续在代码清单 7-6 的 switch case 中添加评论、读数、点赞等处理分支。这样，DBPost 就具备了处理文章收藏的能力。当用户点击收藏按钮后，在点击事件函数中调用 DBPost 的 collect 方法即可。处理文章收藏动作的事件函数是 onCollectionTap，这个事件函数已在代码清单 7-1 中被注册在了收藏功能按钮上。我们只需要在 post-detail.js 中编写这个方法即可。

```
  onCollectionTap: function (event) {
    var newData = this.dbPost.collect();
    // 重新绑定数据。注意，不要将整个newData全部作为setData的参数，
    // 应当有选择的更新部分数据

    this.setData({
      'post.collectionStatus': newData.collectionStatus,
      'post.collectionNum': newData.collectionNum
    })

    // 交互反馈
    wx.showToast({
      title: newData.collectionStatus ? "收藏成功" : "取消成功",
      duration: 1000,
      icon: "success",
      mask: true
    })
  },
```

1『开始的时候无法取消收藏，后来发现 DBPost 类里没有添加 collect() 方法，书里的源码没有提到这点。』


交互反馈 wx:showToast。现在，我们已经实现了文章的收藏与取消收藏功能，但收藏功能的体验并不好，用户在收藏和取消收藏后没有任何交互反馈提示。小程序提供了一些交互反馈 API 来帮助开发者处理交互相关的问题。目前，小程序提供了以下 4 个交互反馈 API：wx:showToast、wx.hideToast、wx:showModal、wx:showActionSheet。

我们选用 wx:showToast 来制作文章收藏功能的交互反馈。其中，object 参数的 title 属性用于设置提醒消息的内容；duration 设置提醒的自动消失时间，最长 10000 毫秒，默认值为 1500 毫秒；icon 可以设置一个小图标，其取值只能是 success 和 loading; mask 指定是否显示透明的蒙层，以防止触摸穿透，默认值为 false。mask 主要用来防止用户连续点击收藏按钮。开发者可执行尝试将 mask 设置为 true 和 false 时的不 同效果：当 mask 为 true 时连续点击收藏图标，图标不会连续做出收藏 / 取消收藏的响应；当 mask 为 false 时，就会不停地响应用户的点击操作。showToast 的效果如图 7-5 所示。

1『实现了收藏成功和取消收藏 2 个状态的来回切换，不过只是跳出来的显示消息，图标没有实现来回切换，下面的点赞功能一样，待解决。』

### 7.3 文章点赞功能

文章点赞功能的实现思路同收藏几乎是一样的。首先在 DBPost.js 中增加点赞的方法。接着在 DBPost 的 updatePostData 方法中处理当 case 为 up 时的情况。下面给出 updatePostData 的全部代码。黑色加粗部分为新增代码。代码清单 7-10 同代码清单 7-6 相比，仅仅增加了 case 为 'up' 时的这段代码。很明显，我们可以看到处理点赞的逻辑同处理收藏时的逻辑几乎一样：改变 upStatus 的状态，并对 upNum 这个计数变量做相应的增减操作。

我们编写完 DBPost 中关于点赞的接口后，接着编写 post-detail.js，和 post-detail.wxml 中关于点赞的相关代码。onUpTap 方法响应用户点赞的动作。当用户点击点赞按钮后，onUpTap 方法将调用 DBPost 的 up 方法并将返回的最新数据使用 this.setData 更新。类似于收藏功能，我们还需要使用条件渲染 wx:if 改写 wxml 中的点赞按钮。

以上代码将在 post.upStatus 为 true 时显示 wx\_app\_liked.png，当 post.upStatus 为 false 时显示 wx\_app\_like.png。在编写完以上代码后，保存运行项目，点击点赞按钮，图片会不断切换，点赞数也将相应地 +1 或者 -1。很多开发者可能还不太习惯使用数据绑定的方式来做样式、状态的切换，但数据绑定的写法确实非常简化、方便。我们只需要在 js 中改变各类变量的状态和值，前端组件就会响应我们的操作，动态地做出变化。

### 7.4 本地缓存的重要性及应用举例

提供本地的 key&value 缓存机制是小程序的一大特点，善用本地鍰存将可以极大地改善客户端的体验与服务器的性能。前几个小节中，我们大量地使用了本地缓存来模拟服务器的数据库。这样做一方面是因为我们并没有真实的服务器，必须依靠客户端的缓存能力来记录数据；另一方面是因为即使在真实的项目中我们拥有自己的远程服务器，也依然需要在客户端管理本地缓存。

举个例子，如果我们要实现一个城市列表插件，就必然要获取全国所有城市的信息。全国大概有 600 多个城市，这么大的数据量难道每次打开这个插件都要去服务器取城市数据吗？这些城市的数据相对非常稳定，并不会频繁变化，每次都去服务器加载是对流量和服务器性能的严重消耗。所以，最好的解決方案就是将城市数据保存在本地缓存中，而不是每次都去服务器请求数据。

在一个高性能的产品中，缓存的重要性是不言而喻的。建议开发者将本地缓存视作一个本地的 key&value 数据库，并封装一些类和公共方法，提供给项目中的各个调用方。最好不要让 getStorage、setStorage 等方法充斥在项目的每一个角落。Orange Can 项目中的 DBPost 类就是一个不错的示例，它实现了对缓存的良好管理，并向调用方提供了一系列可读性非常强的 API。建议开发者参考 DBPost 并将这种思路应用到自己的项目中。

1『这节缓存（本地数据库）的讲解启发很大。项目里做一个管理本地缓存的 API 已经开始在产品库里实现了。』

### 7.5 支持文字、图片、拍照、语音上传的文章评论

文章评论不仅可以发表文字，还可以上传图片和语音。评论页面将使用一个全新的 post-comment 页面，它属于 post-detail 的子页面。我们将通过点击评论功能按钮跳转到 post-comment 页面。

首先，在 app.json 的 pages 数组下注册 post-comment 页面。保存后将自动在项目里创建 post-comment 目录以及页面的 4 种类型文件。post-comment 将作为 post-detail 的子页面。在 post.js 中添加以下代码：

```
  // 跳转到评论页面
    onCommentTap:function(event) {
    var id = event.currentTarget.dataset.postId;
    wx.navigateTo({
      url: 'post-comment/post-comment?id='+id,
      success: (result)=>{
        
      },
      fail: ()=>{},
      complete: ()=>{}
    });
  },
```

以上代码将携带当前文章的 id 号并跳转到 post-comment 页面。

1『发现无需额外设置即可跳转，原以为还需在 post.wxml 里的组件里设置属性才能跳转。』

### 7.6 文章评论页面的实现步骤与思路

构建文章评论页面的思路分为两部分：1）加载并显示当前文章已存在的评论。2）实现添加新评论的功能。

这个思路不是做特定功能的思路，而是一种适用于大部分前端功能的通用思路，就像我们在 post-detail 页面中去编写点赞、收藏等功能时一样，先显示点赞和收藏的数量、状态，再考虑实现点赞和收藏的操作功能。我们来按照以下步骤逐步构建整个文章评论模块的相关页面和功能：1）在 post-comment.js 中获取并绑定文章评论数据。2）编写 post-comment 页面的 wxml 和 wxss 显示文章评论数据。3）编写添加新评论的功能。

### 7.7 获取并绑定文章评论数据

我们在 data.js 中《从童年呼嘯而过的火车》这篇文章下面模拟了 4 条评论数据（comments 数组）。按照 7.6 节中分析的思路，首先应当从缓存数据库中读取这 4 条数据并将数据绑定到框架中。首先在 post-comment.js 中增加以下代码：

以上代码引入了 DBPost 缓存数据库操作类，同时在 onLoad 函数里接收由 post-detial.js 传递过来的 postId。接着实例化 DBPost，再调用 DBPost 的 getCommentData 方法得到评论数据，最后使用 this.setData 将评论数据绑定到框架中。很明显，我们的 DBPost 中缺少 getCommentData 方法，现在来编写这个方法。在 DBPost.js 中新增以下代码：

在 getCommentData 这个方法中，我们还调用了 compareWithTime 和 util.GetDiffTime 这两个方法。compareWithTime 用于将评论按照时间降序排列，保证最新的评论在最上方。util.GetDiffTime 将评论的时间戳转化为「多少分钟前，多少小时前，昨天，月日」等格式。下面我们来实现这两个方法。在  DBPost.js 中添加 compareWithTime 方法，代码如下：

接着实现 util.GetDiffTime 方法。这个方法属于公共方法，我们新建一个 util 文件，将所有的公共方法都放置到这个 util 文件中。在根目录下新建文件夹 util，在 util 文件夹下新建 util.js 文件并在该文件中新增以下代码：

1『新版开发工具里自动建了公共方法文件夹 utils，注意名称后面多了个 s，可以直接用自建的。』

上述 GetDiffTime 方法中调用了 Date 的 format 方法。继续添加 format 这个方法。需要注意的是，format 方法被添加在了 Date 的原型链上，这样所有 Date 类型的变量都将自动拥有 format 这个方法。

不需要深入研究上面这段代码，只需要知道它的作用即可。最后，在 util.js 的末尾添加以下代码；这样 util.js 这个模块就编写完成了。为了在 DBPost.js 中引用这个模块，我们需要在 DBPost.js 中使用 require 来引用 util 模块。

```
var util = require('../utils/util.js')
```

编写完以上代码后，DBPost 的 getCommentData 就完成了。现在，在 post-comment.js 的 onLoad 方法里就可以正确获取文章的评论数据。开发者可自行在代码清单 7-15 中使用 console.log (comments）来验证一下是否能够正确获取到文章评论。需要注意的是，我们仅仅在《从童年呼嘯而过的火车》这篇文章里设置了 4 条评论数据，其他文章是没有评论数据的。开发者可根据自身的需求修改 data.js 中的初始化数据。注意，修改完 data.js 后一定要用开发工具清除一下缓存，并重新运行项目，之后更改才能生效。

1『也就是在 post-comment.js 文件中使用语句 console.log (comments）验证，这个办法好，不用先写 post-comment.wxml 就直接在工作台上看结果；缓冲里的数据修改后记得一定要清除一下缓存。』

图 7-6 是输出的《从童年呼嘯而过的火车》这篇文章的 comments 变量。Comments 数组中包含了 4 个 Object 对象，每一个对象代表着一条评论。我们的评论支持文本、图片和录音 3 种类型。开发者可以对比一下图 7-6 中的 content 属性，在该属性下，img 数组是评论中的图片；txt 是评论中的文本；而 audio 是评论中的音频。注意，img 是数组，txt 是字符串，而 audio 是对象。

对于一条评论，有以下几条规则：1）图片类型评论最多只能包含 3 张图片。2）音频类型评论只能包含一条音频。3）一条评论可以同时包含文字和图片。4）音频类型评论不能包含文字和图片。这样，我们就完成了获取并绑定文章评论数据这个步骤。在下一节中，我们将编写 post-comment 页面的 wxml 和 wxss 文件来显示这些已绑定的数据。

### 7.8 显示文章评论数据

读取到文章评论数据后，我们需要编写 post-comment 页面的 wxml 和 wxss 文件以显示这些数据。在 post-comment.wxml 中增加以下代码：

整个代码里所用到的知识点都已经在前面的内容中讲到过，每条评论都会对 3 种类型的评论做处理。我们重点来看看上述代码中的几个 wx:if 条件渲染。

    <view class="comment-txt" wx:if="{{item.content.txt}}">

这里的 wx:if 将判断 item.content.txt 有没有值，如果没有，那么整个 view 都不会显示；如果有，就将显示文字评论。

    <view class="comment-voice" wx:if="{{item.content.audio && item.content.audio.url}}">

这里的 wx:if 将判断 audio 是不是空值，如果不是空值接着判断 audio 这个对象的 url 有没有值，只有满足这两个条件才会显示音频评论。

    <view class="comment-img" wx:if="{{item.content.img.length!=0}}">

这里的 wx:if 将判断 img 这个数组是不是空，如果不是空，就将显示多张图片。

正如我们之前提到的，wx:if 的应用是非常灵活的，开发者应当理解这种用法。post-comment 的 wxml 编写完后，接着来添加评论列表的样式。

以上代码中有部分样式使用了 position:absolute，这是为了后面编写新增评论的功能而准备的。保存运行代码，post-comment！将显示如图 7-7 所示的界面。如果此时我们尝试去点击第二条评论的语言播放，就会发现它并没有效果，原因是初始化数据中的语音给的是一个假的 urI。这里只是为了展现语音评论的显示效果，在后面的章节中我们将真实地新增和旙放语音评论。

### 7.9 实现图片预览

在 7.8 节中，我们所有的图片都以固定尺寸显示，并将 image 的 mode 设置为了 aspectFill。本节我们将为图片添加预览功能。

无须自己编写图片预览插件，小程序已经为我们提供好了图片预览的接口 wx.previewlmage(object)。它有以下两个重要属性：1）current 当前显示图片的链接，不填则默认为 urls 的第一张。2）urls 需要预览的图片链接列表，类型为数组。

这里要注意的是，urls 是一个数组，可以支持多张图片。它实际上类似于一个相册，可以左右滑动查看多张图片。修改 post-comment.wxml 中 class="comment-img" 这个 view 组件内容。

```
<view class="comment-img" wx:if="{{item.content.img.length!=0}}">
<block wx:key="comment-{{idx}}" wx:for="{{item.content.img}}" wx:for-item="img" wx:for-index="imgIdx">
  <image src="{{img}}" mode="aspectFill" catchtap='previewImg' data-comment-idx="{{idx}}" data-img-idx="{{imgIdx}}"></image>
</block>
</view>
```

以上代码在原有代码的基础上增加了以下属性：1）在每一张 image 图片上注册一个事件 catchtap="previewImg"，用来相应点击图片的操作。2）在 block 标签上新增 wx:for-index="imgIdx"，用以定义图片序号。3）在每一张 image 图片上绑定了ー个自定义属性：data-comment-idx="{{idx}}"，用来绑定当前评论在评论数组中的序号，并在 previewImg 方法中获取这个序号。

接着在 post-comment.js 中实现 previewImg 这个方法。

```
  // 预览图片
  previewImg:function(event){
    // 获取评论号
    var commentIdx = event.currentTarget.dataset.commentIdx,
      imgIdx = event.currentTarget.dataset.imgIdx,
      imgs = this.data.comments[commentIdx].content.img;
      wx.previewImage({
        urls: imgs,
        current:imgs[imgIdx]
      })
```

注意 wx.previewImage 的用法，它接收一个 object 对象，对象的 urls 数组定义了一组需要预览的图片 url；而 current 定义了当前展示的图片 url。完成以上代码后，保存刷新项目。这时，我们会发现点击评论中的某一张图片后会打开图片预览窗口，但图片并不会显示出来。

wx.previewImage 在当前 130400 版本中有以下几个情况会造成无法预览图片：1）wx.previewImage 只能预览位于网络中的图片，而无法预览本地图片。我们初始化数据中的图片是位于本地的，所以无法预览。开发者可以将 data.js。文件中的文章评论图片地址更换为以 http 开头的网络地址；2）除了网络地址和本地地址，还有一种地址是小程序的临时文件地址，对于这样的临时文件地址，同样在模拟器中无法预览，但在真机中却可以预览。关于临时文件地址，我们将在后面学习 wx.chooselmage 方法时看到。

注意，在目前的 130400 版本中，本地文件既无法在模拟器中预览，也无法在真机中预览；临时地址文件无法在模拟器中预览，却可以在真机中预览。130400 版本的下ー个版本已经放出了 beta 测试版，官方文档在版本说明中指出有可能会修复 wx.previewImage 不支持 localld 的问题。经下载测试版测试，开发工具中可以预览来自临时文件地址的图片，但依然不可以预览本地图片。总体来说，这些怪异的现象对我们开发小程序影响不大，因为在真实项目中评论显示的图片都来自于服务器，所以无论是在模拟器中还是在真机中都可以预览。

### 7.10 实现提交评论的界面

在前几节中我们完成了评论的显示功能。在这一节中我们将实现如何提交一条文本类型的评论。提交评论的功能区域如图 7-8 所示。点击提交功能区域最左侧的声音图标将可以由发送文本切换到发送语音，点击右边的加号图标将可以选择图片和拍照。我们一步步地完成以上各项功能。

2『化工 101 上实现提交评论的功能。』

首先需要完成的是文本类型评论的提交功能。在 post-comment.wxml 文件中新增一段代码，以显示评论区域。接着编写 post-comment 页面的样式，在 post-comment.wxss 文件中新增以下样式；保存后，可以看到评论框的大致模样。当然，我们还没有为评论框编写任何逻辑代码，此时开发工具有可能会报错。需要注意的是，代码清单 7-27 中的部分样式在代码清单 7-26 中并未全部用到，但我们在后续的代码中将会使用到。下面我们来对 wxml 里的新增代码关键部分做一些解释：

    <view hidden="{{useKeyboardFlag}}" class="input-item"> 表示录音输入框。

    <view hidden="{{!useKeyboardFlag}}" class="input-item"> 表示键盘输入框。

以上两个评论框由 useKeyboardFlag 这个 Boolean 变量来控制显示或者隐藏。useKeyboardFlag 变量将由 catchtap="switchInputType" 这个事件来控制。

catchtouchstart="recordStart" 和 catchtouchend="recordEnd" 将开启录音和结束录音。

    <input class="input keyboard-input"> 实现文字内容的录入。

关于 Input 组件的使用，我们将在后面详细介绍。

catchtap="sendMoreMsg" 将实现向内容中添加图片和拍照选择框的功能。

catchtap="submitComment" 将实现评论内容的最终发送功能。

### 7.11 wx:if 与 hidden 控制元素显示和隐藏

在小程序中，最常用的显示 / 隐藏 UI 元素的方法有两种：一种是之前我们介绍的 wx:if，另外一种是 hidden。我们特别在代码清单 7-26 中使用了 hidden 这种方式来控制元素的显示和隐藏效果。

在代码清单 7-26 中，注意以下两段代码。

```
<view hidden="{{useKeyboardFlag}}" class="input-item">
<view hidden="{{!useKeyboardFlag}}" class="input-item">
```

hidden 的使用方式与 wx:if 类似，都是通过一个状态变量来控制元素的显示和隐藏。

当 useKeyboardFlag 为 true 时，第 1 个 view(hidden={usekeyboardflag}) 将被隐藏，而第 2 个 view(hidden={!usekeyboardflag}) 将被显示。当 useKeyboardFlag 为 false 时，则第 1 个 view 被显示，第 2 个 vew 被隐藏。

那么 wx:if 和 hidden 之间有什么异同吗？wx:if 的切换和渲染机制较为复杂。当 wx:if 进行切换时，MINA 框架有一个局部渲染的过程，它确保条件块在切换时销毀或重新渲染。同时 wx:if 也是惰性的，如果初始渲染条件为 false，那么框架什么也不做，在条件第一次变成真的时候才开始局部渲染。相比之下，hidden 就简单得多了，组件始终会被渲染，只是简单地控制显示与隐藏。一般来说，wx:if 有更高的切换消耗，而 hidden 有更高的初始渲染消耗。因此，在要频繁切換的情景下用 hidden 更好，在运行时条件不大可能改变时用 wx:if 较好。

### 7.12 实现文字评论框和语音评论框的切换

编写完页面的 wxml 和 wxss 文件后，我们来继续编写这些组件的业务逻辑。首先实现「按住说话」和「说点什么吧...」这两个组件的切换效果。之前我们提到过，实现语音和文字评论框切换的效果关键是控制 useKeyboardFlag 这个变量。

1『 js 文件对应于 JavaScript，是定义行为的，是业务逻辑，要有这个概念。』

```
  // 切换语音和键盘输入
  switchInputType:function(event) {
    this.setData({
      useKeyboardFlag: !this.data.useKeyboardFlag
    })
  }
```

在 post-comment.js 文件的 Page (object）方法的 data 属性下新増一个 useKeyboardFlag 变量作为初始化的数据绑定变量。useKeyboardFlag 初始值为 true 将导致评论框默认显示为键盘类型的输入框。接着编写 switchInputType 方法来切换 useKeyboardFlag 这个控制变量。此时，点击评论框最左侧的小图标将可以实现语音评论框和文字评论框的相互切换效果。接着实现发送文字评论的功能。在实现发送文字评论功能之前，我们需要学习一个非常重要的组件：Input 组件。

### 7.13 input 组件

input 组件是最为重要的数据输入组件，比如我们这里要输入用户的评论信息时就需要用到这个组件。input 组件目前拥有以下若干属性：1）value String 类型，设置 input 输入框的初始内容。2）type String 类型，input 组件目前有 4 种类型，即 text、number、idcard、digit，默认是 text 类型。3）password Boolean 类型，如果设置为 true，就会用 * 号来遮蔽输入，默认为 False。

4）placeholder String 类型，输入框为空时的占位符。所谓占位符，就是当输入框内没有任何用户输入时默认显示的文字，比如 post-comment 页面文字输入框中默认显示的「说点什么吧...」。5）placeholder-style String 类型，指定 placeholder 的样式。可以将 placeholder 的样式编写在这里，形如组件中的 style 属性一样，只不过 placeholder-style 属性专门用来编写 placeholder 样式，而非编写整个 input 的样式。比如你可以这样写：placeholder-style="color:#333B; font-size:24rpx"。6）placeholder-class String 类型，如果你不想在组件的标签上写样式，就可以使用这个属性来指定一个已编写好的 CSS 类名，如同标签的 class 属性一样使用。

7）disabled Boolean 类型，用于设置是否禁用 input 组件，默认值为 false。8）maxlength Number 类型，最大输入长度。设置为 -1 的时候不限制最大长度，认值为 140。9）cursor-spacing Number 类型，指定光标与键盘的距离，单位是 px。取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离，默认值为 0。10）focus Boolean 类型，自动获取焦点并拉起键盘，默认值为 false。如果某个页面的 input 组件包含这个 focus 属性，且将其值设置为 true，那么当进入这个页面后光标将自动定位到 input 中，且会自动拉起输入键盘。

以上是 input 的所有属性。接下来我们看看 input 组件的 4 个事件，这 4 个事件才是 input 组件的重点和难点：1）bindinput。2）bindfocus。3）bindblur。4）bindconfirm。

注意以上事件和我们常用的 catch、bind 开头的通用事件是有区别的。它们是由 MINA 框架直接指定的，不需要在事件名称前再添加 catch 和 bind，干万不要写成 bindbindinput 或者 catchbindinput。此外，以上 4 个事件都属于非冒泡事件，这是它们和 catch、bind 等通用前缀事件的重要区别。形如 catchtap 等事件通常都是冒泡事件。

首先来看看 bindinput。bindinput 事件较为特殊，具有以下几个特点：1）当用户输入字符时触发。2）每当用户输入或者删除一个字符时，bindinput 事件都会触发一次。3）可以在事件响应函数中使用 return 返回一个字符或者字符串，该字符串将替换 input 输入框的显示文本。4）它非常适合用来做「即时搜索」的功能。

bindfocus，当 input 组件获取焦点时触发。我们将在本书后面的电影部分看到这个事件的用法。bindblur，当 input 组件失去焦点时触发。bindconfirm，122100 版本新增事件，专门用来响应真机上点击键盘「完成」按钮的事件。input 输入值都是在事件对应的响应函数中使用 event.detail.value 来获取的。

### 7.14 bindinput 事件

考虑到一些特殊的输入法键盘或者用户的习惯，我们除了支持点击真机键盘上的「完成」按钮发送文字评论外，还实现了一个小程序里的「发送」按钮。我们先来实现自定义的「发送」按钮。实现自定义发送评论功能的第一步就是能够在 js 中获取 input 的 value 输入值。我们使用 bindinput 事件来获取 inpute 的输入值。在 post-comment.js 文件中新增以下代码：

```
  // 获取用户输入
  bindCommentInput:function(event) {
    var val = event.detail.value;
    console.log(val);
    this.data.keyboardInputValue = val;
  }
```

1『又被书里的源码坑了，最后一行句法里应该有赋值 =，书里没有。』

使用事件的 event 对象下的 detail.value 来获取 input 的输入值，并将这个值保存在 this.data 中。除此之外，我们在代码中加入了一段 console.log(val），一起来看看 bindinput 事件是如何响应用户输入的。在 Input 输入框中不断输入任意字母，比如 q，再不断地删除 q。在 onsale 面板中将看到如图 7-9 所示的输出。可以看到，每次输入一个 q 都会触发 bindinput 事件，并 console 出当前的 input 值；每次删除一个字符 q 同样会触发 bindinput 事件，并输出当前的 input 值。

### 7.15 屏蔽评论关键字

bindinput 还有一个有意思的特性，就是在事件响应函数中可以 return ー个值来代替当前的输入值，并显示在 input 中。下面一起来看一下效果。将 bindCommentInput 函数内部的代码临时更改为以上代码（请注意在测试完毕后还原成之前的代码）。保存代码后，在 input 组件中不断地输入字符「q」，input 组件将显示如图 7-10 所示的内容。很明显，每次输入 q 后都会被更改为 q+。这个 return 的机制非常适合用来过滤关键字。如果不想让用户输入 「qq」「微信号」等关键字，就可以用这种方式强制过滤掉。我们以屏蔽「qq」这个关键字为例来看看如何实现屏蔽关键字。

以上代码实现了当用户输入「qq」时，自动被替换成「*」。注意，最后 return 的是一个 object 对象，该对象的 value 表示要替换的文本值，而 cursor 表示光标所处的位置。其实我们不需要关心 cursor 光标的位置，以上代码只是为了告诉开发者可以控制光标的位置。如果只想屏蔽掉关键字，只需要以下几行代码：

```
  // 获取用户输入
  bindCommentInput:function(event) {
    var value = event.detail.value;
    return value.replace(/qq/g, '*')
  }
```

当用户在 input 中连续输入两个 q 后，屏蔽关键字的效果如图 7-11 听示。

### 7.16 实现自定义发送按钮

在实现自定义发送按钮功能之前，请将 bindCommentInput 函数恢复成代码清单 7-30 中的代码。在代码清单 7-30 中，我们成功地获取了用户的输入，并将输入文本保存到了 this.data 变量中。发送按钮的事件响应函数是 submitComment。在 post-comment.js 的 Page 函数中添加以下代码：

submitComment 中首先构建了一条新的评论 newData。需要注意的是，newData 中硬编码了当前用户的用户名，头像分别是「青石」和「avatar-3.png」。当组装完这个 newData 的评论对象后，我们还需要经过以下 4 个步骤：步骤 1 —— 将 newData 保存到缓存数据库，以便下次打开评论页面时可以显示这条 newData；步骤 2 —— 显示评论发表成功的提示；步骤 3 —— 将当前发表的评论添加到评论列表中，并显示这条新添加的评论；步骤 4 —— 清空 input 组件，准备接收下一条评论。以上 4 个步骤分别对应着代码清单 7-34 中最未尾的 4 个方法调用。

首先来完成步骤 1。在 DBPost 中新增 newComment 方法，用来保存新评论到缓存数据库中。该方法内部再一次调用了 this.updatePostData 方法。我们来修改一下 updatePostData 方法，让其能够支持新增评论。完整的 updatePostData 如下：

相比之前的 updatePostData 方法，我们为该方法新増了一个参数 newComment，用以接收新的评论数据；接着在 case 中新增了ー个 case "comment" 分支，用来处理新增评论。这样步骤 1 就完成了。接着我们来编写步骤 2：显示评论发表成功的提示。在 post-comment.js 中新增 showCommitSuccessToast 方法：

以上代码将完成步骤 2，继续来编写步骤 3：将当前发表的评论添加到评论列表中。在拥有 DOM 节点的对象中，比如在传统网页中，如果我们想插入一条评论，需要新增一个 DOM 节点，并将这个 DOM 节点 insert 插入到 DOM 数组中。在小程序中，我们没有 DOM，也只有一种方式可以操作数据，即数据绑定。不存在「新增一个 DOM，再将 DOM 节点插入到 DOM 对象数组中」这样的思路。

如果我们需要在已有的 n 条评论中插入一条评论，并在 UI 中显示这 n+1 条评论，我们只能将这 n+1 条评论全部重新做数据绑定。我们在实际项目中会有大量插入元素的需求，请开发者牢记这个思路。在 post-comment.js 的 Page 方法中新增以下方法：

1『小程序里实现「将当前发表的评论添加到评论列表中」，通过数据重新绑定的这个思路很重要。』

以上方法重新去缓存数据库中加载全部的评论并再次使用 this.setData 将全部评论进行数据绑定。最后完成步骤 4：清空 input 组件，准备接收下一条评论。清空 input 组件的方法很简单，将 input 的 value 属性重置为空字符串即可。在 post-comment.js 的 Page 方法中添加以下代码：

resetAllDefaultStatus 方法重新绑定了 keyboardInputValue，将其值设置为空字符串。注意 keyboardInputValue 在之前的代码中已经被绑定到了 input 组件的 value 属性上了。完成以上 4 个步骤后保存并运行代码。先在输入框中输入一段文字，再点击右侧的发送按钮，条评论就会出现在评论列表中，且这条评论位于评论列表的顶部。

1『记得清楚缓存，不然评价无法更新显示到页面上。』

### 7.17 同时支持模拟器回车、真机点击「完成」发送评论

到目前为止，我们已经实现了自定义发送按钮发送评论的功能。我们再来实现在模拟器中以敲击键盘回车发送评论和在真机中点击键盘「完成」发送评论的功能。

如果想在模拟器中买现回车发送评论消息的功能，可以使用以下几个 input 事件：binchang、bindblur 和 bindconfirm。binchang 在早期版本中是有的，但官方在后来的文档中去掉了这个事件，截至 130400 版本，binchang 依然有效。虽然它依然有效，但是不建议使用官方文档未明确说明的事件。bindblur 可以触发回车的原理是，点击回车后，input 组件将失去焦点，从而触发 bindblur 事件。bindconfirm 可以在真机上响应键盘的「完成」点击事件，同时也可以在模拟器中响应键盘的「回车」敲击事件。

拿 bindconfirm 举例，修改 input 组件为如下代码：

```
<input class="input keyboard-input"  value="{{keyboardInputValue}}" bindconfirm="submitComment" bindinput="bindCommentInput" placeholder="说点什么吧……" />
```

我们仅仅在 input 组件上新增了ー个 bindconfirm 事件，这个事件的响应函数与自定义发送按钮所向应的事件函数相同，同样都是 submit Comment。这样就可以同时实现自定义发送按钮发送评论、模拟器回车发送评论和真机上点击「完成」发送评论的功能。

开发者还可以依次将 bindconfirm 更换为 bindblur 和 binchang，看一下它们的效果。虽然以上 3 个事件都可以实现回车的效果，但建议使用 bindconfirm 事件作为 input 的「确定」事件。

1『验证了，bindconfirm 和 bindblur，在模拟器上可以直接按「回车」发送消息，但 binchang 不行。』

### 7.18 图片与拍照评论的界面实现

我们接着实现图片和拍照评论。先来实现以下效果：当点击 + 号按钮后，出现选择图片和拍照的界面，如图 7-12 所示。首先在 post-comment.wxml 中添加图 7-12 所示的骨架代码。对应的 CSS 代码已在代码清单 7-27 中添加完毕，不需要再次编写。

这段代码的开头部分有一段 \<view class="send-more-box" hidden="{{!sendMoreMsgFlag}}">。sendMoreMsgFlag 变量将控制整个面板的显示和隐藏。默认状态下它是隐藏的，所以我们首先在 post-comment.js 的 Page 方法 data 属性下设置 sendMoreMsgFlag 的初始状态。

sendMoreMsgFlag 的状态被我们设置成了 false。这样在默认状态下图片与拍照面板是不会显示的。事实上，即使我们不在 data 下面设置 sendMoreMsgFlag，面板依然不显示，因为如果找不到这个变量，默认这个变量的取值就是 false。为了代码的可读性，建议开发者将变量明确地在 data 属性中标注出来。这样的习惯应该成为我们开发小程序的一个小小约定。keyboardInputValue 变量也是基于这个原因而设置了一个空的字符串。keyboardInputValue 是之前控制 input 组件初始值的变量，我们在代码清单 7-39 中使用了这个変量，开发者可自行回顾。

1『「keyboardInputValue: '',」之前不明白这行代码的意义，上面的解释解答了，为了代码的可读性。』

接着实现 sendMoreMsgFlag 方法，它将切换 sendMoreMsgFlag 变量，以实现面板的切换和隐藏。sendMoreMsgFlag 方法已经被我们在代码清単 7-26 中注册到了以下图片的 catchtap 事件上。在 post-comment.js 的 Page 中新增 sendMoreMsgFlag 方法。

```
  // 显示照片、拍照等按钮
  sendMoreMsg:function(){
    this.setData({
      sendMoreMsgFlag:!this.data.sendMoreMsgFlag
    })
  },
```

成以上代码后，我们再次点击 + 号图标，拍照面板将动态地显示和隐藏。

### 7.19 实现从相册选择照片与拍照

在成功显示照片面板后，我们需要实现从相册选择照片和拍照上传照片的功能。小程序提供了一个 API：wx.chooselmage(object) 来实现这个功能。我们首先在 data 变量中新増一个数组来保存已选择图片的 URL。

```
  data: {
    // 控制使用键盘还是发送语音
    useKeyboardFlag: true,
    // 控制 input 组件的初始值，为了代码的可读性
    keyboardInputValue: '',
    // 控制是否显示图片选择面板
    sendMoreMsgFlag: false,
    // 保存已选择的图片
    chooseFiles: []
  },
```

每选择一组图片，我们都会将图片的 URL 保存在 chooseFiles 这个数组中。在代码清单 7-41 中，我们分别在「照片」和「拍照」这两个图片按钮上注册了同一个事件 chooselmage 事件。点击这两个图片按钮后将执行 chooselmage 方法。在 post-comment.js 中编写这个事件方法。

```
  // 选择本地照片与拍照
  chooseImage:function(event){
    var imgArr = this.data.chooseFiles;
    var leftCount = 3 - imgArr.length;
    if(leftCount <=0){
      return;
    }
    var sourceType = [event.currentTarget.dataset.category],
      that = this;
    wx.chooseImage({
      count:leftCount,
      sourceType:sourceType,
      success: function(res) {
        that.setData({
          chooseFiles:imgArr.concat(res.tempFilePaths)
        })
      },
    })
  },
```

解释一下上述代码。我们选择一次评论内容中最多只允许发送 3 张照片。leftCount 检测当前已经选择了多少图片，如果超过了 3 张就直接 return，不能再执行下面的 wx.chooselmage 方法。如果还不到 3 张，就多次选择照片，一直到选满 3 张为止。

我们重点看下 wx.chooselmage 方法。wx.chooselmage (object）接收两个主要的参数：count 和 sourceType。count 指定一次最多可以选择多少张图片，sourceType 指定是拍照生成照片还是从手机相册选择照片。注意，它是一个数组，可以有以下几个取值：['album']、['camera']、['album', 'camera']。

第一个取值将直接打开相册，并可以选择照片。注意，无论是在开发工具中还是在真机上都可以支持多选。第二个取值将直接打开相机并拍照生成照片。注意，在开发工具中，camera 取值不会打开相机拍照，只会打开相册。第三个取值将打开如图 7-13 所示的图片界面。

['album', 'camera'] 可以让用户自行选择是拍照还是从手机相册选择。需要注意的是，在开发工具中这个取值不会出现这样的选择框。开发工具中只会直接打开相册，因为开发工具没有拍照功能。

我们分别选取第一个和第二个取值，对应面板中的「照片」和「拍照」功能。var sourceType = [event.currentTarget.dataset.category] 这段代码決定了当前选择的是哪一种方式。当选择照片或者拍照成功后，将进入 wx.chooselmage 的 success 方法中，success 方法将接收一个框架传入的 res 参数。在 success 方法中加入 console.log (res)，res 的输出结果如图 7-14 所示。

重点是 tempFilePaths 这个数组，它装载了我们选择的 3 张图片（来自相册或者拍照）的 URL。注意，这个 URL 是图片的临时地址。拿到图片的地址后，我们就可以将这些图片地址添加到 imgArr 中，并将 imgArr 绑定到 chooseFiles 变量中。一旦 chooseFiles 变量被绑定了数据，wxml 代码中的 \<block wx:key="chooseFiles" wx:for="{{chooseFiles}}" wx:for-index="idx"> 将循环显示这些图片，如图 7-15 所示。需要注意的是，你并不需要一次选择 3 张，可以分多次选择，但最多只能选择 3 张。

### 7.20 icon 图片

在 7.19 节中，我们实现了图片的选择功能。注意看图 7-14，每张图片的右上角都有一张小图片。这个小图片并不是我们自定义的图片，而是由小程序的 icon 组件提供的图片。

在代码清单 7-41 中有一段代码：

    <icon class="remove-icon" type="cancel" size="23" color="#B2B2B2" catchtap="deleteImage" data-idx="{{idx}}" />

这段代码就是 icon 组件的用法。icon 组件非常简单，只有 3 个属性：1）type，icon 的类型，取值可以是 success、success_no_ circle、info、warn、waiting、cancel、download、search、clear。我们在代码中选用的是 cancel。2）size，con 图片的大小，单位是 px。3）color 颜色，同 CSS 的 color。

图 7-16 所示的是不同类型的 icon 示意图。如果开发者对项目样式要求不是很高，建议尽量选择 icon 组件。

### 7.21 删除已选择的图片

当我们选择好图片后，存在想删除图片并重新选择的可能，所以还需要支持图片的删除功能。刪除功能是通过点击图片右上角的 icon 图标来实现的。我们已经在 wxml 代码的 icon 组件中注册了 deletelmage 事件。在 post-comment.js 中添加 deletelmage 方法。

```
  // 删除已选择的图片
  deleteImage:function(event){
    var index = event.currentTarget.dataset.idx,
      that = this;
    that.setData({
      deleteIndex:index
    });
    that.data.chooseFiles.splice(index, 1);
    setTimeout(function(){
      that.setData({
        deleteIndex:-1,
        chooseFiles: that.data.chooseFiles
      });
    }, 500);  
  },
```

刪除图片的逻辑非常简单，只需要获取当前删除图片的序号，并将该图片的 URL 从 this.data.chooseFiles 数组中删除，重新绑定 chooseFiles 变量即可。保存并重新运行代码，就可以通过点击已选择图片右上角的叉叉按钮删除图片了。删除图片后，可以重新选择图片。

### 7.22 在小程序中使用 CSS3 动画

虽然 MINA 框架提供了小程序专有的动画 API，但是我们依然可以在小程序中使用 CSS3 动画。我门建议开发者尽量使用 CSS3 动画，因为目前版本小程序的动画存在较多 bug，使用起来并不是很方便。后面我们也会介绍小程序的动画，这里先来看看如何在小程序中使用 CSS3 动画。

我们使用 CSS3 动画对 7.21 节中删除图片的操作做一个特效。在代码清单 7-41 中，有一段这样的代码：

    <view class="file-box {{deleteIndex==idx?'deleting':''}}">

如果 deletelndex 的值等于当前图片的序号，就说明该图片是要被删除的，需要添加一个 deleting 动画。以下代码是 deleting 动画的 CSS 代码：

```
  .send-more-result-main .file-box.deleting{
      animation:deleting 0.5s ease;
      animation-fill-mode: forwards;
  }
  
  @keyframes deleting {
      0%{
          transform: scale(1);
      }
      100%{
          transform: scale(0);
      }
  }
```

这段动画已经在代码清単 7-27 中添加到了 post-comment.wxss 中，这里就无须再添加了。我们需要做的就是在删除图片时执行这段 CSS3 动画。修改 post-comment.js 中的 deletelmage 方法，以支持 CSS3 动画效果。

```
  // 删除已选择的图片
  deleteImage:function(event){
    var index = event.currentTarget.dataset.idx,
      that = this;
    that.setData({
      deleteIndex:index
    });
    that.data.chooseFiles.splice(index, 1);
    setTimeout(function(){
      that.setData({
        deleteIndex:-1,
        chooseFiles: that.data.chooseFiles
      });
    }, 500);  
  },
```

在新代码中，我们使用了一个 deleteIndex 変量，正如在 7-18 节中所讲的，最好将这些变量都在页面的 data 属性中设定一个初始值（当然不设置直接使用也可以）。在下面的代码中，将 deleteIndex 设置为 - 1，表示当前没有删除任何图片。

在定义了 deleteIndex 变量后，在删除图片时首先使用 this.setData 方法更新 deletelndex 変量值为当前删除图片的序号，使用 this.setData 将立即执行数据绑定，使被删除的图片立即添加并执行个 deleting 动画（正如本节开头所分析的那样）。动画执行的时间为 500 毫秒，所以我们使用 setTimeout 函数延迟 500 毫秒后再真实地删除这张图片。注意，一定要记得将 deletelndex 的值恢复为 -1, 否则动画执行将出错。

大多数动画的编写方式都如本节中所展示的方式那样，只是动画的效果不同而已。开发者可以举反三，尝试不同的动画效果。适度使用动画将大大提升客户端的体验，需要注意的是不要过度使用动画，特别是在一些性能不好的手机上，动画将大大消耗手机性能。建议能不用动画就尽量不用，毕竟小程序是即用即走，做太多动画的意义不大。

### 7.23 实现图片评论的发送

在前面我们已经完成了图片的选择和删除功能，接着实现发送图片评论。

实现发送图片评论的方式非常简单，只需要将当前 this.data.chooseFiles 所保存的图片地址存入数据缓存中，并重新渲染评论列表即可。我们来修改一下 submitComment 方法，这个方法我们已经在发送文字评论时实现过。

相比之前的 submitComment 方法，我们只是将 this.data.chooseFiles 这个保存图片 URL 的数组加入到了 newData 中，这样 newData 中不仅仅包含有 txt 文本，还包括 img 图片。

在发送完图片评论后，还要清空已选择的图片，并在此隐藏图片选择面板。修改 resetAllDefaultStatus 方法，代码如下：

```
  // 将所有相关的按钮状态、输入状态都恢复到初始化状态
  resetAllDefaultStatus:function(){
    this.setData({
      keyboardInputValue:'',
      chooseFiles:[],
      sendMoreMsgFlag:false
    });
  },
```

相比之前只重置了 keyboardinputValue 变量，这里还重置了 chooseFiles 变量和 sendMoreMsgFlag 变量。重置 chooseFiles 变量将清空图片选择面板中已选择的图片，重置 sendMoreMsgFlag 变量将再次隐藏图片选择面板。

需要注意的是，图片和文字可以存在于同一条评论中。开发者可以尝试发表几条带图片的评论。如果此时你点击评论中的图片，就会发现图片无法显示。关于这一点我们已在 7.9 节中提到过在开发工具中是无法预览这些图片的。如果是在真机中，这些图片可以被正常预览。最新的 140600 版本修复了这个问题，现在可以在开发工具中预览上传的图片。

### 7.24 实现语音消息的发送

1『该节的功能因为目前用不到，源码没有加进去。』

目前为止，文字和图片评论的发送功能已全部完成，接下来我们学习如何发送语音评论。需要注意的是，语音消息的相关组件已在 7.10 节中实现，并在 7.12 节中实现了文字评论和语音评论之间的切换效果，大家可以回顾一下。

语音评论需要真机的支持，虽然在模拟器中有麦克风就可以实现录音并可以生成录音文件，但在后续的函数调用和播放上存在不少 bug。所以，下面的代码虽然在模拟器上不会报错，但无法实现录音效果。如果你不能够在真机上运行小程序，建议简单浏览下本节，了解内容即可。

发送语音评论的操作过程为：1）切换到语音发送状态（点击最左側的声音图标）。2）长按「按住说话」这个按钮。3）说话。4）松开「按住说话」，语音消息自动发送。

要实现按住和松开这两个动作，我们需要使用小程序的 touchstart 和 touchend 事件。对于 touchstart，我们已注册了事件函数 recordStart；而对于 touchend，我们已注册了 recordEnd。下面实现这两个事件函数。

按住录音按钮后将执行 recordStart 函数。函数首先绑定了变量 recodingClass，这个变量将改变录音按钮的样式，使其变成正在录音的样式。接着记录了当前录音开始的时间，并保存在 this 变量中。接着调用 wx.startRecord 录音 APl。wx.startRecord 只接受 3 个方法作为参数，分别是 success、fail 和 complete。如果录音成功就执行 success，录音失败则执行 fail，无论录音成功还是失败，都将执行 complete。

发生以下两种情况将会结束录音：1）当主动调用 wx.stopRecord 时。2）如果没有主动调用 wx.stopRecord，那么在录音开始 1 分钟后自动结束录音。在我们的 Orange Can 顼目中并未处理录音 1 分钟自动结束的情况，开发者可根据自身需求来处理这种情况。对于业务逻辑，我们需要在用户松开录音按钮时结束录音。下面编写 recordEnd 方法结束录音。

在 recordEnd 方法中首先将按钮的样式还原，接着记录录音结束的时间，并将其保存在 this 变量中。最后调用 wx.stopRecord 方法结束录音。当用户松开录音按钮后，代码将执行 recordStart 中的 success 方法或 fail 方法（complete 方法当然也会被执行）。在 recordStart 的 success 方法中，我们首先计算语音时长，接着调用 submitVoiceComment 方法发送语音评论。在 post-comment.js 中增加以下代码来实现语音评论的发送：

发送语音评论的思路与发送文本、图片的思路几乎一样。首先新增一条评论数据，并将 audio 对象存入评论的 audio 属性中；然后调用 DBPost 的 newComment 方法将评论数据保存到存数据中；接着弹出操作结果提示；最后重新渲染评论列表。

语音不可以和文字、图片混合在一条评论中，只能单独作为一条评论。需要注意的是，当前 130400 版本有一个奇怪的现象：在模拟器中，录音结束后既不会执行 wx.startRecord 的 success，也不会执行 fail，只会执行 complete 方法，即使 PC 接有麦克风也是如此。在真机中则可正常执行 success。

### 7.25 实现语音消息的暂停与播放

1『该节的功能因为目前用不到，源码没有加进去。』

### 7.26 用户授权

小程序如果想使用某些特定的 API，是需要用户主动授权的。比如，当获取用户敏感信息时，以及调用 wx.startRecord 接口录音时，都需要用户主动授权，如图 7-17 和图 7-18 所示。在本项目中，如果用户第一次使用录音功能，就会弹出如图 7-16 所示的请求授权提示。当用户授权后，下次再使用录音功能时将不会再弹出这个提示框。

我们可以在开发工具中清除用户的授权数据，让授权提示框再次出现。开发工具的侧边栏里有一项「缓存」按钮，如图 7-19 所示。「清除工具授权数据」可以清除开发工具中用户授权数据缓存。「清除手机授权数据」可以清除手机上的授权数据媛存。清除缓存后，授权数据框将再次出现。这里要提醒开发者，一定要处理用户拒绝授权的场景，否则程序有可能发生非常严重的错误。

1『如果要增加需要授权的功能模块，一定要考虑用户拒绝授权的处理场景。』

### 7.27 解决真机运行时评论页面滑动卡顿的问题

在真机上运行 Orange Can，会发现评论页面在上下滑动时过程并不是那么的流畅，体验非常差。在页面容器中加入以下 CSS 代码可以解決这个问题：

```
  .comment-main-box {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 100rpx;
    right: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling:touch;
  }
```

加粗部分代码是我们在 comment-main-box 类下新增的一段代码，加入这段代码后，post-comment 页面的滑动将非常流畅。

1『这个小技巧以后一定要用。』

### 7.28 文章阅读计数功能

到目前为止，我们已经完成了文章的收藏、评论和点赞功能，接着完成最后一个文章计数功能。每次进入 post-detail 页面时，当前文章的阅读数需要增加 1 次。在 post-detail.js 中增加一个阅读数加 1 的方法。

```
  // 阅读量+1
  addReadingTimes:function(){
    this.dbPost.addReadingTimes();
  },

```

addReadingTimes 方法中再一次使用到了 DBPost 中的方法。在 DBPost.js 中新增以下方法：

```
  addReadingTimes(){
    this.updatePostData("reading");
  }
```

接着在 DBPost 类的 updatePostData 方法中增加一个 case 'reading' 来处理阅读数加 1 的情况。下面给出 updatePostData 方法的最终代码；加粗部分代码是新增代码。编写完以上代码后，记得在 post-detal.js 中的 onLoad 方法中调用一下 addReadingTimes 方法。加粗部分代码是新增代码。

完成以上代码后，每次点击进入页面的详情页阅读数都会加 1。需要注意的是，本项目并没有实现实时刷新。进入某篇文章的详情页面后，再返回文章阋读列表页面，此时阅读列表中的阅读数并没有加 1，当我们刷新项目或者下次进入小程序时，文章列表的阅读数将会被更新。

1『经试验，按照上面的操作还是没更新。』

## 09. 丰富文章页面

### 1. 逻辑脉络

小程序的分享功能以及 animation 动画的使用。重点如下：

事件冒泡机制的运用，在父级元素定义冒泡事件，当操作子元素时，事件会冒泡上升传递到父元素，从而被父级元素事件捕获。currentTarget 和 target 的区别：1）target 指的是事件最开始被触发的元素。2）currentTarget 指的是捕获事件的元素。小程序动画效果的实践，几个概念：1）动画实例 animation = wx.createAnimation(object)。2）动画组animation.scale(2).rotate(45).step().translate(30).step()。3）动画方法 scale(2).rotate(45)。4）动画队列，动画组以 step() 方法分隔每个队列。5）导出后需绑定到要实现动画的元素上，animation.export() {}.bind(this)。

### 2. 摘录及评论

### 9.1 将页面分享给朋友和微信群

在内测和公测期间，小程序是没有任何分享能力的，但就在小程序临近正式开放时，微信放出了这个分享功能。我们首先要提醒的是不同于公众号的分享，微信小程序只能分享给好友和群聊，不能分享到朋友圈。在 122100 版本中，小程序在右上角増加了一个如图 9-1 所示的 ··· 按钮。在模拟器中点击这个按钮将出现如图 9-2 所示的底部菜单栏。如果我们没有在当前页面调用分享的 API，那么点击右上角的按钮将出现「当前页面未设置分享」的提示。注意，分享按钮是页面的行为，而不是应用程序的行为，每个页面都可以调用分享 API 并设置自己的分享参数。

MINA 框架提供了一个用于设置页面分享的 API：onShareAppMessage。注意，这个 API 是一个页面方法，而不是我们前面调用的 wx 类方法（wx.playBackgroundAudio 等）。它和 onLoad、onShow 等一样，属于页面级别的方法。所以，你不可以自定义分享按钮，只能使用小程序页面右上角的按钮进行分享。

onShareAppMessage 方法必须返回一个 object 对象，这个对象可以包含以下 3 个属性：1）title 设置分享标题，如果忽略这个参数，就将默认 title 为当前小程序的名称。2）desc 分享描述，如果忽略这个参数，就将默认 title 为当前小程序的名称。3）path 分享路径，当前页面 path 是以 / 开头的完整路径。注意，这个 path 同 wx.Navigateo 一样，可以在 path 后面添加形如 id=2&mid=3 的参数。获取方式同样是在页面的 onLoad 函数的参数中获取。

1『目前发现不添加 onShareAppMessage 方法也能分享页面，待证实。官网的 API 说明：[Page(Object object) | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object)。』

现在我们来尝试在 post-detail 页面中加入分享功能，在 post-detail.js 中增加以下方法：

```
  // 定义页面分享函数
  onShareAppMessage: function () {
    return {
      title: this.postData.title,
      desc: this.postData.content,
      path: "/pages/post/post-detail/post-detail"
    }
  },
```

在 post-detail.js 中加入以上函数后，点击右上角的上 … 按钮，页面底部将不再显示图 9-2 中所示的「当前页面未设置分享」，取而代之的是可以点击的分享菜单，如图 9-3 所示。点击分享后将弹出分享确定界面，如图 9-4 所示。

需要特别注意的是，分享图片是不能自定义的，MINA 框架会将当前页面从顶部开始、高度为 80% 屏幕宽度的图像作为分享图片。所以，对于我们需要分享的页面，请好好设计页面的顶部部分，以免分享出去的图片不美观。官方文档对于 onShareAppMessage 函数有一段这样的描述：「只有定义了此事件处理函数，右上角菜单才会显示『分享』按钮」。

这段描述极易让人误以为如果不定义分享函数 onShareAppMessage，右上角的三个小点就不会出现，从而实现隐藏右上角按钮的效果。事实上，并不是像字面意思这么理解。官方文档的正确解读应该是：只有定义了 onShareAppMessage 处理函数，从右上角按钮打开的菜单才有「分享」按钮。无论如何，右上角的按钮是无法隐藏或者取消的。

右上角按钮还有一个重要作用，就是点击右上角后在弹出的菜单中会有一个「显示在聊天顶部」选项。点击「显示在聊天顶部」将折叠小程序，并返回微信聊天列表页面。当再次点击被折叠的小程序时，将重新进入小程序。这个功能将帮助用户在使用小程序时临时切换到微信消息界面进行消息査看和回复。这个功能只有在真机上才会出现，开发工具中是没有这个体验功能的。虽然小程序目前只能分享给朋友和群聊，但其意义依然非常重大，至少给了开发者一个线上推广和传播的机会。在目前小程序发展初期，很多小程序的推广都是依靠微信群聊在传播。

### 9.2 从 swiper 组件跳转到文章详情页面

截至目前，post-detail 详情页面就已经完成了全部功能，但是在 post 文章列表页面还有一点小小的功能需要补充，既然可以点击文章列表的文章跳转到文章详情页面，那么文章列表顶部的 Swiper 组件也应该能够点击跳转。首先对 post.wxml 页面的 swiper 组件做一些小小的修改，在每个 swiper 组件的 image 元素上设置需要跳转的文章 id 号。

```
  <swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="5000" catch:tap="onSwiperTap">
    <swiper-item >
      <image src="/images/post/post-1@text.jpg" data-post-id='3'/>
    </swiper-item>
    <swiper-item >
      <image src="/images/post/post-2@text.jpg" data-post-id='4'/>
    </swiper-item>
    <swiper-item >
      <image src="/images/post/post-3@text.jpg" data-post-id='5'/>
    </swiper-item>
  </swiper>
```

加粗部分代码为新增代码。注意，该 id 号必须是已存在的文章 id 号，否则跳转后无法获取文章详细信息。按照一般的思路，跳转到文章详情页面需要在每个 swiper-item 组件上都注册一个 tap 事件，从而保证点击每一张图片都可以响应该事件。这样做当然是可以的，但我们设想一下，如果 swiper 组件下有十几个元素呢？这样一个个地去绑定事件是不是太麻烦了？

这里使用之前我们讲到的冒泡事件，不在每个 swiper-item 的 image 上注册事件，而只是在 swiper 上注册一个 onSwiperTap 事件。无论点击哪个 swiper-item 的 image，点击事件都将通过冒泡机制传递到 swiper-item 的父节点 swiper 上。所以，我们只需要在 swiper 组件上捕获这个点击事件，无须在每个子元素上监听点击事件。在 post.js 中编写事件响应函数 onSwiperTap。

```
  // swiper 组件跳转到详细页面
  onSwiperTap:function(event){
    var postId = event.target.dataset.postId;
    wx.navigateTo({
      url: 'post-detail/post-detail?id='+postId
    })
  },
```

代码非常简单，思路就是获取文章 id 号后再通过 wx.NavigateTo 导航跳转到 post-detail 文章详情页面。需要注意的是，在获取文章 id 号时，我们并不是使用的 event.currentTarget，而是使用的 event.target。在冒泡事件中，target 指的是事件最开始被触发的元素，而 currenttarget 指的是捕获事件的元素。放在我们的代码中，target 指的是 image 元素，而 currenttarget 指的是 swiper 元素。点击 swiper 时实际上点击的是 image 组件，事件由 image 一级一级地传递到 swiper 组件中，最后被我们注册在 swiper 组件上的 onSwiperTap 捕获。

只有在 image 元素上才设置有 postId，从 currentTarget(Swiper) 元素中是无法获取到 postId 的，所以我们必须使用 event.target 来获取 postId。保存并运行代码，发现点击 swiper 组件的不同图片可以跳转到对应的文章详情页面。

### 9.3 使用小程序动画实现点赞特效

1『该节的功能因为目前用不到，源码没有加进去。』

除了使用 CSS3 的动画，MINA 框架也提供了一组动画 API。在本节中，我们不使用 CSS3 动画，而是使用 wx.createAnimation 来实现点赞动画效果。学习小程序的动画，首先要明白下面几个概念：1）动画实例。2）动画组。3）动画方法。4）动画队列。

在使用小程序动画前必须先创建一个动画实例，创建动画实例的方法为 wx.createAnimation(object)。该方法的 object 参数会接受一些属性，用于定义动画的具体执行参数：1）duration 数值整型，描述动画的持续时间，单位为 ms（毫秒），默认值为 400；2）timingFunction 字符串，定义动画的效果，默认值为「linear」，有效值为 linear、ease、ease-in、ease-in-out、ease-out、step-start、step-end。3）delay 数值整型，表示动画延迟多少毫秒执行，単位为毫秒，默认值为 0，表示不延迟。4）transformOrigin 字符串类型，设置 transform-origin，默认为「50% 50% 0」。以上参数都为非必填参数，它们都有自己的默认值。

当我们使用 wx.createAnimation 创建一个动画实例 animation 后，可以对这个实例设置多个动画组，而每个动画组中会有若干个动画方法；组与组之间使用 step() 方法来分隔，多个组形成一个链式的调用队列，这个链式队列就是我们所说的动画队列。看一下下面的演示代码会比较清楚地理解以上几个概念。

在以上代码中，首先我们创建了一个动画实例 animation，并设置这个 animation 的特效为 ease-in-out。接着我们对这个动画实例设置了两个动画组，它们之间使用 step() 作为分隔。第一组动画包含两个动画方法 scale 和 rotate（缩放和旋转）；第二组动画包含一个动画方法 translate（偏移）。

我们在这里提出一个问题，以上两个动画组以及每个动画组里的动画方法执行顺序是什么？scale 与 rotate 是同时执行还是先执行 scale 后执行 rotate? rotate 和 translate 又是谁先执行？毕竟是动画，每个动画的执行先后顺序是非常重要的。

请开发者牢记：同一组中的动画方法会同时执行，但动画组必须是先后执行。也就是说，一组动画先执行完成后，后面的动画才能执行，它们是 one by one 地执行。用以上理论来解释以下示例代码中动画执行的先后顺序：scale 和 rotate 会同时执行，而 translate 必须等 scale 和 rotate 执行完成后オ会执行。

还有一个问题，可不可以在不同的动画组中设置不同的动画效果参数？答案是可以的。每个 step 方法都可以接受一个 object 对象：可以传入一个跟 wx.createAnimation() 一样的配置参数，用于指定当前组动画的配置。注意黑色加粗部分的代码，这将改变第二组动画 translate 的执行效果。

常见的动画方法有哪些？截至 130400 版本，小程序提供了 6 类动画方法：1）样式 opacity、backgroundcolor、width、height、top、left、bottom、right。2）旋转 rotate、rotateX、rotateY、rotateZ、rotate3d。3）缩放 scale、scaleX、scaleY、scaleZ、scale3d。4）偏移 translate、translateX、translateY、translateZ、translate3d。5）倾斜 skew、skewX、skewY。6）矩阵变形 matrix、matrix3d。

以上动画的参数及使用方法请参考官方文档。动画属于实践性非常强的知识点，在这里用文字去罗列每个动画的使用方法效果并不好，反而会产生各种误解和歧义。如果要详细讲解动画知识，可以写ー本书了；如果简单复制官方的示例文档，那不如开发者自己去查看官方的 demo 示例。所以强烈建议，如果你正在研究动画的使用方法，就请创建一个动画实例，根据我们所讲的动画理论知识不断地变化动画实例参数、动画方法等，亲自看看都有什么不同的效果。

笔者在这里也强烈建议各位开发者，对于像动画这类实践性很强的知识点不要「死记硬背」。当你使用的时候再来查找这些动画方法，效果会更好。

代码清单 9-4 和代码清单 9-5 都是在定义动画，那么如何使用动画呢？不用着急，我们现在拿 Orange Can 项目中的实例来学习如何定义和使用动画。还记不记得在 post-detaild 页面中有ー个点赞的按钮（心形图标）？我们用小程序动画来实现点赞的特效：当点击按钮时，心形图标会有一个渐渐放大随后又缩小的效果。回忆一下在本节之前的文字中介绍的动画基本概念与如何定义动画。下面我们来实践一下。

在 post-detail.js 中新增一个方法。以上代码定义了一个 setAniation 方法，接着我们在 post-detail.js 的 onLoad 方法中使用 setAniation 方法。接着我们修改 onUpTap 这个点赞按钮的事件响应函数。如果你的点赞事件响应函数没有按照本书命名，那么请找到自己的点赞响应函数并修改。使用动画的关键有以下两点：1）必须调用动画实例 animationUP 的 export 方法导出动画。2）将 export 方法导出的动画绑定到动画需要作用的 wxml 组件上。

注意，当调用动画实例 animation 的 export 方法后，animation 上所设置的动画方法将被情况。

以上代码中，我们对动画实例 animationUP 做了两次设置和调用：第一次设置 scale 动画方法让图标先放大，随后调用 step 方法表示这组动画完成。接着调用 export 方法导出动画，并做数据绑定更新，这将导致点赞图标被放大。

第二次设置 scale 方法让图标恢复到原状，同样再次调用 step 和 export 并做数据绑定更新，这将导致点赞图标还原。注意，第一次调用 export 后，animation 动画实例会被清空，所以第二次设置 animationUP 时不会受第一次动画方法的影响。在执行第二次动画时，我们使用 setTimeOut 让缩小的动画效果延迟 300 秒再执行。既然我们在代码中使用了数据绑定，就必须在 wxml 中绑定这个动画，这样点赞动画才能够正常执行。

修改 post-detail.wxml 中设置点赞图标的 image 组件代码。作用很简单一接受动画的数据绑定。注意，需要同时绑定已点赞和未点赞两种状态的图标。编写完以上代码后，保存代码并运行，点击点赞图标将出现先放大再缩小的动画效果。

有些开发者可能会提出质疑，为什么要设置两次动画效果？之前不是说过，动画队列中的不同组动画将依次执行吗？理论上，确实可以通过设置两个动画组来实现先放大再缩小的效果。但截至 130400 版本，小程序动画存在以下已知 bug：iOS/ Android6.3.30，通过 step() 分隔动画，只有第一步动画能生效。以上说明来自于官方文档，我们在模拟器上测试后，发现确实只有第一个分组的动画可以被执行，而第二组动画是无法执行的。所以，我们采用了以上代码的编写方法来实现先放大再缩小的动画效果。

笔者在之前编写 post-comment 评论页面时也向大家介绍过 CSS3 动画在小程序中的编写方法，这说明小程序依然是支持 CSS3 动画的。CSS3 是 Web 标准且没有特别明显的 bug，如果你已经能够很熟练地使用 CSS3 动画，就请在小程序中优先使用 CSS3 动画。熟练使用 CSS3 动画对我们编写 Web 项目也是有好处的，毕竟 CSS3 在很多地方都可以使用，但是小程序动画却只能在小程序中使用。但 CSS3 动画也有一定的风险。CSS3 动画种类众多，小程序不ー定全都支持，我们无法一一验证。究竟如何抉择还请开发者自行考虑。