# 2020104Laravel实战入门R00

## 记忆时间

## 卡片

### 0101. 主题卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡——访问页面的数据流向

当用户在查看一个网页时，一个完整的访问过程如下：1）打开浏览器在地址栏输入 URL 并访问；2）路由将 URL 请求映射到指定控制器上；3）控制器收到请求，开始进行处理。如果视图需要动态数据进行渲染，则控制器会开始从模型中读取数据；4）数据读取完毕，将数据传送给视图进行渲染；5）视图渲染完成，在浏览器上呈现出完整页面。

### 0202. 术语卡——Laravel 前端工作流

利用 Sass、NPM、Yarn、Laravel Mix 来构成一套完整的前端工作流。Sass 来编写 css 样式文件，Yarn 来安装包（包的管理沿用 npm）、Laravel Mix 来进行任务自动化管理（管理前端资源）。

### 0203. 术语卡——

### 0301. 人名卡——Taylor Otwell 

Taylor Otwell，laravel 框架的发明者。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

## 0101基础信息.md

官方文档：[Installation - Laravel - The PHP Framework For Web Artisans](https://laravel.com/docs/6.x)

通过阅读本教程，你将学到如 HTML、CSS、JavaScript、PHP 和 Laravel 等 Web 开发相关的基础知识。不仅如此，本书还会对这些基础知识点进行延伸扩展，为你讲解一些在 Web 开发中更为专业、实用的技能，如 Git 工作流、Laravel Mix 前端工作流、Bootstrap 框架基本使用等。

### 1.3 Laravel 与 PHP

扩展阅读：[为什么 PHP 是最好的语言？现在是，将来也会是 - 知乎](https://zhuanlan.zhihu.com/p/26704744)

架构选型。如果你是创业者或者技术负责人，在做技术架构选型，PHP 的巨大的市场占有率有以下好处：1）招人好招 —— 笔者喜爱 ROR（基于 Ruby 语言），但是在 PHP 有了 Laravel 后毫不犹豫就把公司的整个技术堆栈切到 PHP，最大原因就是人好招，创业公司里，组建团队是个头痛的问题；2）解决方案多 —— PHP 有很多优质的开源软件，拿过来直接就能使用。另外，作为日常开发，也是非常方便。举个有趣的例子：很多第三方开发者服务 SDK 包优先考虑的就是先出个 PHP 的 SDK，原因就是：PHP 占有率高。

什么是 Laravel？Laravel 是 Taylor Otwell 开发的一款基于 PHP 语言的 Web 开源框架，采用了 MVC 的架构模式，在 2011 年 6 月正式发布了首个版本。由于 Laravel 具备 Rails 敏捷开发等优秀特质，深度集成 PHP 强大的扩展包（Composer）生态与 PHP 开发者广大的受众群，让 Laravel 在发布之后的短短几年时间得到了极其迅猛的发展。我们通过 Google Trends 提供的趋势图（图 1.1）可以看出，Laravel 框架在过去七年，其增长速度在各类 PHP 框架中都是有史以来最快的，这也从正面直接反映出了 Laravel 的强大，以及其未来非常可观的发展前景。

扩展阅读：[数据说话 - 最火的 PHP 框架是哪个？ - 知乎](https://zhuanlan.zhihu.com/p/24673684)

为何 Laravel 如此受欢迎？一个优秀的工程师在构建一个语言框架时，应该懂得如何去协调好框架和语言之间的关系，并借助前人的智慧来思考框架的合理性与可扩展性。Laravel 的作者 Taylor Otwell 无疑做到了这一点。若你之前对 Web 开发有所了解，那么你可能会知道有个叫 Ruby on Rails（简称 Rails）的知名 Web 开发框架。Rails 是基于 Ruby 语言构建的一个 Web 开发框架，该框架有以下原则：1）强调与注重敏捷开发；2）约定高于配置（Convention over configuration）；3）DRY（Don't repeat yourself）不要重复自己，提倡代码重用；4）重视「编码愉悦性」。自诞生之日起，Rails 便受到了技术社区的广泛关注与讨论。而 Laravel 正是由于结合了 Rails 框架的这几项优秀特质，才使得其在 PHP 社区中备受推崇。

国内 Laravel 生态圈在哪？Laravel 在国内的生态圈发展也日趋成熟，你可以很轻松的在网上找到很多 Laravel 相关的中文学习资料、技术讨论社区：

- [Laravel China 社区 | Laravel China 社区 - 高品质的 Laravel 开发者社区](https://learnku.com/laravel) —— 国内最大的 PHP / Laravel 开发者社区，由 Summer 在 2014 年创建。

- [Laravel China 社区 | 中文文档](https://learnku.com/laravel/docs) —— Laravel China 社区维护的中文文档，涵盖所有版本。

- [优质外文翻译 | Laravel China 社区](https://learnku.com/laravel/c/translations) —— 为 Laravel 开发者提供最新最热的技术资讯。

- [《Laravel 速查表》 | Laravel China 社区](https://learnku.com/docs/laravel-cheatsheet/5.8) —— Laravel 速查表。

- [Laravel 安装和开发环境：Composer 国内加速镜像 | Laravel China 社区](https://learnku.com/laravel/wikis/25522) —— Packagist 中国全量镜像，让 Composer 速度如飞。

什么是「长期支持」？长期支持 （英语：Long-term support，缩写：LTS）是一种软件的产品生命周期政策，特别是开源软件，它增加了软件开发过程及软件版本周期的可靠度。长期支持延长了软件维护的周期；它也改变了软件更新（补丁）的类型及频率以降低风险、费用及软件部署的中断时间，同时提升了软件的可靠性。但这并不必然包含技术支持。在长期支持周期的开始，软件设计师会将软件特性冻结：他们制作补丁来修复程序错误及计算机安全隐患，但不会加入新的，可能会造成软件破坏的功能。软件维护者可能会单独发布补丁，或是将其置于维护版本、小数点版本或是服务包中发布。支持周期结束后，其称之为产品的生命周期结束。「长期支持」这个术语通常是保留给特殊的软件版本，其他版本会有更短的生命周期。通常来说，长期支持版本至少会被维护两年。

1『目前的长期版本是 6，安全修复截止时间为 2021-03-03。那么以后新建项目命令里带上选项 6。（2020-04-09）』

如何选择 Laravel 版本？不同角色，不同项目类型，有不同的建议：1）如果你是新手，目的只是为了学习，请直接选用最新版本；2）如果是现有项目，目的是学成后能对项目进行二次开发，请选用与项目匹配的版本进行学习；3）如果是商业项目，请优先考虑 LTS 版本；4）不同角色，不同项目类型，推荐阅读：《[如何选择 Laravel 框架版本 | Laravel China 社区](https://learnku.com/laravel/t/2595/how-to-select-the-laravel-framework-version)》 by Summer

### 1.4 如何正确阅读本书？

行文篇幅的约定。在书写针对 Laravel 的 Web 开发入门书籍时，最大的挑战在于对涉及技术话题讲解篇幅的控制。Web 开发涉及的技术话题比较广泛，新手在接触时，如果暴露在太多的技术话题下，会觉得无所适从。我们会尽量把对一些技术话题的讲解做到点到为止，只暴露出来刚刚好的知识，让你能跟上整书的行文线路，而不会深陷技术话题的沼泽。我们希望新手读者能理解这个设计，在第一遍的学习中，遇到本书提到的一些技术话题时， 不需要做到力求甚解。跟着本书的线路走，一步步前进，慢慢地脑子里对这些新话题有了基本的印象，等最终学习完本书后，再去对本书提到的技术话题进行深度学习。不用着急，要告诉自己：1）随后你会有很多机会来学习它们。现在最重要的是保持「训练」的连贯性。2）编程和学习的愉悦性，都需要谨慎的呵护，这样才能高效学习。

刻意练习。编程是技能，不是知识，技能只有在不断练习下才会有进步。本书是一本用来动手练习的书，不是一本用来阅读的书。你的编码学习之路，只能从你敲打下第一行代码开始。这个有点像学打篮球，我们知道，看再多的 NBA 视频，你都无法成为篮球高手。你的篮球学习，只有当你站着球场上，真真实实地拍打篮球，才算开始。本书的线索性很强，节节相扣，读者可以轻松的照着一步一步完成一个完整的 Web 项目，这也是本书的魅力所在。编程是一门技能，是一门需要刻意练习的技能，我们要求读者在短时间内，仔细揣摩、分解其中提到的技术话题，尽量手打代码，做上 5 遍，方能尽得此书精华。编程如作画，基本功非常重要。我们的目的是把「完整项目编码」这个技能训练为「潜意识动作」，有点像职业选手一样的潜意识动作，有了这个坚实的基础，我们就可以在上面建造高楼。

### 1.7 本书源码

本书源码：[summerblue/weibo: Laravel 中文新手课程《L01 Laravel 教程 - Web 开发实战入门》的源代码](https://github.com/summerblue/weibo/tree/L01_6.x)。

2『已下载源码「2020104Laravel实战入门源码」。』

找不到答案的话，就可以提问。提问时注意思路清晰、提供足够的信息，阅读下程序员必读的 《[8.1. 提问的智慧 |《社区使用指南》| LearnKu 产品论坛](https://learnku.com/docs/guide/smart-questions/2032)》 ，再做一下小测验（[懂得提问很重要，社区上线《提问的智慧》小测验 | LearnKu 产品论坛](https://learnku.com/articles/27606)） 。

## 0201开发环境.md

### 1. 逻辑脉络

本章内容：1）编辑器和浏览器的选择；2）命令行的基本使用；3）开发环境的部署搭建；4）虚拟机 Homestead 的基本使用；5）创建并运行一个 Laravel 项目；6）分布式版本控制系统 Git 的基本使用；7）将本地代码推送到 GitHub 上；8）部署一个 Laravel 应用到生产环境上。

### 2. 摘录及评论

### 2.2 第一个应用

    $ composer create-project laravel/laravel demoweb --prefer-dist "6.*"

上面命令可以指定新建项目的版本。查看项目所用版本的命令：

    artisan --version

注意这里我们使用 composer create-project 命令来进行创建 Laravel 项目，这样能利用 Composer 的本地缓存功能和 Composer 中文镜像来达到下载速度最优，尤其是后续的项目创建。打开 Code 文件夹可以看到刚刚创建的 Laravel 应用，Laravel 默认会为我们生成了一堆文件和文件夹，每一个文件的置放目录和位置都有它的用意。这些目录结构都是经过 Laravel 作者精心设计的，为的就是统一开发规范，强调约定高于配置的原则。

2、文件夹结构简介。表 1.1 为 Laravel 文件夹结构简介。

1）app，应用程序的业务逻辑代码存放文件夹。2）app/Console，存放自定义 Artisan 命令文件。3）app/Http/Controllers，存放控制器文件。4）app/Http/Middleware，存放「中间件」文件。5）bootstrap，框架启动与自动加载设置相关的文件。

6）composer.json，应用依赖的扩展包。7）composer.lock，扩展包列表，确保这个应用的副本使用相同版本的扩展包。8）config，应用程序的配置文件。9）database，数据库操作相关文件（数据库迁移和数据填充）。10）node_modules，存放 NPM 依赖模块。

11）package.json，应用所需的 NPM 包配置文件。12）phpunit.xml，测试工具 PHPUnit 的配置文件。13）public，前端控制器和资源相关文件（图片、JavaScript、CSS）。14）readme.md，项目介绍说明文件。15）resources，应用资源。

16）resources/js，未编译的 JavaScript 代码。17）resources/sass，未编译的 SASS 代码 （将会编译为 CSS ）。18）resources/lang，多语言文件。19）resources/views，视图文件。20）routes/api.php，用于定义 API 类型的路由。

1『routes/api.php，小程序等客户端从后台服务器上获取数据的 api 就是在这定义的。』

21）routes/channels.php，事件广播注册信息。22）routes/console.php，用于定义 Artisan 命令。23）routes/web.php，用于定义 Web 类型的路由（重点，大部分情况下本书会用到）。24）server.php，使用 PHP 内置服务器时的 URL 重写（类似于 Apache 的 "mod_rewrite" ）。

25）storage，编译后的视图、基于会话、文件缓存和其它框架生成的文件。26）storage/app，目录可用于存储应用程序使用的任何文件。27）storage/framework，目录被用于保存框架生成的文件及缓存。28）storage/logs，应用程序的日志文件。29）tests，应用测试相关文件。30）vendor，Composer 依赖模块。

31）webpack.mix.js，Laravel 的前端工作流配置文件。32）yarn.lock，Yarn 依赖版本锁定文件。33）.gitignore，被 Git 所忽略的文件。34）.env，环境变量配置文件。

1『 public 文件夹是根目录，把文件「test.php」放在里面，那么在浏览器里输入「http://localhost:8000/test.php」可直接执行，这是一种不用路由直接访问页面的形式。』

3、Composer。Composer 是一款跨平台的 PHP 依赖管理工具，其创作灵感来源于 Node.js 的 NPM 与 Ruby 的 Bundler。Laravel 使用 Composer 来作为扩展包的管理工具。你可以利用 Composer 结合其它开源扩展包来达到快速建站的目的。打开 composer.json 文件，可以看到 Laravel 默认集成了一些为框架提供支持的扩展包。Composer 是一个伟大的发明，他让组件式编程成为可能，编写软件时，就如拼接乐高玩具一样。极大的提高了开发的效率和代码的可复用性，解放了生产力。composer.json 文件内容如下。

该文件使用 JSON 格式编写，require 键对应的是应用在 Laravel 所有环境上的扩展包，require-dev 键对应的是应用在 Laravel 开发环境上的扩展包。在添加扩展包到 composer.json 时，需要为扩展包指定版本号才能进行安装。我们从 composer.json 文件中可以看到使用 ^ 来指定版本范围，如：

```
"facade/ignition": "^1.4",
```

^1.4 表示任意大于等于 1.4 的 1.x.x 版本，比如 1.4.0、1.4.1、1.11.0、1.9.99999 等。只要前面的 1 并且大于 ^ 后面指定的 1.4 都满足条件。

1『开发环境的搭建就按之前安装 laravel-admin 的配置来，详见「2020014laravel文档」里的相关信息。』

### 2.3 Git 与 GitHub

### 2.4 部署上线

1、部署。我们可以通过购买 Linode、DigitalOcean、UCloud、阿里云服务器来部署应用，或者是使用一些如 Engine Yard Cloud 和 Heroku 这样的云部署服务来快速完成应用的部署上线。由于 Heroku 的部署上线流程异常简单，对新手友好。因此在本书教程当中，我们将使用 Heroku 来部署 Laravel 应用。

2、什么是 Heroku？Heroku 是一个支持多种编程语言的 PaaS (Platform-as-a-Service)。在 2010 年被 Salesforce 收购。Heroku 作为最开始的云平台之一，从 2007 年 6 月起开始开发，当时它仅支持 Ruby，后来增加了对 Java、Node.js、Scala、Clojure、Python 以及 PHP 和 Perl 的支持。由于其应用部署流程异常简单，因此倍受广大开发者欢迎。

## 0301构建页面.md

### 1. 逻辑脉络

本章内容：1）对新建的 Laravel 项目进行基本配置；2）手动创建静态视图、控制器；3）了解控制器与视图的基本协作流程；4）了解如何使用通用视图；5）了解 Artisan 命令的基本使用。

### 2. 摘录及评论

1『这章 get 到一个小知识点，往 GitHub 上推东西直接命令「git push」，不用每次用全命令「git push origin master」。』

### 3.1 章节说明

从本章节开始，我们将使用 Laravel 开发一个类似新浪微博的网站。整个网站功能包括：1）用户的注册登录。2）用户个人信息的更改。3）使用管理员权限删除用户。4）发布微博。5）关注用户。6）查看关注用户的微博动态。

3、修改 hosts。每个 Laravel 项目创建完成后的第一步，即是对 Homestead 进行配置，让应用能在 Homestead 的开发环境上跑起来。为了方便记忆，一般我们都会将 IP 映射为域名，我们能够通过设置 hosts 文件来指定 IP 与域名之间的映射关系，由于我们在 Homestead 上默认使用 192.168.10.10 来作为虚拟机的 IP 的地址，因此我们需要在系统的 hosts 文件中将域名指向该 IP 上。Mac 下打开 Hosts 文件：

    > subl /etc/hosts

文件成功打开后，在 hosts 文件最后面新增下面一行以完成设置：

    192.168.10.10   weibo.test

1『同理，xampp 里应该也可以映射域名。可以直接进 hosts 文件里修改「vi /etc/hosts」。』

6、env 文件。接下来，我们还需要对应用根目录下的 .env 文件进行设置，为应用指定数据库名称 weibo。

```
.
.
.
DB_DATABASE=weibo
DB_USERNAME=homestead
DB_PASSWORD=secret
.
.
.
```

在 .env 文件中，除了 DB\_DATABASE 之外还有其它的设置信息，接下来让我们对里面的几项配置信息进行简单讲解。一般来说，在进行实际应用的开发过程中，应用会拥有不同的运行环境，通常会有以下环境：1）本地开发环境。2）测试环境。3）生产环境。在不同环境中，我们可能会使用不同的数据库或邮件发送驱动等配置，这时候则需要通过 .env 文件来针对不同的运行环境作不同的设置。比如上面我们所编辑的 .env 文件配置将应用在本地的开发环境（local）上。

.env 支持对应用的进行简单配置，比如你可以通过 APP\_ENV 来设定当前应用的运行环境，使用 APP\_DEBUG 来设定是否在应用报错时显示调试信息，使用 APP\_KEY 来生成应用的密钥用于加密一些较为敏感的数据。APP\_NAME 和 APP\_URL 分别是应用名称和访问 URL 。

```
APP_NAME=Weibo
APP_ENV=local
APP_KEY=base64:dIAK2B7exLbY2S54RFQdI3c6vg9/qIWWjYy5M4ESa4A=
APP_DEBUG=true
APP_URL=http://weibo.test
```

接下来对数据库的连接方式、数据库名、用户名密码等做相关配置：

```
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=weibo
DB_USERNAME=homestead
DB_PASSWORD=secret
```

3『

产品库里戴强的配置：

```
DB_CONNECTION=mysql
DB_HOST=47.99.104.199
DB_PORT=3306
DB_DATABASE=shop
DB_USERNAME=root
DB_PASSWORD=root
```

这里把本地服务器改成：127.0.0.1，本地数据库的用户名和密码也修改下。

』

缓存、会话、队列等驱动的相关配置信息：

```
BROADCAST_DRIVER=log
CACHE_DRIVER=file
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120
```

Redis 相关的配置信息，默认为 Redis 的通用配置：

```
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

邮件相关的配置信息：

```
MAIL_DRIVER=smtp
MAIL_HOST=mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
```

在完成对 .env 文件的设置后，我们便可以通过传参给 getenv 方法来获取到 .env 文件中指定的值，如调用 getenv('APP_ENV') 将返回 local。

8、Git 代码版本控制。为了在接下来更好的追踪项目代码的更改，我们还需要将新建的 Laravel 项目纳入到 Git 版本管理中：

我们前面已讨论过关于使用 GitHub 的种种好处，而现在是我们开始正式应用它的时候了。熟悉一个东西最快的方法就是不断训练，不断重复，因此本教程接下来项目构建的代码都将统一托管到 GitHub 上，以便让你对 GitHub 的使用更加熟悉。现在，我们需要在 GitHub 上新建一个名为 weibo 的项目点击创建新项目，并将代码推送上去；注意请把下面的 \<username> 替换为你的用户名。

```
$ git remote add origin git@github.com:<username>/weibo.git
$ git push -u origin master
```

1『之前是先在 GitHub 上建好空项目，拉到本地，在这个项目里加东西。后来发现上面的这个方式更佳。』

### 3.3 静态页面

1、说明。在进行完项目的基本配置之后，我们要开始正式进行项目开发了。本节将通过三个基本静态页面的构建，来让你了解 Laravel 最基本的页面构建流程。本书在接下来都会为每个章节新建一个 Git 分支，并在该分支上进行功能开发，开发完毕之后再将新建的分支合并到主分支上。

2、新建分支。首先让我们使用 Git 来新建一个 static-pages 分支。

```
$ git checkout master
$ git checkout -b static-pages
```

上面的第一条命令 git checkout master 代表将当前分支切换到 master 分支上，master 分支是我们初始化 Git 时默认创建的主分支，其它分支都是基于主分支衍生出来的。第二条命令 git checkout -b static-pages 将会为你创建一个名为 static-pages 的新分支。-b 选项表示创建指定名称的新分支。

你可以将新建的 static-pages 理解为是对 master 分支的克隆，在上面做的所有修改都不会影响到 master 分支。本节后面会将 static-pages 分支合并到 master 分支上，合并成功之后，在 static-pages 分支上做的所有改动都会并入到 master 分支。另外，你也可以选择对一个分支进行删除操作，当一个分支被删除之后，在该分支之上的所有改动也都将被销毁，删除分支的操作不会影响到 master 分支。这便是 Git 工作流的强大之处。

合并分支示例：

    $ git merge fake-branch

删除分支示例：

    $ git branch -d fake-branch

3、移除无用视图。Laravel 默认会为我们生成一个 welcome.blade.php 视图文件，主要用于对默认页面进行渲染，这个文件对我们接下来的项目开发没有一点用处，因此我们可将其移除。

4、配置路由。当用户在查看一个网页时，一个完整的访问过程如下：1）打开浏览器在地址栏输入 URL 并访问；2）路由将 URL 请求映射到指定控制器上；3）控制器收到请求，开始进行处理。如果视图需要动态数据进行渲染，则控制器会开始从模型中读取数据；4）数据读取完毕，将数据传送给视图进行渲染；5）视图渲染完成，在浏览器上呈现出完整页面。

1『书里有张图很形象。』

在 Laravel 开发中，我们使用路由来定义 URL 和 URL 的请求方式，再将该 URL 分配到相对应的控制器动作中进行处理。接下来要构建三个静态页面分别是主页、帮助页、关于页。因此我们需要为路由指定好三个不同的 URL：

routes/web.php

```php
<?php

Route::get('/', 'StaticPagesController@home');
Route::get('/help', 'StaticPagesController@help');
Route::get('/about', 'StaticPagesController@about');
```

1『

默认的代码是下面这种形式：

```php
Route::get('/about', function () {
    return view('StaticPagesController@about');
});
```

目前改用默认的会报错，后面发现理解错了，上面的代码全完错误。

```php
Route::get('/', function () {
    return view('welcome');
});
```

通过默认的 welcome 页面发现，view 文件夹下有个「welcome.blade.php」，那么在默认路由里，没有经过控制器，直接用 view 函数传递页面，默认例子里传给它的参数是「welcome」。比如可以在 view 文件夹下新建「vuetest.php」，文件里可以引入 vue.js 框架，注意这里的文件名不能是「vuetest.blade.php」，否则 laravel 解析不了。

web.php 是网页的路由，api.php 是做数据库 api 的路由。

』

在上面代码的代码中，我们为 get 方法传递了两个参数，第一个参数指明了 URL，第二个参数指明了处理该 URL 的控制器动作。get 表明这个路由将会响应 GET 请求，并将请求映射到指定的控制器动作上。比方说，我们向 http://weibo.test/ 发出了一个请求，则该请求将会由 StaticPagesController 的 home 方法进行处理。我们将在下节创建 StaticPagesController，为你讲解控制器在收到请求后如何进行相关操作。

在 Laravel 中我们较为常用的几个基本的 HTTP 操作分别为 GET、POST、PATCH、DELETE。1）GET 常用于页面读取。2）POST 常用于数据提交。3）PATCH 常用于数据更新。4）DELETE 常用于数据删除。在这四个动作中，PATCH 和 DELETE 是不被浏览器所支持的，但我们可以通过在提交表单中做一些手脚，让服务器以为这两个动作是从浏览器中发出的一样，后面我会具体讲解如何在表单中通过添加隐藏域的方式来欺骗服务器。这里你只需要有个大概的印象即可。

5、生成静态页面控制器。要让静态页面在网站上进行展示，我们需要先创建一个 StaticPagesController 控制器，这个控制器将负责整个网站静态页面的处理。Laravel 的控制器命名规范统一使用「驼峰式大小写」和复数形式来命名，在这里我们也应该这么做。一般情况下，我们会使用下面命令来生成静态页面控制器：

    $ php artisan make:controller StaticPagesController

让我们来看下 StaticPagesController 文件生成的默认代码（app/Http/Controllers/StaticPagesController.php）：

namespace 代表的是命名空间，这是在 PHP 5.3 之后才加入的语言特性，如果你之前学习过 Java 或 C# 的话，那么你应该对命名空间不陌生。简单来说，开发者可以利用命名空间来区分归类不同的代码功能，避免引起变量名或函数名的冲突。你可以把命名空间理解为文件路径，把变量名理解为文件。当我们在不同路径分别存放了相同的文件时，系统就不会出现冲突。

我们用 use 来引用在 PHP 文件中要使用的类，引用之后便可以对其进行调用。最后我们看到，在静态页面控制器中还定义了一个 StaticPagesController 类，这个类继承了父类 App\Http\Controllers\Controller，这意味着你可以在 StaticPagesController 类中任意使用父类中除私密方法外的其它方法。现在的静态页面控制器中还没有指定好三个页面对应的动作，让我们来为控制器加上这三个动作来处理从路由发过来的请求（app/Http/Controllers/StaticPagesController.php）：

在 StaticPagesController 类中，我们新定义了三个方法，这三个方法在接受到路由发过来的请求时，将会返回各自页面的名称，这三个方法名称与路由上的定义一一对应。现在：1）访问 http://weibo.test/ 你将看到有「主页」二字输出。2）访问 http://weibo.test/help 页面，则会看到「帮助页」。3）访问 http://weibo.test/about 页面，则会看到「关于页」。这三个方法返回的只是纯文本内容，算不上真正的视图，接下来我们再来添加并渲染真正的视图。

1『看官网上的代码确认了，php 缩进跟 Python 一样也是 4 个空格。』

6、添加静态页面视图。要在控制器中指定渲染某个视图，则需要使用到 view 方法，view 方法接收两个参数，第一个参数是视图的路径名称，第二个参数是与视图绑定的数据，第二个参数为可选参数。本章节讲的是静态页面的构建，因此并不需要利用到第二个参数，在后面的教程中我们会再讲解如何为视图绑定数据，并在视图中使用绑定的数据。view 方法在控制器的应用如下：

下面这行代码，将会渲染在 resources/views 文件夹下的 static_pages/home.blade.php 文件。默认情况下，所有的视图文件都存放在 resources/views 文件夹下。在控制器中指定渲染的视图之后，接下来便是对视图进行构建了，我们需要在 resources/views 中新增下面三个视图。

```
resources/views/static_pages/home.blade.php
resources/views/static_pages/help.blade.php
resources/views/static_pages/about.blade.php
```

8、Blade 模板。细心的你可能会留意到这三个文件的后缀名均为 .blade.php，而不是 .php。这是因为 Blade 是 Laravel 中提供的一套模板引擎，在 Blade 视图中我们可以使用 Laravel 为这套引擎定义的一些默认方法，并完全兼容 PHP 语法的书写。在项目运行时，Laravel 会把所有的 Blade 视图进行编译缓存成普通的 PHP 代码，因此你不必担心 Blade 会对应用产生负担。现在所有视图已经创建完毕，访问对应的 URL 地址便能看到视图被成功渲染。

8、使用通用视图。你可能已经注意到了，前面我们创建的几个视图里面包含着一些重复的代码，这明显违反了 DRY（Don't repeat yourself）原则，导致代码变得不够灵活、简洁。因此我们需要对页面进行重构，把多余的代码从视图中抽离出来，单独创建一个默认视图来进行存放通用代码。我们给应用创建了一个 default 视图，并将其放在 layouts 文件夹中，default 视图将作为整个应用的基础视图。实际上你只要保证视图文件被放置在 resources/views 目录下即可，Laravel 对视图的文件夹和文件命名并没有限制，我将 default 文件放在 layouts 文件下，只是为了让应用的目录结构让人更好理解（resources/views/layouts/default.blade.php）。

下面的这行代码表示该占位区域将用于显示 content 区块的内容，而 content 区块的内容将由继承自 default 视图的子视图定义。

    @yield('content')

Laravel 的 Blade 模板支持继承，这意味多个子视图可以共用父视图提供的视图模板。接下来让我们修改之前创建的首页视图文件，来学习下如何使用 Blade 模板的继承（resources/views/static_pages/home.blade.php）。

```
@extends('layouts.default')
@section('content')
  <h1>主页</h1>
@stop
```

我们使用了 @extends 并通过传参来继承父视图 layouts/default.blade.php 的视图模板。

    @extends('layouts.default')

使用 @section 和 @stop 代码来填充父视图的 content 区块，所有包含在 @section 和 @stop 中的代码都将被插入到父视图的 content 区块。在 Laravel 对 home.blade.php 文件进行编译后，结果如下；由此可见 Blade 模板继承有多方便。接下来让我们对其它两个视图也进行更改，统一使用父视图的代码。修改完成之后，再次在网页上访问这几个静态页面，你会发现父视图的代码已被成功嵌入到子视图中。

现在还有一点不足的地方，就是所有的网站标题名字都为 Weibo，这可太没个性了。因此我们接下来要做的就是针对页面标题进行优化，让不同页面显示不同的标题。首先我们要修改默认视图文件，在代码显示标题的位置嵌入 @yield 区块；我们给 @yield 传了两个参数，第一个参数是该区块的变量名称，第二个参数是默认值，表示当指定变量的值为空值时，使用 Weibo 来作为默认值。

    <title>@yield('title', 'Weibo App')</title>

下面让我们来为帮助页和关于页加上指定标题（resources/views/static_pages/help.blade.php）。

```
@extends('layouts.default')
@section('title', '帮助')

@section('content')
  <h1>帮助页</h1>
@stop
```

注意的是，当 @section 传递了第二个参数时，便不需要再通过 @stop 标识来告诉 Laravel 填充区块会在具体哪个位置结束。我们也可以在 @yield 区块后面进行内容拼接。让我们标题拥有更加丰富的信息（resources/views/layouts/default.blade.php）。

```
<!DOCTYPE html>
<html>
  <head>
    <title>@yield('title', 'Weibo App') - Laravel 新手入门教程</title>
  </head>
  <body>
    @yield('content')
  </body>
</html>
```

现在到浏览器重新刷新下页面，应该能看到标题后面成功拼接上我们定义的内容了。

1『才发现 HTML 里 title 标签里的内容即为浏览器中，页面标签最上面显示的内容。』

### 3.4 Artisan 命令

Artisan 是 Laravel 提供的 CLI（命令行接口），它提供了非常多实用的命令来帮助我们开发 Laravel 应用。前面我们已使用过 Artisan 命令来生成应用的 App Key 和控制器。在本教程中，我们会用到以下 Artisan 命令，你也可以使用 php artisan list 来查看所有可用的 Artisan 命令。后面我们会再对上面每个 Artisan 命令进行具体应用，你也可以使用 help 来查看各个 Artisan 命令的帮助界面，如：

    $ php artisan help migrate

2『书里那张 artisan 的各个命令常翻翻。』

## 0401优化页面.md

### 1. 逻辑脉络

本章基本内容：1）Bootstrap 前端框架的基本介绍与使用；2）Laravel Mix 前端工作流；3）Sass 语法的基本使用；4）局部视图的定义和引用；5）命名路由的使用。

### 2. 摘录及评论

本章节将针对前面创建的几个静态页面进行样式优化，并在本章节的最后面为接下来的用户注册功能准备好一个注册页面。

### 4.2 样式美化

1、样式美化。现在，让我们来新建一个分支，接下来针对样式的调整修改都将在此分支上进行：

```
$ git checkout master
$ git checkout -b filling-layout-style
```

2、Bootstrap。在本书的教学过程中将使用 Bootstrap 来作为演示应用的前端框架。Bootstrap 是由 Twitter 的两位工程师 Mark Otto 和 Jacob Thornton 在 2011 年开源的一个 Web 前端框架。该框架兼容当下主流浏览器，并支持响应式设计，对新手友好，容易上手，且内置了非常多的样式组件可供使用。如果你对 Bootstrap 的使用不太熟悉，推荐你阅读下 Bootstrap 的官方文档（[Bootstrap · The most popular HTML, CSS, and JS library in the world.](https://getbootstrap.com/)）。

3『[Introduction · Bootstrap](https://getbootstrap.com/docs/4.4/getting-started/introduction/)

Bootstrap, Build responsive, mobile-first projects on the web with the world’s most popular front-end component library. Bootstrap is an open source toolkit for developing with HTML, CSS, and JS. Quickly prototype your ideas or build your entire app with our Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful plugins built on jQuery. 

Bootstrap 是一组用于网站和网络应用程序开发的开源前端框架，包括 HTML、CSS 及 JavaScript 的框架，提供字体排印、窗体、按钮、导航及其他各种组件及 Javascript 扩展，旨在使动态网页和 Web 应用的开发更加容易。 Bootstrap 是 GitHub 上面被标记为「Starred」次数排名第四多的项目。

[Bootstrap - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/Bootstrap)

本意是制作一套可以保持一致性的工具和框架。在 Bootstrap 之前，开发界面需要使用不同的代码库，这样很容易导致不一致的问题，从而增加了维护的负担。Twitter 开发者 Mark Otto 说：我和几个开发者一起设计创建一个新的内部使用的工具，然后我们发现有机会可以做更多的事。从那之后，我们发现我们设计的工具比别人设计的更强壮。几个月之后，我们做出了 Bootstrap 的原型，在公司内分享文档、设计和资源。

经过一个小组几个月之后的努力，Twitter 的许多开发者把它当作 Hack Week（在 Twitter 开发者中流行的类似于黑客松的一星期）的一部分，开始参与开发。大家把 Twitter Blueprint 改名为 Bootstrap，并且在 2011 年 8 月 19 日将其作为开源项目发布。[4] 此后项目继续由 Mark Otto、Jacob Thornton 和一个核心开发小组维护，此外还有众多来自社区的贡献者。[5] 在 2012 年 1 月 31 日，Bootstrap 2 发布。这一版增加了十二列网格布局和响应式组件，并且对许多组件进行了修改。[6] Bootstrap 3 于 2013 年 8 月 19 日发布，开始将移动设备优先作为方针，并且开始使用扁平化设计。[6] 2015年 4 月 23 日，Mark Otto 宣布正在开发 Bootstrap 4 [7]。Bootstrap 4 的第一个 alpha 版本部署在 2015 年 8 月 19 日 [8]。

功能：Bootstrap 与最新版的 Google Chrome、Firefox、Internet Explorer、Opera 和 Safari 浏览器兼容，尽管有些浏览器并不是支持所有操作系统。[9]

[uiv - Bootstrap 3 Components implemented by Vue 2.](https://uiv.wxsm.space/getting-started)

[BootstrapVue](https://bootstrap-vue.js.org/)

』

3、网站导航。我们在很多网站上都能看到顶部导航的存在，因为这是个非常通用的产品需求，顶部导航能够让用户很方便的对网站进行浏览。接下来我们会使用 Bootstrap 来为网站添加顶部导航，加入一些基本的如 LOGO，帮助页，登录页等链接，方便用户跳转，随着后面功能的添加，该导航也会被不断完善。Laravel 项目中使用 Bootstrap 前端框架，需要先执行以下命令：

    $ composer require laravel/ui --dev

composer require 是用来安装扩展包使用的命令，参数 --dev 是指定此扩展包只在开发环境中使用。

1『

报错：laravel/ui 2.x-dev requires illuminate/filesystem ^7.0。尝试在 composer.json 文件里增加对框架的支持版本。

```
"require-dev": {
        "facade/ignition": "^1.4",
        "fzaninotto/faker": "^1.9.1",
        "mockery/mockery": "^1.0",
        "nunomaduro/collision": "^3.0",
        "phpunit/phpunit": "^8.0",
        "laravel/ui": "^2.0"
```

还是安装不了。查得信息「ui 2.0 只支持 Laravel 7.x」，那么安装 ui 框架需要指定版本 1.2.0 的，更换命令：

    composer require laravel/ui:^1.0 --dev

』

上面的命令安装完成后，使用以下命令来引入 Bootstrap ：

    $ php artisan ui bootstrap

1『

运行后显示：

```
Bootstrap scaffolding installed successfully.
Please run "npm install && npm run dev" to compile your fresh scaffolding.
```

按上面的命令跑一下。

』

Bootstrap 是以 NPM 扩展包的形式集成到 Laravel 项目中的，NPM 是 Node.js（一个基于 Google V8 引擎的 JavaScript 运行环境）的包管理和分发工具。Composer 的一些概念也是从 NPM 中借鉴过来的，因此 NPM 也有个类似 composer.json 文件的 package.json 文件：

以上的 NPM 扩展包，我们重点看以下几个：1）bootstrap —— Bootstrap NPM 扩展包；2）jquery —— jQuery NPM 扩展包；3）laravel-mix —— 由 Laravel 官方提供的静态资源管理工具。这些扩展包，为 Laravel 提供了一套完整的前端工作流。

我们可以使用 NPM 对这些扩展包进行安装，但由于 NPM 的安装速度，安全性和稳定性等都饱受开发者的诟病。因此我们在教程中改用 Facebook 在 2016 年的 10 月份开源的 Yarn 来作为 NPM 的替代品，在后面的章节中我将为大家详细讲解 NPM 和 Yarn 之间的关系。开始安装之前，我们需要设置安装器来使用国内的淘宝镜像加速，加速镜像的原理是使用国内的 CDN 来下载所需代码包，会更加顺畅：

```
$ npm config set registry=https://registry.npm.taobao.org
$ yarn config set registry 'https://registry.npm.taobao.org'
```

现在先让我们使用 Yarn 对扩展包进行安装，请在项目根目录下运行以下命令进行安装：

```
$ yarn install --no-bin-links
$ yarn add cross-env
```

1『

第一条命令后的信息：

```
success Saved lockfile.
warning Your current version of Yarn is out of date. The latest version is "1.22.4", while you're on "1.22.0".
info To upgrade, run the following command:
$ brew upgrade yarn
✨  Done in 59.45s.
```

第二条命令后的信息：

```
success Saved lockfile.
warning "cross-env" is already in "devDependencies". Please remove existing entry first before adding it to "dependencies".
success Saved 1 new dependency.
info Direct dependencies
└─ cross-env@7.0.2
info All dependencies
└─ cross-env@7.0.2
✨  Done in 3.96s.
```
』

在本教程提供的定制化 Homestead 安装包中，我们已默认为大家集成了 Yarn，因此不必再进行重复安装 Yarn，若你想了解具体的安装方式，可查阅 Yarn 官方安装文档（[Installation | Yarn](https://classic.yarnpkg.com/en/docs/install#mac-stable)）。

1『

尝试了很多方法均已失败告终（详见原书复制里的记录），最终还是回到了用 brew 安装，通过更改镜像源：[执行 brew install 命令长时间卡在 Updating Homebrew 的解决方法 | Mac 用户论坛](https://learnku.com/articles/18908)。平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：1）brew.git。2）homebrew-core.git。3）homebrew-bottles。通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址。安装 yarn 的时候，卡住就 control +c 中断出来，接着重复安装。最后终于安装成功，随便也把 brew 整体更新了一下：brew update --verbose。

[RN: Yarn | veryitman](http://www.veryitman.com/2017/02/05/RN-Yarn/)

』

安装完成之后，让我们对 Laravel 默认生成的 app.scss 文件进行编辑，删除此文件里的所有内容，只留下面一行，导入 Bootstrap：resources/sass/app.scss

```
// Bootstrap
@import '~bootstrap/scss/bootstrap';
```

1『 app.scss 文件所在的位置：resources/sass。』

细心的你可能会发现上面新建的样式文件后缀名（.scss）有别我们之前经常看到的样式文件后缀名（.css），这是因为 .scss 是 Sass（一种 CSS 开发工具）专属的文件格式，我们后面会再对 Sass 相关的知识进行补充讲解。将 Bootstrap 导入成功之后，我们需要使用以下命令来将 .scss 文件编译为 .css 才能正常使用，编译命令如下：

    $ npm run dev

1『

运行后显示：

```
 DONE  Compiled successfully in 8211ms                          
       Asset      Size   Chunks             Chunk Names
/css/app.css   178 KiB  /js/app  [emitted]  /js/app
  /js/app.js  1.06 MiB  /js/app  [emitted]  /js/app
```

』

我们也可以通过下面的命令，在每次检测到 .scss 文件发生更改时，自动将其编译为 .css 文件：

    $ npm run watch-poll

请保证在进行项目开发时 npm run watch-poll 一直运行着，避免出现前端文件更改后没有应用到页面上的歧义。执行成功可以看到以下：

所有编译后的资源文件都被存放在 public 文件夹中，你能在 public/css 文件夹中看到刚刚编译成功之后的文件。接下来让我们更改基础视图的页面结构，为应用添加顶部导航，并加入帮助页和登录页的链接（resources/views/layouts/default.blade.php）。

Laravel 在运行时，是以 public 文件夹为根目录的，因此我们可以使用下面这行代码来为 Laravel 引入样式：

    <link rel="stylesheet" href="{{ mix('css/app.css') }}">

1『既然 public 是根目录，把 html、js 放在这里就可以显示？经试验发现可行。（2020-04-11）』

上面代码将引入 public/css/app.css 样式文件。header、nav 是 HTML5 提供的一种语义化标签，其实际作用与 div 一致，语义化的标签能帮助机器更方便理解代码，使代码更简洁，有助于网站的 SEO 优化。我们在上面代码使用到一些如 navbar、container 等类名在 Bootstrap 中都拥有特殊含义。现在让我们接着更改首页信息，加多一些页面元素（resources/views/static_pages/home.blade.php）。接下来让我们来调整下（resources/sass/app.scss）：

因为我们在上面运行着 npm run watch-poll 命令，watch-poll 任务会监控着 resources 下的文件变更。当你保存 app.scss 的动作被 watch-poll 命令捕捉到以后，就会触发自动编译功能，将 .scss 文件编译为 .css 文件，并存放到 public/css 文件夹里。

1『

还是决定将项目放到 GitHub 上，同时练习分支的应用。现在 GitHub 上创建一个新的仓库 demoweb，记得别建 readme.md，否者跟本地的 readme.md 会冲突，还要处理。进本地的项目初始化，先提交 commit，再推送到远程仓库。

```
git init
git add .
git commit -m '初始化样式'

git remote add origin git@github.com:dalong0514/demoweb.git
git push -u origin master
```

』

### 4.3 Laravel 前端工作流

1、Laravel 前端工作流。接下来讲解 Laravel 是如何利用 Sass、NPM、Yarn、Laravel Mix 来构成一套完整的前端工作流。

2、SASS 语法基础。Sass 是一种可用于编写 CSS 的语言，起初由 Hampton Catlin 进行设计并由 Natalie Weizenbaum 开发。借助 Sass 我们可以少写很多 CSS 代码，并使样式代码的编写更加灵活多变。接下来我们将对 Sass 的几个主要功能进行讲解。

1）样式文件导入。Sass 使用 @import 来导入其它的样式文件。如：

    @import '~bootstrap/scss/bootstrap';

上面代码将导入 node_modules/bootstrap/scss/bootstrap.scss 文件。你也可以使用下面代码来对单独一个文件进行导入：

    @import "node_modules/bootstrap/scss/_alert.scss";

2）变量。Sass 还允许你在代码中加入变量，所有的变量均以 \$ 开头。定义了一个 \$navbar-color 颜色变量，在编译成功之后，变量将被替代为它所对应的值。

```
$navbar-color: #3c3e42;
.navbar-inverse {
  background-color: $navbar-color;
}
```

3）嵌套。Sass 还允许你在选择器中进行相互嵌套，以减少代码量。引用父选择器。你还可以在 Sass 嵌套中使用 & 对父选择器进行引用。

3、NPM、Yarn、Laravel Mix。

NPM。注意以下区块中 npm 安装相关的命令只用于说明（全改用 yarn 安装），不需要在命令行中运行。我们将在本文后面使用 Yarn 来作为我们的安装器。NPM 是 Node.js 的包管理和任务管理工具，其强大的功能也是 Node.js 能够如此成功的因素之一。在使用 NPM 安装第三方模块（也可理解为扩展包）时，你需要在 package.json 中对要安装的模块指定好名称和版本号。然后运行下面命令进行安装：

    $ npm install

在开始安装之前，npm install 命令会先检查 node\_modules 文件夹是否已存在要安装的模块，如果该模块已安装，则跳过，接着安装下一模块。安装完成后，所有的第三方模块都将被下载到 node\_modules 文件夹中。你也可以使用下面命令来强制安装所有模块，不管该模块之前是否安装过：

    $ npm install -f

由于国内的网络环境原因，我们在使用 NPM 安装第三方模块时会耗费较长时间，我们可通过淘宝提供的加速镜像来解决该问题。使用以下命令做 NPM 和 Yarn 安装加速：

```
$ npm config set registry=https://registry.npm.taobao.org
$ yarn config set registry 'https://registry.npm.taobao.org'
```

在本教程中，出于安装速度考虑，我们使用更加现代化的 Yarn 来替代 NPM 的包管理功能。然而我们仍然会使用到 NPM 的任务管理功能，如命令 npm run watch-poll。

1『 yarn 安装替代 npm 安装，但沿用 npm 的任务管理功能。』

Yarn 是 Facebook 在 2016 年 10 月开源的一个新的包管理器，用于替代现有的 NPM 客户端或者其他兼容 NPM 仓库的包管理工具。Yarn 在保留 NPM 原有工作流特性的基础上，使之变得更快、更安全、更可靠。在后面的项目开发中，我们统一使用 Yarn 来代替 NPM 进行安装包的管理。我们可通过下面命令来安装当前项目的所有包：

    $ yarn install

或是使用下面这种更加简洁的命令：

    $ yarn

当执行 yarn install 命令时，Yarn 会先判断当前文件夹中是否存在 yarn.lock 文件，存在的话会按照文件中特定的包版本进行安装，否则读取 package.json 文件中的内容并发送到服务器上解析，解析成功后把结果写入 yarn.lock 文件中，最后安装扩展包。 Laravel 自带 yarn.lock 文件，此文件的作用与 composer.lock 一致，是为了保证项目依赖代码版本号绝对一致而存在的。另外，我们也可以通过下面命令来添加指定的包：

    $ yarn add [package]

1『

发现有个警告：

```
yarn install v1.22.0
warning package-lock.json found. Your project contains lock files generated by tools other
 than Yarn. It is advised not to mix package managers in order to avoid resolution inconsi
stencies caused by unsynchronized lock files. To clear this warning, remove package-lock.json.
[1/4]  Resolving packages...
success Already up-to-date.
```

按提示把 package-lock.json 移除，这个文件对应于 npm 的，不用 npm 安装的话是可以移除。

』

Laravel Mix 是一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix 提供了简洁流畅的 API，让你能够为你的 Laravel 应用定义 Webpack 编译任务。Mix 支持许多常见的 CSS 与 JavaScript 预处理器，通过简单的调用，你可以轻松地管理前端资源。我们可以在 webpack.mix.js 文件中制定一些如资源文件的编译、压缩等任务。Laravel 已默认为我们生成了 webpack.mix.js 文件，并集成了 laravel-mix 模块（webpack.mix.js）。

```
const mix = require('laravel-mix');

mix.js('resources/js/app.js', 'public/js')
   .sass('resources/sass/app.scss', 'public/css');
```

代码分解：

    const mix = require('laravel-mix');

webpack.mix.js 的解析引擎是 Node.js ，在 Node.js 中 require 关键词是对模块进行引用。Mix 提供了一些函数来帮助你使用 JavaScript 文件，像是编译 ECMAScript 2015、模块编译、压缩、及简单的合并纯 JavaScript 文件。更棒的是，这些都不需要自定义的配置。

    mix.js('resources/js/app.js', 'public/js')

以上这一行简单的代码，支持：1）ECMAScript 2015 语法；2）Modules；3）编译 .vue 文件；4）针对生产环境压缩代码。js 方法的第二个参数可以用来自定义生成的 JS 文件的输出目录。

1『

引入 vue 模块也是在这「webpack.mix.js」。

```js
mix.js('resources/js/app.js', 'public/js')
    .js('resources/js/vueapp.js', 'public/js')
    .sass('resources/sass/app.scss', 'public/css');
```

』

    mix.sass('resources/sass/app.scss', 'public/css');

sass 方法可以让你将 Sass 文件编译为 CSS，你可以使用第二个参数来自定义生成的 CSS 的输出目录。

4、开始使用 Mix。使用 Mix 很简单，首先你需要使用以下命令安装 npm 依赖：

    $ yarn install

安装成功后，运行以下命令即可：

    $ npm run watch-poll

watch-poll 会在你的终端里持续运行，监控 resources 文件夹下的资源文件是否有发生改变。在 watch-poll 命令运行的情况下，一旦资源文件发生变化，Webpack 会自动重新编译。在后面的课程中，我们需要保证 npm run watch-poll 一直处在执行状态中。

1『这个知识点作者前面有提到过。』

### 4.4 浏览器缓存问题

1、问题描述。现代化的浏览器，会对静态文件进行缓存，静态文件在本课程的范畴内，指的是 .css 、.js 后缀的文件。这是一个浏览器的优化功能，极大地加快了网页的加载速度，但是在我们日常开发和维护中，有时候会造成混淆。开发时，你明明修改了样式，但是刷新浏览器却看不见变化，然后你就来回不断地修改你的样式文件，做各种测试，浏览器页面仍然一成不变。直到你重新刷新好多次，或者修改样式文件名称时，才恍然大悟，原来是浏览器缓存了。

2、解决方案。Laravel Mix 给出的方案是为每一次的文件修改做哈希处理。只要文件修改，哈希值就会变，提醒客户端需要重新加载文件，很巧妙地解决了我们的问题。我们只需要对 webpack.mix.js 稍作修改，即可使用此功能（webpack.mix.js）：

```js
const mix = require('laravel-mix');

mix.js('resources/js/app.js', 'public/js')
   .sass('resources/sass/app.scss', 'public/css').version();
```

以上可看出，我们只是增加了 version() 函数的调用，其他未做修改。接下来还需要修改模板，使其动态加载样式代码（resources/views/layouts/default.blade.php）：

以上代码只是做了这一行的修改：

    <link rel="stylesheet" href="{{ mix('css/app.css') }}">

mix() 方法与 webpack.mix.js 文件里的逻辑遥相呼应。注意：webpack.mix.js 文件只在 npm run watch-poll 指令执行时引入，之后指令后台运行不再重新引入。如果你后台运行 watch-poll 命令的话，需关闭 watch-poll 服务（Ctrl + Z），再次启动（ npm run watch-poll ）即可生效。接下来刷新页面，查看页面源代码：

另外的，线上环境中，我们一般会使用 CDN 服务器来加载静态文件，以达到优化网页加载速度的效果。CDN 也会遇到像浏览器缓存类似的问题，Laravel Mix 的 version() 同时也是一个很好解决文件版本变更的方案。

### 4.5 局部视图

1、局部视图。介绍完前端工作流以后，我们接下来回到代码中。现在我们的应用已拥有顶部导航，但还存在一个问题。随着后面顶部导航功能愈加完善，代码量也会越来越多，如果把所有代码都放在默认视图文件中，会让这个文件变得无法维护，这明显不符合 Laravel 项目开发的最佳实践。因此我们需要把顶部导航从 default 视图中分离出来，成为一个单独的头部视图。

2、头部和底部视图。首先，我们需要新建一个头部视图文件（resources/views/layouts/\_header.blade.php）。可以看到，我们在头部视图的文件名前面加了下划线 \_，这样做是为了指定该视图文件为局部视图，为局部视图增加前缀下划线是「约定俗成」的做法，方便了其它人快速地理解该文件的实际作用。从这里开始，我们都会为局部文件添加下划线前缀。现在让我们再来为应用创建一个底部视图，用于置放网站的一些基础信息（resources/views/layouts/\_footer.blade.php）。

1『局部视图文件的下划线是个约定。』

3、样式优化。针对底部视图进行样式优化（resources/sass/app.scss）。

4、引入局部视图。在完成头部视图和底部视图的定义后，接下来便可以在 default 视图中引用这两个视图（resources/views/layouts/default.blade.php）。@include 是 Blade 提供的视图引用方法，可通过传参一个具体的文件路径名称来引用视图。

1、布局中的链接。由于我们进行了样式优化，现在的首页已经比一开始的好看多了。但视图里面的一些代码仍可以进行优化，比如链接地址（resources/views/layouts/_header.blade.php）。

    <li><a href="/help">帮助</a></li>

上面的代码链接形式是 Web 开发中较为常用的一种，但在 Laravel 中，我们可以这么写：

    <li><a href="{{ route('help') }}">帮助</a></li>

{{ }} 是在 HTML 中内嵌 PHP 的 Blade 语法标识符，表示包含在该区块内的代码都将使用 PHP 来编译运行。route() 方法由 Laravel 提供，通过传递一个具体的路由名称来生成完整的 URL。后面我们再来讲解路由名称的具体定义方法。

2『 {{}} 里放 PHP 代码块，这个知识点做一张「计算机信息」卡片。』

2、Laravel 路由。我们在前面讲到，如果要使用下面这种方式来渲染 help 链接，则需要先为路由定义 help 路由名称。

    <li><a href="{{ route('help') }}">帮助</a></li>

在 Laravel 中，我们可以通过在路由后面链式调用 name 方法来为路由指定名称：

    Route::get('/help', 'StaticPagesController@help')->name('help');

当我们在页面渲染该路由时，route('help') 最终的渲染结果将如下：

可以看到 route('help') 为我们生成了完整的 URL 地址，这样当我们需要对生成的 URL 进行更改时，我们只需要改动路由文件即可，由此可见在实际开发中养成对路由的命名是一个好习惯，可以帮助我们节省很多工作量，另外也是 Laravel 项目开发的最佳实践。

2『用 laravel 框架开发时，养成对路由命名的习惯。做一张计算机卡片。』

这里举一个例子来说明：假如我们的应用中有 10 个地方使用 route('help') 方式书写这个 URL 地址，因为特殊原因，需要将 http://weibo.test/help 修改为 http://weibo.test/faq ，这时候，你只需要修改路由定义为以下即可：

    Route::get('/faq', 'StaticPagesController@help')->name('help');

这样子不需要修改到其他代码。作为比较，如果不使用 route('help') 方式，而是直接在代码中写入 http://weibo.test/help ，那你只能一个个的去手工修改。了解了使用命名路由的好处之后，让我们开始动手，命名之前创建的几个路由（routes/web.php）。

```php
<?php

Route::get('/', 'StaticPagesController@home')->name('home');
Route::get('/help', 'StaticPagesController@help')->name('help');
Route::get('/about', 'StaticPagesController@about')->name('about');
```

3、使用命名路由。由于我们都为路由指定好了名称，因此我们可以将头部视图和底部视图的链接更改为 route() 的方式来生成（resources/views/layouts/\_header.blade.php 以及 resources/views/layouts/\_footer.blade.php）。

### 4.7 用户注册页面

1、静态页面。在我们后面的教程中，将会为应用添加注册登录的功能，本节让我们先来完成用户注册功能的第一步：为用户注册功能创建基本的静态页面。

2、注册路由。按照我们之前的讲的构建流程，我们需要先为路由定义一个 signup 路由，当用户访问 http://weibo.test/signup 时将进入我们的注册页面（routes/web.php）。这次我们把 signup 的路由请求交给用户控制器 UsersController 来处理。因为我们在后面会为注册页面添加上表单注册功能，到时候表单提交请求会与数据库进行交互，因此该页面并不能算静态页面，也就意味着我们不能再使用 StaticPagesController 来处理此动作。由于后面的用户注册、更新、删除等一系列操作都是围绕着用户进行的，因此统一使用用户控制器来处理此逻辑比较符合 Laravel 的开发规范。注册路由时，URI signup 和 /signup 从使用上来看，并无区别，Laravel 框架兼容这两种写法。

```php
Route::get('signup', 'UsersController@create')->name('signup');
```

3、生成用户控制器。现在我们还没有用户控制器，让我们运行下面命令来生成。

    $ php artisan make:controller UsersController

以上命令会生成 app/Http/Controllers/UsersController.php 文件。在路由中，我们会将用户注册页面的请求处理指定给用户控制器的 create 方法进行处理，接下来让我们完成该方法的定义（app/Http/Controllers/UsersController.php）。

4、注册页面视图。接下来让我们来添加一个简单的注册视图，后面再为该视图加上表单，让用户可以提交自己的个人信息（resources/views/users/create.blade.php）。

```html
@extends('layouts.default')
@section('title', '注册')

@section('content')
<h1>注册</h1>
@stop
```

最后我们让我们修改首页注册按钮的链接，提供给用户一个进入注册页面的入口（resources/views/static_pages/home.blade.php）。保存后刷新首页看看吧。试试看点击「现在注册」按钮是否会跳转到 signup 页面呢？

### 4.8 小结

我们运行 Git 的状态检查命令，会发现新增了一个 public/css 文件夹。这是为什么呢？原因是我们在前面使用了 npm run watch-poll 来监听文件的更改并持续编译，因此当我们切回到主分支上时，app.scss 文件会回到一开始在主分支上未经过任何修改的状态，这时 app.scss 文件被 watch-poll 任务检测到发生更改，便会对该文件进行编译，最终产生一个 public/css/app.css 文件。但这个文件对我们来说是个累赘，没有一点作用，原因如下：1）新编译的 app.css 文件没有包含我们本章新添加的样式代码，因为它是由初始状态的 app.scss 文件编译成的。2）在 Git 分支 filling-layout-style 上已新增了 app.css，若将该分支与主分支进行合并，将导致文件冲突的情况发生。解决冲突的方法很简单，先检出 Master，放弃所有文件修改，再进行分支合并即可。

```
$ git checkout .
$ git reset --hard
$ git merge filling-layout-style
```

## 0501用户模型.md

### 1. 逻辑脉络

本章内容：1）Eloquent 模型的定义与应用；2）数据库迁移的创建、数据表生成、数据表回滚；3）模型的基本使用；4）Tinker 的基本使用。

### 2. 摘录及评论

### 5.1 章节说明

1、MVC 的 M。在前面讲的 MVC 模式中，我们一直没讲到其中的 M - Model（模型），本章我们将构建一个基本的用户模型来实现用户数据的存储，并了解 Laravel 如何对模型对象进行增删改查操作。后面我们还会在此用户模型基础上添加用户注册和登录功能，并对用户身份进行权限认证，让管理员可以对用户进行删除操作。接着我们还会构建一套用户账号激活和密码找回系统，只有成功进行邮箱激活的用户才能在网站上进行登录，激活成功后的用户如果出现密码丢失的情况，可以使用已认证的邮箱进行密码找回。

2、用户认证系统。事实上，Laravel 已默认为我们集成了一整套用户登录注册功能，并提供了一些非常方便的 API，让我们可以快速构建自己的用户认证系统。如果完全借助 Laravel 提供的用户认证系统，我们能够在短短几分钟便完成整个登录注册功能的开发，包括用户数据库的整个构建过程。但这不利于新手的学习，整个功能的具体实现代码被 Laravel 隐藏起来，像一个黑盒一样，你很难去理解这里面整个实现和调用过程。因此，本教程将不会完全借助 Laravel 提供的用户认证系统，而是借助 Laravel 提供的一些简便的 API 来独自开发一个完整的用户认证系统，帮助新手更好的学习用户认证系统的运行机制。但在实际项目的开发中，如果对注册登录功能的定制性不高，还是建议你使用 Laravel 默认提供的用户认证系统来操作。

2『 Laravel 默认提供的用户认证系统，看完本书后去研究一下。』

3、Eloquent ORM。在接下来几章要实现的用户注册功能需要用到数据库来进行数据存储，用于放置用户的基本信息。在这期间，还需要用到数据模型 —— Model，利用 Laravel 提供的 Eloquent ORM 跟数据库进行交互，实现用户数据的增删改查操作。Eloquent 提供了简洁优雅的 ActiveRecord 实现来跟数据库进行交互。Active Record 是一种领域模型模式，该模式由 Martin Fowler 在 2003 年出版的《企业应用架构模式》一书中进行了详细叙述并命名。其特点是一个模型类对应关系型数据库中的一个表，模型类的一个实例对应表中的一行记录。Active Record 最大优点是允许我们简单，直观地操作数据层。

3『类对应于一张表，实例化后的对象对应于一行记录。又联系到脑子里多维向量的概念，一个多维向量对应于一条记录，即对象，可表示万物，每个维度即一个属性，对应于表里的列名（字段）。』

4、准备好舞台。现在让我们照例先来创建一个新分支。

```
$ git checkout master
$ git checkout -b modeling-users
```

### 5.2 数据库迁移

1、什么是数据库迁移？在 Laravel 中，我们使用「数据库迁移」来管理数据库表结构，迁移就像是数据库中的版本控制，它让团队成员之间能够轻松的修改跟共享应用程序的数据库结构，而不用担心并行更新数据结构而造成冲突等问题。同时也让 Laravel 项目的部署变得很方便。不仅如此，Migration 建表要比直接手动创建表或者 .sql 文件具备额外的管理数据库的功能，如：回滚 / 重置 / 更新等。Migration 的建表方法大部分情况下能兼容 MySQL, PostgreSQL, SQLite 甚至是 Oracle 等主流数据库系统。总结下迁移的好处：1）多人并行开发；2）代码版本管理；3）数据库版本控制 —— 如：回滚 / 重置 / 更新等；4）兼容多种数据库系统；5）部署方便。

2、默认迁移文件。所有创建的迁移文件都被统一放在 database/migrations 文件夹里。打开该文件夹我们可以看到，Laravel 已默认为我们创建好了三个迁移文件：

```
database/migrations/2019_08_19_000000_create_users_table.php
database/migrations/2019_08_19_100000_create_password_resets_table.php
database/migrations/2019_08_19_000000_create_failed_jobs_table.php
```

从上面迁移文件的命名可以看出，Laravel 在创建迁移文件时会默认在生成的文件名前面加上一个当前时间戳，用于指明该文件的创建时间。加上时间戳来命名迁移文件的好处在于，当我们进行团队协作开发时，如果有多个成员生成了相同名字的迁移文件，也不会出现文件冲突的问题，除非这几个成员都在同一时间生成了相同名称的迁移文件，不过这种概率太低了，基本可以忽略不计。

Laravel 默认创建的三个迁移文件，一个用于构建用户表，一个用于构建密码重置表，一个用于构建任务失败表。密码重置的功能我们在后面章节再进行讲解，本章我们先来看下 Laravel 为我们生成的创建用户迁移文件里面都包含了什么内容（database/migrations/2014\_10\_12\_000000\_create\_users\_table.php）。

```php
<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
}
```

可以看到在该文件里面定义了一个 CreateUsersTable 类，并继承自 Migration 基类。CreateUsersTable 有两个方法 up 和 down ：1）当我们运行迁移时，up 方法会被调用；2）当我们回滚迁移时，down 方法会被调用。

3、创建数据库表。在 up 方法里面，我们通过调用 Schema 类的 create 方法来创建 users 表：

```php
Schema::create('users', function (Blueprint $table) {
    ...
});
```

create 方法会接收两个参数：一个是数据表的名称，另一个则是接收 \$table（Blueprint 实例）的闭包。

1『上面的 create 方法是关键知识点。』

4、定义数据表字段。CreateUsersTable 类中通过 Blueprint 的实例 \$table 为 users 表创建所需的数据库字段。接下来让我们来详细讲解 Blueprint 实例 \$table 的基本用法：

```php
$table->increments('id');
```

由 increments 方法创建了一个 integer 类型的自增长 id。

```php
$table->string('name');
```

由 string 方法创建了一个 name 字段，用于保存用户名称。

```php
$table->string('email')->unique();
```

由 string 方法创建了一个 email 字段，且在最后指定该字段的值为唯一值，用于保存用户邮箱。

```php
$table->timestamp('email_verified_at')->nullable();
```

Email 验证时间，空的话意味着用户还未验证邮箱。

```php
$table->string('password', 60);
```

由 string 方法创建了一个 password 字段，且在 string 方法中指定保存的值最大长度为 60，用于保存用户密码。

```php
$table->rememberToken();
```

由 rememberToken 方法为用户创建一个 remember_token 字段，用于保存「记住我」的相关信息。

```php
$table->timestamps();
```

由 timestamps 方法创建了一个 created\_at 和一个 updated\_at 字段，分别用于保存用户的创建时间和更新时间。

最终该迁移文件生成的用户表字段信息如下所示（字段名称以及字段类型）：id——integer；name——string；email——string；email\_verified\_at——datetime；password——string；remember\_token——string；created\_at——datetime；updated\_at——datetime；若要了解更多 \$table 的可用方法，可查阅官方文档（[快速入门 |《Laravel 6 中文文档 6.x》| Laravel China 社区](https://learnku.com/docs/laravel/6.x/database/5170)）。

5、回滚迁移。down 方法会在回滚命令发起时被调用，是 up 方法的逆向操作。在上面的代码中，up 创建了 users 表，那么这里将会通过调用 Schema 的 drop 方法来删除 users 表。

```php
public function down()
{
    Schema::dropIfExists('users');
}
```

### 5.3 查看数据库表

在 Mac 上，我们可以通过安装 SequelPro （ 百度盘下载 ）来进行数据库的一些操作，如查阅数据或删除数据。SequelPro 是一款开源的数据库软件，非常容易使用。

2、数据库迁移。我们需要运行下面的命令来生成执行迁移，migrate 命令会执行所有未被执行过的迁移。我们可以看到有三个迁移成功执行。注：我们一开始在创建 weibo 项目时，已经为其创建了数据库，并在 .env 文件中做了配置，所以这里会直接使用这些数据库设置。

1『注意得先进 mysql 里新建一个「demoweb」的数据库；sequel pro 一直读不出数据库，直接进终端的 mysql 查看，数据库已经键好了。后来查得信息：问题原因是 mysql 8.0 升级后造成的。解决方法：先使用测试版（[Test Builds](https://sequelpro.com/test-builds)），等正式稳定版兼容 mysql 8.0 后， 再使用稳定版。』

接下来查看下生成的数据库表。可以看到我们有四个表，分别是：1）failed\_jobs —— 记录队列任务执行失败的表（L02 里会讲到）；2）migrations —— 第一次执行 artisan migrate 命令时生成的，其作用是用来做迁移版本的记录；2）password\_resets —— 保存密码重置令牌的表；3）users —— 应用最重要的表，用户表。我们来看下 migrations 表内的数据。migrations 表主要两个字段：1）migration 是迁移文件的名称；2）batch 是用来记录迁移对应的批次，以此来实现「回滚迁移」的功能。

3、数据库回滚。在日常开发中，我们有时候也需要通过下面的方式来回滚到最近一次执行的迁移。回滚执行成功后，两个表都将被删除。

    $ php artisan migrate:rollback

回到数据库管理工具的视图，刷新以后会发现只剩下 migrations 表；如果你尝试了回滚迁移的操作，请再次运行迁移，以方便后面章节的顺利进行。

    $ php artisan migrate

### 5.4 模型文件

1、用户模型。Laravel 默认为我们生成了用户模型文件，代码如下所示（app/User.php）：

```php
<?php

namespace App;

use Illuminate\Notifications\Notifiable;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;

class User extends Authenticatable
{
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    /**
     * The attributes that should be cast to native types.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];
}
```

可以看到 Laravel 默认为我们生成的用户模型中包含了不少代码，其中 Notifiable 是消息通知相关功能引用，Authenticatable 是授权相关功能的引用。接下来我们主要将精力放在用户模型中定义的三个属性 table、fillable、hidden 上。我们在前面提到过，Eloquent 模型可以让我们很方便的与数据库进行交互，因此我们需要在 Eloquent 模型中借助对 table 属性的定义，来指明要进行数据库交互的数据库表名称，在用户模型中，我们对应要交互的数据库表为 users，因此定义的代码如下：

    protected $table = 'users';

在使用 Laravel 进行项目开发时，我们需要考虑到，当一些不怀好意的用户将类似 is_admin 这样的字段也嵌入到表单中进行提交时，会有怎样的后果？其后果是用户能够将自己指定为管理员，并进行一些只有管理员才能执行的操作，如删除用户，删除帖子等，这即是我们常说的『批量赋值』的错误，后面我将在后面章节「进行微博模型构建」时，为你演示「批量赋值」的报错。为了提高应用的安全性，Laravel 在用户模型中默认为我们添加了 fillable 在过滤用户提交的字段，只有包含在该属性中的字段才能够被正常更新：

```php
protected $fillable = [
    'name', 'email', 'password',
];
```

最后，当我们需要对用户密码或其它敏感信息在用户实例通过数组或 JSON 显示时进行隐藏，则可使用 hidden 属性：

```php
protected $hidden = [
    'password', 'remember_token',
];
```

2、使用 App\Models 命名空间。Laravel 为我们默认创建的模型文件放置在 app 文件夹下，为了让新手能够更好理解 MVC 模式的开发流程，本教程中将统一使用 app/Models 文件夹来放置所有的模型文件。现在让我们先来创建一个 app/Models 文件夹，并将 User.php 文件放置到其中。在执行完这一步的操作之后，我们还需要执行下面这两个操作：1）修改 User.php 文件，更改 namespace 为我们新创建的文件夹路径（app/Models/User.php）；2）编辑器全局搜索 App\User 替换为 App\Models\User，先在 Sublime Text 中可使用快捷键 shift + cmd(ctrl) + f 搜索下总共有几处需要修改；再次使用快捷键 shift + cmd(ctrl) + f 填写要替换的内容，确定无误后点击右下角的 Replace All 按钮，执行全局搜索替换的操作。

```php
<?php

namespace App\Models;
.
.
```

2『 vscode 里没找到只对这个项目文件夹批量改好的办法，因为目前习惯打开的是项目的父文件夹，所以直接也用的 Sublime Text 来修改的。』

3、Article 模型的例子。模型文件可通过多种方式进行创建，下面让我们以文章模型（Article）为例，为你讲解模型文件的创建。一般情况下，如果我们要自己手动创建一个模型文件，最简单的方式是通过 make:model 来创建。需要注意的一点是，模型类名称使用「单数」形式来命名；如果需要在创建模型的同时顺便创建数据库迁移，则可以使用 --migration 或 -m 选项：

```
$ php artisan make:model Models/Article -m
Model created successfully.
Created Migration: 2018_12_12_090551_create_articles_table
```

2『原来创建模型文件命令里可以直接指定文件夹，牢记使用成本能。』

Eloquent 数据模型。正常情况下，一个最小代码的 Eloquent 模型如下所示；Eloquent 表命名约定。在该文件中，Eloquent Article 模型默认情况下会使用类的「下划线命名法」与「复数形式名称」来作为数据表的名称生成规则。如：1）Article 数据模型类对应 articles 表；2）User 数据模型类对应 users 表；3）BlogPost 数据模型类对应 blog_posts 表。因此 Eloquent 将会假设 Article 模型被存储记录在 articles 数据表中。如果你需要指定自己的数据表，则可以通过 table 属性来定义，如：

```php
<?php
class Article extends Model
{
    protected $table = 'my_articles';
}
```

「约定优于配置」（convention over configuration），也称作按约定编程，这是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。如果所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式。Eloquent 数据表命名约定机制即属于「约定优于配置」，数据模型类 Article 按照系统约定对应于 articles 数据表，如果我们因为特殊原因需要使用其他表名称，只需要通过配置 \$table 即可达到预期。「约定优于配置」能极大提高开发效率，并且也更有利于团队协作。Laravel 项目中大量的使用了「约定优于配置」这种设计范式，这也是 Laravel 的另一个可爱之处。

由于我们刚刚创建的文章模型仅作演示用，因此我们无需对这几个文件的更改进行保存，可通过下面命令进行移除：

```
$ git add -A
$ git checkout -f
```

1『上面的命令太有用了，之前竟然不知道。针对只是试验的场景，把刚刚修改的东西直接全加进工作暂存区里，然后清空工作暂存区，这样相当于回到试验之前的场景里去了。』

### 5.5 创建用户对象

创建用户对象。在了解 Eloquent 模型的基本原理之后，接下来让我们尝试使用 Eloquent 模型来创建一个用户对象，并将该用户对象存储到数据库。虽然我们现在还没有用户注册表单，但是通过 Laravel 提供的 Tinker 环境可以让我们完成对用户对象创建。Tinker 是一个 REPL (read-eval-print-loop)，REPL 指的是一个简单的、可交互式的编程环境，通过执行用户输入的命令，并将执行结果直接打印到命令行界面上来完成整个操作。REPL 对于学习一门新的编程语言具有很大的帮助，因为它能立刻对初学者做出的动作进行响应。接下来我们将使用 Tinker 来操作用户对象。首先让我们使用此命令进入 Tinker 环境：

    $ php artisan tinker

如果中途想要退出 Tinker，可使用 ctrl + c 快捷键。通过下面命令我们可以很轻松的创建一个用户对象：

    >>> App\Models\User::create(['name'=> 'Summer', 'email'=>'summer@example.com','password'=>bcrypt('password')])

在以上命令中，我们使用 App\Models\User Eloquent 模型提供的 create 方法，通过传入一个关联数组来新建一个用户对象。在我们对用户的 password 进行赋值时，调用了一个叫 bcrypt 的方法，将 password 的值进行加密。这是因为所有保存到数据库的用户密码在经过加密保存后安全性更高，这样当我们的数据库不幸被黑客脱库时，泄露出去的用户密码也都是有经过加密处理的。在读取用户密码的时候，Laravel 会先对密码进行解密再返回，这块的具体操作逻辑我们不必太担心，因为 Laravel 已为我们做好了一切防范措施。注意：这里我们又多了一种命令行提示符 - >>> ，在接下来的章节里，请记住 >>> 代表着 artisan tinker 命令行环境。

### 5.6 查找用户对象

在前面的章节中我们学过，当使用了 use 对类进行引用之后，便可以对类进行直接调用。为了让接下来的命令可读性更高，我们使用 use 来引用 App\Models\User Eloquent 模型类：

    >>> use App\Models\User

这样我们就可以在后面的操作中直接调用 User 而不是完整的类名 App\Models\User。注意：上面的 use 引用命令只会对当前会话有效，如果中途退出了 Tinker 的话，需要重新再执行一次上面的命令，才能继续使用 User 类名缩写。使用 Eloquent 模型，能让我们更加轻松的与数据库进行交互。当我们要查找一个 id 为 1 的用户时，可以使用下面这种方法：

    >>> User::find(1)

当你传给 find 方法的 id 不存在时，Tinker 将会返回 null：

```
>>> User::find(5)
=> null
```

如果你想在查询用户不存在时触发报错的话，可使用 findOrFail：

```
>>> User::findOrFail(5)
Illuminate\Database\Eloquent\ModelNotFoundException with message 'No query results for model [App\Models\User] 5'
```

如果要查找用户表中的首个用户，可以使用 first 方法：

    >>> User::first()

我们还可以用 all 方法取出所有的用户数据：

    >>> User::all()

### 5.7 更新用户对象

1、更新用户对象。在用户创建成功之后，我们还可以对用户信息进行更新。有两种方式可以完成用户的更新操作：第一种是通过给用户对象属性进行赋值，赋值成功后再调用 save 方法进行保存更新；第二种则是直接调用 update 方法进行更新。一般较为常用的是第二种更新方式。让我们以刚刚新建的用户对象为例，对用户名进行更新。首先，让我们将用户对象从数据库中取出，并赋值给 user 变量。

    >>> $user = User::first()

2、通过 save 方法更新。让我们使用属性赋值更新的方法对用户名进行更新，将其名字更改为 Monkey：

    >>> $user->name = 'Monkey'

这时，新的用户名已赋值成功，但是尚未保存到数据库，因此查看用户信息时我们能够看到，用户名显示的还是之前的 Summer。

```
>>> User::first()
=> App\Models\User {#2906
     id: 1,
     name: "Summer",
     email: "summer@example.com",
     email_verified_at: null,
     created_at: "2018-12-12 09:09:53",
     updated_at: "2018-12-12 09:09:53",
   }
```

让我们来调用 save 方法对用户信息进行保存。

    >>> $user->save()

这时再次对用户信息进行查询，我们能看到用户名已成功更改。

```
>>> User::first()
=> App\Models\User {#2909
     id: 1,
     name: "Monkey",
     email: "summer@example.com",
     email_verified_at: null,
     created_at: "2018-12-12 09:09:53",
     updated_at: "2018-12-12 09:21:27",
   }
```

3、通过 update 方法更新。下面让我们再来使用 update 方法将用户名更改回 Summer：

    >>> $user->update(['name'=>'Summer'])

再次查询用户信息，可看到改动成功。

```
>>> User::first()
=> App\Models\User {#2903
     id: 1,
     name: "Summer",
     email: "summer@example.com",
     email_verified_at: null,
     created_at: "2018-12-12 09:09:53",
     updated_at: "2018-12-12 09:21:53",
   }
```

至此，用户对象已成功存入数据库。Eloquent 除 create，update 之外还提供了很多其它的方法来方便我们跟数据库进行交互，后面的教程中会讲到更多关于 Eloquent 模型的基本使用，你也可以通过查阅相关文档（[快速入门 |《Laravel 6 中文文档 6.x》| Laravel China 社区](https://learnku.com/docs/laravel/6.x/eloquent/5176)）来进行深入学习。

现在让我们将代码切回到主分支中进行合并。

```
$ git checkout master
$ git merge modeling-users
```

## 0601用户注册.md

### 1. 逻辑脉络

本章内容：1）使用 RESTful 来构建用户资源；2）Gravatar 头像的实现；3）通过表单与控制器协同处理数据；4）验证表单提交的数据，验证失败给出错误提示；5）利用 Composer 安装扩展包（中文错误提示）；6）使用闪存来展示提醒信息；7）在 Heroku 上使用数据库。

### 2. 摘录及评论

### 6.1 章节说明

在我们成功为用户创建完模型之后，接下来就得开始着手用户注册功能的构建了。本章我们将为注册页面添加一个注册表单，允许用户在表单上填写个人信息并提交注册，提交之后用户数据将转由控制器进行处理。在控制器中首先会对用户提交的数据进行验证，验证通过后才能存入数据库。在用户注册成功之后，我们还需要提供一个个人页面来展示用户的基本信息。

### 6.2 显示用户的信息

1、用户资源。我们之前已使用 Tinker 成功创建了一个用户对象。运行下面命令使用 Tinker 来查询用户的信息，确保该用户对象在数据库中确实存在；从数据库中获取第一号用户的个人信息；通过 Tinker 返回的信息可以看到，id 为 1，用户名为 Summer 的用户信息被成功返回。接下来让我们开始着手构建用户个人页面，并在此页面上对用户信息进行显示。

Laravel 遵从 RESTful 架构的设计原则，将数据看做一个资源，由 URI 来指定资源。对资源进行的获取、创建、修改和删除操作，分别对应 HTTP 协议提供的 GET、POST、PATCH 和 DELETE 方法。当我们要查看一个 id 为 1 的用户时，需要向 /users/1 地址发送一个 GET 请求，当 Laravel 的路由接收到该请求时，默认会把该请求传给控制器的 show 方法进行处理。Laravel 为我们提供了 resource 方法来定义用户资源路由（routes/web.php）。

1『数据库里的表单抽象为一个资源（resource）。』

新增的 resource 方法将遵从 RESTful 架构为用户资源生成路由。该方法接收两个参数，第一个参数为资源名称，第二个参数为控制器名称。

    Route::resource('users', 'UsersController');

上面代码将等同于：

```php
Route::get('/users', 'UsersController@index')->name('users.index');
Route::get('/users/create', 'UsersController@create')->name('users.create');
Route::get('/users/{user}', 'UsersController@show')->name('users.show');
Route::post('/users', 'UsersController@store')->name('users.store');
Route::get('/users/{user}/edit', 'UsersController@edit')->name('users.edit');
Route::patch('/users/{user}', 'UsersController@update')->name('users.update');
Route::delete('/users/{user}', 'UsersController@destroy')->name('users.destroy');
```

1『这个打包真心很赞，可以借鉴来用。开发数据流的时候记得用上。（2020-04-25）』

可以看到使用 resource 方法让我们少写了很多代码，且严格按照了 RESTful 架构对路由进行设计。生成的资源路由列表信息如下所示：HTTP 请求——URL——动作——作用。

1）GET——/users——UsersController@index——显示所有用户列表的页面。

2）GET——/users/{user}——UsersController@show——显示用户个人信息的页面。

3）GET——/users/create——UsersController@create——创建用户的页面。

4）POST——/users——UsersController@store——创建用户。

5）GET——/users/{user}/edit——UsersController@edit——编辑用户个人资料的页面。

6）PATCH——/users/{user}——UsersController@update——更新用户。

7）DELETE——/users/{user}——UsersController@destroy——删除用户。

这时我们访问 http://weibo.test/users/1 页面，会出现如下页面。这是因为该路由请求由 UsersController 里面的 show 方法来处理，但现在该方法还不存在，因此会导致报错；红框里翻译过来就是：在 UsersController 控制器里找不到 show 方法。接下来我们定义此方法（app/Http/Controllers/UsersController.php）：

```php
public function show(User $user)
{
    return view('users.show', compact('user'));
}
```

Laravel 会自动解析定义在控制器方法（变量名匹配路由片段）中的 Eloquent 模型类型声明。在上面代码中，由于 show() 方法传参时声明了类型 —— Eloquent 模型 User，对应的变量名 \$user 会匹配路由片段中的 {user}，这样，Laravel 会自动注入与请求 URI 中传入的 ID 对应的用户模型实例。此功能称为 「隐性路由模型绑定」，是「约定优于配置」设计范式的体现，同时满足以下两种情况，此功能即会自动启用：1）路由声明时必须使用 Eloquent 模型的单数小写格式来作为路由片段参数，User 对应 {user}：

```php
Route::get('/users/{user}', 'UsersController@show')->name('users.show');
```

在使用资源路由 Route::resource('users', 'UsersController'); 时默认已经包含了上面的声明。2）控制器方法传参中必须包含对应的 Eloquent 模型类型声明，并且是有序的：

```php
public function show(User $user)
{
    return view('users.show', compact('user'));
}
```

当请求 http://weibo.test/users/1 并且满足以上两个条件时，Laravel 将会自动查找 ID 为 1 的用户并赋值到变量 \$user 中，如果数据库中找不到对应的模型实例，会自动生成 HTTP 404 响应。

```php
return view('users.show', compact('user'));
```

我们将用户对象 \$user 通过 compact 方法转化为一个关联数组，并作为第二个参数传递给 view 方法，将数据与视图进行绑定。show 方法添加完成之后，我们便能在视图中使用 user 变量来访问通过 view 方法传递给视图的用户数据。由于我们还没有创建用户个人页面，因此这时访问用户页面时会出现如下报错。

    View [users.show] not found.

3『

上面是控制器文件传数据到前端视图层的关键点了。试验后发现，这个数据在 HTML 内是可以直接读取出来的，比如：

```html
<div>
    {{ $user }}
</div
```

但在 JS 脚本里获取不了，以后留意这方面的解决办法。（2020-04-25）

在做数据流一体化开发的时候还了解到一种传递方式：

```php
return view('importresult', ['model' => $collection[0]]);

// 视图层那边获取
<script type="text/javascript">
    window.calculate_model = "{!!addslashes(json_encode($model))!!}";
    console.log(JSON.parse(window.calculate_model));
</script>
```

经检验，作者提供的传数据方式只适用于路由那边传递模型文件里的数据到视图层。

』

下面让我们来新建一个用户个人页面（resources/views/users/show.blade.php）。

```js
@extends('layouts.default')
@section('title', $user->name)

@section('content')
{{ $user->name }} - {{ $user->email }}
@stop
```

由于我们使用了 view('users.show', compact('user')) 将用户数据与视图进行绑定，因此在视图中可以直接使用 \$user 来访问用户实例。这时候我们再访问用户个人页面，便能够看到基本的数据展示。

2、Gravatar 头像和侧边栏。现在，我们要为用户的个人页面添加头像显示的功能。接下来的项目开发将使用 Gravatar 来为用户提供个人头像支持。Gravatar 为「全球通用头像」，当你在 Gravatar 的服务器上放置了自己的头像后，可通过将自己的 Gravatar 登录邮箱进行 MD5 转码，并与 Gravatar 的 URL 进行拼接来获取到自己的 Gravatar 头像。接下来让我们在用户模型中定义一个 gravatar 方法，用来生成用户的头像（app/Models/User.php）。

```php
public function gravatar($size = '100')
{
    $hash = md5(strtolower(trim($this->attributes['email'])));
    return "http://www.gravatar.com/avatar/$hash?s=$size";
}  
```

该方法主要做了以下几个操作：1）为 gravatar 方法传递的参数 size 指定了默认值 100；2）通过 \$this->attributes['email'] 获取到用户的邮箱；3）使用 trim 方法剔除邮箱的前后空白内容；4）用 strtolower 方法将邮箱转换为小写；5）将小写的邮箱使用 md5 方法进行转码；6）将转码后的邮箱与链接、尺寸拼接成完整的 URL 并返回；

定义好 gravatar 方法之后，我们便可以在视图中通过以下方式进行调用：1）使用默认尺寸来获取头像：

```php
$user->gravatar();
```

2）为 gravatar 指定尺寸大小来获取头像：

```php
$user->gravatar('140');
```

接下来让我们来构建一个全局通用的局部视图，用于展示用户的头像和用户名等基本信息（resources/views/shared/_user_info.blade.php）。

```html
<a href="{{ route('users.show', $user->id) }}">
  <img src="{{ $user->gravatar('140') }}" alt="{{ $user->name }}" class="gravatar"/>
</a>
<h1>{{ $user->name }}</h1>
```

该视图将被嵌套在用户个人页面中进行使用，因此我们需要对用户个人页面进行更改，加入我们新创建的用户信息局部视图（resources/views/users/show.blade.php）。

```js
@extends('layouts.default')
@section('title', $user->name)

@section('content')
<div class="row">
  <div class="offset-md-2 col-md-8">
    <div class="col-md-12">
      <div class="offset-md-2 col-md-8">
        <section class="user_info">
          @include('shared._user_info', ['user' => $user])
        </section>
      </div>
    </div>
  </div>
</div>
@stop
```

我们可以通过给 @include 方法传参，将用户数据以关联数组的形式传送到 \_user\_info 局部视图上。

```js
@include('shared._user_info', ['user' => $user])
```

接下来对样式再进行优化（resources/sass/app.scss）。提醒：请注意运行 npm run watch-poll。现在再次访问个人页面，便可以看到用户头像了。

1『小插曲，发现 git log 里之前的 commit 中用户名全是「dalong3」，通过命令「git config --global user.name "dalong"」修改下，这样只能保证之后提交的 commit 是新的用户名，要修改以前的 commit 也是可以的，目前没这个需求。』

### 6.3 注册表单

1、注册表单。在我们接下来要进行的用户注册功能开发中，第一个步骤即是构建注册表单。首先我们需要把之前在 Tinker 中创建的所有用户数据进行删除，将数据库重置。重置的方法很简单，只需借助 migrate:refresh 命令，即可完成数据库的重置操作。

    $ php artisan migrate:refresh

refresh 的作用是重置数据库并重新运行所有迁移。

1『 laravel 里重置数据路表单的一个简单方法。』

2、表单构建。现在让我们更改之前已创建的用户注册页面，加入表单元素（resources/views/users/create.blade.php）。Laravel 提供了全局辅助函数 old 来帮助我们在 Blade 模板中显示旧输入数据。这样当我们信息填写错误，页面进行重定向访问时，输入框将自动填写上最后一次输入过的数据。

```html
<div class="form-group">
  <label for="name">名称：</label>
  <input type="text" name="name" class="form-control" value="{{ old('name') }}">
</div>
```

### 6.4 用户数据验证

1、用户数据验证。如果你现在填写注册表单并进行提交，则会出现报错，因为表单还不能真正使用。我们还需要在用户控制器中添加一个用于处理表单数据提交后的 store 方法，用于处理用户创建的相关逻辑（app/Http/Controllers/UsersController.php）。接下来让我来讲解下新增的 store 方法。

```php
public function store(Request $request)
{
    $this->validate($request, [
        'name' => 'required|unique:users|max:50',
        'email' => 'required|email|unique:users|max:255',
        'password' => 'required|confirmed|min:6'
    ]);
    return;
}
```

在实际开发中，我们经常需要对用户输入的数据进行验证，在验证成功后再将数据存入数据库。在 Laravel 开发中，提供了多种数据验证方式，在本教程中，我们使用其中一种对新手较为友好的验证方式 —— validator 来进行讲解。validator 由 App\Http\Controllers\Controller 类中的 ValidatesRequests 进行定义，因此我们可以在所有的控制器中使用 validate 方法来进行数据验证。validate 方法接收两个参数，第一个参数为用户的输入数据，第二个参数为该输入数据的验证规则。

1、验证规则。下面来看下我们在验证用户数据时，都用到了哪几种验证规则。

1）存在性验证。在用户填写表单的时候，我们会要求用户必须填写上自己的用户名，当用户名为空时将注册失败。这时我们可以使用 required 来验证用户名是否为空。

```php
'name' => 'required'
```

2）唯一性验证。一般情况下，我们还需要验证用户使用的用户名是否已被它人使用，这时我们可以使用唯一性验证，这里是针对于数据表 users 做验证。

```php
'name' => 'unique:users'
```

3）长度验证。我们还可以使用 min 和 max 来限制用户名所填写的最小长度和最大长度。如果需要同时验证多个条件时，则可使用 | 对验证规则进行分割。

```php
'name' => 'min:3|max:50'
```

4）格式验证。在其它的一些应用上，如果要对用户邮箱进行验证，则可能需要你写一段非常冗长且不易理解的 正则表达式 来匹配邮箱格式。但在 Laravel 中，我们只需简单的使用 email 便能够完成邮箱格式的验证。

```php
'email' => 'email'
```

5）唯一性验证。一般情况下，我们还需要验证用户使用的注册邮箱是否已被它人使用，这时我们可以使用唯一性验证，这里是针对于数据表 users 做验证。但这种验证方式还是不够严谨，所以我们需要在一开始创建「用户数据表」时便设置邮箱字段的唯一属性。这个 Laravel 在默认给我们生成的用户表迁移文件中便已经默认设定好了。

```php
'email' => 'unique:users'
```

6） 密码匹配验证。如果我们需要确保用户在输入密码时，保证两次输入的密码一致。这时候则可以使用 confirmed 来进行密码匹配验证。

```php
'password' => 'confirmed'
```

3、表单提交。在我们为注册表单添加上验证规则之后，尝试点击注册会发现「页面过期」的报错异常；出现该报错的原因是，在我们使用 POST 方法提交表单时，Laravel 为了安全考虑，会让我们提供一个 token（令牌）来防止我们的应用受到 CSRF（跨站请求伪造）的攻击。修复该异常的方法很简单，我们只需要在表单元素中添加 Blade 模板为我们提供的 csrf_field 方法即可。该方法在 Blade 模板中调用如下：

    {{ csrf_field() }}

上面这段代码转换为 HTML 如下所示：

```html
<input type="hidden" name="_token" value="fhcxqT67dNowMoWsAHGGPJOAWJn8x5R5ctSwZrAq">
```

由于输入框为 hidden 类型，因此该 input 元素在页面上是不可见的。现在让我们为注册表单添加 csrf_field 方法（resources/views/users/create.blade.php）。

```php
@extends('layouts.default')
@section('title', '注册')

@section('content')
<div class="offset-md-2 col-md-8">
  <div class="card ">
    <div class="card-header">
      <h5>注册</h5>
    </div>
    <div class="card-body">
      <form method="POST" action="{{ route('users.store') }}">
        {{ csrf_field() }}

        <div class="form-group">
          <label for="name">名称：</label>
          <input type="text" name="name" class="form-control" value="{{ old('name') }}">
        </div>

        <div class="form-group">
          <label for="email">邮箱：</label>
          <input type="text" name="email" class="form-control" value="{{ old('email') }}">
        </div>

        <div class="form-group">
          <label for="password">密码：</label>
          <input type="password" name="password" class="form-control" value="{{ old('password') }}">
        </div>

        <div class="form-group">
          <label for="password_confirmation">确认密码：</label>
          <input type="password" name="password_confirmation" class="form-control" value="{{ old('password_confirmation') }}">
        </div>

        <button type="submit" class="btn btn-primary">注册</button>
      </form>
    </div>
  </div>
</div>
@stop
```

这时候如果你再次填写注册表单并进行提交，你会发现表单依旧处于不可用状态，这是因为：1）在表单信息验证失败时，在页面上没有给出错误提示；2）在表单信息验证通过后，页面没有重定向跳转到其它页面，并给出注册成功的提示。下面让我们针对上面两种情况继续完善注册表单。

### 6.5 注册失败错误消息

1、显示表单错误信息。目前是我们尝试填写完表单，如果表单信息填写有误并提交，页面不会展示报错信息。Laravel 默认给我们提供了一种非常好的展示错误信息的方法，现在让我们来为应用加上提交失败时的错误信息展示（resources/views/shared/_errors.blade.php）。

```html
@if (count($errors) > 0)
  <div class="alert alert-danger">
      <ul>
          @foreach($errors->all() as $error)
          <li>{{ $error }}</li>
          @endforeach
      </ul>
  </div>
@endif
```

通过上面代码我们可以看到 Blade 模板还为我们提供了一些其它的便利方法，如：

```html
@if (count($errors) > 0)
    {{ count($errors) }}
@endif
```

在解析成 PHP 代码后为：

```php
if (count($errors) > 0) {
    {{ count($errors) }}
}
```

Blade 支持所有的循环语句和条件判断语句，如 @if, @elseif, @else, @for, @foreach, @while 等等，应用在 Blade 中的表达式都需要以 @ 开头。Laravel 默认会将所有的验证错误信息进行闪存。当检测到错误存在时，Laravel 会自动将这些错误消息绑定到视图上，因此我们可以在所有的视图上使用 errors 变量来显示错误信息。需要注意的是，在我们对 errors 进行使用时，要先使用 count(\$errors) 检查其值是否为空。定义好错误消息局部视图，便可以在用户的注册表单中对该视图进行引用（resources/views/users/create.blade.php）。这时，如果再次尝试填写一些验证无法通过的信息并进行表单提交，便能够在页面上看到错误消息提示。

2、添加语言包。通过页面显示我们可以看到，这时的报错信息显示的还是英文。Laravel 为消息验证的多语言提供了一种非常简便的方法进行支持。我们可以通过添加一个如 resources/lang/xx/validation.php 语言包，并在语言包的 custom 数组中对翻译语言进行设定。如：

```php
'custom' => [
    'email' => [
        'required' => '邮箱地址不能为空！',
    ],
],
```

这是非常通用的功能，所以在 GitHub 上有人专门为此写了一个扩展包 - overtrue/laravel-lang 来对 Laravel 提供默认提示信息添加多语言版本翻译。接下来让我们使用 Composer 来安装 laravel-lang。

    $ composer require "overtrue/laravel-lang:~3.0"

安装成功后，在 config/app.php 文件中将以下这一行：

Illuminate\Translation\TranslationServiceProvider::class,

替换为：

Overtrue\LaravelLang\TranslationServiceProvider::class,

最后，我们还需要将项目语言设置为中文（config/app.php）。现在再次提交验证不通过的信息，能看到错误提示已变成中文。如果你需要对属性或者验证消息改写，直接在 resources/lang/xx/validation.php 中编写你需要定制的部分即可，更多使用方式请参考 overtrue/laravel-lang 中文使用说明（[laravel-lang](https://github.com/overtrue/laravel-lang/blob/master/README_CN.md)）。

### 6.6 注册成功

1、注册成功。目前用户注册失败的逻辑已经处理完成，让我们接着完善用户注册成功后的处理逻辑。当用户注册完成，且表单信息验证通过后，我们需要做以下两个操作：1）将用户提交的信息存储到数据库，并重定向到其个人页面；2）在网页顶部位置显示注册成功的提示信息。让我们针对这两个操作来写具体的逻辑实现代码。

1『如何将用户提交的信息存储到数据库，很想弄清楚的知识点。（2020-03-12）』

2、保存用户并重定向（app/Http/Controllers/UsersController.php）。

```php
public function store(Request $request)
{
    $this->validate($request, [
        'name' => 'required|unique:users|max:50',
        'email' => 'required|email|unique:users|max:255',
        'password' => 'required|confirmed|min:6'
    ]);

    $user = User::create([
        'name' => $request->name,
        'email' => $request->email,
        'password' => bcrypt($request->password),
    ]);

    return redirect()->route('users.show', [$user]);
}
```

store 方法接受一个 Illuminate\Http\Request 实例参数，我们可以使用该参数来获得用户的所有输入数据。如果我们的表单中包含一个 name 字段，则可以借助 Request 使用下面的这种方式来获取 name 的值：

```php
$name = $request->name;
```

如果需要获取用户输入的所有数据，可使用：

```php
$data = $request->all();
```

用户模型 User::create() 创建成功后会返回一个用户对象，并包含新注册用户的所有信息。我们将新注册用户的所有信息赋值给变量 \$user，并通过路由跳转来进行数据绑定。

```php
redirect()->route('users.show', [$user]);
```

注意这里是一个「约定优于配置」的体现，此时 \$user 是 User 模型对象的实例。route() 方法会自动获取 Model 的主键，也就是数据表 users 的主键 id，以上代码等同于：

```php
redirect()->route('users.show', [$user->id]);
```

3、消息提示。现在验证通过的注册用户已经能够成功创建，并进行重定向跳转了。接下来我们要做的就是，用户注册成功后，在页面顶部位置显示注册成功的提示信息（app/Http/Controllers/UsersController.php）。

由于 HTTP 协议是无状态的，所以 Laravel 提供了一种用于临时保存用户数据的方法 —— 会话（Session），并附带支持多种会话后端驱动，可通过统一的 API 进行使用。我们可以使用 session() 方法来访问会话实例。而当我们想存入一条缓存的数据，让它只在下一次的请求内有效时，则可以使用 flash 方法。flash 方法接收两个参数，第一个为会话的键，第二个为会话的值，我们可以通过下面这行代码的为会话赋值。

```php
session()->flash('success', '欢迎，您将在这里开启一段新的旅程~');
```

之后我们可以使用 session()->get('success') 通过键名来取出对应会话中的数据，取出的结果为「欢迎，您将在这里开启一段新的旅程~」。接下来的消息提示我们会用会话进行闪存，并分别为其设定好指定的键。danger, warning, success, info 这四个键名在 Bootstrap 分别具有不同样式展现效果，因此后面我们将使用这几个键名作为消息提示的专有设定。

现在让我们加入消息提醒视图，让会话消息在视图上进行展示（resources/views/shared/_messages.blade.php）。session()->has(\$msg) 可用于判断会话中 \$msg 键对应的值是否为空，若为空则在页面上不进行显示。最后，我们通过 session()->get(\$msg) 来取出对应的值并在页面上进行显示。

现在，让我们在全局通用视图中加入消息提醒视图（resources/views/layouts/default.blade.php）。当我们再次注册一个验证通过的用户时，能够看到消息提醒在页面上成功展示。

1『注册了 2 个用户，刷新 mysql 里的数据库后发现已经更新进去了。』

### 6.7 在 Heroku 上使用 PostgreSQL

1『因目前没有在虚拟机上开发的需求，该节暂时不看。』

