# 2019018Python编程R02

## 记忆时间


## 15 生成数据

### 1. 逻辑脉络

如何用 matplotlib 来作图；如何实现产生随机数；如何使用 pygal 来创建直方图（矢量图）。

### 2. 摘录及评论

在本章中，你学习了：如何生成数据集以及如何对其进行可视化；如何使用 matplotlib 创建简单的图表，以及如何使用散点图来探索随机漫步过程；如何使用 Pygal 来创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。

使用代码生成数据集是一种有趣而强大的方式，可用于模拟和探索现实世界的各种情形。完成后面的数据可视化项目时，请注意可使用代码模拟哪些情形。请研究新闻媒体中的可视化，看看其中是否有图表是以你在这些项目中学到的类似方式生成的。

数据可视化指的是通过可视化表示来探索数据，它与数据挖掘紧密相关，而数据挖掘指的是使用代码来探索数据集的规律和关联。数据集可以是用一行代码就能表示的小型数字列表，也可以是数以吉字节的数据。

漂亮地呈现数据关乎的并非仅仅是漂亮的图片。以引人注目的简洁方式呈现数据，让观看者能够明白其含义，发现数据集中原本未意识到的规律和意义。

所幸即便没有超级计算机，也能够可视化复杂的数据。鉴于 Python 的高效性，使用它在笔记本电脑上就能快速地探索由数百万个数据点组成的数据集。数据点并非必须是数字，利用本书前半部分介绍的基本知识，也可以对非数字数据进行分析。

在基因研究、天气研究、政治经济分析等众多领域，大家都使用 Python 来完成数据密集型工作。数据科学家使用 Python 编写了一系列令人印象深刻的可视化和分析工具，其中很多也可供你使用。最流行的工具之一是 matplotlib，它是一个数学绘图库，我们将使用它来制作简单的图表，如折线图和散点图。然后，我们将基于随机漫步概念生成一个更有趣的数据集——根据一系列随机决策生成的图表。

我们还将使用 Pygal 包，它专注于生成适合在数字设备上显示的图表。通过使用 Pygal，可在用户与图表交互时突出元素以及调整其大小，还可轻松地调整整个图表的尺寸，使其适合在微型智能手表或巨型显示器上显示。我们将使用 Pygal 以各种方式探索掷骰子的结果。

1『

WARNING: The scripts f2py, f2py3 and f2py3.7 are installed in '/Users/Daglas/Library/Python/3.7/bin' which is not on PATH.

Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.

』

安装必要的包后，对安装进行测试。为此，首先使用命令 python 或 python3 启动一个终端会话，再尝试导入 matplotlib：

```
$ python3

>>> import matplotlib

>>>
```

如果没有出现任何错误消息，就说明你的系统安装了 matplotlib。

要查看使用 matplotlib 可制作的各种图表，请访问 http://matplotlib.org/ 的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。

3『[Matplotlib: Python plotting — Matplotlib 3.1.1 documentation](https://matplotlib.org/)』

在本节中，我们将使用 Python 来生成随机漫步数据，再使用 matplotlib 以引人瞩目的方式将这些数据呈现出来。随机漫步是这样行走得到的路径：每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。你可以这样认为，随机漫步就是蚂蚁在晕头转向的情况下，每次都沿随机的方向前行所经过的路径。

在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上移动。水滴中的分子运动是随机的，因此花粉在水面上的运动路径犹如随机漫步。我们稍后将编写的代码模拟了现实世界的很多情形。

我们首先导入了模块 pyplot 和 RandomWalk 类，然后创建了一个 RandomWalk 实例，并将其存储到 rw 中（见❶），再调用 fill_walk() 。在 ❷ 处，我们将随机漫步包含的 x 和 y 值传递给 scatter() ，并选择了合适的点尺寸。图 15-8 显示了包含 5000 个点的随机漫步图（本节的示意图未包含 matplotlib 查看器部分，但你运行 rw_visual.py 时，依然会看到）。

这些代码模拟一次随机漫步，在 matplotlib 查看器中显示结果，再在不关闭查看器的情况下暂停。如果你关闭查看器，程序将询问你是否要再模拟一次随机漫步。如果你输入 y ，可模拟多次随机漫步：这些随机漫步都在起点附近进行，大多沿特定方向偏离起点，漫步点分布不均匀等。要结束程序，请输入 n 。

1『这里的这个 while 语句，提供了一个实现控制 matplotlib 查看器的实现办法。』

在 ❶ 处，我们使用了 range() 生成了一个数字列表，其中包含的数字个数与漫步包含的点数相同。接下来，我们将这个列表存储在 point_numbers 中，以便后面使用它来设置每个漫步点的颜色。我们将参数 c 设置为 point_numbers ，指定使用颜色映射 Blues ，并传递实参 edgecolor=none 以删除每个点周围的轮廓。最终的随机漫步图从浅蓝色渐变为深蓝色，如图 15-9 所示。

1『这里面涉及到方法希望以后有机会可以弄明白。』

为修改坐标轴，使用了函数 plt.axes() （见❶）来将每条坐标轴的可见性都设置为 False 。随着你越来越多地进行数据可视化，经常会看到这种串接方法的方式。

函数 figure() 用于指定图表的宽度、高度、分辨率和背景色。你需要给形参 figsize 指定一个元组，向 matplotlib 指出绘图窗口的尺寸，单位为英寸。

Python 假定屏幕分辨率为 80 像素/英寸，如果上述代码指定的图表尺寸不合适，可根据需要调整其中的数字。如果你知道自己的系统的分辨率，可使用形参 dpi 向 figure() 传递该分辨率，以有效地利用可用的屏幕空间，如下所示：

	plt.figure(dpi=128, figsize=(10, 6))

在本节中，我们将使用 Python 可视化包 Pygal 来生成可缩放的矢量图形文件。对于需要在尺寸不同的屏幕上显示的图表，这很有用，因为它们将自动缩放，以适合观看者的屏幕。如果你打算以在线方式使用图表，请考虑使用 Pygal 来生成它们，这样它们在任何设备上显示时都会很美观。

在这个项目中，我们将对掷骰子的结果进行分析。掷 6 面的常规骰子时，可能出现的结果为 1~6 点，且出现每种结果的可能性相同。然而，如果同时掷两个骰子，某些点数出现的可能性将比其他点数大。为确定哪些点数出现的可能性最大，我们将生成一个表示掷骰子结果的数据集，并根据结果绘制出一个图形。

在数学领域，常常利用掷骰子来解释各种数据分析，但它在赌场和其他博弈场景中也得到了实际应用，在游戏《大富翁》以及众多角色扮演游戏中亦如此。

要了解使用 Pygal 可创建什么样的图表，请查看图表类型画廊：访问 http://www.pygal.org/ ，单击 Documentation，再单击 Chart types。每个示例都包含源代码，让你知道这些图表是如何生成的。

1『[Pygal — pygal 2.0.0 documentation](http://www.pygal.org/en/stable/)』

1『

创建 Die 类时总是报错：unindent does not match any outer indentation level

怎么也找不出来 die.py 里哪错了，最后重新敲了一遍代码就解决了。

』

为创建条形图，我们创建了一个 pygal.Bar() 实例，并将其存储在 hist 中（见❶）。接下来，我们设置 hist 的属性 title （用于标示直方图的字符串），将掷 D6 骰子的可能结果用作 x 轴的标签（见❷），并给每个轴都添加了标题。在 ❸ 处，我们使用 add() 将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表，其中包含将出现在图表中的值）。最后，我们将这个图表渲染为一个 SVG 文件，这种文件的扩展名必须为 .svg。要查看生成的直方图，最简单的方式是使用 Web 浏览器。为此，在任何 Web 浏览器中新建一个标签页，再在其中打开文件 die_visual.svg（它位于 die_visual.py 所在的文件夹中）。

注意，Pygal 让这个图表具有交互性：如果你将鼠标指向该图表中的任何条形，将看到与之相关联的数据。在同一个图表中绘制多个数据集时，这项功能显得特别有用。

## 16 下载数据

### 1. 逻辑脉络

csv 和 json 文件的概念，以及如何使用它们；加深学习使用 pygal 库。

### 2. 摘录及评论

在本章中，你学习了：如何使用网上的数据集；如何处理 CSV 和 JSON 文件，以及如何提取你感兴趣的数据；如何使用 matplotlib 来处理以往的天气数据，包括如何使用模块 datetime，以及如何在同一个图表中绘制多个数据系列；如何使用 Pygal 绘制呈现各国数据的世界地图，以及如何设置 Pygal 地图和图表的样式。

有了使用 CSV 和 JSON 文件的经验后，你将能够处理几乎任何要分析的数据。大多数在线数据集都可以以这两种格式中的一种或两种下载。学习使用这两种格式为学习使用其他格式的数据做好了准备。

在本章中，你将从网上下载数据，并对这些数据进行可视化。网上的数据多得难以置信，且大多未经过仔细检查。如果能够对这些数据进行分析，你就能发现别人没有发现的规律和关联。

我们将访问并可视化以两种常见格式存储的数据：CSV 和 JSON。我们将使用 Python 模块 csv 来处理以 CSV（逗号分隔的值）格式存储的天气数据，找出两个不同地区在一段时间内的最高温度和最低温度。然后，我们将使用 matplotlib 根据下载的数据创建一个图表，展示两个不同地区的气温变化：阿拉斯加锡特卡和加利福尼亚死亡谷。在本章的后面，我们将使用模块 json 来访问以 JSON 格式存储的人口数据，并使用 Pygal 绘制一幅按国别划分的人口地图。

阅读本章后，你将能够处理各种类型和格式的数据集，并对如何创建复杂的图表有更深入的认识。要处理各种真实世界的数据集，必须能够访问并可视化各种类型和格式的在线数据。

要在文本文件中存储数据，最简单的方式是将数据作为一系列以逗号分隔的值 （CSV）写入文件。这样的文件称为 CSV 文件。例如，下面是一行 CSV 格式的天气数据：

	2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195

这是阿拉斯加锡特卡 2014 年 1 月 5 日的天气数据，其中包含当天的最高气温和最低气温，还有众多其他数据。CSV 文件对人来说阅读起来比较麻烦，但程序可轻松地提取并处理其中的值，这有助于加快数据分析过程。

导入模块 csv 后，我们将要使用的文件的名称存储在 filename 中。接下来，我们打开这个文件，并将结果文件对象存储在 f 中（见❶）。然后，我们调用 csv.reader() ，并将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的阅读器（reader ）对象（见❷）。我们将这个阅读器对象存储在 reader 中。

模块 csv 包含函数 next() ，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。在前面的代码中，我们只调用了 next() 一次，因此得到的是文件的第一行，其中包含文件头（见❸）。我们将返回的数据存储在 header_row 中。正如你看到的，header_row 包含与天气相关的文件头，指出了每行都包含哪些数据：

reader 处理文件中以逗号分隔的第一行数据，并将每项数据都作为一个元素存储在列表中。文件头 AKDT 表示阿拉斯加时间（Alaska Daylight Time），其位置表明每行的第一个值都是日期或时间。文件头 Max TemperatureF 指出每行的第二个值都是当天的最高华氏温度。可通过阅读其他的文件头来确定文件包含的信息类型。

注意：文件头的格式并非总是一致的，空格和单位可能出现在奇怪的地方。这在原始数据文件中很常见，但不会带来任何问题。

读取该数据时，获得的是一个字符串，因为我们需要想办法将字符串 '2014-7-1' 转换为一个表示相应日期的对象。为创建一个表示 2014 年 7 月 1 日的对象，可使用模块 datetime 中的方法 strptime() 。我们在终端会话中看看 strptime() 的工作原理：

我们首先导入了模块 datetime 中的 datetime 类，然后调用方法 strptime() ，并将包含所需日期的字符串作为第一个实参。第二个实参告诉 Python 如何设置日期的格式。在这个示例中，'%Y-' 让 Python 将字符串中第一个连字符前面的部分视为四位的年份；'%m-' 让 Python 将第二个连字符前面的部分视为表示月份的数字；而 '%d' 让 Python 将字符串的最后一部分视为月份中的一天（1~31）。方法 strptime() 可接受各种实参，并根据它们来决定如何解读日期。表 16-1 列出了其中一些这样的实参。

	dates, highs = [], []

1『原来同时创建 2 个空列表还能这么操作的。』

我们创建了两个空列表，用于存储从文件中提取的日期和最高气温（见❶）。然后，我们将包含日期信息的数据（row[0] ）转换为 datetime 对象（见❷），并将其附加到列表 dates 末尾。在 ❸ 处，我们将日期和最高气温值传递给 plot() 。在 ❹ 处，我们调用了 fig.autofmt_xdate() 来绘制斜的日期标签，以免它们彼此重叠。图 16-2 显示了改进后的图表。

添加两个数据系列后，我们就可以了解每天的气温范围了。下面来给这个图表做最后的修饰，通过着色来呈现每天的气温范围。为此，我们将使用方法 fill_between() ，它接受一个 x 值系列和两个 y 值系列，并填充两个 y 值系列之间的空间：

❶处的实参alpha 指定颜色的透明度。Alpha 值为 0 表示完全透明，1（默认设置）表示完全不透明。通过将alpha 设置为0.5，可让红色和蓝色折线的颜色看起来更浅。

在 ❷ 处，我们向 fill_between() 传递了一个 x 值系列：列表 dates ，还传递了两个 y 值系列：highs 和 lows 。实参 facecolor 指定了填充区域的颜色，我们还将 alpha 设置成了较小的值 0.1，让填充区域将两个数据系列连接起来的同时不分散观察者的注意力。图 16-5 显示了最高气温和最低气温之间的区域被填充的图表。

我们应该能够使用有关任何地方的天气数据来运行 highs_lows.py 中的代码，但有些气象站会偶尔出现故障，未能收集部分或全部其应该收集的数据。缺失数据可能会引发异常，如果不妥善地处理，还可能导致程序崩溃。

其中好像没有记录 2014 年 2 月 16 日的数据，表示最高温度的字符串为空。为解决这种问题，我们在从 CSV 文件中读取值时执行错误检查代码，对分析数据集时可能出现的异常进行处理，如下所示：

对于每一行，我们都尝试从中提取日期、最高气温和最低气温（见❶）。只要缺失其中一项数据，Python 就会引发 ValueError 异常，而我们可这样处理：打印一条错误消息，指出缺失数据的日期（见❷）。打印错误消息后，循环将接着处理下一行。如果获取特定日期的所有数据时没有发生错误，将运行 else 代码块，并将数据附加到相应列表的末尾（见❸）。鉴于我们绘图时使用的是有关另一个地方的信息，我们修改了标题，在图表中指出了这个地方（见❹）。

使用的很多数据集都可能缺失数据、数据格式不正确或数据本身不正确。对于这样的情形，可使用本书前半部分介绍的工具来处理。在这里，我们使用了一个 try-except-else 代码块来处理数据缺失的问题。在有些情况下，需要使用 continue  来跳过一些数据，或者使用 remove() 或 del 将已提取的数据删除。可采用任何管用的方法，只要能进行精确而有意义的可视化就好。

Open Knowledge Foundation（http://data.okfn.org/ ）提供了大量可以免费使用的数据集，这些数据就来自其中一个数据集。

1『书里的那些 --snip-- 是指省略的意思。』

原始数据的格式常常不统一，因此经常会出现错误。导致上述错误的原因是，Python 不能直接将包含小数点的字符串 '1127437398.85751' 转换为整数（这个小数值可能是人口数据缺失时通过插值得到的）。为消除这种错误，我们先将字符串转换为浮点数，再将浮点数转换为整数：

函数 float() 将字符串转换为小数，而函数 int() 丢弃小数部分，返回一个整数。现在，我们可以打印 2010 年的完整人口数据，不会导致错误了：

每个字符串都成功地转换成了浮点数，再转换为整数。以数字格式存储人口数量值后，就可以使用它们来制作世界人口地图了。

制作地图前，还需要解决数据存在的最后一个问题。Pygal 中的地图制作工具要求数据为特定的格式：用国别码表示国家，以及用数字表示人口数量。处理地理政治数据时，经常需要用到几个标准化国别码集。population_data.json 中包含的是三个字母的国别码，但 Pygal 使用两个字母的国别码。我们需要想办法根据国家名获取两个字母的国别码。

Pygal 使用的国别码存储在模块 i18n （internationalization 的缩写）中。字典 COUNTRIES 包含的键和值分别为两个字母的国别码和国家名。要查看这些国别码，可从模块 i18n 中导入这个字典，并打印其键和值：

导致显示错误消息的原因有两个。首先，并非所有人口数量对应的都是国家，有些人口数量对应的是地区（阿拉伯世界）和经济类群（所有收入水平）。其次，有些统计数据使用了不同的完整国家名（如 Yemen, Rep.，而不是 Yemen）。当前，我们将忽略导致错误的数据，看看根据成功恢复了的数据制作出的地图是什么样的。

有了国别码后，制作世界地图易如反掌。Pygal 提供了图表类型 Worldmap ，可帮助你制作呈现各国数据的世界地图。为演示如何使用 Worldmap ，我们来创建一个突出北美、中美和南美的简单地图：

有几个国家没有相关的数据，我们将其显示为黑色，但对于大多数国家，都根据其人口数量进行了着色。本章后面将处理数据缺失的问题，这里先来修改着色，以更准确地反映各国的人口数量。在当前的地图中，很多国家都是浅色的，只有两个国家是深色的。对大多数国家而言，颜色深浅的差别不足以反映其人口数量的差别。为修复这种问题，我们将根据人口数量将国家分组，再分别给每个组着色。

印度和中国的人口比其他国家多得多，但在当前的地图中，它们的颜色与其他国家差别较小。中国和印度的人口都超过了 10 亿，接下来人口最多的国家是美国，但只有大约 3 亿。下面不将所有国家都作为一个编组，而是根据人口数量分成三组——少于 1000 万的、介于 1000 万和 10 亿之间的以及超过 10 亿的：

为将国家分组，我们创建了三个空字典（见❶）。接下来，遍历 cc_populations ，检查每个国家的人口数量（见❷）。if-elif-else 代码块将每个「国别码-人口数量」对加入到合适的字典（cc_pops_1 、cc_pops_2 或cc_pops_3 ）中。

在 ❸ 处，我们打印这些字典的长度，以获悉每个分组的规模。绘制地图时，我们将全部三个分组都添加到 Worldmap 中（见❹）。如果你现在运行这个程序，首先看到的将是每个分组的规模：

在这个地图中，根据人口将国家分组虽然很有效，但默认的颜色设置很难看。例如，在这里，Pygal 选择了鲜艳的粉色和绿色基色。下面使用 Pygal 样式设置指令来调整颜色。我们也让 Pygal 使用一种基色，但将指定该基色，并让三个分组的颜色差别更大：

Pygal 样式存储在模块 style 中，我们从这个模块中导入了样式 RotateStyle （见❶）。创建这个类的实例时，需要提供一个实参——十六进制的 RGB 颜色（见❷）；Pygal 将根据指定的颜色为每组选择颜色。十六进制格式的 RGB 颜色是一个以井号（#）打头的字符串，后面跟着 6 个字符，其中前两个字符表示红色分量，接下来的两个表示绿色分量，最后两个表示蓝色分量。每个分量的取值范围为 00 （没有相应的颜色）~FF （包含最多的相应颜色）。如果你在线搜索 hex color chooser（十六进制颜色选择器 ），可找到让你能够尝试选择不同的颜色并显示其 RGB 值的工具。这里使用的颜色值（#336699）混合了少量的红色（33）、多一些的绿色（66）和更多一些的蓝色（99），它为 RotateStyle 提供了一种淡蓝色基色。

Pygal 通常默认使用较暗的颜色主题。为方便印刷，我使用 LightColorizedStyle 加亮了地图的颜色。这个类修改整个图表的主题，包括背景色、标签以及各个国家的颜色。要使用这个样式，先导入它：

3『[Welcome - Home - DataHub - Frictionless Data](https://datahub.io/)』

16-6 选择你感兴趣的数据：免费的 JSON 格式数据非常丰富，许多著名的国际组织都在积极分享有价值的数据。例如 OpenKnowledgeInternational (https://okfn.org/）上就有许多有趣的 JSON 数据。你也可以用本节的方法获取它们，开启自己的分析项目。

[Home | Open Knowledge Foundation](https://okfn.org/)

16-8 尝试 Python 数据科学工具：虽然 Python 标准库对数据分析的支持相对有限，但是 Python 具有非常完善的数据科学生态系统，有许多易学易用、高效便捷的第三方开源数据分析工具。除了前面介绍的 matplotlik，还有科学计算工具包 [NumPy — NumPy](https://numpy.org/)、[SciPy.org — SciPy.org](https://www.scipy.org/)、快速数据分析工具 [Python Data Analysis Library — pandas: Python Data Analysis Library](https://pandas.pydata.org/)、机器学习工具 [scikit-learn: machine learning in Python — scikit-learn 0.22 documentation](https://scikit-learn.org/stable/) 以及让深度学习开发更简单的 [Home - Keras Documentation](https://keras.io/)，它支持 Tensorflow、CNTK 和 Theano）。如果感兴趣，可以用 Pandas 直接读取 JSON 文件数据，并进行格式转换、数据聚合、时间序列分析，结合 Scikit-learn 可以对收盘价进行回归分析与预测。

我们首先导入了模块 json ，以便能够正确地加载文件中的数据，然后，我们将数据存储在 pop_data 中（见❶）。函数 json.load() 将数据转换为 Python 能够处理的格式，这里是一个列表。在 ❷ 处，我们遍历 pop_data 中的每个元素。每个元素都是一个字典，包含四个「键-值」对，我们将每个字典依次存储在 pop_dict 中。

## 17 使用 API

### 1. 逻辑脉络

如何自动采集数据并对其可视化处理（学会使用 requests 包的基本操作）。

### 2. 摘录及评论

在本章中，你学习了：如何使用 API 来编写独立的程序，它们自动采集所需的数据并对其进行可视化；使用 GitHub API 来探索 GitHub 上星级最高的 Python 项目，还大致地了解了 Hacker News API；如何使用 requests 包来自动执行 GitHub API 调用，以及如何处理调用的结果。我们还简要地介绍了一些 Pygal 设置，使用它们可进一步定制生成的图表的外观。

在本章中，你将学习如何编写一个独立的程序，并对其获取的数据进行可视化。这个程序将使用 Web 应用编程接口 （API）自动请求网站的特定信息而不是整个网页，再对这些信息进行可视化。由于这样编写的程序始终使用最新的数据来生成可视化，因此即便数据瞬息万变，它呈现的信息也都是最新的。

Web API 是网站的一部分，用于与使用非常具体的 URL 请求特定信息的程序交互。这种请求称为 API 调用。请求的数据将以易于处理的格式（如 JSON 或 CSV）返回。依赖于外部数据源的大多数应用程序都依赖于 API 调用，如集成社交媒体网站的应用程序。

本章的可视化将基于来自 GitHub 的信息，这是一个让程序员能够协作开发项目的网站。我们将使用 GitHub 的 API 来请求有关该网站中 Python 项目的信息，然后使用 Pygal 生成交互式可视化，以呈现这些项目的受欢迎程度。

GitHub 的 API 让你能够通过 API 调用来请求各种信息。要知道 API 调用是什么样的，请在浏览器的地址栏中输入如下地址并按回车键：

	https://api.github.com/search/repositories?q=language:python&sort=stars

这个调用返回 GitHub 当前托管了多少个 Python 项目，还有有关最受欢迎的 Python 仓库的信息。下面来仔细研究这个调用。第一部分（https://api.github.com/ ）将请求发送到 GitHub 网站中响应 API 调用的部分；接下来的一部分（search/repositories ）让 API 搜索 GitHub 上的所有仓库。

repositories 后面的问号指出我们要传递一个实参。q 表示查询，而等号让我们能够开始指定查询（q= ）。通过使用 language:python ，我们指出只想获取主要语言为 Python 的仓库的信息。最后一部分（&sort=stars ）指定将项目按其获得的星级进行排序。

从第二行输出可知，编写本书时，GitHub 总共有 713 062 个 Python 项目。"incomplete_results" 的值为 false ，据此我们知道请求是成功的（它并非不完整的）。倘若 GitHub 无法全面处理该 API，它返回的这个值将为 true 。接下来的列表中显示了返回的 "items" ，其中包含 GitHub 上最受欢迎的 Python 项目的详细信息。

requests 包让 Python 程序能够轻松地向网站请求信息以及检查返回的响应。

在 ❶ 处，我们导入了模块 requests 。在 ❷ 处，我们存储 API 调用的 URL，然后使用 requests 来执行调用（见❸）。我们调用 get() 并将 URL 传递给它，再将响应对象存储在变量 r 中。响应对象包含一个名为 status_code 的属性，它让我们知道请求是否成功了（状态码 200 表示请求成功）。在 ❹ 处，我们打印 status_code ，核实调用是否成功了。这个 API 返回 JSON 格式的信息，因此我们使用方法 json() 将这些信息转换为一个 Python 字典（见❺）。我们将转换得到的字典存储在 response_dict 中。

像这样简单的调用应该会返回完整的结果集，因此完全可以忽略与 'incomplete_results' 相关联的值。但执行更复杂的 API 调用时，程序应检查这个值。

在这里，我们打印了表示第一个仓库的字典中与很多键相关联的值。在 ❶ 处，我们打印了项目的名称。项目所有者是用一个字典表示的，因此在 ❷ 处，我们使用键 owner 来访问表示所有者的字典，再使用键 key 来获取所有者的登录名。在 ❸ 处，我们打印项目获得了多少个星的评级，以及项目在 GitHub 仓库的 URL。接下来，我们显示项目的创建时间（见❹）和最后一次更新的时间（见❺）。最后，我们打印仓库的描述。输出类似于下面这样：

对这些数据进行可视化时，我们需要涵盖多个仓库。下面就来编写一个循环，打印 API 调用返回的每个仓库的特定信息，以便能够在可视化中包含所有这些信息：

    print('\nName: ', repo_dict['name'])

1『想要实现在恰当的地方空行，试试用上面的语句，踩过坑的。如果把 \n 拿到 name 字符串外面来的话，会比自己想要的结果多一个空格出来。』

我们关心的信息是搜索 API 的速率限制（见❶）。从 ❷ 处可知，极限为每分钟 10 个请求，而在当前这一分钟内，我们还可执行 8 个请求（见❸）。reset 值指的是配额将重置的 Unix 时间或新纪元时间 （1970 年 1 月 1 日午夜后多少秒）（见❹）。用完配额后，你将收到一条简单的响应，由此知道已到达 API 极限。到达极限后，你必须等待配额重置。

注意：很多 API 都要求你注册获得 API 密钥后才能执行 API 调用。编写本书时，GitHub 没有这样的要求，但获得 API 密钥后，配额将高得多。

1『注意，函数括号里面传递实参时的赋值号 = 是没有空格的。』

我们首先导入了 pygal 以及要应用于图表的 Pygal 样式。接下来，打印 API 调用响应的状态以及找到的仓库总数，以便获悉 API 调用是否出现了问题。我们不再打印返回的有关项目的信息，因为将通过可视化来呈现这些信息。

在 ❶ 处，我们创建了两个空列表，用于存储将包含在图表中的信息。我们需要每个项目的名称，用于给条形加上标签，我们还需要知道项目获得了多少个星，用于确定条形的高度。在循环中，我们将项目的名称和获得的星数附加到这些列表的末尾 ❷。

接下来，我们使用 LightenStyle 类（别名 LS ）定义了一种样式，并将其基色设置为深蓝色（见❸）。我们还传递了实参 base_style ，以使用 LightColorizedStyle 类（别名 LCS ）。然后，我们使用 Bar() 创建一个简单的条形图，并向它传递了 my_style （见❹）。我们还传递了另外两个样式实参：让标签绕 x 轴旋转 45 度（x_label_rotation=45 ），并隐藏了图例（show_legend=False ），因为我们只在图表中绘制一个数据系列。接下来，我们给图表指定了标题，并将属性 x_labels 设置为列表 names 。

由于我们不需要给这个数据系列添加标签，因此在 ❺ 处添加数据时，将标签设置成了空字符串。生成的图表如图 17-1 所示。从中可知，前几个项目的受欢迎程度比其他项目高得多，但所有这些项目在 Python 生态系统中都很重要。

在 ❶ 处，我们创建了一个Pygal类 Config 的实例，并将其命名为 my_config 。通过修改 my_config 的属性，可定制图表的外观。在 ❷ 处，我们设置了两个属性——x_label_rotation 和 show_legend ，它们原来是在创建 Bar 实例时以关键字实参的方式传递的。

在 ❸ 处，我们设置了图表标题、副标签和主标签的字体大小。在这个图表中，副标签是 x 轴上的项目名以及 y 轴上的大部分数字。主标签是 y 轴上为 5000 整数倍的刻度；这些标签应更大，以与副标签区分开来。在 ❹ 处，我们使用 truncate_label 将较长的项目名缩短为 15 个字符（如果你将鼠标指向屏幕上被截短的项目名，将显示完整的项目名）。接下来，我们将 show_y_guides 设置为 False ，以隐藏图表中的水平线（见❺）。最后，在 ❻ 处设置了自定义宽度，让图表更充分地利用浏览器中的可用空间。

在 ❼ 处创建Bar 实例时，我们将 my_config 作为第一个实参，从而通过一个实参传递了所有的配置设置。我们可以通过 my_config 做任意数量的样式和配置修改，而 ❼ 处的代码行将保持不变。图 17-2 显示了重新设置样式后的图表。

在 Pygal 中，将鼠标指向条形将显示它表示的信息，这通常称为工具提示 。在这个示例中，当前显示的是项目获得了多少个星。下面来创建一个自定义工具提示，以同时显示项目的描述。

来看一个简单的示例，它可视化前三个项目，并给每个项目对应的条形都指定自定义标签。为此，我们向 add() 传递一个字典列表，而不是值列表：

Pygal 还允许你将图表中的每个条形用作网站的链接。为此，只需添加一行代码，在为每个项目创建的字典中，添加一个键为 'xlink' 的「键-值」对。Pygal 根据与键 'xlink' 相关联的 URL 将每个条形都转换为活跃的链接。单击图表中的任何条形时，都将在浏览器中打开一个新的标签页，并在其中显示相应项目的 GitHub 页面。至此，你对 API 获取的数据进行了可视化，它是交互性的，包含丰富的信息！

为探索如何使用其他网站的 API 调用，我们来看看 [Hacker News](https://news.ycombinator.com/)。在 Hacker News 网站，用户分享编程和技术方面的文章，并就这些文章展开积极的讨论。Hacker News 的 API 让你能够访问有关该网站所有文章和评论的信息，且不要求你通过注册获得密钥。

这个字典包含很多键，如 'url' （见❶）和 'title' （见❷）。与键 'descendants' 相关联的值是文章被评论的次数（见❸）。与键 'kids' 相关联的值包含对文章所做的所有评论的 ID（见❹）。每个评论自己也可能有 kid，因此文章的后代（descendant）数量可能比其 kid 数量多。

下面来执行一个 API 调用，返回 Hacker News 上当前热门文章的 ID，再查看每篇排名靠前的文章：

首先，我们执行了一个 API 调用，并打印了响应的状态（见❶）。这个 API 调用返回一个列表，其中包含 Hacker News 上当前最热门的 500 篇文章的 ID。接下来，我们将响应文本转换为一个 Python 列表（见❷），并将其存储在 submission_ids 中。我们将使用这些 ID 来创建一系列字典，其中每个字典都存储了一篇文章的信息。

在 ❸ 处，我们创建了一个名为 submission_dicts 的空列表，用于存储前面所说的字典。接下来，我们遍历前 30 篇文章的 ID。对于每篇文章，我们都执行一个 API 调用，其中的 URL 包含 submission_id 的当前值（见❹）。我们打印每次请求的状态，以便知道请求是否成功了。

在 ❺ 处，我们为当前处理的文章创建一个字典，并在其中存储文章的标题以及到其讨论页面的链接。在 ❻ 处，我们在这个字典中存储了评论数。如果文章还没有评论，响应字典中将没有键 'descendants' 。不确定某个键是否包含在字典中时，可使用方法 dict.get() ，它在指定的键存在时返回与之相关联的值，并在指定的键不存在时返回你指定的值（这里是 0）。最后，我们将 submission_dict 附加到 submission_dicts 末尾。

Hacker News 上的文章是根据总体得分排名的，而总体得分取决于很多因素，其中包含被推荐的次数、评论数以及发表的时间。我们要根据评论数对字典列表 submission_dicts 进行排序，为此，使用了模块 operator 中的函数 itemgetter() （见❼）。我们向这个函数传递了键 'comments' ，因此它将从这个列表的每个字典中提取与键 'comments' 相关联的值。这样，函数 sorted() 将根据这种值对列表进行排序。我们将列表按降序排列，即评论最多的文章位于最前面。

对列表排序后，我们遍历这个列表（见❽），对于每篇热门文章，都打印其三项信息：标题、到讨论页面的链接以及文章现有的评论数：

使用任何 API 来访问和分析信息时，流程都与此类似。有了这些数据后，你就可以进行可视化，指出最近哪些文章引发了最激烈的讨论。

## 18 Django 入门

### 1. 逻辑脉络

创立虚拟环境；安装 Django；在 Django 里创建项目；为这个项目创建数据库；查看核实该项目是否在正常运行。

### 2. 摘录及评论

在本章中，你首先学习了如何使用 Django 框架来创建 Web 应用程序。你制定了简要的项目规范，在虚拟环境中安装了 Django，创建了一个项目，并核实该项目已正确地创建。你学习了如何创建应用程序，以及如何定义表示应用程序数据的模型。你学习了数据库，以及在你修改模型后，Django 可为你迁移数据库提供什么样的帮助。你学习了如何创建可访问管理网站的超级用户，并使用管理网站输入了一些初始数据。

你还探索了 Django shell，它让你能够在终端会话中处理项目的数据。你学习了如何定义 URL、创建视图函数以及编写为网站创建网页的模板。最后，你使用了模板继承，它可简化各个模板的结构，并使得修改网站更容易。

在第 19 章，我们将创建对用户友好而直观的网页，让用户无需通过管理网站就能添加新的主题和条目，以及编辑既有的条目。我们还将添加一个用户注册系统，让用户能够创建账户和自己的学习笔记。让任意数量的用户都能与之交互，是 Web 应用程序的核心所在。

当今的网站实际上都是富应用程序（rich application），就像成熟的桌面应用程序一样。Python 提供了一组开发 Web 应用程序的卓越工具。在本章中，你将学习如何使用 [The Web framework for perfectionists with deadlines | Django](https://www.djangoproject.com/)来开发一个名为「学习笔记」（Learning Log）的项目，这是一个在线日志系统，让你能够记录所学习的有关特定主题的知识。

我们将为这个项目制定规范，然后为应用程序使用的数据定义模型。我们将使用 Django 的管理系统来输入一些初始数据，再学习编写视图和模板，让 Django 能够为我们的网站创建网页。

Django 是一个 Web 框架 ——一套用于帮助开发交互式网站的工具。Django 能够响应网页请求，还能让你更轻松地读写数据库、管理用户等。在第 19 章和第 20 章，我们将改进「学习笔记」项目，再将其部署到活动的服务器，让你和你的朋友能够使用它。

完整的规范详细说明了项目的目标，阐述了项目的功能，并讨论了项目的外观和用户界面。与任何良好的项目规划和商业计划书一样，规范应突出重点，帮助避免项目偏离轨道。这里不会制定完整的项目规划，而只列出一些明确的目标，以突出开发的重点。我们制定的规范如下：

我们要编写一个名为「学习笔记」的 Web 应用程序，让用户能够记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。「学习笔记」的主页对这个网站进行描述，并邀请用户注册或登录。用户登录后，就可创建新主题、添加新条目以及阅读既有的条目。

学习新的主题时，记录学到的知识可帮助跟踪和复习这些知识。优秀的应用程序让这个记录过程简单易行。

为项目新建一个目录，将其命名为 learning_log，再在终端中切换到这个目录，并创建一个虚拟环境。如果你使用的是 Python 3，可使用如下命令来创建虚拟环境：

```
learning_log$ python3 -m venv ll_env

learning_log$
```

这里运行了模块 venv ，并使用它来创建一个名为 ll_env 的虚拟环境。

注意：如果你的系统安装了多个 Python 版本，需要指定 virtualenv 使用的版本。例如，命令 virtualenv ll_env --python=python3 创建一个使用 Python 3 的虚拟环境。

建立虚拟环境后，需要使用下面的命令激活它：

```
learning_log$ source ll_env/bin/activate

❶ (ll_env)learning_log$
```

这个命令运行 ll_env/bin 中的脚本 activate。环境处于活动状态时，环境名将包含在括号内，如 ❶ 处所示。在这种情况下，你可以在环境中安装包，并使用已安装的包。你在 ll_env 中安装的包仅在该环境处于活动状态时才可用。

要停止使用虚拟环境，可执行命令 deactivate ：

创建并激活虚拟环境后，就可安装 Django 了：

	pip3 install Django

由于我们是在虚拟环境中工作，因此在所有的系统中，安装 Django 的命令都相同：不需要指定标志 --user ，也无需使用 python -m pip install package_name 这样较长的命令。别忘了，Django 仅在虚拟环境处于活动状态时才可用。

❶ 处的命令让 Django 新建一个名为 learning_log的项目。这个命令末尾的句点让新项目使用合适的目录结构，这样开发完成后可轻松地将应用程序部署到服务器。

注意：千万别忘了这个句点，否则部署应用程序时将遭遇一些配置问题。如果忘记了这个句点，就将创建的文件和文件夹删除（ll_env 除外），再重新运行这个命令。

在 ❸ 处，运行了命令 ls （在Windows系统上应为 dir ），结果表明 Django 新建了一个名为 learning_log 的目录。它还创建了一个名为 manage.py 的文件，这是一个简单的程序，它接受命令并将其交给 Django 的相关部分去运行。我们将使用这些命令来管理诸如使用数据库和运行服务器等任务。

目录 learning_log 包含 4 个文件（见❸），其中最重要的是 settings.py、urls.py 和 wsgi.py。文件 settings.py 指定 Django 如何与你的系统交互以及如何管理项目。在开发项目的过程中，我们将修改其中一些设置，并添加一些设置。文件 urls.py 告诉 Django 应创建哪些网页来响应浏览器请求。文件 wsgi.py 帮助 Django 提供它创建的文件，这个文件名是 web server gateway interface（Web 服务器网关接口 ）的首字母缩写。

Django 将大部分与项目相关的信息都存储在数据库中，因此我们需要创建一个供 Django 使用的数据库。为给项目「学习笔记」创建数据库，请在处于活动虚拟环境中的情况下执行下面的命令：

	(ll_env)learning_log$ python3 manage.py migrate

我们将修改数据库称为迁移数据库。首次执行命令 migrate 时，将让 Django 确保数据库与项目的当前状态匹配。在使用 SQLite（后面将更详细地介绍）的新项目中首次执行这个命令时，Django 将新建一个数据库。在 ❶ 处，Django 指出它将创建必要的数据库表，用于存储我们将在这个项目（Synchronize unmigrated apps，同步未迁移的应用程序 ）中使用的信息，再确保数据库结构与当前代码（Apply all migrations，应用所有的迁移 ）匹配。

在 ❷ 处，我们运行了命令 ls ，其输出表明 Django 又创建了一个文件——db.sqlite3。SQLite 是一种使用单个文件的数据库，是编写简单应用程序的理想选择，因为它让你不用太关注数据库管理的问题。

下面来核实 Django 是否正确地创建了项目。执行命令：

	(ll_env)learning_log$ python manage.py runserver

Django 启动一个服务器，让你能够查看系统中的项目，了解它们的工作情况。当你在浏览器中输入 URL 以请求网页时，该 Django 服务器将进行响应：生成合适的网页，并将其发送给浏览器。

在 ❶ 处，Django 通过检查确认正确地创建了项目；在 ❷ 处，它指出了使用的 Django 版本以及当前使用的设置文件的名称；在 ❸ 处，它指出了项目的 URL。URL http://127.0.0.1:8000/ 表明项目将在你的计算机（即 localhost）的端口 8000 上侦听请求。localhost 是一种只处理当前系统发出的请求，而不允许其他任何人查看你正在开发的网页的服务器。

现在打开一款Web浏览器，并输入 URL：http://localhost:8000/；如果这不管用，请输入 http://127.0.0.1:8000/。你将看到类似于图 18-1 所示的页面，这个页面是 Django 创建的，让你知道到目前为止一切正常。现在暂时不要关闭这个服务器。若要关闭这个服务器，按 Ctrl + C 即可。

Django 项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。我们暂时只创建一个应用程序，它将完成项目的大部分工作。在第 19 章，我们将再添加一个管理用户账户的应用程序。

当前，在前面打开的终端窗口中应该还运行着 runserver 。请再打开一个终端窗口（或标签页），并切换到 manage.py 所在的目录。激活该虚拟环境，再执行命令 startapp ：

	(ll_env)learning_log$ python manage.py startapp learning_logs

1『这个命令前记得一定要把虚拟环境激活。』

命令 startapp appname 让 Django 建立创建应用程序所需的基础设施。如果现在查看项目目录，将看到其中新增了一个文件夹 learning_logs（见❶）。打开这个文件夹，看看 Django 都创建了什么（见❷）。其中最重要的文件是 models.py、admin.py 和 views.py。我们将使用 models.py 来定义我们要在应用程序中管理的数据。admin.py 和 views.py 将在稍后介绍。

我们来想想涉及的数据。每位用户都需要在学习笔记中创建很多主题。用户输入的每个条目都与特定主题相关联，这些条目将以文本的方式显示。我们还需要存储每个条目的时间戳，以便能够告诉用户各个条目都是什么时候创建的。

打开文件 models.py，看看它当前包含哪些内容：

这为我们导入了模块 models，还让我们创建自己的模型。模型告诉 Django 如何处理应用程序中存储的数据。在代码层面，模型就是一个类，就像前面讨论的每个类一样，包含属性和方法。下面是表示用户将要存储的主题的模型：

我们创建了一个名为 Topic 的类，它继承了 Model ——Django 中一个定义了模型基本功能的类。Topic 类只有两个属性：text 和 date_added 。

属性 text 是一个 CharField——由字符或文本组成的数据（见❶）。需要存储少量的文本，如名称、标题或城市时，可使用 CharField 。定义 CharField 属性时，必须告诉 Django 该在数据库中预留多少空间。在这里，我们将 max_length 设置成了 200（即 200 个字符），这对存储大多数主题名来说足够了。

属性 date_added 是一个 DateTimeField ——记录日期和时间的数据（见❷）。我们传递了实参 auto_add_now=True ，每当用户创建新主题时，这都让 Django 将这个属性自动设置成当前日期和时间。

1『DateTimeField 是 django.db.models 的一个属性。开始码的时候把 DateTimeField 误打成了 DataTimeField，找了很久才发现这个错误。』

注意：要获悉可在模型中使用的各种字段，请参阅 Django Model Field Reference（Django 模型字段参考），其网址为 [Model field reference | Django documentation | Django](https://docs.djangoproject.com/en/1.8/ref/models/fields/)。就当前而言，你无需全面了解其中的所有内容，但自己开发应用程序时，这些内容会提供极大的帮助。

我们需要告诉 Django，默认应使用哪个属性来显示有关主题的信息。Django 调用方法 __str__() 来显示模型的简单表示。在这里，我们编写了方法 __str__() ，它返回存储在属性 text 中的字符串（见❸）。

注意：如果你使用的是 Python 2.7，应调用方法 __unicode__() ，而不是 __str__() ，但其中的代码相同。

要使用模型，必须让 Django 将应用程序包含到项目中。为此，打开 settings.py（它位于目录 learning_log/learning_log中），你将看到一个这样的片段，即告诉 Django 哪些应用程序安装在项目中：

这是一个元组，告诉 Django 项目是由哪些应用程序组成的。请将 INSTALLED_APPS 修改成下面这样，将前面的应用程序添加到这个元组中：

1『我的文件里 INSTALLED_APPS 是个列表，而非元组。』

通过将应用程序编组，在项目不断增大，包含更多的应用程序时，有助于对应用程序进行跟踪。这里新建了一个名为 My apps 的片段，当前它只包含应用程序 learning_logs。

接下来，需要让 Django 修改数据库，使其能够存储与模型 Topic 相关的信息。为此，在终端窗口中执行下面的命令：

	(ll_env)learning_log$ python manage.py makemigrations learning_logs

命令 makemigrations 让 Django 确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据。输出表明 Django 创建了一个名为 0001_initial.py 的迁移文件，这个文件将在数据库中为模型 Topic 创建一个表。

下面来应用这种迁移，让 Django 替我们修改数据库：

	(ll_env)learning_log$ python manage.py migrate

这个命令的大部分输出都与我们首次执行命令 migrate 的输出相同。我们需要检查的是 ❶ 处的输出行，在这里，Django 确认为 learning_logs 应用迁移时一切正常（OK ）。

每当需要修改「学习笔记」管理的数据时，都采取如下三个步骤：修改 models.py；对 learning_logs 调用 makemigrations ；让 Django 迁移项目。

为应用程序定义模型时，Django 提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。在本节中，我们将建立管理网站，并通过它使用模型 Topic 来添加一些主题。

















