# 2018112黑客与画家R03

## 记忆时间

## 总结汇总

10、机器语言是计算机的操作命令清单。编译器的存在，可以将以某种简便方式书写的程序转变为计算器可以理解的语言，而这种简便方式书写的语言即为高级语言。

11、编程语言如同生物物种一般演化，关心一百年后的编程语言等同于选择演化的主干。那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。

## 1001. 编程语言解析

所有机器都有一张操作命令清单，让你可以控制它。有时这个清单非常简短。电水壶就只允许两种操作：打开和关闭。CD 播放器稍微复杂点，除了打开和关闭以外，还能调节音量、播放、暂停、快进、快退、随机播放等。计算机和其他机器一样，也有一张操作命令清单。比如，可以命令计算机把两个数相加。这种操作命令的总和就是计算机的机器语言（machine language）。

### 10.1 机器语言

计算机刚发明的时候，所有程序就是一条条机器语言的命令。没过多久，程序就改成使用汇编语言了，它要比机器语言写起来稍微方便一点。命令清单还是一样的，就是每个命令换了一个更人性化的名字。机器语言的加法命令是 11001101，这可能就是计算机内部的加法表达方式，但是在汇编语言中，这条命令就改成了 add。机器语言和汇编语言的共同问题就是，只能让大多数计算机做一些很简单的事情。比如，假定你想让计算机的蜂鸣器响 10 次，但是不存在一条直接的机器语言命令让电脑重复进行 n 次操作，所以只能用机器语言写出下面这样的程序：

```
a 将数字 10 存入内存地址 0

如果内存地址 0 的值为负数，跳到 b 行

蜂鸣器发出声音

将内存地址 0 的值减 1

跳到 a 行

b …… 程序的其他部分……
```

如果只是为了让蜂鸣器响 10 次就不得不写这么多代码，不难想象写出一个文字处理器或电子表格将是一项多么浩大的工程。顺便说一句，请再看一下上面的程序。蜂鸣器真的会响 10 次吗？不，响了 11 次。我不应该在第一行使用 10，而应该使用 9。我故意在这个例子中留了一个 bug，证明编程语言的一个重要特点：一个操作所需的代码越多，就越难避免 bug，也越难发现它们。

1『编程里很多很多地方，计数是从 0 开始的。回复：之前看算法相关知识时知道，因为数组的指针是靠偏移量来定位的，偏移 0 即为首个元素。（2020-12-16）』

### 10.2 高级语言

现在假设你不得不用汇编语言开发程序，但是你有了一个助手，他可以帮你承担那些麻烦的脏活。所以，你只要把程序写成下面这样就行了 [1]：

```
dotimes 10 蜂鸣器响
```

接下来，你的助手会用汇编语言来实现这条命令（假定他不会产生 bug）。事实上大多数程序员就是这样工作的，不同之处就是，程序员的助手不是一个人，而是编译器。所谓「编译器」，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。

这种简便方式书写的程序所使用的语言就叫做高级语言。它让你能够使用更强大的命令开发程序，比如现在你就有了「重复 n 次操作」的命令，不再仅限于只能做简单的「两个数相加」。写程序时有了方便的命令，就可以把程序写得更简短。在上面假想的例子中，高级语言写出来的程序的长度只有机器语言的五分之一。所以，要是你犯错了，现在也更容易发现。

高级语言还有一个优点，它使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的。所以，你无法将为某一种机型写的机器语言程序放到另一种机型上运行，只有彻底重写才能实现。但是，如果你的程序是用高级语言写的，你只需要重写编译器就可以了。

编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。

1『典型如 Python 解释器。回复：PHP 也是解释型语言。（2020-12-16）』

### 10.3 开放源码

编译器处理的高级语言代码又叫做源码。它经过翻译以后产生的机器码就叫做目标码。顾客购买市场上的商业软件时得到的往往只是目标码。（目标码很难读懂，所以相当于被加密了，可以保护公司的商业秘密。）但是，后来出现另一种潮流：开放源码的软件。你可以得到源码，并且可以不受限制地修改它。这两种方式的真正区别在于，开放源码使你对软件有更大的控制权，如果你想理解开源软件如何运行，只要阅读源码就行了。如果愿意，你甚至可以修改软件、重新编译。

你之所以需要这样做，一个原因可能是为了修正 bug。比如，你自己不可能修正 Windows 的 bug，因为你没有源码。（理论上你也许可以破解目标码，但是实际上这是非常难的。另一方面，软件的授权协议一般也不允许你这样做。）这会导致很大的问题。一旦 Windows 出现新的安全漏洞，只能等待微软公司发布解决方法，这还算是快的。如果 bug 的危害性不严重，只是偶尔会让你的机器死机，那么可能不得不等到下一次全面升级后问题才会得到解决。

开放源码的优势还不仅局限于可以自己动手解决 bug。这里的关键是所有人都可以参与。所以，开源软件就像一篇经受同行评议的论文。许许多多的聪明人仔细阅读了 Linux 和 FreeBSD 这样的开源操作系统的源码，发现并且解决了大量的 bug。相比之下，Windows 的可靠性只能依赖于大公司自己的质量保证部门了。

开放源码的拥护者常常被看作反对知识产权的怪人。其中有些人确实如此，但是我本人肯定不反对知识产权。只是如果你要我安装没有源码的软件，我会非常犹豫。普通的消费者也许不需要看到他们使用的文字处理器的源码，但是在非常强调软件可靠性的情况下，出于强烈的工程需求的考虑，会要求开放源码。

### 10.4 语言的战争

绝大多数程序员在绝大多数时候都使用高级语言编程。现在很少有人使用汇编语言。程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了，所以几乎不值得非常麻烦地用汇编语言开发软件。只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观水平控制硬件，使得游戏速度得到最大限度的终极提高。

Fortran、Lisp、Cobol、Basic、C、Pascal、Smalltalk、C++、Java、Perl 和 Python，全都是高级语言。它们只是比较出名的几种而已。现在的高级语言大概有几百种之多。不同机器语言的指令集基本相同，但是高级语言就不一样，它们开发程序的模式差别相当大。

那么，应该使用哪一种语言？嗯，关于这个问题，现在有很多争论。部分原因是，如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。

可能因为想炫耀自己见多识广，某些黑客会告诉你所有高级语言基本相似。「所有编程语言我都用过。」某个看上去饱经风霜又酷的黑客往酒吧里一坐，「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」

这当然是一派胡言。各种语言简直是天差地别，比如 Fortran I 和最新版的 Perl 就是两种完全不同的语言，而早期版的 Perl 和最新版的 Perl 之间的差别也大得惊人。但是，那个夸夸其谈的黑客可能真的相信自己的这番话，的确有可能使用所有不同的语言写出了与用原始的 Pascal 语言写的差不多的程序。如果你吃过麦当劳，就会知道全世界各地的麦当劳的味道都几乎一样。

一些黑客只喜欢自己用的语言，反感其他所有的语言。另一些黑客则说所有的语言都一样。事实介于这两个极端之间。语言之间确实有差别，但是很难确定地说哪一种语言是最好的。这个领域依然还在快速发展。

### 10.5 抽象性

高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C 语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而 Lisp 语言的层次则是相当高。

如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得 Prolog 语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决 2％ 的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是 Pascal 语言的程序。

另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用 C 语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用 C 这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望「缓存区溢出攻击」继续存在下去，以便让大家时时保持警惕。[2] ）

### 10.6 安全带还是手铐？

语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java 语言是前一个阵营的代表，Perl 语言则是后一个阵营的代表。（美国国防部很看中 Java 也就不足为奇了。）自由语言派的信徒嘲笑另一方是「B&D」（奴役和戒律，Bondage and Discipline）语言，很无礼地暗示用那些语言编程的人是下等人。我不知道对方如何反击这些喜欢 Perl 的自由派，也许他们不喜欢给别人起绰号，因此我就无从知道。

由于防止程序员做蠢事有好几种方法，所以上面的争论逐渐分化成几个较小的议题。目前最活跃的议题之一就是静态类型语言与动态类型语言之争。在静态类型语言中，写代码时必须知道每个变量的类型。而在动态类型语言中，随便什么时候，你都可以把变量设为任意类型的值。

静态类型语言的拥护者认为这样可以防止 bug，并且帮助编译器生成更快的代码（这两点理由都成立）。动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。我本人更喜欢动态类型，痛恨那些限制我的自由的语言。但是，确实有一些很聪明的人看来喜欢用静态类型语言。所以，这个问题依然值得讨论，并没有固定答案。

### 10.7 面向对象编程

眼下另一个争论的热点则是面向对象编程。它是一种不同的组织程序的方法。假定你要写一个程序，计算二维图形的面积。首先，你必须知道到底是圆形还是正方形。一种解决方法是用一整块的代码判断遇到的是什么图形，然后再用相应的公式计算面积。面向对象编程不是这样，它的方法是写出两个类，一个是圆形类，另一个是正方形类，然后每个类里面用一小块代码（叫做方法）计算该类图形的面积。求面积的时候，你就问要用哪一个类，然后再使用相应的方法得出最后答案。

这两种不同的计算方法可能听上去很相似，事实上，运行代码后，实际计算面积的运算过程也很相似。（这不奇怪，因为你本来就在解决同一个问题。）但是，代码的形式却是大相径庭。在面向对象编程的方式中，计算圆面积和正方形面积的代码可能分散在不同的文件中。与圆形有关的代码都放在一个文件中，与正方形有关的代码则放在另一个文件中。

面向对象编程的优点在于，如果你需要修改程序，计算另一种图形的面积，比如三角形，你只需要再另外增加一块相应的代码就可以了，甚至可以不修改程序的其他部分。但是，批评者会反驳说，这种方法的缺点是，由于增加代码不用考虑其他部分，结果往往导致写出性能不佳甚至有副作用的代码，就好比造房子不考虑已经完成的部分一样。

关于面向对象编程优劣的争论并不像静态类型与动态类型之争那样壁垒分明，因为编程的时候你只能在静态类型和动态类型之中选一种。但是，面向对象编程只是程度不同的问题。事实上有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程。我觉得后一类语言不可取。允许你做某事的语言肯定不差于强迫你做某事的语言。所以，至少在这方面我们可以得到明确的结论：你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。

### 10.8 文艺复兴

有一件事，我想所有软件业的人都会同意，那就是最近出现了很多新的编程语言。直到 20 世纪 80 年代，只有大机构才买得起开发编程语言所需的硬件，所以大多数编程语言都是大公司的教授或者研究员开发的。而现在，一个高中生就能搞到所有必需的硬件。Perl 语言的设计者拉里·瓦尔 [3] 的例子启发了很多黑客：为什么不动手设计一种自己的语言呢？只要你懂得驾驭开源软件社区，就会有很多人在短期内为你提供大量的代码。

结果就是产生了一些也许可以称为「头重脚轻」的语言：它们的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。 [4] 

另一个结果就是语言的多样化。编程语言之间总是存在很大区别。Fortran、Lisp、APL 都是 1970 年以前开发出来的，它们之间的区别大得就像海星、熊、蜻蜓之间的区别。新兴的开源编程语言肯定将继承这种传统。现在好像每隔一段日子就能听到一种新出现的语言。乔纳森·埃里克森把这种现象称为「编程语言的文艺复兴」。人们有时还会用另一个说法，即「编程语言的战争」。这并不矛盾，文艺复兴时期就是存在很多战争的。

实际上，很多历史学家相信战争是文艺复兴的一个副产品。 [5] 当时，欧洲活力旺盛可能就是因为它分成许多互相竞争的小国。它们互相毗邻，所以新思想能够从一个国家传播到另一个国家，但是它们又互相独立，使得单个的统治者无法遏制创新的发展。相比之下，中国古代的封建皇朝禁止民间建造大型的远洋船只，阻止了经济的正常发展。所以，程序员活在这个文艺复兴时代可能是一件好事。如果我们所有人都使用同一种编程语言，反而有可能是坏事。

### 注释

[1] dotimes 是 Lisp 语言中表示循环处理的命令。—— 译者注

[2] 最常见的几种入侵计算机的手法都是利用了 C 语言的某些特点。当你在 C 语言中为输入的内容分配出一片内存（也叫「缓存」）时，它会被分配在当前运行代码的返回地址旁边。所谓「返回地址」指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。也就是说，它实际上是计算机下一步要做的事情。

假定有人打算入侵你的计算机，他们猜出你会为某种输入分配 256 字节的缓存，于是他们就提交多于 256 字节的内容，目的是覆盖旁边的「返回地址」。那么，当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地址通常是缓存的首地址，缓存中是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。

如果使用更抽象的高级语言，上面的事情是不可能发生的。但是，在 C 语言中，一旦接受用户输入的时候你没有检查输入长度，就创造出了一个安全漏洞。利用这种漏洞的攻击行为就被称为「缓冲区溢出攻击」。在这种攻击中，还有其他方法可以控制计算机，但是覆盖返回地址是最经典的一种。有意思的是，劫持飞机与「缓冲区溢出攻击」有类似之处。在一般飞机上，乘客区与驾驶舱是相通的，就好像 C 语言中数据区与代码区是相邻的一样。劫机者一旦进入驾驶舱，实际上就相当于把自己从数据提升为代码。

[3] Larry Wall（1954—）在大学里主修语言学。1987 年为了使管理机房的工作变得方便，他在业余时间创造了 Perl 语言。—— 译者注

[4] 提醒各位亲爱的黑客，我只是打一个比方，请不要尝试在车顶绑上飞机发动机。另外，可以认为这类「头重脚轻」的语言存在已久，Fortran 语言的流行主要就是因为它的函数库。

[5] 参见 Carlo Cipolla 所著的《枪，帆船，帝国：技术革新在 1400-1700 年欧洲扩张早期阶段的作用》（Guns, Sails, and Empires: Technological Innovation and the Early Phases of European Expansion 1400-1700），Pantheon，1965 年出版。

## 1101. 一百年后的编程语言

很难预测一百年后的人类生活，只有少数几件事是可以确定的。那时，汽车将具备低空飞行能力，城市规划的法规将放宽，大楼可以造到几百层，大街上一天到晚看不见太阳，女性个个都学过防身术。本文只想讨论其中的一个细节：一百年后，人们使用什么语言开发软件？

为什么这个问题值得思考？原因不是我们最终会用上这些语言，而是幸运的话，我们从现在开始就能用上这些语言。我认为，编程语言就像生物物种一样，存在一个进化的脉络，许许多多分支最终都会成为进化的死胡同。这种现象已经发生了。Cobol 语言曾经流行一时，但是现在看来没有任何后续语言继承它的思想。它就像尼安德特人 [1] 一样，进化之路已经走到了尽头。

我预言 Java 也会如此。有人写信说：「你怎么能说 Java 不会成功呢？它已经成功了。」我觉得这要看你的成功标准是什么。如果标准是相关书籍的出版量，或者是相信学会 Java 就能找到工作的大学生数量，那么 Java 确实已经成功了。当我说 Java 不会成功时，我的意思是它和 Cobol 一样，进化之路已经走到了尽头。

这只是我的猜测，未必正确。这里的重点不是看衰 Java，而是提出编程语言存在一个进化的脉络，从而引导读者思考，在整个进化过程中，某一种语言的位置到底在哪里？之所以要问这个问题，不是为了一百年后让后人感叹我们曾经如此英明，而是为了找到进化的主干。它会启发我们去选择那些靠近主干的语言，这样对当前的编程最有利。

无论何时，选择进化的主干可能都是最佳方案。要是你不幸选错了，变成了一个尼安德特人，那就太糟了。你的对手克鲁马努人时不时就会来攻打你，把你的食物全部偷走。这就是我想找出一百年后的编程语言的原因。我不愿意押错赌注。

编程语言的进化与生物学进化还是有区别的，因为不同分支的语言会发生聚合。比如，Fortran 分支看来正在与 Algol [2] 的继承者聚合。理论上，不同的生物物种也可能发生聚合，但是可能性很低，所以大概从来没有真正出现过。编程语言之所以可能出现聚合，一个原因是它的概率空间 [3] 比较小，另一个原因是它的突变不是随机的。语言的设计者们总是有意识地借鉴其他语言的设计思想。对于语言设计者来说，认清编程语言的进化路径特别有用，因为这样就可以照着样子设计语言了。这时，认清进化的主干就不仅有助于识别现存的优秀语言，还可以把它当作设计语言的指南。

任何一种编程语言都可以分成两大组成部分：基本运算符的集合（扮演公理的角色）以及除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来）。我认为，基本运算符是一种语言能否长期存在的最重要因素。其他因素都不是决定性的。这有点像买房子的时候你应该先考虑地理位置。别的地方将来出问题都有办法弥补，但是地理位置是没法变的。慎重选择公理还不够，还必须控制它的规模。数学家总是觉得公理越少越好，我觉得他们说到了点子上。

1-2『编程语言的两大部分：基本运算符以及除此之外的。编程语言的演化主干，做一张主题卡片。』——已完成

你仔细审视一种语言的内核，考虑哪些部分可以被摒弃，这至少也是一种很有用的训练。在长期的职业生涯中，我发现冗余的代码会导致更多冗余的代码，不仅软件如此，而且像我这样性格懒散的人，我发现在床底下和房间的角落里这个命题也成立，一件垃圾会产生更多的垃圾。我的判断是，那些内核最小、最干净的编程语言才会存在于进化的主干上。一种语言的内核设计得越小、越干净，它的生命力就越顽强。

当然，猜测一百年后人们使用什么编程语言，这本身就是一个很大的假设。也许一百年后人类已经不编程了，或者直接告诉计算机想做什么，计算机就会自动完成。不过，到目前为止，计算机智能并没有取得太大进展。我猜测一百年后，人们还是使用与现在差不多的程序指挥计算机。可能有一些我们今天需要编程解决的问题，那时已经不需要编程了，但是我想，那时还会存在大量与今天一样的编程任务。

你可能认为只有那些自以为是的人才会去预言一百年后的技术。但是，请不要忘记，软件发展的历史已经走过了 50 年。在这 50 年中，编程语言的进化其实是非常缓慢的，因此展望一百年后的语言并不是虚无缥缈的想法。

编程语言进化缓慢的原因在于它们并不是真正的技术。语言只是一种书写法，而程序则是一种严格符合规则的描述，以书面形式记录计算机应该如何解决你的问题。所以，编程语言的进化速度更像数学符号的进化速度，而不像真正的技术（比如交通或通信技术）的进化速度。数学符号的进化是缓慢的渐变式变化，而不是真正技术的那种跳跃式发展。

无论一百年后的计算机是什么样子，我们基本上可以断定它们的运行速度一定会快得多。如果摩尔定律依然成立，一百年后计算机的运行速度将是现在的 74 乘以 10 的 18 次方倍（准确地说是 73 786 976 294 838 206 464 倍）。真是让人难以想象。不过实际上更现实的预测并不是速度会提高这么多，而是摩尔定律最终将不成立。不管是什么东西，如果每 18 个月就增长一倍，那么最后很可能会达到极限。但那时的计算机比现在快得多大概是毫无疑问的。即使最后只是略微快了 100 万倍，也将实质性地改变编程的基本规则。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。

那时，依然会有对运行速度要求很高的应用程序。我们希望计算机解决的有些问题其实是计算机本身引起的。比如，计算机处理视频的速度取决于生成这些视频的另一台计算机。此外，还有一些问题本身就要求无限快的处理能力，比如图像渲染、加密 / 解密、模拟运算等。

既然在现实中一些应用程序本身的效率较低，而另一些应用程序会耗尽硬件提供的所有运算能力，那么有了更快速的计算机就意味着编程语言不得不应付更多的极端情况，涵盖更大范围的效率要求。我们已经看到这种情况发生了。要是以几十年前的标准衡量，有一些使用新语言开发的热门应用程序对硬件资源的浪费非常惊人。

不仅编程语言有这种现象，这实际上是一种普遍的历史趋势。随着技术的发展，每一代人都在做上一代人觉得很浪费的事情。30 年前的人要是看到我们今天如此随意地使用长途电话，一定会感到震惊。100 年前的人要是看到一个普通的包裹竟然也能享受一天内从波士顿发件、途经孟菲斯、抵达纽约的待遇，恐怕就要更震惊了。

我已经预测了，一旦未来硬件的性能大幅提高将会发生什么事。新增加的运算能力都会被糟蹋掉。

在我学习编程的年代，计算机还是稀罕玩意。我记得当时使用的微机型号是 TRS-80，它的内存只有 4K，为了把 BASIC 程序装入内存，我不得不把源码中的空格全部删除。我一想到那些极其低效率的软件，不断重复某些愚蠢的运算，把硬件的计算能力全部占用，就感到无法忍受。但是，我的这种反应是错的，我就像某个出身贫寒的穷孩子，一听到要花钱就舍不得，即使把钱用在重要场合（比如去医院看病）都觉得很难接受。

某些浪费确实令人厌恶。比如有人就很讨厌 SUV（运动型多用途车），即使它采用可再生的清洁能源也改变不了看法，因为 SUV 来自一个令人厌恶的想法（如何使得小货车看上去更有男子汉气概）。但是，并非所有的浪费都是坏的。既然如今的电信基础设施已经如此发达，再掐着时间打长途电话就有点锱铢必较了。如果有足够的资源，你可以将长途电话和本地电话视为同一件事，一切会变得更轻松。

浪费可以分成好的浪费和坏的浪费。我感兴趣的是好的浪费，即用更多的钱得到更简单的设计。所以，问题就变成了如何才能充分利用新硬件更强大的性能最有利地「浪费」它们？对速度的追求是人类内心深处根深蒂固的欲望。当你看着计算机这个小玩意，就会不由自主地希望程序运行得越快越好，真的要下一番功夫才能把这种欲望克制住。设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。

很多数据结构存在的原因都与计算机的速度有关。比如，今天的许多语言都同时有字符串和列表。从语义上看，字符串或多或少可以理解成列表的一个子集，其中的每一个元素都是字符。那么，为什么还需要把字符串单列为一种数据类型呢？完全可以不这么做。只是为了提高效率，所以字符串才会存在。但是，这种以加快运行速度为目的、却使得编程语言的语义大大复杂的行为，很不可取。编程语言设置字符串似乎就是一个过早优化的例子。

1『自己以前从来没想到过，字符串是列表的一个子集，字符串数据类型是多余的，有一种原来如此的感觉。（2020-12-16）』

如果我们把一种语言的内核设想为一些基本公理的集合，那么仅仅为了提高效率就往内核添加多余的公理，却没有带来表达能力的提升，这肯定是一件很糟的事。没错，效率是很重要，但是我认为修改语言设计并不是提高效率的正确方法。正确做法应该是将语言的语义与语言的实现予以分离。在语义上不需要同时存在列表和字符串，单单列表就够了。而在实现上做好编译器优化，使它在必要时把字符串作为连续字节的形式处理。[4] 

1-2『语言的语义和语言的实现应该分离开来。回复：以前听过说，语义与语言的实现应该分离，通过上面字符串和列表的例子总算有点明白了。做一张任意卡片。』——已完成

对于大多数程序，速度不是最关键的因素，所以你通常不需要费心考虑这种硬件层面上的微观管理。随着计算机速度越来越快，这一点已经越发明显了。

语言设计时，对实现方式少作限制还会使得程序具备更大的灵活性。语言的规格发生变化不仅是无法避免的，也是合理的。通过编译器的处理，按照以前规格开发的软件就会照常运行，这就提供了灵活性。essay（论文）这个词来自法语的动词 essayer，意思是「试试看」。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。软件也是如此。我觉得一些最好的软件就像论文一样，也就是说，当作者真正开始动手写这些软件的时候，他们其实不知道最后会写出什么结果。

Lisp 语言的黑客早就明白数据结构灵活性的价值。我们写程序的第一版时，往往会把所有事情都用列表的形式处理。所以，这些最初版本可能效率低下得惊人，你必须努力克制自己才能忍住不动手优化它们，这就好像吃牛排的时候必须努力克制自己才能不去想牛排是从哪里来的一样，至少对我来说是这样的。

1『又一次想到了 lisp 的元编程能力，但目前还是不太懂它的「元编程」。（2020-12-16）』

一百年后的程序员最需要的编程语言就是可以让你毫不费力地写出程序第一版的编程语言，哪怕它的效率低下得惊人（至少按我们今天的眼光来看是如此）。他们会说，他们想要的就是很容易上手的编程语言。效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。随着计算机速度越来越快，这会变得越来越明显。

1『在浪费人的时间和浪费机器的时间之间选择，无疑是选择后者。』

我觉得，放弃字符串类型已经是大家可以接受的想法了。Arc 语言已经这样做了，看上去效果不错。以前用正则表达式很难描述的一些操作，现在用回归函数可以表达得很简单。这种数据结构的扁平化趋势会怎么发展？我极其努力地设想各种可能，得到的结果甚至令我自己都吓了一跳。比如，数组会不会消失？毕竟数组只是散列表的一个子集，其特点就是数组的键全部都是整数向量。进一步说，散列表本身会不会被列表取代呢？

还有比这更惊人的预言。在逻辑上其实不需要对整数设置单独的表示法，因为可以把它们也看作列表，整数 n 可以用一个 n 元素的列表表示。这一样能完成数学运算，只是效率低得让人无法忍受。

编程语言会发展到放弃基本数据类型之一的整数这一步吗？我这样问并不是真的要你严肃思考这个问题，更多的是希望打开你对未来的思路。我只是提出一种假想的情况：如果一股不可抗拒的力量遇到了一个不可移动的物体，会发生什么事。具体就本文而言：一种效率低得不可想象的语言遇到了性能强大得不可想象的硬件，会发生什么事。我看不出放弃整数类型有什么不妥。未来相当漫长。如果我们想要减少语言内核中基本公理的数目，不妨把眼光放得远一点，想一想如果时间变量 t 趋向无限会怎么样。一百年是一个很好的参考指标，如果你觉得某个想法在一百年后仍然可能是难以令人接受，那么也许一千年后它也依然难以令人接受。

让我说清楚，我的意思不是说所有的整数运算都用列表来实现，而是说语言的内核（不涉及任何编译器的实现）可以这样定义。在现实中，任何进行数学运算的程序可能都是以二进制形式表示数字，但是这属于编译器的优化，而不属于语言内核语义的一部分。

另一种消耗硬件性能的方法就是，在应用软件与硬件之间设置很多的软件层。这也是我们已经看到的一种趋势，许多新兴的语言就被编译成字节码 [5] 。比尔·伍兹曾经对我说，根据经验判断，每增加一个解释层，软件的运行速度就会慢一个数量级。但是，多余的软件层可以让编程灵活起来。

Arc 语言 [6] 最初的版本就是一个极端的例子，它的层很多，运行速度非常慢，但是确实带来了相应的好处。Arc 是一个典型的「元循环」（metacircular）解释器，在 Common Lisp 的基础上开发，很像约翰·麦卡锡在他经典的 Lisp 论文中定义的 eval 函数。Arc 解释器一共只有几百行代码，所以很便于理解和修改。我们采用的 Common Lisp 版本是 CLisp，它本身是在另一个字节码解释器的基础上开发的。所以，我们一共有两层解释器，最上面那层效率低下得惊人，但是语言本身是能用的。我承认只是勉强可用，但是确实能用。

1『好几次看到 Arc 语言，原来也是 lisp 的一种方言，而且是作者和其创业合伙人莫里斯一起开发的。（2020-12-16）』

即使是应用程序，使用多层形式开发也是一种很强大的技巧。自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯 —— 可重用性（reusability）—— 的最佳路线。从定义上看，语言就是可以重用的。在编程语言的帮助下，你的应用程序越是采用这种多层形式开发，它的可重用性就越好。

可重用性这个概念多多少少与 20 世纪 80 年代兴起的面向对象编程有些关联。不管怎样寻找证据，也不可能把这两件事完全分开。某些使用面向对象编程开发出来的软件确实具有可重用性，但是这不是因为它使用了面向对象编程，而是因为它的开发方法是自下而上的。以函数库为例，它们具有可重用性，是因为它们属于语言的一部分，而不是因为它们采用面向对象或者其他编程方法。

顺便说一句，我不认为面向对象编程将来会消亡。我觉得，除了某些特定的领域，这种编程方法其实没有为优秀程序员带来很多好处，但是它对大公司有不可抗拒的吸引力。面向对象编程使得你有办法对一团乱码似的代码进行可持续性开发。通过不断地打补丁，它让你将软件一步步做大。大公司总是倾向于采用这样的方式开发软件。我预计一百年后也是如此。

1『原来作者不太看好面向对象。（2020-12-16）』

既然是谈论未来，最好谈谈并行计算（parallel computation），因为看上去并行计算好像就是为未来而存在的。无论怎么想，并行计算似乎都是未来生活的一部分。它会在未来实现吗？过去二十年，人们都在说并行计算马上就会来临。但是，到目前为止，它对编程实践并没有太大影响。这是真的吗？芯片设计师已经不得不把它考虑在内，为多 CPU 计算机开发系统软件的程序员也是如此。但是，真正的问题在于，并行计算到底能达到哪个抽象层次？一百年后它就会影响到开发应用软件的程序员吗？或者，它还只是编译器作者需要考虑的事情，在应用软件的代码中根本就无处寻觅？

一种可能是，大多数可以用到并行计算的场合，人们都会放弃使用并行计算。虽然我总的预测是未来的软件会挥霍掉大部分新增的硬件性能，但是并行计算是一个特例。我估计随着硬件性能得到惊人的提升，如果你明确地说想要并行计算，那么肯定可以得到它，但是通常情况下你不会用到它。这意味着，除了一些特殊的应用程序，一百年后的并行计算不会是那种大规模的并行计算（massive parallelism）。我预料，对于普通程序员来说，一切更像对进程进行分叉，然后让多个进程在后台并行运行。

这是编程进行到很后期才要做的事情，属于对程序的优化，类似于你想开发一种特定的数据结构来取代现有的数据结构。程序的第一个版本通常会忽略并行计算提供的各种好处，就好像编程开始时会忽略某种特定的数据结构给你带来的好处一样。除了某些特定的应用软件，一百年后，并行计算不会很流行。如果应用软件真的大量使用并行计算，这就属于过早优化了。

一百年后会有多少种编程语言？从最近来看，出现了大量的新语言。硬件性能提高是一个原因，这就允许程序员根据使用目的在运行速度和编程便利性之间做出不同的取舍。如果这就是未来的趋势，那么一百年后强大的硬件只会使得语言数目变得更多。

但是，另一方面，一百年后的常用语言可能只有很少几种。部分原因是基于我的乐观主义，我相信在未来，如果你的作品确实很出色，你可能选择的是一种开发起来很方便的语言。使用这种语言写出来的软件第一版的运行速度很慢，只有对编译器进行优化设置后运行速度才会提升。既然我抱有这种乐观主义，那么我还要做一个预言。有些语言可以达到机器的最高效率，另一些语言的效率则慢到刚刚可以运行而已，两者之间存在巨大的差距。我预言一百年后，这段差距之间的各个点上都会有对应的编程语言存在。

因为这段差距正在变得越来越大，所以性能分析器（profiler）将变得越来越重要。目前，性能分析并没有受到重视。许多人好像仍然相信，程序运行速度提升的关键在于开发出能够生成更快速代码的编译器。代码效率与机器性能的差距正在不断加大，我们将会越来越清楚地看到，应用软件运行速度提升的关键在于有一个好的性能分析器帮助指导程序开发。

我说将来可能只有很少几种常用语言，但没有把用于特定领域的「小众语言」（little language）算进去。我觉得，这些嵌入式语言的想法很不错，一定会蓬勃发展。但是我判断这些「小众语言」会被设计成相当薄的一层，使得用户可以一眼看出在底下作为基础的通用型语言，这样就减少了学习时间，降低了使用成本。

谁来设计这些未来的语言？过去 10 年最激动人心的趋势之一就是开源语言的崛起，比如 Perl、Python 和 Ruby。语言设计已经被黑客接管。到目前为止这样到底是好是坏还看不清楚，但是发展势头令人鼓舞。比如，Perl 就有一些绝妙的创新。不过，它也包含了一些很糟糕的想法。对于一种充满进取心、大胆探索的语言来说，这也是很正常的事。以它现在这种变化的速率，大概只有上帝才知道一百年后 Perl 会变成什么样。

有一句俗话说，如果你自己做不到，那就去当老师。这在语言设计领域不成立，我认识的一些最出色的黑客就在当教授。但是，当老师的人确实有很多事情不能做。研究性职位给黑客带来了一些限制。在任何学术领域，都有一些题目是可以做的，另一些题目是不可以做的。不幸的是，这两类题目的区别通常取决于它们写成论文后看上去是不是很高深，而不是取决于它们对软件业的发展是否重要。最极端的例子可能就是文学，文学研究者的任何成果几乎对文学创作者都毫无影响。

虽然科学领域的状况要稍好一点，但是研究者可以做的题目与能够对设计优秀语言有所帮助的题目之间的交集小得令人沮丧。（奥林·希弗斯曾经对这一点表达不满，而且说得头头是道。）比如，研究变量类型的论文好像多得无穷无尽，尽管事实上静态类型语言看来无法真正支持宏（在我看来，一种语言不支持宏，那就不值得使用了）。

1-3『目前还是不明白「宏」的真实含义，第一次知道宏 macro 是在书籍「2019117Practical-Common-Lisp」里看到的。（2020-12-16）』

新语言更多地以开源项目的形式出现，而不是以研究性项目的形式出现。这是语言的一种发展趋势。另一种发展趋势是，新语言的设计者更多的是本身就需要使用它们的应用软件作者，而不是编译器作者。这似乎是好的趋势，我期待它继续保持下去。

一百年后的物理学基本上不可能预测。但是计算机语言不一样，现在就动手设计一种一百年后可以吸引使用者的新语言，这在理论上似乎是可能的。设计新语言的方法之一就是直接写下你想写的程序，不管编译器是否存在，也不管有没有支持它的硬件。这就是假设存在无限的资源供你支配。不管是今天还是一百年后，这样的假设好像都是有道理的。

你应该写什么程序？随便什么，只要能让你最省力地写出来就行。但是要注意，这必须是在你的思维没有被当前使用的编程语言影响的情况下。这种影响无处不在，必须很努力才能克服。你也许觉得，对于人类这样懒惰的生物，喜欢用最省力的方式写程序是再自然不过的事情。但是事实上，我们的思想可能往往会受限于某种现存的语言，只采用在这种语言看来更简单的形式，它对我们思想的束缚作用会大得令人震惊。新语言必须靠你自己去发现，不能依靠那些让你自然而然就沉下去的思维定势。

1『语言不是思维的外衣，语言是思维本身。』

采用程序的长度作为它耗费工作量的近似指标是个很有用的技巧。这里的程序长度当然不是指字符的数量，而是指各种句法元素的总长度，基本上就是整个解析树的大小。也许不能说最短的程序就是写起来最省力的程序，但是当你一心想把程序写得简洁而不是松松垮垮时，你就更接近省力这个目标，你的日子也会变得好过得多。所以，设计语言的正确做法就变成了，看着一段程序，然后问自己是不是能把它写得更短一点？

实际上，用想象出来的一种一百年后的语言来写程序，这件事情的可靠程度，取决于你对语言内核的估计是否足够正确。常规的排序，你现在就可以写出来。但是，想要预测一百年后的语言使用什么函数库就很难了。很可能许多函数库针对的领域现在还根本不存在。比如，如果 SETI@home [7] 计划成功，我们就需要与外星人联系的函数库了。当然，如果外星人的文明高度发达，已经到了用 XML 格式交换信息的地步，那就不需要新的函数库了。

另一个极端是，我觉得今天你就能设计出一百年后的语言内核。事实上，在有些人看来，大部分语言内核在 1958 年就已经设计出来了。 [8] 如果今天就能使用一百年后的编程语言，我们会用它编程吗？观古而知今。如果 1960 年就能使用今天的编程语言，那时的人们会用它们吗？

在某些方面，回答是否定的。今天的编程语言依赖的硬件在 1960 年并不存在。比如，Python 这样的语言，正确的缩进（indentation）在编写时很重要，但是 1960 年的计算机没有显示器，只有打印机终端，所以编写起来就不会很顺利。但是，如果把这些因素排除在外（你可以假设，我们只在纸上编程），20 世纪 60 年代的程序员会喜欢用现在的语言编程吗？

我想他们会的。某些缺乏想象力、深受早期编程语言思想影响的人可能会觉得不可能。（没有指针运算，如何复制数据？没有 goto 语句，如何实现流程图？）但是我想，那时最聪明的程序员一定能轻松地使用今天的大多数语言，假定他们能得到的话。

如果我们现在就能拥有一百年后的编程语言，那就至少能用来写出优秀的伪码 [9] 。我们会用它开发软件吗？因为一百年后的编程语言需要为某些应用程序生成快速代码，所以很可能它生成的代码能够在我们的硬件上运行，速度也还可以接受。相比一百年后的用户，我们也许不得不对这种语言做更多的优化，但是总的来看，它应该仍然会为我们带来净收益。

现在，我们的两个观点就是：1）一百年后的编程语言在理论上今天就能设计出来；2）如果今天真能设计出这样一种语言，很可能现在就适合编程，并且能够产生更好的结果。如果我们把这两个观点联系起来，那就得出了一些有趣的可能性。为什么不现在就动手尝试写出一百年后的编程语言呢？

当你设计语言的时候，心里牢牢记住这个目标是有好处的。学习开车的时候，一个需要记住的原则就是要把车开直，不是通过将车身对齐画在地上的分隔线，而是通过瞄准远处的某个点。即使你的目标只在几米开外，这样做也是正确的。我认为，设计编程语言时，我们也应该这样做。

### 注释

[1] 尼安德特人（Neanderthal），一种生活在欧洲的古人类，三万多年前已经全部灭绝。—— 译者注

[2] Algol 语言诞生于 20 世纪 50 年代，是最早的计算机语言之一，对后来的许多语言产生了极大的影响。—— 译者注

[3] 概率空间是一个数学术语，大致指概率的可能取值范围。这里的意思是，不管编程语言怎么变，它的形式总是很有限的。—— 译者注

[4] 我相信，Lisp Machine Lisp（Lisp 语言的一种方言）是第一个具体表达这样一种观点的语言：变量的声明（除了动态类型变量之外）只是优化的建议，对一个正确程序本身的含义不构成影响。Common Lisp（Lisp 语言的另一种方言）则好像第一个明确提出了这一点。

[5] 字节码（byte code）是已经经过编译但是需要进一步处理才能变成机器码的中间代码。它的好处是与硬件和软件环境无关，在编译器的配合下，可以在不同的操作系统上运行。字节码的典型运用就是 Java 语言。—— 译者注

[6] Arc 是 Lisp 的一种方言，由本书作者提出，目前由他本人和罗伯特·莫里斯负责开发。—— 译者注

[7] SETI@home 是一个寻找地球以外智慧生命的科学实验，由加州大学伯克利分校发起并主持。它使用射电望远镜监听太空中的无线电信号，然后用计算机进行数据分析，如果发现有些信号不可能自然产生，就可以证明外星文明的存在。1995 年，该项目决定向志愿者开放，使用全球联网的大量计算机进行分布式计算，1999 年 5 月开始正式运行。详细情况参见 [SETI@home](https://setiathome.berkeley.edu/)。—— 译者注

[8] Lisp 语言的第一版规格说明书是 1958 年发布的。—— 译者注

[9] 伪码又称虚拟代码，用来抽象地描述算法，而不是现实存在的编程代码。—— 译者注

## 1201. 拒绝平庸

1995 年，罗伯特·莫里斯和我一起创办了 Viaweb。我们打算开发软件，让用户可以自己搭建网上商店。当时，我们的创意是把软件放在服务器端，使用普通的网页作为用户界面。

当然，那个时候许多人可能都想到过这个主意。但是，就我所知，Viaweb 是第一个互联网应用程序。在我们看来，这真的是很新颖的想法，所以我们就把公司命名为 Viaweb [1]，意即我们的软件通过网络使用，而不是运行在你的桌面电脑上。另一个特别之处是，这个软件主要采用 Lisp 语言开发。 [2] 它是最早的用 Lisp 语言开发的大型应用程序，在此之前，Lisp 语言主要用于大学和实验室中。

### 12.1 秘密武器

埃里克·雷蒙德写过一篇文章《如何变成一个黑客》（How to Become a Hacker）。文中有一部分专门谈到，在他看来，如果你想当一个黑客，应该学习哪些语言。他建议从 Python 和 Java 入手，因为它们比较容易学。想当高级一点的黑客，还应该学习 C 和 Perl。前者用来对付 Unix 系统，后者用来系统管理和开发 CGI 脚本。最后，真正非常严肃地把黑客作为人生目标的人，应该考虑学习 Lisp：Lisp 很值得学习。你掌握它以后，会感到它给你带来的极大启发。这会大大提高你的编程水平，使你成为一个更好的程序员。尽管在实际工作中极少会用到 Lisp。

在讨论学习拉丁语有何价值时，你往往也会听到这一类的话。拉丁语无助于你找工作（也许古典文学教授的工作除外），但是它可以训练你的思维，帮助你更好地运用母语（比如英语）进行写作。但是且慢，拉丁语的比喻并不完全适合 Lisp 语言。拉丁语无助于你找工作的原因是因为没有人说拉丁语。如果你用它写作，没有人能看懂。但是，Lisp 是一种计算机语言，无论我们程序员使用哪一种语言与计算机交谈，它都能听懂。

如果埃里克·雷蒙德没有说错，Lisp 语言确实可以使你成为更好的程序员，那么为什么你不使用它编程呢？如果画家有一支让他画得更好的画笔，我觉得他应该会用这支笔完成所有的画作，对不对？我在这里不是想证明埃里克·雷蒙德错了。他的观点整体上非常正确，他对 Lisp 语言的看法确实是大多数人的看法，但是这里面就是有一个矛盾：Lisp 语言能让你成为更好的程序员，但你却不用它，这难道不奇怪吗？

为什么不用呢？编程语言毕竟是一种工具。如果 Lisp 语言真的能开发出更好的程序，你就应该用它。如果它无助于编程，那么就不会有人需要它。这不仅仅是一个理论问题。软件业是竞争非常激烈的行业，而且容易出现垄断。在不考虑其他情况的条件下，某家公司的软件更快更好用，就会把竞争者赶出这个市场。一旦你开始创业，你就会更深切地感受到这一点。一般情况是，创业公司要么赢得一切，要么彻底失败。你要么成为富翁，要么一无所获。创业的时候，如果你选择了错误的技术，竞争对手就会一举打败你。

罗伯特·莫里斯和我都很了解 Lisp 语言，我们相信自己的直觉，找不出任何不使用它的理由。我们知道其他人都用 C++ 或 Perl 开发软件，但是我们不觉得这说明了什么问题。如果别人用什么技术，你也用什么技术，那么你大概只能使用 Windows 了。选择使用哪一种技术的时候，你不能考虑别人的做法，只能考虑什么样的技术能最好地完成工作。

图 12-1 我和罗伯特·莫里斯在 Viaweb，1996 年年初

创业公司尤其如此。大公司可以互相模仿，但是创业公司就不行。我觉得很多人没有意识到这一点，尤其是一些创业者。大公司每年平均成长大约 10％。所以，如果你掌管一家大公司，只要每件事都做到大公司的平均水准，你就能得到大公司的平均结果，也就是每年成长大约 10％。如果你掌管创业公司，当然也可以这样。你把每件事都做到平均水准，就能得到平均结果。问题在于，小公司的平均结果就意味着关门倒闭。创业公司的生存率远低于 50％。所以，如果你掌管创业公司，最好做一些独特的事情，否则就会有麻烦。

回到 1995 年，我们懂得一些竞争对手不懂的事情（至少在我们看来是如此），这些事情甚至直到今天都很少有人懂：如果开发只在自己服务器上运行的软件，这意味着你想用什么语言就能用什么语言。如果开发桌面软件，就完全不一样了，大多数情况下你只能使用操作系统所用的开发语言。10 年前，开发桌面软件就意味着要使用 C 语言。但是，对于互联网软件，你能使用任何你想用的语言。如果你还同时拥有操作系统和语言的源码，那么你的自由就更大了。

但是，这种新出现的自由是一把双刃剑。既然你可以使用任何语言，你就不得不思考到底使用哪一种语言。如果你的公司对这种选择的自由视而不见，而竞争对手看到了，那么你就有被击败的危险。如果选择哪种语言都行，你到底使用哪一种语言？我们选择 Lisp。首先，很明显，对于这个市场来说，快速开发出产品是很重要的。我们所有人都是从零开始，所以能够快速做出新功能的公司就会取得巨大的竞争优势。我们知道 Lisp 语言真的非常合适快速开发软件，而且我们的软件运行在服务器端，你一写完代码就能发布出去，所以这又进一步放大了快速开发的效果。

如果其他公司不想使用 Lisp 语言，那就更好了。这会让我们拥有技术优势。我们不能放过任何有利的因素。创办 Viaweb 的时候，我们对于如何经营一家公司毫无经验，对市场推广、雇用员工、融资、发展新客户等都一无所知。在此之前，我和莫里斯甚至连一天正式上班的经历都没有。我们唯一擅长的事情就是开发软件。我们希望这一点可以弥补我们的劣势。任何在软件开发上面有助于我们获得优势的事情我们都不能放过。

可以这样说，我们使用 Lisp 只是一个大胆的冒险。我们设想如果用 Lisp 语言开发自己的软件，就能比竞争对手更快地写出新功能，还能做到他们做不到的事情。同时，因为 Lisp 是一种抽象层次非常高的语言，所以就不需要非常庞大的开发团队，这会降低成本。如果我们的设想是正确的，那么我们就能用更少的钱做出一个更好的产品，从而获得利润。最终，我们将独占市场，竞争对手什么也得不到，到头来只能退出这个行业。我们当时心里就是这么盘算的。

这次冒险的结果如何？多少有点出人意料，它竟然达到了我们的设想。我们前前后后遭遇到很多竞争对手，一共大概有二三十个，但是他们的软件没有一个能与我们竞争。我们的软件运行在服务器端，用户可以「所见即所得」地搭建网上商店，感觉就像在操作桌面软件。我们的竞争对手使用 CGI 脚本。我们在功能上总是遥遥领先于他们。有时，他们出于绝望，试图引入我们没有的功能。但是，有了 Lisp 语言的帮助，我们的开发周期很短。有时候，竞争对手刚刚发布新闻稿宣布将引入新功能，我们就能在一两天内做出自己的版本。当对手找来的记者抽出时间打电话过来想了解我们的反应，我们就会告诉他我们已经有了这个功能。

竞争对手一定觉得我们好像拥有了某种秘密武器，能够破解他们内部的通信或者其他机密。事实上，我们的确拥有秘密武器，但是没他们想的那么复杂。从来没有人向我们泄露他们的内部机密，只是我们的开发速度比别人想象的更快而已。

9 岁时，我碰巧读过弗雷德里克·福赛思的小说《刺杀戴高乐》（The Day of the Jackal）。小说的主角是一个刺客，有人雇他暗杀法国总统。那个刺客必须通过警察的岗哨才能到达可以俯视总统行进路线的公寓。他扮成拄着拐杖的老头从警察身边经过，没有引起任何人的怀疑。

我们的秘密武器很类似上面的情景。我们使用一种奇特的人工智能语言开发软件，它的语法非常古怪，大量使用括号。多年来，要是听到别人这样描述 Lisp 语言，我会勃然大怒。但是现在，这却成了我们的优势。在竞争中，你的对手无法理解你的技术优势，这可是再宝贵不过了。商场如战场，对手摸不透你，你的胜算就增加了。

虽然有些令人难为情，但是我必须承认，就是因为这个原因，在 Viaweb 创业期间我从来没有公开谈论过 Lisp 语言。我们对新闻媒体闭口不谈 Lisp，如果你在我们的网站上搜索 Lisp，只会发现我在个人介绍中提到过两次，那是我写的两本关于 Lisp 的书。这是故意的，创业公司对竞争对手应该越保密越好。如果他们不知道（或者不关心）我们的软件用什么语言开发，我就要把这个秘密保持下去。 [3] 

最了解我们技术的人就是客户。他们不关心 Viaweb 用什么语言开发，但是发现它真的很好用。Viaweb 可以让用户在几分钟内搭建起漂亮的网上商店。因此，主要通过口碑效应，我们得到了越来越多的新客户。1996 年年底，我们支持的网上商店大约是 70 家。1997 年，变成了 500 家。6 个月后，雅虎收购我们的时候，我们有 1070 个用户。更名为 Yahoo Store 之后，这个软件继续主导市场，它是雅虎获利最丰厚的业务之一，用它搭建的商店成为「雅虎购物」（Yahoo Shopping）的基础。我在 1999 年离开了雅虎，所以不知道现在的准确用户数量，但是我上一次听到的数字是超过了 2 万。

### 12.2 Blub 困境

Lisp 语言到底好在什么地方？如果它真的这么好，为什么没有得到广泛使用呢？这种问题听起来有点像绕口令，但是实际上回答起来很简单。Lisp 语言的好处不在于它有一些狂热爱好者才明白的优点，而只在于它是目前最强大的编程语言。它没有得到广泛使用的原因就是因为编程语言不仅仅是技术，也是一种习惯性思维，非常难于改变。当然，上面两句话都需要进一步解释。

我先从一个争议极大的命题开始讲起：编程语言的编程能力有差异。至少不会有人反对高级语言比机器语言更强大这一观点。今天的大多数程序员通常情况下都不会想用机器语言编程，而是使用一种高级语言，然后再让编译器帮你把它翻译成机器语言。这种观念甚至已经移植到了硬件，从 20 世纪 80 年代开始，硬件的指令集都是针对编译器而不是针对程序员设计的。

大家都知道，徒手用机器语言写出整个程序是一件很蠢的事。但是，把这个观点推广到一种更普遍的情况，知道的人就不多了。如果你有好几种语言可以选择，在不考虑其他因素的情况下，你不选择最强大的那种语言就是一件很蠢的事。 [4] 

上面这个观点有许多例外情况。如果在开发的程序必须与另一个程序紧密配合，那么可能最好还是使用后者的开发语言。如果你的程序只是要做一些很简单的事（比如整数运算或者位操作），那就不妨使用一种比较靠近机器的低层次语言，主要原因是这样运行起来会更快一些。如果你的程序很短，只是为了特定场合一次性使用，那么你最好根据自己要解决的问题选择具有最强大函数库的语言。不过，总的来看，对于应用程序来说，还是应该选择总体最强大、效率也在可接受范围内的编程语言，否则都是不正确的选择，就好像你选择机器语言编程一样，只是程度上有差异而已。

大家都公认机器语言属于非常低层次的语言。但是，至少在社会上很多人眼里，高级语言其实也差不多。但事实并非如此，高级语言与机器语言的差别很大。从技术上看，「高级语言」并不是一个定义很清晰的名词。在高级语言与机器语言之间并不存在一条明确的分界线。语言的抽象性是一条连续曲线， [5] 从最强大的语言一直到最底层的机器语言，每一种语言的能力都有差异。

以 Cobol 语言为例，通过编译器，它可以被编译成机器语言。从这个角度来说它是一种高级语言。但是，有谁会真的把 Cobol 当成与其他高级语言（比如 Python）一样强大的语言？比起 Python，它可能更接近机器语言。Perl 4 如何？与 Perl 5 相比，它不支持闭包。所以，大多数 Perl 的黑客都认为 Perl 5 比 Perl 4 更强大。如果你同意这一点，就意味着你也认可一种高级语言可以比另一种高级语言更强大。因此，必然能够接着推导出，除了某些特殊情况，你就是应该使用目前最强大的语言。

不过在现实中这个结论很少能落实。到了一定年龄之后，程序员极少主动更换自己的编程语言。不管习惯使用的是哪一种语言，他们往往认为这种语言已经足够好了。程序员非常忠于他们心爱的语言，我不想伤害任何人的感情，所以为了解释我的观点，我假设有一种 Blub 语言。它的抽象程度正好落在编程能力曲线的中点。它不是最强大的语言，但是要比 Cobol 或机器语言更高级。

我们假设 Blub 程序员既不使用机器语言也不使用 Cobol 语言。他认为前者是编译器的工作，后者他不知道有什么用（Cobol 语言甚至连 XX 功能也没有，Blub 语言就具备这个功能）。只要这位程序员向曲线下方望去，他就肯定知道自己正在看的是一些比较低层次的语言。因为那些语言明显不如 Blub 语言强大，缺少他习惯使用的某些功能。但是，当他向曲线上方望去，他不会意识到自己正在看更高层次的语言，而是仅仅觉得自己正在看某些奇怪的语言。他可能认为那些语言也许与 Blub 一样强大，但是加入了不少怪东西。他觉得 Blub 语言已经够用了，不用再考虑那些语言了。这时，他的思维就是已经被 Blub 同化了。

但是，当我们转换视角，把自己想象成使用曲线更上方某一种语言的程序员并往下看的时候，我们就会发现，自己也同样轻视 Blub 语言。你怎么用 Blub 语言完成工作呢？它甚至连 YY 功能都没有！

通过归纳法我们就会知道，唯一洞悉所有语言优劣的人必然是懂得最强大的那种语言的人。（这大概就是埃里克·雷蒙德所说的 Lisp 语言使你成为一个更好的程序员的意思。）由于 Blub 困境的存在，你无法信任其他人的意见：他们都满足于自己碰巧用熟了的那种语言，他们的编程思想都被那种语言主宰了。

我自己的经历也证实了这个看法。高中时我喜欢用 Basic 语言编程。这种语言功能很弱，甚至不支持递归，很难想象没有递归还怎么编程。但是我那时根本没觉得有损失，Basic 语言控制了我的思维。当时我非常精通 Basic 语言，只要是学过的部分都能熟练地使用。

雷蒙德推荐的五种黑客应该学会的语言，其强大程度各有不同，分布在编程能力曲线五个不同的点上。它们的相对位置是一个敏感的话题。我只想说，我认为，Lisp 语言在最上方。为了证明这个论断，让我告诉你，我发现 Lisp 有一个功能，其他四种语言都没有。我觉得，没有宏（macro）的话，那些语言怎么编程呢？ [6] 

许多语言自称也有宏，但是 Lisp 的宏是独一无二的。信不信由你，Lisp 宏的作用与括号有关。Lisp 语言的设计者大量使用括号并不是为了标新立异。Blub 语言的程序员会觉得 Lisp 代码看上去很怪，有那么多括号，但这是有原因的。它们是 Lisp 与其他语言存在巨大差异的外在表现。

Lisp 代码由 Lisp 数据对象构成。其他语言的源代码一般由字符组成，字符串是主要数据类型之一，但是 Lisp 语言不完全是这样。经过解析器处理之后，Lisp 代码就变成了你可以遍历的数据结构。

1『代码经解析直接变成数据结构，因为那些括号是二叉树结构的，慢慢有点感觉了。（2020-12-16）』

如果你理解编译器的工作原理，那么事实是，与其说 Lisp 有一种很奇特的语法，还不如说它根本没有语法。一般的源代码程序经过编译器解析会生成解析树。Lisp 的奇特之处就在于，你可以完全写出程序，控制这种解析树，进行任意的存取操作。Lisp 的这种程序就叫做宏，它们可以用来生成其他程序。

生成其他程序的程序？什么时候需要用到它们？如果你用 Cobol 语言思考，会觉得很少需要用到它们。如果你用 Lisp 语言思考，会发现它们无所不在。我要是在这里举一个 Lisp 宏功能强大的实例，可能更便于说明问题。你看这个例子！是不是很方便啊？但是如果这样做，对于不懂 Lisp 语言的人来说，这篇文章就不知所云了。本文没有办法把所有事情都解释清楚，无法帮助你彻底理解这门语言。我在 Ansi Common Lisp 一书中已经尽可能地简化内容、快速讲解，但是也要到全书篇幅将近一半的地方（第 11 章）才能讲到宏。

1-2『又见到了宏 macro，一定要去弄明白其真实含义。已下载作者的书籍「2019118ANSI-Common-Lisp」和「2019119On-Lisp」。（2020-12-16）』——未完成

但是我想可以给出事实证明我的这个观点。Viaweb 编辑器的源码之中大约 20％-25％ 是宏。它们比普通的 Lisp 函数难写，而且如果用在不必要的地方，反而是一种很不良的编程习惯。所以，我们代码中的每一个宏都有充分的使用理由。这意味着这个程序至少 20％-25％ 代码的功能无法轻易地用其他语言实现。我在前文一再声称 Lisp 语言无比强大，无论 Blub 语言的程序员对此多么怀疑，看到这个事实应该足以让他感到很好奇，我们居然用到了这么多宏。我们这样写代码并不是为了好玩。我们是一家小创业公司，拼尽全力写代码，只是为了给竞争对手布下重重障碍，不让他们赶上来。

抱有怀疑态度的人可能会想上面的论断是否成立，两者之间是否存在相关关系。我们的一大块代码能够做到其他语言很难做到的事。只凭这一点是否能得出结论：我们的软件能够做到竞争对手的软件做不到的事？我必须说，这里面可能就是存在相关关系。我鼓励你继续深入思考这个问题。表面上，一个老年人拄着拐杖蹒跚而行，你不要只是看看而已，他背后可能有更多的故事值得了解，你应该想得更深一些。

### 12.3 创业公司的合气道 [7] 

尽管 Lisp 语言非常强大，但是我并不期望有谁（超过 25 岁的人）读完这篇文章就立刻开始学习它。我写这篇文章的目的不是想改变任何人的观点，而是想让那些有兴趣学习 Lisp 语言的人放心，他们知道 Lisp 是一种强大的语言，但是担心使用者太少，学会了也没什么用。我想让他们明白，在商业竞争中使用 Lisp 语言就会带来优势。你的竞争对手不懂 Lisp，这将使得它的强大更充分地表现出来。

如果你想在创业公司中使用 Lisp 语言，你不仅不应该担心使用它的人太少，反而应该希望这种局面保持下去。事实上，现状很可能真的会保持下去。因为编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。人类天性变化的速度大大慢于计算机硬件变化的速度，所以编程语言的发展通常比 CPU 的发展落后一二十年。在麻省理工学院这样的地方，20 世纪 60 年代初就开始使用高级语言了。但是，许多公司直到 80 年代还在用机器语言编程。我敢打赌，很多人对机器语言恋恋不舍，直到 CPU 开始采用精简指令集 [8] 了才不得不放弃使用机器语言。这就好比酒吧已经到了打烊时间，酒保开始整理桌子、收拾东西准备回家，客人才被迫离开。

技术的变化速度通常是很快的。但是，编程语言不一样，与其说它是技术，还不如说是程序员的思考模式。编程语言是技术和宗教的混合物。 [9] 所以，一种很普通的编程语言就是很普通的程序员使用的语言，它的变化就像冰山那样缓慢。大概在 1960 年，Lisp 语言引入了垃圾回收机制（Garbage Collection），今天已经被广泛认为是非常好的做法。Lisp 的动态类型特点也同样受到越来越多人的认同。闭包是 20 世纪 60 年代 Lisp 语言引入的功能，现在的接受程度还很低。宏也是 60 年代中期 Lisp 语言引入的，现在还是一片处女地。

很显然，那些很普通的编程语言正在主导一切。我不建议你挑战这种强大的习惯势力，相反，我建议你向日本合气道选手学习，利用这种势力削弱你的竞争对手，让他们自食其果。如果你为大公司工作，想要改用 Lisp 语言可能不是一件容易的事。你很难说服自以为是的老板，让他允许你用 Lisp 语言开发程序。老板受到报纸的影响，认为某些其他语言将主宰世界（就像 20 年前 Ada 语言受到的评价）。但是，如果你为创业公司工作，那里没有这样的老板，那么你就能和我们一样，将他人的 Blub 困境转变为你的优势。你的竞争对手被牢牢粘在那些很普通的语言上面，永远都追不上你使用的技术。

如果你为创业公司工作，那么这里有一个评估竞争对手的妙招 —— 关注他们的招聘职位。他们网站上的其他内容无非是一些陈腐的照片和夸夸其谈的文字，但是招聘职位却不得不写得很明确，反映出他们到底想干什么，否则就会引来一大批不合适的求职者。

在 Viaweb 创业期间，我读过大量竞争对手的招聘职位。差不多每个月都有一个新的竞争对手浮出水面。我首先会看他们的产品有没有一个试用版，然后就去找他们的招聘职位。这样过了几年，我就知道哪些公司值得关注，哪些公司不用在意。有些公司的职位描述使用了大量的 IT 词汇，这样的内容越多，这家公司就越不构成威胁。最不用担心的竞争对手就是那些要求应聘者具有 Oracle 数据库经验的公司，你永远不必担心他们。如果是招聘 C++ 或 Java 程序员的公司，对你也不会构成威胁。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司，就会真的感到如临大敌。

### 注释

[1] 在英语中，via 是一个介词，意为「经过……」，所以 Viaweb 的意思就是经过网络。—— 译者注

[2] 一开始的时候，Viaweb 有两个部分 —— 编辑器和订单处理系统。前者用 Common Lisp 开发，主要供用户搭建自己的网站。后者用 C 语言开发，主要用来处理订单。在 Viaweb 的第一版中，Lisp 是最主要的开发语言，因为订单处理系统非常小，占用的代码很少。2003 年 1 月，Yahoo 发布了 Viaweb 编辑器的新版本，采用 C++ 和 Perl 开发。但是，为了把原始程序翻译成 C++，他们可能不得不专门写一个 Lisp 解释器，因为据我所知，Viaweb 所有的页面生成模板还没变，都是使用 Lisp 代码。（参见 Greenspun 写的 Tenth Rule 一书第 198 页。）

[3] 莫里斯觉得不用这么保密，因为即使竞争对手知道我们使用 Lisp 语言，对他们也不会有帮助：「如果他们真的聪明，早就已经在用 Lisp 编程了。」

[4] 如果从图灵等价（Turing-equivalent）的角度来看，所有语言都是一样强大的，但是这对程序员没有意义。（没人想为图灵机编程。）程序员关心的那种强大也许很难正式定义，但是有一个办法可以解释，那就是有一些功能在一种语言中是内置的，但是在另一种语言中需要修改解释器才能做到，那么前者就比后者更强大。如果 A 语言有一个运算符，可以移除字符串中的空格，而 B 语言没有这个运算符，这可能不足以称 A 语言比 B 语言强大，因为你可以在 B 语言里写一个函数实现这个功能。但是，如果 A 语言支持某种高级功能（假定是递归），而 B 语言不支持，你就不可能通过自己编写函数库解决了，所以这就代表 A 语言比 B 语言更强大。

[5] 语言之间的关系或许还可以比喻成栅格结构（lattice），从下往上朝着顶端慢慢收窄。具体的形状在这里并不重要，重点是语言之间至少存在着一种偏序关系（partial order）。

[6] 把宏说成一种独立的功能有误导之嫌。在实际运用中，如果没有其他 Lisp 功能（比如闭包和函数的 rest 参数）的配合，Lisp 的宏也不会有太大作用。

[7] 合气道（Aikido）是一种日本的武术，主要特点是「以柔克刚」、「借劲使力」、「不主动攻击」。—— 译者注

[8] 精简指令集（Reduced Instruction Set Computing，简称 RISC）是 CPU 的一种设计模式，对指令数目和寻址方式都做了精简，使其实现更容易，执行速度更快，编译器的效率更高。它在 20 世纪 80 年代开始得到大规模采用。—— 译者注

[9] 所以，如果你想对编程语言进行比较，那就做好准备打一场宗教战争，或者索性就写一本绝对不带个人色彩的大学教材，枯燥得像人类学研究一样。那些喜欢平静生活的人以及想要得到终身教职的人对这个话题唯恐避之不及。但是，必须承认的是，它只是一半与宗教有关，所以剩下的一半依然值得研究，尤其是当你要设计新语言的时候。

## 1301. 书呆子的复仇

软件业有一场永不停息的战斗，书生气的开发者与官僚主义的经理之间总是发生冲突。大家应该都看过漫画《呆伯特》，熟悉里面那个发型高耸的经理。[1] 我想，技术行业的大部分人对这个角色都过目难忘，因为在他们的公司里就有这个角色的原型。那些经理奇迹般地同时具备了两种很常见但很难结合在一起的特点：1）对技术一无所知；2）对技术有强烈的个人观点。

举例来说，假设你需要写一个软件。你的经理根本不懂这个软件的运作机制，也不知道各种编程语言有什么区别。但是，他竟然明确要求你一定要使用某一种语言进行开发。没错，他就是要求你一定要用 Java 语言。为什么他会提出这种要求？让我们看看他脑袋里是怎么想的。他的想法无非就是，Java 是业界的标准。我知道肯定如此，因为媒体对此有铺天盖地的报道。既然它是标准，那么使用它就不会错。另外，这也意味着人才市场上肯定有无数 Java 程序员，即使现在为我打工的这批人都辞职了（真奇怪，这种事情总是不断发生），我也能够轻易地找到替代者。

嗯，这听起来也不无道理。但是，它的前提是一个没有说出口的假设，而这个假设实际上是错的。你的经理相信所有编程语言的功能都差不多，可以互相替代。如果这种想法是对的，那么他要求你用 Java 编程就很合理了。反正编程语言之间没有区别，那么就用大家都在用的那种语言吧。

但是，编程语言是不一样的。就算不探讨各种语言之间的具体区别，我也能向你证明这一点。回到 1992 年，如果你问经理使用什么语言开发软件。他会像今天一样毫不迟疑地回答说 C++。如果所有编程语言都一样，为什么答案变了？进一步说，为什么 Java 语言的设计者要如此麻烦地去创造一种新语言呢？

一般来说，如果你动手创造一种新语言，那是因为你觉得它在某些方面会优于现有的语言。Java 语言之父詹姆斯·戈斯林在第一份《Java 白皮书》中说得很清楚，之所以要设计 Java，就是想解决 C++ 的一些弱点。所以结论就是，各种编程语言的编程能力是不相同的。如果你接受你的经理的假设，然后一路追溯到 Java 语言的源头，就会得到与他的假设完全不同的结果。

到底谁对？戈斯林还是你的经理？结果当然是意料之中的，戈斯林是正确的。某些情况下，一些语言就是比另一些语言更出色。可是这样一说又导致了另外的问题。C++ 不适合解决某些难题，所以 Java 才被设计出来。那么，什么情况下应该使用 Java，什么情况下应该使用 C++ 呢？会不会某些情况下其他语言比它们更合适呢？

一旦你开始思考这个问题，就会发现它非常棘手。如果你的经理被迫去想这个问题，当他看到它的复杂性时，脑袋恐怕都会爆炸。如果所有语言真的都一样，那么他只需选择一种看上去获得大部分人拥戴的语言就可以了，因为这实际上是一种流行风尚，而不是技术问题，所以即使像你的经理这样对技术无知的人也有可能轻松得到正确答案。但是，如果语言各有不同，你的经理就会突然发现，有两个互相关联的方程，他必须找到一个能够同时满足两个方程的最佳解，而最要命的却是他对此根本一无所知。第一个方程是找到（相对于要解决的问题）能够适用 20 年左右的最佳语言，第二个方程是（为这种语言）找到合适的程序员、函数库的机会有多大。如果假定所有语言都不同，就会遇到这种苦苦求解的情况，所以难怪你的经理不愿意接受这个假设了。

认为所有语言都一样的看法的缺点是自欺欺人，但是优点是可以使许多事情变得很简单。我想这就是为什么它被广泛接受的主要原因。它是一个令人舒服的想法。

大家都觉得 Java 一定有过人之处，因为它是一种很酷的新兴编程语言。但是真的如此吗？如果你站在远处观察编程语言的世界，似乎 Java 就是最新的东西。（如果你站得足够远，那么你看到的所有东西就是 Sun 公司出钱制作的大型霓虹广告牌。）但是，如果你靠近观察这个世界，就会发现不同的人对「酷」的理解是不一样的。在黑客圈子里，Perl 被公认比 Java 酷得多。黑客社区网站 Slashdot 就是用 Perl 开发的。我估计你不可能看到黑客愿意使用 Java 的 JSP 技术开发网站。可是，还有一种更新的语言叫做 Python，它的使用者往往看不起 Perl。另一些人则认为 Ruby 语言是取代 Python 的最佳选择。

当你按照 Java、Perl、Python、Ruby 这样的顺序观察这些语言，你会发现一个有趣的结果。至少，如果你是一个 Lisp 黑客，你就看得出来，排在越后面的语言越像 Lisp。Python 语言模仿 Lisp，甚至把许多 Lisp 黑客认为属于设计错误的功能也一起模仿了。至于 Ruby 语言，如果回到 1975 年，你声称它是一种有着自己句法的 Lisp 方言，没有人会提出反对意见。编程语言现在的发展不过刚刚赶上 1958 年 Lisp 语言的水平。

1『颠覆了自己之前的认知，lisp 竟然这么「先进」的。（2002-12-17）』

### 13.1 朝着数学的方法发展

1958 年，约翰·麦卡锡第一个提出了 Lisp 语言。我认为，当前最流行的编程语言不过只是实现了他在 1958 年的想法而已。这怎么可能呢？计算机技术的发展不是日新月异吗？1958 年的计算机的运算能力还不如今天的电子表，而体积却大得像冰箱。[2] 那时的技术怎么可能超过今天的水平呢？

图 13-1 IBM 704，美国劳伦斯利弗莫尔国家实验室，1956 年

让我告诉你原因。这是因为设计者本来没打算把 Lisp 设计成编程语言，至少不是我们现在意义上的编程语言。我们今天所说的编程语言指的是用来告诉计算机怎么做的一种工具。麦卡锡最后确实有意开发这种意义上的编程语言，但是实际上他做出来的 Lisp 却是完全不同的一种东西，语言的基础是他的一种理论演算，他想用更简洁的方式定义图灵机。正如他后来所说：

Lisp 比图灵机表达起来更简洁。证明这一点的一种方法就是写一个 Lisp 通用函数，证明它比图灵机的一般性描述更短、更易懂。这个 Lisp 函数就是 eval……它用来计算 Lisp 表达式的值……。编写 eval 函数需要发明一种表示法，能够把 Lisp 函数表示成 Lisp 数据。设计这种书写法完全是为了满足论文写作的需要。（我）根本没有想过用它来编写 Lisp 程序并在计算机上运行。

1-2『确认了，autolisp 里也有 eval 函数，[eval (AutoLISP)](http://help.autodesk.com/view/OARX/2018/CHS/?guid=GUID-D9B3E6CC-A982-4040-AE6E-6FD63D6C54D0)，那么是否意味着 autolisp 也可以自行开发出「元编程」的实践，待研究。（2020-12-17）』——未完成

图 13-2 书呆子之王约翰·麦卡锡

1958 年年底，麦卡锡的一个学生史蒂夫·拉塞尔 [3] 看到了 eval 函数的定义，意识到如果把它翻译成机器语言，就可以把 Lisp 解释器做出来。这在当时是非常令人吃惊的事。麦卡锡后来回忆：

拉塞尔对我说：「我想把 eval 编成程序……」我告诉他，别把理论和实践混淆，eval 只是用来读的，不是用来做计算的。但是他执意要做，并且还真的做出来了。就是说，他把我论文中的 eval 编译成了 [IBM] 704 计算机的机器码，修正了 bug，然后对外宣布做出了 Lisp 语言的一种解释器，这倒没有说错，确实如此。所以，从那个时候开始，Lisp 语言就基本上是它现在的样子了……

这样一下子，就在几个星期之内，麦卡锡发现他的理论演算变成了一种实际的编程语言，而且出乎意料地强大。由此也就得出了 20 世纪 50 年代的编程语言到现在还没有过时的原因。简单说，因为这种语言本质上不是一种技术，而是数学。数学是不会过时的。你不应该把 Lisp 语言与 50 年代的硬件联系在一起，而是应该把它与快速排序（Quicksort）算法进行类比。这种算法是 1960 年提出的，至今仍然是最快的通用排序方法。

1『 lisp 语言本质上是数学，醍醐灌顶，怪不得那么多大牛如此推崇 lisp。（2020-12-17）』

Fortran 语言也是 20 世纪 50 年代出现的，并且一直使用至今。它代表了语言设计的一种完全不同的方向。Lisp 语言是无意中从纯理论发展为编程语言的，而 Fortran 从一开始就是作为编程语言设计出来的。但是，今天我们把 Lisp 看成高级语言，而把 Fortran 看成一种相当低层次的语言。

1956 年 Fortran 刚诞生的时候，叫做 Fortran I，与今天的 Fortran 语言差别极大。Fortran I 实际上是汇编语言加上数学，在某些方面还不如今天的汇编语言强大。比如，它没有子例程，只有分支跳转结构（branch）。今天的 Fortran 语言可以说更接近 Lisp 而不是 Fortran I。

Lisp 和 Fortran 代表了编程语言发展的两大方向。前者的基础是数学，后者的基础是硬件架构。从那时起，这两大方向一直在互相靠拢。Lisp 语言刚设计出来的时候就很强大，接下来的二十年它提高了运行速度。而那些所谓的主流语言把更快的运行速度作为设计的出发点，然后再用四十多年的时间一步步变得更强大。直到今天，最高级的主流语言也只是刚刚接近 Lisp 的水平。虽然已经很接近了，但还是没有 Lisp 那样强大。

### 13.2 为什么 Lisp 语言很特别

Lisp 语言诞生的时候就包含了 9 种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有 2 种是 Lisp 独有的。按照被大众接受的程度，这 9 种思想依次如下排列。

1、条件结构（即 if-then-else 结构）。现在大家都觉得这是理所当然的，但是 Fortran I 就没有这个结构，它只有基于底层机器指令的 goto 结构。

2、函数也是一种数据类型。在 Lisp 语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。

3、递归。Lisp 是第一种支持递归函数的高级语言。[4] 

4、变量的动态类型。在 Lisp 语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。

5、垃圾回收机制。

6、程序由表达式组成。Lisp 程序是一些表达式树的集合，每个表达式都返回一个值。这与 Fortran 和大多数后来的语言都截然不同，它们的程序由表达式和语句组成。区分表达式和语句在 Fortran I 中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。

后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从 Fortran 扩散到 Algol 语言，接着又扩散到它们两者的后继语言。

7、符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。

8、代码使用符号和常量组成的树形表示法。

9、无论什么时候，整个语言都是可用的。Lisp 并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。

在读取期运行代码，使得用户可以重新调整（reprogram）Lisp 的语法；在编译期运行代码，则是 Lisp 宏的工作基础；在运行期编译代码，使得 Lisp 可以在 Emacs 这样的程序中充当扩展语言（extension language）；在运行期读取代码，使得程序之间可以用 S 表达式（S-expression）通信，近来 XML 格式的出现使得这个概念被重新「发明」出来了。[5] 

1『比较两个字符串是否相等其实只需比较它们的指针是否一样即可，无需逐个字符比较，这个知识点直觉上有大用。（2020-12-17）』

Lisp 语言刚出现的时候，这些思想与其他编程语言大相径庭，后者的设计思想主要由 50 年代后期的硬件决定。随着时间流逝，流行的编程语言不断更新换代，语言设计思想逐渐向 Lisp 靠拢。思想（1）到思想（5）已经被广泛接受，思想（6）开始在主流编程语言中出现，思想（7）在 Python 语言中有所实现，不过似乎没有专用的语法。

思想（8）可能是最有意思的一点。它与思想（9）只是由于偶然原因才成为 Lisp 语言的一部分，因为它们不属于麦卡锡的原始构想，是由拉塞尔自行添加的。它们从此使得 Lisp 语言看上去很古怪，但也成为了这种语言最独一无二的特点。说 Lisp 语言古怪倒不是因为它的语法很古怪，而是因为它根本没有语法，程序直接以解析树（parse tree）的形式表达出来。在其他语言中，这种形式只是经过解析在后台产生，但是 Lisp 直接采用它作为表达形式。它由列表构成，而列表则是 Lisp 的基本数据结构。

用一门语言自己的数据结构来表达该语言是非常强大的功能。思想（8）和思想（9），意味着你可以写出一种能够自己编程的程序。这可能听起来很怪异，但是对于 Lisp 语言却是再普通不过。最常用的做法就是使用宏。术语「宏」在 Lisp 语言中的意思与其他语言中的不一样。Lisp 宏无所不包，它既可能是某样表达式的缩略形式，也可能是一种新语言的编译器。无论是想真正理解 Lisp 语言，还是只想拓宽编程视野，最好都学学宏。

1-2『这里看是对「元编程」、「宏」有那么一点点感觉了。补充进「宏」的术语卡里。』——已完成

就我所知，宏（采用 Lisp 语言的定义）目前仍然是 Lisp 独有的。一个原因是为了使用宏，你大概不得不让你的语言看上去像 Lisp 一样古怪。另一个可能的原因是，如果你想为自己的语言添上这种终极武器，你从此就不能声称自己发明了新语言，只能说发明了一种 Lisp 的新方言。

我把这件事当作笑话说出来，但是事实就是如此。如果你创造了一种新语言，其中有 car、cdr、cons、quote、cond、atom、eq 这样的功能，还有一种把函数写成列表的表示方法，那么在它们的基础上完全可以推导出 Lisp 语言的所有其他部分。事实上，Lisp 语言就是这样定义的，麦卡锡把语言设计成这个样子就是为了让这种推导成为可能。

### 13.3 语言优势真正体现的地方

就算 Lisp 确实代表了目前主流编程语言不断靠近的一个方向，这是否意味着你就应该用它编程呢？如果使用一种不是如此强大的语言，你又会有多少损失呢？有时不采用最尖端的技术不也是一种明智的选择吗？这么多人使用主流编程语言，这本身不也说明那些语言有可取之处吗？举例来说，你的经理不正是希望使用一种很容易雇到程序员的语言吗？

另一方面，许多项目是无所谓选择哪一种编程语言，反正不同的语言都能完成工作。一般来说，条件越苛刻的项目，强大的编程语言就越能发挥作用。但是，无数的项目根本没有苛刻条件的限制。大多数的编程任务可能只要写一些很小「胶水程序」，然后再把这些小程序连起来就行了。你可以用自己熟悉的编程语言或者用对于特定项目来说有着最强大函数库的语言来写这些「胶水程序」。如果你只是需要在 Windows 应用程序之间传递数据，使用 Visual Basic 照样能达到目的。

你也可以使用 Lisp 语言编写这些小程序（我用它写了桌面计算器），但是 Lisp 的最大优势体现在编程任务的另一端，就是在激烈竞争的条件下开发那些解决困难问题的复杂程序。ITA 软件公司为 Orbitz 旅行社开发的飞机票价搜索程序就是一个很好的例子。网络订票市场很难进入，因为它已经被两大巨头（Travelocity 和 Expedia）牢牢控制了，但是 ITA 的软件性能看上去使得那两家公司的软件顿时相形见绌。

ITA 的软件的核心是一个 20 万行的 Common Lisp 程序，它的搜索能力比竞争对手高出许多个数量级。那些竞争对手依然使用大型机时代的编程方法。我没有看过 ITA 的软件源码，但是据一个为它工作的顶尖黑客说，他们使用了大量的宏。果然不出我所料。

### 13.4 向心力

我承认，使用一种不常用的技术也有代价。你的经理担心这一点并不是完全没有道理的。但是，因为他不懂风险出在什么地方，所以往往把风险夸大了。使用一种不常见的语言会出现的问题我想到了三个：你的程序可能无法很好地与使用其他语言写的程序协同工作；你可能找不到很多函数库；你可能不容易雇到程序员。

它们有多严重？第一个问题取决于你是否控制整个系统。如果你的软件运行在客户的机器上，而客户又使用一个到处都是 bug 的专有操作系统（我可没提操作系统的名字），那么使用那个操作系统的开发语言可能会给你带来优势。但是，如果你控制整个系统，并且还有各个组成部分的源码（正如我推测 ITA 就是这种情况），那么你就能使用任何你想用的语言。如果出现不兼容的情况，你自己就能动手解决。

把软件运行在服务器端就可以没有顾忌地使用最先进的技术。乔纳森·埃里克森说现在是「编程语言的文艺复兴时期」，我想最大的原因就是有了服务器端软件。这也能解释为什么像 Perl 和 Python 这样的新语言会流行起来，它们之所以流行不是因为人们使用它们开发 Windows 应用程序，而是因为人们在服务器上使用它们。随着软件从桌面端向服务器端转移（连微软公司都看出这是未来的趋势），逼迫你使用某一种语言的限制将越来越少。

至于第二个问题，函数库的重要性也取决于你的应用程序。对于那些条件不苛刻的应用，有没有一个好的函数库比语言本身的能力更重要。那么到底应该怎么选择语言？是根据函数库，还是根据语言本身的能力？很难确切地找出一条清楚的规则，但是无论哪种情况，你都必须考虑到你开发的应用程序的特点。如果你是一家软件公司，你开发的程序打算拿到市场上销售，那么这个程序可能会耗费好几个优秀程序员至少 6 个月的时间。为一个这样规模的项目选择编程语言，语言本身要有强大的编程能力可能就是最重要的考虑因素，比是否有方便的函数库更重要。

第三个问题是你的经理担忧雇不到程序员，我认为这根本就是混淆视听。说实话，你究竟想雇用多少个黑客？到目前为止，大家公认少于 10 个人的团队最适合开发软件。雇用这样规模的开发团队，只要使用的不是无人知道的语言，应该都不会遇到很大麻烦。如果你无法找到 10 个 Lisp 黑客，那么你可能选错了创立软件公司的城市。

事实上，选择更强大的编程语言会减少所需要的开发人员数量。因为：1）如果你使用的语言很强大，可能会减少一些编程的工作量，也就不需要那么多黑客了；2）使用更高级语言的黑客可能比别的程序员更聪明。

我不是说外界因素对你没有影响，肯定还是会有很大压力，逼迫你使用公认的「标准」技术。Viaweb 创业期间，很多风险投资商和潜在的并购方看到我们使用 Lisp 语言都感到很吃惊和不以为然。但是，我们让他们吃惊的还不止这一个地方，我们使用普通的兼容机充当服务器，而不是「企业级」的 Sun 服务器；我们使用那时还默默无闻的开源 Unix 系统 FreeBSD，而不是流行的商业操作系统 Windows NT；我们也没有采用 SET（Secure Electronic Transaction，安全电子交易），它被认为将成为电子商务标准，而实际上现在没人记得它。诸如此类的事情还有很多。

你不能让那些衣冠楚楚、西装革履的家伙替你做技术决策。潜在的并购方有没有对我们使用 Lisp 语言感到很难接受？稍微有一点吧，但是如果我们不使用 Lisp，我们就根本写不出现在的软件，也就不会有人想收购我们。他们眼中不正常的事情恰恰就是使得这一切发生的原因所在。

如果你创业的话，千万不要为了取悦风险投资商或潜在并购方而设计你的产品。让用户感到满意才是你的设计方向。只要赢得用户，其他事情就会接踵而来。如果没有用户，谁会关心你选择的「正统」技术是多么令人放心。

### 13.5 随大流的代价

使用一种不强大的语言，你的损失有多大？实际上有一些现成的数据可以说明这个问题。衡量语言的编程能力的最简单方法可能就是看代码数量。所谓高级语言，就是能够提供更强大抽象能力的语言，从某种意义上，就像能够提供更大的砖头，所以砌墙的时候用到的砖头数量就变少了。因此，语言的编程能力越强大，写出来的程序就越短（当然不是指字符数量，而是指独立的语法单位）。

强大的编程语言如何让你写出更短的程序？一个技巧就是（在语言允许的前提下）使用「自下而上」（bottom-up）的编程方法。你不是用基础语言（base language）开发应用程序，而是在基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。这样写出来的代码会比直接用基础语言开发出来的短得多。实际上，大多数压缩算法也是这样运作的。「自下而上」的编程往往也便于修改，因为许多时候你自己添加的中间层根本不需要变化，你只需要修改前端逻辑就可以了。

1-2『自下而上的编程方法。在基础语言之上先构建一种自己的语言（感觉就是郑烨常说的领域语言），然后用这套语言去做开发，实现需求。这个信息绝对是块金砖，不过目前还无法完全吃透。做一张主题卡片。』——已完成

代码的数量很重要，因为开发一个程序所耗费的时间主要取决于程序的长度。对于同一个软件，如果用一种语言写出来的代码比用另一种语言长三倍，这意味着你开发它耗费的时间也会多三倍。而且即使多雇人手，也无助于缩短开发时间，因为当团队规模超过某个门槛时，再增加人手只会带来净损失。Fred Brooks 在他的名著《人月神话》中描述了这种现象，我的所见所闻印证了他的说法。

如果使用 Lisp 语言，程序能变得多短？以 Lisp 和 C 的比较为例，我听到的大多数说法是 C 代码的长度是 Lisp 的 7 倍到 10 倍。但是最近，New Architect 杂志上有一篇介绍 ITA 软件公司的文章 [6] ，里面说「1 行 Lisp 代码相当于 20 行 C 代码」，因为此文都是引用 ITA 总裁的话，所以我想这个数字来自 ITA 的编程实践。如果真是这样，那么我们可以相信这句话。ITA 的软件不仅使用 Lisp 语言，还同时大量使用 C 和 C++，所以这是他们的经验之谈。

我认为，这种比例肯定不会是一个常数。如果你遇到更困难的问题，或者你雇到了更聪明的程序员，这个比例就会增大。一种出色的工具到了真正优秀的黑客手里，可以发挥出更大的威力。

总之，根据上面的这个数字，如果你与 ITA 竞争，而且你使用 C 语言开发软件，那么 ITA 的开发速度将比你快 20 倍。如果你需要一年时间实现某个功能，它只需要不到三星期。反过来说，如果 ITA 开发某个新功能用了三个月，那么你需要五年才能做出来。

你知道吗？上面的对比还只是考虑到最好的情况。当我们只比较代码数量的时候，言下之意就是假设使用功能较弱的语言也能开发出同样的软件。但是事实上，程序员使用某种语言能做到的事情是有极限的。如果你想用一种低层次的语言解决一个很难的问题，那么你将会面临各种情况极其复杂乃至想不清楚的窘境。

所以，当我说假定你与 ITA 竞争，你用五年时间做出的东西，ITA 在 Lisp 语言的帮助下只用三个月就完成了，我指的五年还是一切顺利、没有犯错误、也没有遇到太大麻烦的五年。事实上，按照大多数公司的实际情况，计划中五年完成的项目很可能永远都不会完成。我承认，上面的例子太极端。ITA 似乎有一批非常聪明的黑客，而 C 语言又是一种很低层次的语言。但是，在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。

### 13.6  一个诀窍

由于选择了不当的编程语言而导致项目失败的可能性，是你的经理不愿意考虑的问题。事实上大部分的经理都这样。因为你知道，总的来说，你的经理其实不关心公司是否真的能获得成功，他真正关心的是不承担决策失败的责任。所以对他个人来说，最安全的做法就是跟随大多数人的选择。

在大型组织内部，有一个专门的术语描述这种跟随大多数人的选择的做法，叫做「业界最佳实践」。这个词出现的原因其实就是为了让你的经理可以推卸责任。既然我选择的是「业界最佳实践」，如果不成功，项目失败了，那么你也无法指责我，因为做出选择的人不是我，而是整个「业界」。我认为这个词原来是指某种核算方法，大致意思就是不要采用很奇怪的处理方法。在核算方法中，这可能是一个很好的主意。「尖端」和「核算」这两个词听上去就不适合放在一起。但是如果你把这个标准引入技术决策，你就开始要出错了。

技术本来就应该是尖端的。正如伊拉恩·加内特所说，编程语言的所谓「业界最佳实践」，实际上不会让你变成最佳，只会让你变得很平常。如果你选择的编程语言使得你开发软件的速度只有（选择更激进技术的）对手的几分之一，那么「最佳实践」真的起错了名字。

所以，我们就有了两点结论，我认为它们非常有价值。事实上，这是我用自己的经历换来的。第一，不同语言的编程能力不一样。第二，大多数经理故意忽视第一点。你把这两点事实结合起来，其实就得到了赚钱的诀窍。ITA 软件公司是运用这个诀窍的典型例子。如果你想在软件业获得成功，就使用你知道的最强大的语言，用它解决你知道的最难的问题，并且等待竞争对手的经理做出自甘平庸的选择。

### 附录：编程能力

为了解释我所说的语言编程能力不一样，请考虑下面的问题。我们需要写一个函数，它能够生成累加器，即这个函数接受一个参数 n，然后返回另一个函数，后者接受参数 i，然后返回 n 增加（increment）了 i 后的值。 这里说的是增加，而不是 n 和 i 的相加（plus）。累加器就是应该完成 n 的累加。]

Common Lisp 的写法如下：

```c
(defun foo (n) 
  (lambda (i) (incf n i))
)
```

下面是一些 Lisp 方言生成累加器函数的写法：

Scheme：

```c
(defun (foo n) 
  (lambda (i) (set! n (+ n i) n) 
)
```

Goo：

```c
(df foo (n) 
  (op incf n _)
)
```

Arc：

```c
(df foo (n) 
  [++ n _]
)
```

Ruby 的写法几乎完全相同：

```c
(defun foo (n) 
  lambda { |i| n += i } end
)
```

Perl 5 的写法则是：

```c
sub foo {  
  my ($n) = @_;  
  sub {$n += shift}
}
```

这比 Lisp 和 Ruby 的版本有更多的语法元素，因为在 Perl 语言中必须手工提取参数。Smalltalk 的写法比 Lisp 和 Ruby 的稍微长一点：

```c
foo: n  
  |s|  
  s := n.  
  ^[:i| s := s+i. ]
```

因为在 Smalltalk 中，词法变量（lexical variable） [8] 是有效的，但是你无法给一个参数赋值，因此不得不设置了一个新变量，接受累加后的值。

JavaScript 的写法也比 Lisp 和 Ruby 稍微长一点，因为 JavaScript 依然区分语句和表达式，所以需要明确指定 return 语句来返回一个值：

```js
function foo (n) {  
  return function (i) {           
    return n += i 
  } 
}
```

实事求是地说，Perl 也保留了语句和表达式的区别，但是使用了常规的 Perl 方式处理，因此可以省略 return。如果想把 Lisp/Ruby/Perl/Smalltalk/JavaScript 的版本改成 Python，你会遇到一些限制。因为 Python 并不完全支持词法变量，你不得不创造一种数据结构来接受 n 的值。而且尽管 Python 确实支持函数数据类型，但是没有一种字面量的表示方式（literal representation）可以生成函数（除非函数体只有一个表达式），所以你需要创造一个命名函数，把它返回。最后的写法如下：

```py
def foo (n):  
  s = [n]  
  def bar (i):    
    s[0] += i    
    return s[0]
  return bar
```

Python 用户完全可以合理地质疑为什么不能写成下面这样：

```py
def foo (n):  
  return lambda i: return n += i
```

或者

```py
def foo (n):  
  lambda i: n += i
```

我猜想，Python 有一天会支持这样的写法。（如果不想等到 Python 慢慢进化到更像 Lisp，总可以直接……）

1『现在已经支持啦，哈哈。（2020-12-17）』

在面向对象编程的语言中，你能够在有限程度上模拟一个闭包（即一个函数，通过它可以引用由包含这个函数的代码所定义的变量）。你定义一个类（class），里面有一个方法和一个属性，用于替换封闭作用域（enclosing scope）中的所有变量。这有点类似于让程序员自己做代码分析，本来这应该是由支持词法作用域（lexical scope）的编译器完成的。如果有多个函数，同时指向相同的变量，那么这种方法就会失效，但是在这个简单的例子中，它已经足够了。

Python 高手看来也同意这是解决这个问题比较好的方法，写法如下：

```py
def foo (n):  
  class acc:    
    def __init__ (self, s):        
      self.s = s    
    def inc (self, i):       
      self.s += i        
      return self.s  
    return acc (n).inc
```

或者

```py
class foo:  
  def __init__ (self, n):      
    self.n = n  
  def __call__ (self, i):      
    self.n += i      
    return self.n
```

我添加这一段是想避免 Python 爱好者说我误解这种语言。但是在我看来，这两种写法好像都比第一个版本更复杂。你实际上就是在做同样的事，只不过划出了一个独立的区域保存累加器函数，区别只是保存在对象的一个属性中，而不是保存在列表（list）的头（head）中。使用这些特殊的内部属性名（尤其是 `__call__`）看上去并不像常规的解法，更像是一种破解。

在 Perl 和 Python 的较量中，Python 黑客的观点似乎是认为 Python 比 Perl 更优雅，但是这个例子表明，最终来说，编程能力决定了优雅程度。Perl 的写法更简单（包含的语法元素更少），尽管它的语法有一点丑陋。其他语言怎么样？前文曾经提到过 Fortran、C、C++、Java 和 Visual Basic，看上去使用它们根本无法解决这个问题。肯·安德森说，Java 只能写出一个近似的解法：

```java
public interface Inttoint {  
  public int call (int i);
}

public static Inttoint foo (final int n) {  
  return new Inttoint () {    
    int s = n;    
    public int call (int i) {    
      s = s + i;    
      return s;    
    }
  };
}
```

这种写法不符合题目要求，因为它只对整数有效。

当然，我说使用其他语言无法解决这个问题，这句话并不完全正确。所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言写出任何一个程序。那么，怎样才能做到这一点呢？就这个小小的例子而言，你可以使用这些不那么强大的语言写一个 Lisp 解释器就行了。

这样做听上去好像开玩笑，但是在大型编程项目中却不同程度地广泛存在。因此，有人把它总结出来，起名为「格林斯潘第十定律」（Greenspun's Tenth Rule）：任何 C 或 Fortran 程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是 bug 的、运行速度很慢的 Common Lisp 实现。

如果你想解决一个困难的问题，关键不是你使用的语言是否强大，而是好几个因素同时发挥作用：a）使用一种强大的语言；b）为这个难题写一个事实上的解释器；或者 c）你自己变成这个难题的人肉编译器。在 Python 的例子中，这样的处理方法已经开始出现了，我们实际上就是自己写代码，模拟出编译器实现词法变量的功能。

这种实践不仅很普遍，而且已经制度化了。举例来说，在面向对象编程的世界中，我们大量听到「模式」（pattern）这个词，我觉得那些「模式」就是现实中的因素（c），也就是人肉编译器。 [9] 当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。程序的形式应该仅仅反映它所要解决的问题。代码中其他任何外加的形式都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码通过宏的扩展自动实现。

### 注释

[1] 这篇文章发上网后，我收到了一封显然发自肺腑的电子邮件，开头是这样写的：发型高耸？难道有谁的头发不是向上耸的吗？如果你只能想出这种词去侮辱你的经理，那么你们这些人活该被称为「书呆子」。

[2] IBM 704 型计算机的 CPU 就像冰箱一样大，并且重得多（1429 千克）。4K 大小的 RAM 则装在另外一个箱子里，重达 1800 千克。相比之下，Sub-Zero 690 是最大的家用冰箱型号之一，重量还不到 300 千克。

[3] Steve Russell，也是历史上第一个电脑游戏的作者，1962 年他写了《太空大战》（Spacewar）。

[4] Lisp 语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在 20 世纪 50 年代的 IPL-V 语言中出现过。但是，IPL-V 更像是汇编语言，它的程序中充满了操作码 / 地址对。参见 Allen Newell 等人编著的《IPL-V 语言操作手册》（Information Processing Language-V Manual），Prentice-Hall，1961 年出版。

[5] 如果你不想让经理发现你正在使用 Lisp 编程，你可以告诉他你用的是 XML。

[6] Jen Muehlbauer，「Orbitz 的新突破」（Orbitz Reaches New Heights），New Architect，2002 年 4 月号。

[8] 词法变量，指的是变量的作用域由代码结构决定，不取决于运行时的调用顺序。也就是说，作用域在代码文本的词法分析阶段就决定了，而不在代码执行时决定。注意将这个概念与「局部变量」的概念相区分。—— 译者注

[9] 皮特·诺维格发现，总共 23 种设计模式之中，有 16 种在 Lisp 语言中「本身就提供，或者被大大简化」。（[Design Patterns in Dynamic Languages](http://www.norvig.com/design-patterns/)）

2『上面的「设计模式」相关的 PPT，发现竟然在之前学习郑烨的软件设计之美时已经下载了，作为附件「0411附件1-design-patterns」。（2020-12-16）』

## 1401. 梦寐以求的编程语言

一心让臣民行善的暴君可能是最专制的暴君。——C. S. LEWIS（1898-1963，英国小说家）

我的朋友曾对一位著名的操作系统专家说他想要设计一种真正优秀的编程语言。那位专家回答，这是浪费时间，优秀的语言不一定会被市场接受，很可能无人使用，因为语言的流行不取决于它本身。至少，那位专家设计的语言就遭遇到了这种情况。

那么，语言的流行到底取决于什么因素呢？流行的语言是否真的值得流行呢？还有必要尝试设计一种更好的语言吗？如果有必要的话，怎样才能做到这一点呢？为了找到这些问题的答案，我想我们可以观察黑客，了解他们使用什么语言。编程语言本来就是为了满足黑客的需要而产生的，当且仅当黑客喜欢一种语言时，这种语言才能成为合格的编程语言，而不是被当作「指称语义」（denotational semantics）或者编译器设计。

### 14.1 流行的秘诀

没错，大多数人选择某一种编程语言，不是因为这种语言有什么独特的特点，而是因为听说其他人使用这种语言。但是我认为，外界因素对于编程语言的流行其实没有想象中那么大的影响力。我倒是觉得，问题出在对于什么是优秀编程语言，黑客的看法与大多数的语言设计者不一样。

黑客的看法其实比语言设计者的更重要。编程语言不是数学定理，而是一种工具，为了便于使用，它们才被设计出来。所以，设计编程语言的时候必须考虑到人类的长处和短处，就像设计鞋子的时候必须符合人类的脚型。如果鞋子穿上去不舒服，无论它的外形多么优美，多么像一件艺术品，你也只能把它当作一双坏鞋。

大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有优秀软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。

专家级黑客的看法不是决定一种语言流行程度的唯一因素，某些古老的软件（Fortran 和 Cobol 的情况）和铺天盖地的广告宣传（Ada 和 Java 的情况）也会起到作用。但是，我认为从长期来看，专家级黑客的看法是最重要的因素。只要有了达到「临界数量」（critical mass）的最初用户和足够长的时间，一种语言可能就会达到应有的流行程度。而流行本身又会使得这种优秀的语言更加优秀，进一步拉大它与平庸语言之间的好坏差异，因为使用者的反馈总是会导致语言的改进。你可以想一下，所有流行的编程语言从诞生至今的变化有多大。Perl 和 Fortran 是极端的例子，但是甚至就连 Lisp 都发生了很大的变化。

所以，即使不考虑语言本身的优秀是否能带动流行，我想单单流行本身就肯定会使得这种语言变得更好，只有流行才会让它保持优秀。编程语言的最高境界一直在发展之中。虽然语言的核心功能就像大海的深处，很少有变化，但是函数库和开发环境之类的东西就像大海的表面，一直在汹涌澎湃。

当然，黑客必须先知道这种语言，才可能去用它。他们怎么才能知道呢？就是从其他黑客那里。所以不管怎样，一开始必须有一群黑客使用这种语言，然后其他人才会知道它。我不知道「一群」的最小数量是多少，多少个黑客才算达到「临界数量」呢？如果让我猜，我会说 20 人。如果一种语言有 20 个独立用户，就意味这 20 个人是自主决定使用这种语言的，我觉得这就说明这种语言真的有优点。

达到这一步并非易事。如果说用户数从 0 到 20 比从 20 到 1000 更困难，我也不会感到惊讶。发展最早的 20 个用户的最好方法可能就是使用特洛伊木马：你让人们使用一种他们需要的应用程序，这个程序偏巧就是用某种新语言开发的。

### 14.2 外部因素

我们得先承认，确实有一个外部因素会影响到语言的流行。一种语言必须是某一个流行的计算机系统的脚本语言（scripting language），才会变得流行。Fortran 和 Cobol 是早期 IBM 大型机的脚本语言。C 是 Unix 的脚本语言，后来的 Perl 和 Python 也是如此。Tcl 是 Tk 的脚本语言，Visual Basic 是 Windows 的脚本语言，（某种形式的）Lisp 是 Emacs 的脚本语言，PHP 是网络服务器的脚本语言，Java 和 JavaScript 是浏览器的脚本语言。

编程语言不是存在于真空之中。「编程」其实是及物动词，黑客一般都是为某个系统编程，在现实中，编程语言总是与它们依附的系统联系在一起的。所以，如果你想设计一种流行的编程语言，就不能只是单纯地设计语言本身，还必须为它找到一个依附的系统，而这个系统也必须流行。除非你只想用自己设计的语言取代那个系统现有的脚本语言。

这种情况导致的一个结果就是，无法以一种语言本身的优缺点评判这种语言。另一个结果则是，只有当一种语言是某个系统的脚本语言时，它才能真正成为编程语言。如果你对此很吃惊，觉得不公平，那么我会跟你说不必大惊小怪。这就好比大家都认为，如果一种编程语言只有语法规则，没有一个好的实现（implementation），那么它就不能算完整的编程语言。这些都是很正常很合理的事情，编程语言本来就该如此。

当然，编程语言本来就需要一个好的实现，而且这个实现必须是免费的。商业公司愿意出钱购买软件，但是黑客作为个人不会愿意这样做，而你想让一种语言成功，恰恰就是需要吸引黑客。

编程语言还需要有一本介绍它的书。这本书应该不厚，文笔流畅，而且包含大量优秀的范例。布赖恩柯尼汉和丹尼斯里奇合写的《C 程序设计语言》（C Programming Language）就是这方面的典范。眼下，我大概还能再加一句，这一类书籍之中必须有一本由 O'Reilly 公司出版发行。这正在变成是否能吸引黑客的前提条件了。

编程语言还应该有在线文档。事实上，在线文档可以当作一本书来写，但是目前它还无法取代实体书。实体书并没有过时，它们读起来很方便，而且出版社对书籍内容的审核是一种很有用的质量保证机制（虽然做得很不完美）。书店则是程序员发现和学习新语言的最重要的场所之一。

### 14.3 简洁

假定你的语言已经能够满足上面三项条件 —— 一种免费的实现，一本相关书籍，以及语言所依附的计算机系统 —— 那么还需要做什么才能使得黑客喜欢上你的语言？

黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。有一个笑话说，黑客动手写程序之前，至少会在心里盘算一下哪种语言的打字工作量最小，然后就选择使用该语言。这个笑话其实与真实情况相差无几。就算这真的是个笑话，语言的设计者也必须把它当真，按照它的要求设计语言。

简洁性最重要的方面就是要使得语言更抽象。为了达到这一点，首先你设计的必须是高级语言，然后把它设计得越抽象越好。语言设计者应该总是看着代码，问自己能不能使用更少的语法单位把它表达出来。如果你有办法让许多不同的程序都能更简短地表达出来，那么这很可能意味着你发现了一种很有用的新抽象方法。不要觉得为用户着想就是让他们使用像英语一样又长又啰嗦的语法。这是不正确的做法，Cobol 就是因为这个毛病而声名狼藉。如果你让黑客像下面这样求和：

```
add x to y giving z
```

而不是写成：

```
z=x+y
```

那么你就是在侮辱黑客的智商，或者自己作孽了。简洁性是静态类型语言的力所不及之处。不考虑其他因素时，没人愿意在程序的头部写上一大堆的声明语句。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。举例来说，hello-world 本应该是一个很简单的程序，但是在 Java 语言中却要写上一大堆东西，这本身就差不多可以说明 Java 语言设计得有问题了。[1] 

单个的语法单位也应该很简短。Perl 和 Common Lisp 在这方面是两个不同的极端。Perl 的语法单位很短，导致它的代码可以拥挤得让人无法理解，而 Common Lisp 内置运算符的名称则长得可笑。Common Lisp 的设计者们可能觉得文本编辑器会帮助用户自动填写运算符的长名称。但是这样做的代价不仅是增加了打字的工作量，还包括提高了阅读代码的难度，以及占用了更多的显示器空间。

### 14.4 可编程性（Hackability）

对黑客来说，选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。在编程语言的历史上，防止程序员做出「错误」举动的措施多得惊人。这是语言设计者很自以为是的危险举动，他们怎么知道程序员该做什么不该做什么？我认为，语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。你也许能够阻止他引用另一个模块中的变量，但是你没法防止他日日夜夜不知疲倦地写出结构混乱的程序去解决完全错误的问题。

优秀程序员经常想做一些既危险又令人恼火的事情。所谓「令人恼火」，我指的是他们会突破设计者提供给用户的外部语义层，试着控制某些高级抽象的语言内部接口。比如，黑客喜欢破解，而破解就意味着深入内部，揣测原始设计者的意图。

你应该敞开胸怀，欢迎这种揣测。对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。如果你制造的是编程语言这样高度组合的系统，那就更是如此了。许多黑客会用你做梦也想不到的方式改动你的语法模型。我的建议就是，让他们这样干吧，而且应该为他们创造便利，尽可能多地把语言的内部暴露在他们面前。

其实，黑客并不会彻底颠覆你的工具，在一个大型程序中，他可能只是对语言改造一两个地方。但是，改动多少地方并不重要，重要的是他能够对语言进行改动。这可能不仅有助于解决一些特殊的问题，还会让黑客觉得很好玩。黑客改造语言的乐趣就好比外科医生摆弄病人内脏的乐趣，或者青少年喜欢用手挤破青春痘的那种感觉。[2] 至少对男生来说，某些类型的破坏非常刺激。针对青年男性读者的 Maxim 杂志每年出版一本特辑，里面一半是美女照片，另一半是各种严重事故的现场照片。这本杂志非常清楚它的读者想看什么。

一种真正优秀的编程语言应该既整洁又混乱。「整洁」的意思是设计得很清楚，内核由数量不多的运算符构成，这些运算符易于理解，每一个都有很完整的独立用途。「混乱」的意思是它允许黑客以自己的方式使用。C 语言就是这样的例子，早期的 Lisp 语言也是如此。真正的黑客语言总是稍微带一点放纵不羁、不服管教的个性。

优秀的编程语言所具备的功能，应该会使得言必称「软件工程」的人感到非常不满、频频摇头。与黑客语言形成鲜明对照的就是像 Pascal 那样的语言，它是井然有序的模范，非常适合教学，但是除此之外就没有很大用处了。

### 14.5 一次性程序

为了吸引黑客，一种编程语言必须善于完成黑客想要完成的各种任务。这意味着它必须很适合开发一次性程序。这一点可能出乎很多人的意料。所谓一次性程序，就是指为了完成某些很简单的临时性任务而在很短时间内写出来的程序。比如，自动完成某些系统管理任务的程序，或者（为了某项模拟任务）自动生成测试数据的程序，以及在不同格式之间转化数据的程序等。令人吃惊的是，一次性程序往往不是真的只用一次，就像二战期间很多美国大学造的一大批临时建筑后来都成了永久建筑。许多一次性程序后来也都变成了正式的程序，具备了正式的功能和外部用户。

我有一种预感，最优秀的那些大型程序就是这样发展起来的，而不是像胡佛水坝那样从一开始就作为大型工程来设计。一下子从无到有做出一个大项目是很恐怖的一件事。当人们接手一个巨型项目时，很容易被它搞得一蹶不振。最后，要么是项目陷入僵局，要么是做出来一个规模小、性能差的东西。你想造一片闹市，却只做出一家商场；你想建一个罗马，却只造出一个巴西利亚；你想发明 C 语言，却只开发出 Ada。

开发大型程序的另一个方法就是从一次性程序开始，然后不断地改进。这种方法比较不会让人望而生畏，程序在不断的开发之中逐渐进步。一般来说，使用这种方法开发程序，一开始用什么编程语言，就会一直用到最后，因为除非有外部政治因素的干预，程序员很少会中途更换编程语言。所以，我们就有了一个看似矛盾的结论：如果你想设计一种适合开发大型项目的编程语言，就必须使得这种语言也适合开发一次性程序，因为大型项目就是从一次性程序演变而来的。

Perl 就是一个鲜明的例子。它不仅仅设计成适合开发一次性程序，而且它本身就很像一次性程序。最初的 Perl 只是好几个生成表格的工具收集在一起而已。后来程序员用它写一次性程序，当那些程序逐渐发展壮大后，Perl 才随之发展成了一种正式的编程语言。到了 Perl 5，这种语言才适合开发重要的程序，但是在此之前它已经广为流行了。

什么样的语言适合写一次性程序？首先，它必须很容易装备。一次性程序是你只想在一小时内写出来的程序，所以它不应该耗费很多时间安装和配置，最好已经安装在你的电脑上了。它必须是想用就用的。C 语言可以想用就用，因为它是操作系统的一部分；Perl 可以想用就用，因为它本来就是一种系统管理工具，操作系统已经默认安装它了。

很容易装备不仅仅指很容易安装或者已经安装，还指很容易与使用者互动。一种有命令行界面、可以实时反馈的语言就具有互动性，那些必须先编译后使用的语言就不具备互动性。受欢迎的编程语言应该是前者，具有良好的互动性，可以快速得到运行结果。

一次性程序的另一个特点就是简洁。对黑客来说，这一点永远有吸引力。如果考虑到你最多只打算在这个程序上耗费一个小时，这一点就更重要了。

### 14.6 函数库

简洁性的最高形式当然是有人已经帮你把程序写好，你只要运行就可以了。函数库就是别人帮你写好的程序，所以它是编程语言的另一个重要特点，并且我认为正在变得越来越重要。Perl 就赢在它具有操作字符串的巨大函数库。这类函数库对一次性程序特别重要，因为开发一次性程序的原始目的往往就是转化或提取字符串。许多 Perl 程序的原型可能就是把几个函数库调用放在一起。

1『这么说的话，字符串处理、文本处理的话，Perl 应该有很大的优势喽。（2020-12-17）』

我认为，未来 50 年中，编程语言的进步很大一部分与函数库有关。未来的函数库将像语言内核一样精心设计。优秀函数库的重要性将超过语言本身。某种语言到底是静态类型还是动态类型、是面向对象还是函数式编程，这些都不如函数库重要。那些习惯用变量类型考虑问题的语言设计者可能会对这种趋势感到不寒而栗。这不等于把语言设计降到开发应用程序的层次吗？哦，真是太糟了。但是别忘了，编程语言是供程序员使用的，而函数库就是程序员需要的东西。

设计优秀的函数库是很难的，并不只是写一大堆代码而已。一旦函数库数量变得太多，找到一个你需要的函数有时候还不如自己动手写来得快。函数库的设计基础与语言内核一样，都是一个小规模的运算符集合。函数库的使用应该符合程序员的直觉，让他可以猜得出哪个函数能满足自己的需要。

### 14.7 效率

众所周知，好的编程语言生成的代码有较快的运行速度。但是实际上，我觉得代码的运行速度不是编程语言的设计者能够控制的。高德纳很久以前就指出，运行速度只取决于一些关键的瓶颈。而在编程实践中，许多程序员都已经注意到自己很容易搞错瓶颈到底在哪里。

所以，编程时提高代码运行速度的关键是使用好的性能分析器（profiler），而不是使用其他方法，比如精心选择一种静态类型的编程语言。为了提高运行速度，并没有必要每个函数的每个参数类型都声明清楚，你只需要在瓶颈处声明清楚参数类型就可以了。所以，更重要的是你需要能够找出瓶颈到底在什么地方。

1『赞同作者的观点，其实只需要在关键的节点处，借鉴静态语言的特点即可。（2020-12-17）』

人们在使用非常高级的语言（比如 Lisp）时，经常抱怨很难知道哪个部分对性能的影响比较大。可能确实如此，如果你使用一种非常抽象的语言，这也许是无法避免的。不管怎样，我认为一个好的性能分析器会解决这个问题，虽然这方面还有很长的路要走，但是未来你可以快速知道程序每个部分的时间开销。

这个问题一部分源于沟通不畅。语言设计者喜欢提高编译器的速度，认为这是对自己技术水平的考验，而最多只把性能分析器当作一个附送给使用者的赠品。但是在现实中，一个好的性能分析器对程序的帮助可能大于编译器的作用。这里又一次反映出语言设计者与用户之间发生了脱节，前者竭尽全力想要解决的问题其实方向不甚正确。

让性能分析器自动运行可能是一个好主意。它自动告诉程序员每个部分的性能，而不是非要等到程序员手动运行后才能知道。比如，当程序员编辑源码的时候，代码编辑器能够实时用红色显示瓶颈的部分。另一个方法应该是设法显示正在运行的程序的情况，这对互联网软件尤其重要，因为服务器上有很多程序同时运行，它们都需要你密切关注。自动运行的性能分析器用图形实时显示程序运行时的内存状况，甚至可以发出声音，表示出现了问题。

出现问题时，声音是很好的提示。我们在 Viaweb 搞了一块很大的面板，上面有各种各样的仪表盘，用来显示服务器的状况。仪表盘的指针由微型马达驱动，每当马达旋转的时候，就会发出一阵轻微的噪音。在我的工位没法看到仪表盘，但是只要我听到声音，就能立刻知道服务器出现了问题。

性能分析器甚至有可能自动找出不合理的算法。如果将来有人发现某种形式的内存访问是不合理算法的信号，我不会感到很惊讶。如果有一个小人儿可以钻进计算机看看我们的程序是怎么运行的，他可能会变成一个忙碌又悲惨的可怜虫，就像那些为政府跑腿的小人物。我总觉得自己用处理器做了很多无用功，但是一直没有找到能够看出程序是怎样浪费运算能力的好办法。

现在有一些语言先编译成字节码（byte code），然后再由解释器执行。这样做主要是为了让代码容易移植到不同的操作系统，但是这也可以变成一项很有用的功能。让字节码成为语言的正式组成部分，允许程序员在瓶颈处内嵌字节码，这可能是一个不错的主意。然后，针对这部分字节码的优化也就变得可以移植了。

正如许多最终用户已经意识到的，运行速度的概念正在发生变化。随着互联网软件的兴起，越来越多的程序主要不是受限于计算机的运算速度，而是受限于 I/O 的速度。加快 I/O 速度将是很值得做的一件事。在这方面，编程语言也能起到作用，有些措施是显而易见的，比如采用简洁、快速、格式化输出的函数，还有些措施则需要深层次的结构变化，比如采用缓存和持久化对象（persistent object）。

用户关心的是反应时间（response time），但是软件的另一种效率正在变得越来越重要，那就是每个处理器能够同时支持的用户数量。未来许多有趣的应用程序都将是运行在服务器端的互联网软件，所以每台服务器能够支持的用户数量就成了软件业者的关键问题。互联网软件的资本支出就取决于这个指标。

许多年以来，大多数面向最终用户的程序都不太关心效率。软件开发者总是假设用户桌面电脑的运算能力会不断增长，所以不用刻意提高软件的效率。帕金森定律 [3] 被证明与摩尔定律一样颠扑不破。软件不断膨胀，消耗光所有可以得到的资源。这一切将随着互联网软件的出现发生改变，因为硬件和软件现在捆绑在一起供应。对于那些提供互联网软件的公司来说，将每台服务器支持的用户数量最大化会对降低成本产生巨大影响。

在一些应用程序中，处理器的运算能力是瓶颈，那么最重要的优化对象就是软件的运行速度。但是，一般情况下内存才是瓶颈，你能够同时支持的用户数量取决于用户数据所消耗的内存。编程语言在这方面也能发挥作用，对线程的良好支持将使得所有用户共享同一个内存堆（heap）。持久化对象和语言内核级别的延迟加载（lazy loading）支持也有助于减少内存需求。

### 14.8 时间

一种编程语言要想变得流行，最后一关就是要经受住时间的考验。没人想用一种会被淘汰的语言编程，这方面已经有很多前车之鉴了。所以，大多数黑客往往会等上几年，看看某一种新语言的势头，然后才真正考虑使用它。新事物的发明者通常对这个发现很震惊，他们没想到人们居然这样对待发明创造。但是，让别人相信一种新事物是需要时间的。我有一个朋友，他的客户第一次提出某种需求时，他很少理会。因为他知道人们有时候会想要自己并不真正需要的东西。为了避免浪费时间，只有当客户第三次或第四次提出同样的需求时，他才认真对待。这个时候客户可能已经很不高兴了，但是这至少保证他们提出的需求应该就是他们真正需要的东西。

1『这里的例子很有启发，值接受用户第三、第四次提出的需求。其实很多地方是值得借鉴的。（2020-12-17）』

大多数人接触新事物时都学会了使用类似的过滤机制。甚至有时要听到别人提起十遍以上他们才会留意。这样做完全是合理的，因为大多数的热门新商品事后被证明都是浪费时间的噱头，没多久就消失得无影无踪。虚拟现实建模语言 VRML 刚诞生时曾经轰动一时，但是我决定等到一两年后再去学习它，结果一两年后已经没有学习的必要了，因为市场已经把它遗忘了。

所以，发明新事物的人必须有耐心，要常年累月不断地做市场推广，直到人们开始接受这种发明。我们就耗费了好几年才使得客户明白 Viaweb 不需要下载安装就能使用。不过，好消息是，简单重复同一个信息就能解决这个问题。你只需要不停地重复同一句话，最终人们将会开始倾听。人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。

新事物的发展改进一般也需要很长时间。大多数技术在诞生后都逐渐发生了巨大的变化，编程语言更是如此。诞生头几年，一小批早期使用者比其他因素更能促进技术发展。早期使用者都是行家，要求也很高，能够很快找出你的技术中存在的缺点。而且，如果你的用户只有很少几个人，你就能够与他们所有人保持密切接触。只要不断改进你的系统，即使给用户造成了损失，早期使用者也会对你宽容大度的。

新技术被市场接纳的方式有两种，一种是自然成长式，另一种是大爆炸式。自然成长式的一个例子就是在车库里白手起家、自力更生的创业者。几个好朋友埋头工作，在外界毫不知晓的情况下开发出某种新技术。他们把它推向市场，没有任何宣传，最初的用户寥寥无几（但是热心程度无与伦比）。创业者持续改进新技术，与此同时，通过口碑效应，用户数量不断增长。在创业者不经意间，他们已经壮大起来了。大爆炸式的例子是有风险资本支持、在市场上大张旗鼓宣传的创业公司。他们急急忙忙地开发一个产品，推向市场的时候大肆曝光，立刻就获得了一大批使用者（至少他们希望如此）。

一般来说，车库里的创业者会妒忌大爆炸式的创业公司。后者的主导人物个个光彩照人、自信非凡，深受风险资本商的追捧。他们什么都买得起，在公关公司配合产品推出的宣传活动中，他们自己也附带成为了明星人物。自然成长式的创业者坐在自家车库里，觉得自己又穷又可怜。但是我想他们不必难过。最终来看，自然成长式会比大爆炸式产生更好的技术，能为创始人带来更多的财富。如果你研究一下目前的主流技术，就会发现大部分都是源于自然成长式。

这种模式不仅存在于商业公司，还存在于科研活动中。Multics 操作系统和 Ada 语言是大爆炸式项目，现在都已经销声匿迹了，而它们的继承者 Unix 和 C 语言则是自然成长式项目。

1『又对应于自下而上和自上而下。（2020-12-17）』

### 14.9 再设计

著名散文家 E.B. 怀特说过，「最好的文字来自不停的修改」。所有优秀作家都知道这一点，它对软件开发也适用。设计一样东西，最重要的一点就是要经常「再设计」，编程尤其如此，再多的修改都不过分。

1『所以多多学习重构的技巧，把「重构」的概念深入骨髓。（2020-12-17）』

为了写出优秀软件，你必须同时具备两种互相冲突的信念。一方面，你要像初生牛犊一样，对自己的能力信心万丈；另一方面，你又要像历经沧桑的老人一样，对自己的能力抱着怀疑态度。在你的大脑中，有一个声音说「千难万险只等闲」，还有一个声音却说「早岁哪知世事艰」。

这里的难点在于你要意识到，实际上这两种信念并不矛盾。你的乐观主义和怀疑倾向分别针对两个不同的对象。你必须对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。做出优秀成果的人，在做的过程中常常觉得自己做得不够好。其他人看到他们的成果觉得棒极了，而创造者本人看到的都是自己作品的缺陷。这种视角的差异并非偶然，因为只有对现状不满，才会造就杰出的成果。

如果你能平衡好希望和担忧，它们就会推动项目前进，就像自行车在保持平衡中前进一样。在创新活动的第一阶段，你不知疲倦地猛攻某个难题，自信一定能够解决它。到了第二阶段，你在清晨的寒风中看到自己已经完成的部分，清楚地意识到存在各种各样的缺陷。此时，只要你对自己的怀疑没有超过你对自己的信心，就能够坦然接受这个半成品，心想不管多难我还是可以把剩下的部分做完。

让这两股相反的力量保持平衡是很难的。初出茅庐的年轻黑客都很乐观，自以为做出了伟大的产品，从不反思和改进。上了年纪的黑客又太不自信，甚至故意回避一些挑战性很强的项目。任何措施，只要能让「再设计」周而复始地进行下去，就都是可取的。文章可以修改到你满意为止，但是软件的修改通常来说可以无休止地进行下去。文章的读者不可能抱怨修改后新增加的内容让他们前后的思想产生了不协调，但是软件的使用者就会抱怨修改后的版本有不兼容问题。

用户是一把双刃剑。他们推动语言的发展，但也使得你不敢对语言进行大规模改造。所以，一开始的时候要精心选择用户，避免使用者过快增长。发展用户就像一种优化过程，明智的做法就是放慢速度。一般情况下，用户比较少意味着你任何时候都可以加大修改的力度。这时，对语言规格做出改变就像撕绷带，当你感到痛苦的一瞬间，痛苦就已经成为了回忆。如果用户数量庞大，修改语言带来的痛苦就将持续很长时间。

大家都知道，让一个委员会负责设计语言是非常糟糕的主意。委员会只会做出恶劣的设计。但是我觉得，委员会最大的问题在于他们妨碍了「再设计」。在委员会的主持下，修改一种语言是非常麻烦的事，没有人愿意自讨苦吃。而且，即使大多数成员不喜欢某种做法，委员会最后的决定往往还是维持现状。

就算委员会只有两个人，还是会妨碍「再设计」，典型例子就是软件内部的各个接口由不同的人负责。这时除非两个人都同意改变接口，否则接口就无法改变。因此现实中，尽管软件功能越来越强大，内部接口却往往一成不变，成为整个系统中拖后腿的部分。

一种可能的解决方法是，将软件内部的接口设计成垂直接口而不是水平接口。这意味着软件内部的模块是一个个垂直堆积起来的抽象层，层与层之间的接口完全由其中的一层控制。如果较高的一层使用了较低的一层定义的语言，那么接口就由较低的一层控制；如果较低的一层从属于较高的一层，那么接口就由较高的一层控制。

### 14.10 梦寐以求的编程语言

让我们试着描述黑客心目中梦寐以求的语言来为以上内容做个小结。

1、这种语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。

2、这种语言的句法短到令人生疑。你输入的命令中，没有任何一个字母是多余的，甚至用到 Shift 键的机会也很少。

3、这种语言的抽象程度很高，使得你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个真正出色的性能分析器，告诉你应该重点关注什么地方。你能让多重循环快得难以置信，并且在需要的地方还能直接嵌入字节码。

4、这种语言有大量优秀的范例可供学习，而且非常符合直觉，你只需花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册，它本身很薄，里面关于限定条件和例外情况的警告寥寥无几。

5、这种语言的内核很小，但很强大。各个函数库高度独立，而且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样完美契合，不需要为了兼容性问题放弃或者保留某些功能。所有函数库的源码都很容易得到。这种语言能够很轻松地与操作系统和用其他语言开发的应用程序对话。

6、这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层之上。如果需要的话，你可以直接使用较低的抽象层。

7、除了一些绝对必要隐藏的东西，这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你的开发，而不是为了强迫你按照它的方式行事。事实上，它鼓励你参与它的设计，给你提供与语言创造者平等的权力。你能够对它的任何部分加以改变，甚至包括它的语法。它尽可能让你自己定义的部分与它本身定义的部分处于同等地位。这种梦幻般的编程语言不仅开放源码，更开放自身的设计。

2「梦寐以求语言的指标，做一张主题卡片。（2020-12-17）」

### 注释

[1] hello-world 程序的唯一作用就是显示出「Hello, world!」这句话。使用 Java 语言，你需要这样写：

```java
public class Hello {      
    public static void main(String[] args) {          
        System.out.println("Hello, world!");      
    }  
}
```

如果你从来没有接触过编程，看到上面的代码可能会很奇怪，让计算机显示一句话为什么要搞得这么复杂？有意思的是，资深程序员的反应与你一样。

[2] 在《神经外科医生手记》（When the Air Hits Your Brain）一书中，神经外科医生弗托塞克讲述了住院总医生戈雷的一段话，内容关于外科医生与内科医生的区别。

戈雷和我要了一个大比萨，找了一张空桌子坐下。他点起一根香烟，说：「那些内科医生真是令人讨厌，总是喜欢谈论一辈子只能遇到一次的病例。这就是他们的问题，他们只喜欢古怪的东西，讨厌普通的常见病例。这就是我们和他们的区别。你看，我们喜欢腰椎间盘突出，觉得像比萨一样又大又好吃，但是他们看到高血压就憎恨不已……」

很难把腰椎间盘突出与又大又好吃联系在一起，但是，我想我知道他们指的是什么。我经常觉得某个 bug 非常诱人，一定要追踪下去。不是程序员的人很难想象 bug 有什么好玩的。一切正常当然很好，但是不可否认，能够抓到某些 bug 会让人兴奋到极点。

[3] 帕金森定律（Parkinson's Law）的一种原始表达形式是「工作总是到最后一刻才会完成」，后来引申到计算机领域就变成了「数据总是会填满所有空间」，更一般性的总结则是「对一种资源的需求总是会消耗光这种资源的所有供应」。—— 译者注

## 1501. 设计与研究

外国游客常常惊讶地发现，美国人交谈的时候，一开始总是问「你干什么工作」。我一直讨厌回答这个问题，因为一句话说不清楚。不过我最终找到了解决方法，现在如果有人问我干什么工作，我会正视对方的双眼说：「我正在设计一种 Lisp 语言的新方言。」如果你也有同样困扰，我推荐你也如此回答。对方就立刻转向其他话题了。我确实是在「设计」一种编程语言，而且我不认为自己在做「研究」。我所做的工作与其他人设计一幢大楼、一把椅子、一种新字体并没有本质不同。我的目的不是发现一种「新」东西，而是做出一种很「好」的编程语言。

设计与研究的区别看来就在于，前者追求「好」（good），后者追求「新」（new）。优秀的设计不一定很「新」，但必须是「好」的；优秀的研究不一定很「好」，但必须是「新」的。我认为这两条道路最后会发生交叉：只有应用「新」的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是「好」的难题），才会诞生最佳研究。所以，最终来说，设计和研究都通向同一个地方，只是前进的路线不同罢了。

如果把创造一种编程语言看成是设计问题，而不是科研方向，那么有何不同？最大的不同在于你会更多地考虑用户。设计的时候，一开始总是问：我为谁设计？他们需要什么？比如，优秀的建筑师不会先设计，然后强迫用户接受，而是先研究最终用户的需求，然后做出用户需要的设计。

注意，我说的是「用户需要的设计」，而不是「用户要求的设计」。我不想让读者产生一种印象，认为设计师就像厨师一样，顾客点什么菜就一模一样做出来。艺术的各个领域有着巨大的差别，但是我觉得任何一个领域的最佳作品都不可能由对用户言听计从的人做出来。

有一句话说「顾客永远是对的」，这是指评价优秀设计的标准是看它能够多大程度上满足用户的需求。如果你的小说没人爱看，或者你做的椅子极不舒服，那么就说明你的作品失败了，被一票否决了。就算你的小说（或者椅子）有着最先进的理论指导也无济于事。

可是，让用户满意并不等于迎合用户的一切要求。用户不了解所有可能的选择，也经常弄错自己真正想要的东西。做一个好的设计师就像做一个好医生一样。你不能头痛医头，脚痛医脚。病人告诉你症状，你必须找出他生病的真正原因，然后针对病因进行治疗。

2『设计和研究的区别，做一张任意卡片。』——已完成

大多数优秀设计都是这样产生的，它们关注用户，并且以用户为中心。我说设计必须考虑用户的需求，这里的「用户」并不是指所有普罗大众。事实上，你可以选择任何想要的目标用户。比如，假定你正在设计一种工具，你可以把目标用户定为初学者，也可以定为专家级用户。一种人眼里的优秀设计可能在另一种人眼里却是糟糕无比。这里的重点是你必须选出某些人作为你的目标用户。我觉得，除非设定目标用户，否则一种设计的好坏根本无从谈起。

如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。如果目标用户与你本人差别很大，你往往会假定目标用户的需求比你本人的需求更简单，而不是更复杂。低估用户（即使出于善意）一般来说总是会让设计师出错。我怀疑那些设计「公共住宅项目」（housing project）[1] 的建筑师根本没想过自己住在里面会是什么感觉。编程语言也有这种现象。C、Lisp 和 Smalltalk 都是设计者为了自己使用而设计的，而 Cobol、Ada 和 Java 则是为了给别人使用而设计的。

如果你觉得自己在为傻瓜设计产品，那么很可能不仅无法设计出优秀产品，而且就连傻瓜也不喜欢你的设计。不过，就算你的设计针对的是最高端的用户，你也一样是设计给人类使用。研究就不一样了。做数学研究时，你不会只为了方便读者理解而故意选择一种更麻烦的证明方式，你只会选择最直接、最简洁的证明。我想，一般来说科学研究都是这样。科学观点不需要服从人类工程学（ergonomic）。

到了艺术领域，情况就完全变了。设计必须以人为本。设计椅子的时候，你不能只考虑椅子，还必须考虑人体各种千奇百怪的特点，不可能回避掉这一点。所有的艺术都必须迎合人类的兴趣和极限。举例来说，不考虑其他因素时，肖像画就是比风景画更能引发观众的兴趣。文艺复兴时期的经典绘画作品都是画人的，这并非巧合。如果绘画艺术不能用来表现人类本身，那么绘画也不会成为今天这样受推崇的艺术形式了。

不管你喜不喜欢，编程语言也是以人为本的。我怀疑人类的大脑与躯干一样，都有着许多令人琢磨不透的特点。否则为什么有些事情人类特别擅长，而另一些事情人类干起来特别困难。比如，人类似乎不善于处理精细的工作，所以最好还是交给计算机处理。另一方面，如果人类真的擅长和细节打交道，那么我们应该都用机器语言编程才对。

另外，还要记住一点。怎么理解编程语言？你不要把它看成那些已完成的程序的表达方式，而应该把它理解成促进程序从无到有的一种媒介。这里的意思是说，成品的材料和开发时用的材料其实是不一样的。搞艺术的人都知道，这两个阶段往往需要不同的媒介。比如，大理石是一种非常良好、耐用的材料，很适合用于最后的成品，但是它极其缺乏弹性和灵活性，所以不适合在构思阶段用来做模型。

最后写出来的程序就像已经完成的数学证明一样，是一棵经过精心修剪的树木，上面杂乱滋生的树杈都已经被剪去了。所以，评价一种语言的优劣不能简单地看最后的程序是否表达得很漂亮，而要看程序从无到有的那条完成路径是否很漂亮。某种设计使得最后的程序非常漂亮，但是不一定同时具备漂亮的编程过程。比如，我写过一些宏，它们的作用是自动生成另一些宏，它们看上去非常精美优雅，就像一粒粒精细的宝石。但是，开发过程非常丑陋，我就是连续好几个小时不停地试错，而且老实说，至今仍然无法完全确定它们是否百分之百正确。

我们常常采用错误的方法评价编程语言，只看一眼最后完成的程序就做出判断。同一个软件有两种不同语言开发的版本，你发现其中一个版本比另一个版本短得多，于是非常自信地认定前者的编程语言比后者的更好。但是，如果你从艺术创作的角度思考这个问题，就不太可能这样评价编程语言。因为你不想最后只剩下一种像大理石那样漂亮、又像大理石那样难用的编程语言。

比如，开发软件的时候，一个「交互式顶层解释器」（interactive toplevel）会带来巨大的优势。在 Lisp 语言中，这种解释器就叫做「读取 — 求值 — 打印」循环（read-eval-print loop）。有了这个解释器后，语言的设计就会受到巨大影响。静态类型语言不适合部署这样的解释器，因为静态类型语言要求在使用变量前先声明类型，这对于「交互式顶层解释器」行不通。当你在解释器中输入表达式，然后对变量 x 进行赋值，接着再对 x 做进一步处理时，你只想尽快看到结果，肯定不想很麻烦地先声明 x 的类型。你也许不同意「交互式顶层解释器」为软件开发带来便利的说法，但是如果你接受它，同意易于使用的编程语言必须有一个这样的解释器，那么强制声明变量类型的做法就是与这个解释器不兼容，因此结论就是所有的静态类型语言都不易于编程。

为了做出优秀的设计，你必须贴近用户，始终寸步不离，永远站在用户的角度调整自己的构想。19 世纪英国作家简·奥斯汀的小说为何如此出色？一个原因就是她把自己的作品大声读给家人听，所以她就不会陷入孤芳自赏难以自拔的境地，不会长篇累牍地赞叹自然风光，也不会滔滔不绝地宣扬自己的人生哲学。（事实上，简·奥斯汀还是在小说里宣扬了自己的人生哲学，不过她把它编进故事之中，而不是直接像贴标签那样讲出来。）你可以随便找一本平庸的「文学」读物，想象一下把它当作自己的作品读给朋友们听，这样会让你真切地感受到那些「文学」读物高高在上的视角，读者必须承受所有沉重的负担才能阅读这些作品。

在软件领域，贴近用户的设计思想被归纳为「弱即是强」（Worse is Better）模式 [2]。这个模式实际上包含了好几种不同的思想，所以至今人们还在争论它是否真的成立。但是，其中有一点是正确的，那就是如果你正在设计某种新东西，就应该尽快拿出原型，听取用户的意见。

与之对照，还有另一种软件设计思想，也许可以被称为「万福玛丽亚」模式。它不要求尽快拿出原型，然后再逐步优化，它的观点是你应该等到完整的成品出来以后再一下子隆重地推向市场，就像圣母玛丽亚降临一样，哪怕整个过程漫长得像橄榄球运动员长途奔袭、达阵得分也没有关系。在互联网泡沫时期，无数创业公司因为相信了这种模式而自毁前程。我还没听说过有人采用这种模式而获得成功。

软件领域以外的人可能没听过「弱即是强」，所以意识不到这种模式在艺术领域普遍存在。以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。

在大多数艺术领域，原型使用的材料与成品的材料一般来说是不一样的。印刷活字先画在纸上，然后才做成铅字。雕塑先用石蜡创作，然后才用青铜浇铸。地毯图案先用墨水画出纸型，然后才织成地毯。建筑物先做出木模型，然后才做成石头建筑。为什么 15 世纪油画首次亮相会引起轰动并很快流行起来？原因就是油彩使得画家可以在原型上直接画出最后的样子。你可以按照自己的想法画出初稿，但是它并不对你构成限制。接下来你可以逐步加上细节，甚至对初稿做出重大修改，直到最后完成。

软件开发也可以这样做。原型（prototype）并不只是模型（model），不等于将来一定要另起炉灶，你完全能够在原型的基础上直接做出最后的成品。我认为，只要有可能，你就应该这样做。这样的方式使得你可以利用在开发过程中一路产生的新想法。不过更重要的是，这样做有助于鼓舞士气。

士气是设计的关键因素。令我吃惊的是，大家很少提到这一点。我的一位美术启蒙老师告诉我：如果你觉得画某样东西很乏味，那么你画出来的东西就会真的很乏味。比如，假设你必须画一幢建筑物，你决定从每一块砖头开始画起。你觉得自己可以坚持下去，但是画到一半的时候突然感到很厌倦，于是你就不再认真观察每块砖头并画出它们各自不同的特点，而是以一种机械重复的方式草草地把砖头画完了事。这样一来，你的作品效果就很差，甚至还不如一开始就不采用写实手法，只是若隐若现地暗示砖头的存在。

先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果，这好比让你看到不远处就是唾手可得的奖励，你因此会受到激励和鼓舞。其他艺术领域也是如此，尤其是油画。大多数画家都是先画一个草图，然后再逐步加工。如果你采用这种方式，那么从理论上说，你每天收工的时候都可以看到整体的效果，不会对最后的成品一点感觉都没有。跟你说实话吧，画家之间甚至流传着一句谚语：「画作永远没有完工的一天，你只是不再画下去而已。」这种情况对于第一线的程序员真是再熟悉不过了。

士气也可以解释为什么很难为低端用户设计出优秀产品。因为优秀设计的前提是你自己必须喜欢这种产品，否则你不可能对设计有兴趣，更不要说士气高昂了。为了把产品设计好，你必须对自己说：「哇，这个产品太棒了，我一定要设计好！」而不是心想：「这种垃圾玩意，只有傻瓜才会喜欢，随便设计一下就行了。」设计意味着做出符合人类特点和需要的产品。但是，「人类」不仅包括用户，还包括设计师，所以设计工作本身也必须符合设计师的特点和需要。

### 注释

[1]「公共住宅」指的是由政府出资建造的房产，用来出租给低收入家庭居住，类似于廉租房。—— 译者注

[2]「弱即是强」指的是一种软件传播的模式，由 Common Lisp 专家理查德·加布里埃尔（Richard P. Gabriel）于 1991 年在 Lisp: Good News, Bad News, How to Win Big（http://www.dreamsongs.com/WIB.html）一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中的一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能「弱」反而是更好的选择「强」，因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力。加布里埃尔本人经常举 Unix 和 C 语言的例子，Unix 和 C 在设计上考虑了实际环境，放弃了一些功能，但是保证了简单性，这使得它们最终在竞争中胜出，成为主流操作系统和编程语言。—— 译者注

2-3『发现上面的链接打不开了，但是找到了这篇 Paper，已下载「2020030Lisp: Good News, Bad News, How to Win Big」并存入 Zotero 的「2020Paper」里，一定要去研读。』——未完成