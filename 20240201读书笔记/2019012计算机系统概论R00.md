## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡——

根据反常识，再补充三个证据——就产生三张术语卡。

### 0202. 术语卡——

### 0203. 术语卡——

### 0301. 人名卡——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 任意卡——

最后还有一张任意卡，记录个人阅读感想。

## 前言

本书的主要目标之一是：揭示一个高层结构在现实机器上的实现机制，而不是仅仅介绍使用它的方法。其中所闻述的内容将包括：多个相互关联的程序之间的链接、树结构、随机数生成、高精度运算、radix 变换、数据封装、组合査找、递归等内容，即一种自底层逐步向上的论述方法（简称自底向上，bottom-up）。

在我的书中，程序例子都非常简短，原因是：我希望能更多地突出关键思想，引发读者思考。我要对那些希望深入了解计算机的读者说：了解底层硬件的工作原理机制是必需的，否则写出来的程序必然是「莫名其妙的」。

一些基本算法（如排序和搜索）通常都是用机器语言编写的，因为，只有这样才能保证最佳效率。在它们的编写中，要求我们对 Cache、RAM 大小等硬件结构有足够深入的研究，如内存访问速度、流水、多发（multi-Issue）、后援缰冲、Cache 块大小等问题。并且，还要分析它们对程序运行性能的影响，从而在各种可能的实现方法之间作出权衡和比较。

在「华章教育」的总规划之下出版三个系列的计算机教材：除「计算机科学丛书」之外，对影印版的教材，则单独开辟出「经典原版书库」；同时，引进全美通行的教学辅导书「Schaum's Outlines」系列组成「全美经典学习指导系列」。

2『华章教育是机械工业出版社下面的，去读这三个系列的书。』

Patt 教授在他的主页中说到：他热爱计算机教学和科研，但相比科研，教学是他的「first love」。鉴于他在计算机发展历程中的贡献及在计算机科学教育方面的深刻理解和倾心投入，他被 IEEE 评为泰斗级人物（与《「计算机程序设计艺术》的作者 Donald Knuth 齐名，全球只有他们两人享此殊荣）。

有关本书在教学中的使用方法可参考原书序言。作者在第 1 版前言中提出了六种教学模式，在第 2 版前言中又将其归纳为三种教学模式，即「一年级两个小学期全授课」、「一年级两学期先高级语言再回顾深入底层」、「二年级再回顾底层」三种模式。我们的总结是，本书分为两部分，前 10 章（第一部分）讲述的是计算机的组成原理，后 9 章（第二部分）讲述 C 语言。

在前半部分内容中，作者以开发的 LC-3 机器（仿真机器）为背景，讲述了计算机的基本组成和实现（如运算器、指令编码/译码、I/O）等。学生可以通过 LC-3 机器和汇编器学习汇编，甚至尝试自己的机器设计方法。

本书的后半部分讲述了 C 语言内容。但其讲述方法与通常的 C 语言课本完全不同，它在讲述 C 语言变量、指针、语句、数据结构等内容的同时，结合前 10 章的知识，闻释了这些高级语言行为怎样转换为机器语言并运行在硬件系统中。其中，涉及很多长期困惑程序员的问题，如函数调用时栈空间（或函数帧空间）的使用规则、给变量赋值常量的几种方法之间的比较、软件中断指令的执行过程等。此外，即使将后半部分内容看作是单纯的 C 语言教材也无妨，它没有通篇机械地论述 C 语言的语法规则，而是通过简单计算器、Hanoi 塔、排序等问题的求解，轻松地讲述了 C 语言编程的要点，且非常自然地传授了 C 编译器的工作原理、递归编程技巧和注意事项、程序调试的原理和技术、数据结构的重要性等「高级」内容。也正如作者在文中提到的，在语言教学中，编程方法学和实现原理比编程语法更为重要，前者传授的是通过编程解决问题的能力，后者则可以通过练习和自学就达到熟练。

也许你听过这个有启示的故事：在 20 世纪五六十年代时，美国 GE 公司的一个大型发电机出了问題。所有的操作人员及工程技术人员面对一大堆的仪表和旋钮一等莫展。于是他们请来了一位这方面的专家，这位专家看了一下，便拿出一把螺丝刀，将一个旋钮反时针转动了 35 度，发电机就正常运转了。后来，专家开出的账单为 1000 美元，GE 觉得花两分钟钮动一个旋钮就收取 1000 美元太多，便要求专家出具一份更详细的说明。两天后，专家寄来了新的账单：

1、将旋钮反时针方向转动 35 度：0.75 美元。

2、知道应转动哪个旋钮及转动幅度：999.25 美元。

一本好的教科书不应只教导学生转动 A 旋钮 35 度，而是应教会学生为什么要转动 A 旋钮及为什么只能转动不多不少的 35 度。这个例子恰恰能印证本书的优点所在。

本书最大的特点是其提倡的层次转换概念，即从问题开始到计算机运算出结果可以分为七个层次。通过七个层次的转换，即可完成从问题到结果的转变。这七个层次及其转换是问题到算法的转换、算法到程序设计语言的转换、程序到指令集结构（ISA）的转换、指令集结构到微观结构的转换、微观结构到电路的转换和电路到电路组件的转换。该书对每个层次转换进行了深入的闻述，讲解了为什么需要这些转换以及没有这些转换所带来的困难。

本书是计算科学相关专业新生的入门教材。我们认为「自底向上」方法是帮助学生理解技术计算原理的最好方法（参考后面第 1 版前言中的详细论述）。事实和经验表明，学生在掌提了计算机底层工作的原理机制之后，能更加从容地解决以后可能面临的新问题，包括高级编程语言方面的向題。而且，这些学生学习編程语言的方法是「理解式」而不是「记亿式」的，因为一切动作都是明明白白的。

本书内容取自密歇根大学开设的 EECS100 课程——这是计算机科学（CS）、计算机工程（CE）和电子工程（EE）三个专业的第一门计算机类主修课程。该课程由 Kevin Compton 教授和本书第一作者于 1995 年秋季开设。

之所以开设 ECS100，是因为多年来计算机科学与工程系的教师认为，他们的本科生对计算机基本概念缺乏深入的理解。例如，学生们无法清楚地解释指针变量，而递归概念对他们来说就像是在「变魔术」，难以理解。

所以，我们在 1993 年提出对传统教学思路的改革。传统的教学思路是从高级计算机语言开始入手，但是在这种教学方式下，学生仅仅是「记住」了其中的技术细节，并不能真正「理解」其原理、机制。本书的教学思路是「自底向上」（bottom-up）：1）从 MOS 晶体管开始，依次介绍逻辑门、锁存器、各种逻辑结构（如 MUX、解码器、加法器、门控锁存器），然后通过存储器（或内存）的实现案例，将以上概念有机结合。2）随后，介绍冯·诺伊曼模型，并以简单的 LC-2 计算机为背景，介绍 LC-2 机器语言编程和汇编语言编程；3）再之后，我们继续上升到高级语言（如 C 语言），以及递归、指针、数组等概念；4）最后，引入一些基本的数据结构。

有一种「信息隐藏」（Information Hiding）学习方法，但我们不太赞同这种方法。事实上，「信息隐藏」确实是个很有效的学习方法 [1]。但我们认为，只有在你真正搞明白它在做什么之后，信息隐藏方法才具有意义。换句话说，我们计划将每个概念的底层动作都暴露、表现出来，消除在上层感受到的神秘感。

需要指出的是，虽然本书采用的是「自底向上」方法，但并不意味着我们反对「自顶向下」（top-dowm）方法。相反，我们认为「自顶向下」在设计方面是非常正确的方法。在设计中采用的方法，与在学习中采用什么样的方法，是两件不同的事情。就是说，对前者我们主张采用「自顶向下」方法（前提是设计者已深入理解底层构造），而对后者（即学习和理解过程）我们则主张「自底向上」方法。

本书的前半部分偏重计算机底层机制。从底层基础知识开始，逐步上升到操作系统和高级语言程序的接口层，以便能够理解真实计算机的工作原理。

第 2 章：介绍基于位（bit）的算术和逻辑运算操作，以及相关的结构设计（即 LC-2 计算机的组成）。

第 3 章：存储器设计。从 MOS 晶体管开始，逐步介绍存储器的实现过程。该存储器很简单，每字宽度为 3-bit，共 4 个字大小（而不是 64 MB）。其中，每个部件的设计图都不超过一页大小（以方便阅读）。至此，构建存储器所要求的知识就全部介绍完了。

第 4 章和第 5 章：介绍冯・诺伊曼模型及 LC-2 计算机的组成结构。LC-2 是一个 16-bit 结构的计算机，也是冯・诺伊曼模型的一个具体实现。它具备以下功能和特性：1）键盘和显示器等物理 IO 设备。2）调用操作系统服务的 TRAP 机制。3）基于 N、Z、P 等条件码的条件跳转。4）子程序调用和返回机制。5）基本的操作指令集合（ADD、AND 和 NOT）。6）各种加载（load）和存储（store）寻址模式，如直接、间接、基址 + 偏移和立即数等有效地址计算方式。

第 6 章：介绍编程方法学和调试方面的知识。

第 7 章：介绍汇编语言编程，以及我们开发的 LC-2 仿真器和汇编器。

第 8 章：讨论物理设备的输入（键盘）和输出（显示器）。

第 9 章：讨论操作系统的陷入机制（TRAP），以及子程序调用和返回机制。

第 10 章：是本书上半部分的总结。通过「计算器程序」例子，讲述栈和数据转换的原理和机制。该程序由 1 个主程序和 11 个子程序组成。

作为一种高级语言，C 语言最适合于我们的「自底向上」方法，因为 C 语言是各种高级语言中「最低级的」。通过它，能够清晰地表现软件和硬件的接口关系。本书的 C 语言学习内容，着重于控制结构语句、函数、数组等基本概念；在基本掌握编程概念之后，高级概念（如对象、抽象等）的学习就是轻而易举的事情了。

第 11 章：高级编程语言概述。本章将通过一个简单的 C 程序，作为学习 C 语言的「敲门砖」学生之前学习的汇编技术，将有助于对高级语言要素背后动机的理解。

第 12、13 章：这两章是对 C 语言的系统介绍。其中，第 12 章涉及数值、变量、常数、运算符等概念。第 13 章引入 C 语言的控制结构。

第 14 章：介绍高级语言源代码的调试技术。

第 15 章：介绍 C 语言的「函数」概念的。但本书中的重点不仅是语法层面的介绍，更重要的是其运行时原理的描述。如栈空间运行时的变化过程。

第 16 章：讲述「递归」技术。它涉及之前学过的函数、活动记录、运行时栈空间等概念。

第 17 章：指针和数组。理解这两个概念之间微妙区别的要点在于对内存结构的深入理解。

第18章：介绍 C 语言 I/O 函数的技术细节，包括：流、可变长参数，以及 C 语言通过各种「格式」（format specification）控制 IO 的效果（参考第 8 章）。

第 19 章：C 语言的总结。并引出结构、动态内存分配和链表等概念。

我们在教学过程中发现，学生对「指针变量」的理解毫不费力，这让我们非常意外。这或许就是本书教学方法的效果，因为之前他们已了解内存的概念及其逻辑设计和实现机制，所以能迅速理解地址和数据之间的差异。

「递归」是个难以掌握的概念。但在学习「递归」概念时，理解「递归」所需的基础知识都已具备，如：子程序调用/返回时的栈变化（第 10 章）、被调用者（called 或 callee）和调用者（caller）之间的链接方法等，然后引入运行时活动记录、参数传递、动态声明等概念就比较容易了。换句话说，如果你能够理解一个函数是怎样调用另一个函数的，那么一个函数调用它自己的过程（即递归）也就不言而喻了。

1、理解而不是记忆。

由于本课程的学习方法是「自底向上」，所以不存在编程课程所面临的「规则」记亿。这是因为按照本书的知识结构，在接触新概念之前，与之相关的底层实现机制必然都已学过。另外，这种「自底向上」的方法对以后设计类课程的学习也非常有益。因为如何在多种设计方案中做出正确的权衡和决策，完全取决于你对问题的理解和洞察深度。

2、自己动手。

我们经常听到工业界抱怨：「计算机专业毕业的学生不懂得编程」。然而，造成这种现象的部分原因，竟然是「热心」的助教。因为，他们将「实验」准备得太充分了，以至于学生不费力气就能完成题目，从而失去了对编程过程和艺术的「体会」。我们所要求的是：学生必须在没有助教帮助的情况下，尽可能独立地完成编程任务。当然，我们之所以敢这么要求，原因在于：

1）本书所采用的「自底向上」方法给予学生的是「理解」而不是「记忆」。

2）本书配套的仿真器工具，学生从第一天学习开始，就要使用它，并用它来调试程序。这种学习顺序的安排，以及基于仿真器的编程调试经验，培养了学生通过分析和实验方法来解决问题的能力（而不是一味地求助于助教，即由助教完成程序的编写工作）。

3、为未来做准备：深入底层。

计算机专业人士都有这样的体会，即系统运行的性能不仅仅取决于他们编写程序的水平。缺乏对系统底层知识的了解，使得他们面对一些性能问题时一筹莫展。这种情况很多，其中不乏资深程序员和工程师。

作为高级程序员，要编写高效率代码，仅仅掌握高级语言本身是不够的。除此之外，他们还需要了解与设备相关的知识（甚至是引脚定义等）。例如，在一些应用系统中，计算机的作用是从某种测量设备（如天气测量仪或反馈控制系统等）中采样数据，那么工程师要掌握的知识就不仅限于 FORTRAN 语言了。对于电子工程师来说是如此，在机械、化工、航空等领城亦如此。而在高级语言编程课程中，编译器这个「保护层」也将计算机底层的丑陋细节都隐藏了。换句话说，如果计算机课程的内容仅限于编程语言，那么培养出来的学生是无法胜任未来工作的。

4、连漪效应。

本书内容对后续课程将产生涟漪效应（rippling effect）。例如，假设学生对 C 语言语法和底层结构之间的互动机制已有所了解，那么在以后的语言编程课程中就可以将重点放在问题求解算法及更复杂的数据结构方面。再如，在硬件方面也存在类似的情况：在以后的数字逻辑设计和计算机组织课程中，他们很容易联想到硬件和上层语言之间的交互场景，从而理解底层设计的重点和动机。在计算机组织课程中，刚接触术语「程序计数器」（Program Counter）时，学生通常会问，「为什么要有程序计数器，有什么用？」密歇根大学的教学反馈表明，在 ECS100 课程开设前后，学生在后续课程中对该类问题的理解有明显差异。