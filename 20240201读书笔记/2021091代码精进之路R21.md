## 记忆时间

## 目录

第二部分 思想

0801 抽象

0901 分治

1001 技术人的素养

1101 技术 Leader 的修养

## 0801. 抽象

若想捉大鱼，就得潜入深渊。深渊里的鱼更有力，也更纯净。硕大而抽象，且非常美丽。

—— 大卫·林奇

### 本章小结

「抽象」作为名词，代表着一种思维方式，它的伟大之处在于可以让我们撇开细枝末节，去把握事物更本质、更一般的特性，从而更有效地对问题域进行分析设计。「抽象」作为动词，代表着一种能力，它是我们理解概念、理清概念之间逻辑关系的基础，也是我们面向对象分析设计所要求的底层能力。

归纳总结，合并同类项是进行抽象活动时最有效的方法。同时，我们也要注意到抽象是有层次性的。当一个概念无法涵盖其外延的时候，我们有必要提升一个抽象层次来减少它的内涵，让其有更大的外延。

建议读者一定要多多培养自己的抽象思维。阅读、写文章，以及逻辑思维训练都是提升抽象思维能力非常好的方式。只要坚持学习和锻炼，你慢慢就能体会到一种不一样的美 —— 抽象之美。

### 8.0

软件行业有一个概念，对其了解越深入，我就越会感叹之前的理解是多么肤浅。在很长一段时间里，对这个概念的一知半解阻碍了我对面向对象技术，甚至是软件架构的深层次理解。

实际上，对这个概念的认知偏差，我并非个例，我接触的工程师中能深入理解这个概念的并不多。能把这个概念和建模、面向对象和软件架构进行融会贯通，并进行问题分析、化繁为简的人就更是凤毛麟角了。

因此，我认为很有必要用一章的篇幅深入介绍这个重要的概念 —— 抽象。

### 8.1 伟大的抽象

没有抽象思维，就没有人类今天灿烂的文明。原始人看到一片满是松树的树林，不会给它们一个名字，而是给每一棵树取一个独特的名字，可能叫「silisiba」。原始人只知道某棵具体的树。

随着意识水平的发展，人类开始将具有相同特征的事物归并到一起，从「silisiba」到「松树」—— 到「树木」—— 到「植物」—— 到「物质」，从具象思维到抽象思维，这个过程人类花了几万年的漫长时间。

赫拉利在《人类简史》中说，「人类之所以成为人类，是因为人类能够想象」。这里的想象，我认为很大程度上是指抽象能力。正是抽象思维帮助人类从具体事物中抽象出各种概念，再用这些概念去构筑种种虚构的故事。这些概念包括经济（例如货币、证券）、文学、艺术和科学等，都是建立在抽象的基础之上的。

### 8.2 到底什么是抽象

抽象和具象是相对应的概念，「抽」就是抽离，「象」就是具象。从字面上理解抽象，就是从具体中抽离出来。英文的抽象 abstract 来自拉丁文 abstractio，它的原意是排除、抽出。

按照维基百科上的解释，抽象是指为了某种目的，对一个概念或一种现象包含的信息进行过滤，移除不相关的信息，只保留与某种最终目的相关的信息。例如，一个「皮质的足球」，我们可以过滤它的质料等信息，得到更一般性的概念，也就是「球」。从另一个角度看，抽象就是简化事物，抓住事物本质的过程。

按照这个定义，「苹果」就是一个抽象，是对「苹果」这个概念的统称，它抹去了单个苹果对象的特征，不管是大的小的、甜的不甜的、红的不红的，都叫作「苹果」。

在绘画流派中，有一种流派叫抽象主义，最著名的抽象派大师就是毕加索，图 8-1 所示是毕加索画的牛。

图 8-1 实物牛和抽象牛的对比

毕加索的画中只有几根线条，却是做了高度抽象之后的线条，过滤了绝大部分水牛的细节，只保留了牛的最主要的一些特征。正因为其抽象层次更高，因此其泛化能力更强，「抽象牛」不仅可以表示水牛，也可以表示黄牛、奶牛、野牦牛…… 只要是牛都逃不过这几根线。可以说，抽象更接近问题的本质。

### 8.3 抽象是 OO 的基础

面向对象（Object Oriented，OO）的思考方式，就是万物皆对象。抽象帮助我们将现实世界的对象抽象成类，完成从现实世界的概念到计算机世界的模型的映射。例如，有一堆苹果，如果对其进行抽象，我们可以得到 Apple 这个类，通过这个类，我们可以实例化一个红色的苹果：new Apple ("red")。此时，如果我们需要把香蕉、橘子等水果也纳入考虑范围，那么 Apple 的抽象层次就不够了，我们需要 Fruit 这个更高层次的抽象来表达「水果」的概念。

面向对象的思想主要包括 3 个方面：面向对象的分析（Object Oriented Analysis，OOA）、面向对象的设计（Object Oriented Design，OOD），以及我们经常提到的面向对象的编程（Object Oriented Programming，OOP）。

OOA 是根据抽象关键问题域来分解系统。OOD 是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成「现实世界」的抽象。OOP 可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者更直接些，就是一系列对计算机下达的指令。

可以看到，抽象贯穿于 OO 的始终，是 OO 的前提和底层能力，抽象能力差的人是很难做好 OO 的。

### 8.4 抽象的层次性

对同一个对象的抽象是有不同层次的。层次越往上，抽象程度越高，它所包含的东西就越多，其含义越宽泛，忽略的细节也越多；层次越往下，抽象程度越低，它所包含的东西越少，细节越多。也就是我们常说的，内涵越小，外延越大；内涵越大，外延越小。不同层次的抽象有不同的用途。

有一次在家，女儿问我：「爸爸你会不会画猫？」我说，「会呀」。然后她又问：「那你会画房子吗？」我说，「也会呀」。她有点失落，然后看看外面问：「那你会不会画城市？」。为了让女儿开心，我跟她说：「城市那么大，爸爸不会画。」她还太小，以为画城市就要把城市的每个细节都画出来，不知道抽象是有层次的。

这种抽象的层次性基本可以体现在任何事物上，以下是对一份报纸在多个层次上的抽象。

第一层：一个出版物。

第二层：一份报纸。

第三层：《旧金山纪事报》。

第四层：5 月 18 日出版的《旧金山纪事报》。

第五层：我拥有的 5 月 18 日出版的《旧金山纪事报》。

如果我要统计美国有多少家出版单位，那么就要用到第一层「出版单位」的抽象。如果我要查询旧金山 5 月 18 日当天的新闻，那么就要用到第五层的抽象。

分层抽象在软件的世界里随处可见，是软件架构的核心，也是我们构建当今信息帝国的基石。有一句名言，「软件领域的任何问题，都可以通过增加一个间接的中间层来解决。」

这种分层在某种意义上也是抽象的分层，每一层的抽象只关注本层相关的信息，对上层屏蔽复杂性，从而简化整个系统的设计。

例如，我们的系统就是分层的。最早的程序直接运行在硬件上，开发成本非常高。然后慢慢开始有了操作系统，操作系统提供了资源管理、进程调度、输入输出等所有程序都需要的基础功能，开发程序时调用操作系统的接口就可以了。再后来发现操作系统也不够用，于是又有了各种运行环境（如 JVM）。

编程语言也是一种分层的抽象。机器理解的其实是机器语言，即各种二进制的指令。但是使用二进制编程效率极低，所以我们用汇编语言抽象了二进制指令，用 C 语言抽象了汇编语言，而高级语言 Java 抽象了低级语言。

很难想象，如果没有抽象分层，人类该如何应对软件世界这么高的复杂度。阿里巴巴的软件系统的复杂度绝对不亚于一个城市，若是没有抽象分层，就像要在一张画布上画出整个城市的细节，从摩天大厦到门把手，从公园到街道上的猫，其画面难以想象……

### 8.5 如何进行抽象

#### 8.5.1 寻找共性

简单来说，抽象的过程就是合并同类项、归并分类和寻找共性的过程。也就是将有内在逻辑关系的事物放在一起，然后给这个分类进行命名，这个名字就代表了这组分类的抽象。

我们的生活中无时无刻不在进行着这样的抽象，语言本身就是对现实世界的抽象符号表达。比如当你说「花」的时候，就使用了抽象概念，它包含了各种各样、万紫千红的花的本性。

在我们写代码的过程中，如果遇到大量重复或者部分重复的代码，往往意味着抽象的缺失，可以通过合并归类来进行优化。

例如，我们在一个应用中大量使用搜索的功能，因为搜索的条件比较复杂，所以系统中充斥着大量的如下所示的代码：

```java
// 取默认搜索条件
List<String> defaultConditions = searchConditionCacheTunnel.getJsonQueryByLabelKey(labelKey);

for (String jsonQuery : defaultConditions) {
    jsonQuery = jsonQuery.replaceAll(SearchConstants.SEARCH_ DEFAULT_PUBLICSEA_ENABLE_TIME, String.valueOf(System.currentTimeMillis() / 1000));
    jsonQueryList.add(jsonQuery);
}

// 取主搜索框的搜索条件
if (StringUtils.isNotEmpty(cmd.getContent())) {
    List<String> jsonValues = searchConditionCacheTunnel.getJsonQueryByLabelKey(SearchConstants.ICBU_SALES_MAIN_SEARCH);
    for (String value : jsonValues) {
        String content = StringUtil.transferQuotation(cmd. getContent());
        value = StringUtil.replaceAll(value, SearchConstants. SEARCH_DEFAULT_MAIN, content);
        jsonQueryList.add(value);
    }
}
```

这样的代码不是出现在一个地方，而是散落在需要搜索查询的地方，总共几十处。随着时间的推移，这样的重复代码可能还会继续增加，如图 8-2 所示。

图 8-2　散落在各处的搜索代码

问题就在于抽象的缺失。首先，对于搜索条件，我们可以用 SearchCondition 这个类进行抽象和封装；其次，对于组装搜索条件的过程，我们可以用 SearchConditionAssembler 类进行抽象。添加这两个抽象之后，我们再对原来的代码进行重构，消除重复后的代码如下所示：

```java
public class SearchConditionAssembler {
    public static SearchCondition assemble(String labelKey) {
        String jsonSearchCondition = getJsonSearchConditionFromCache (labelKey);
        SearchCondition sc = assembleSearchCondition(jsonSearchCondition);
        return sc;
    }
}
```

因此，合并同类项，找到共性，再给这个共性命名的过程就是一个简单的抽象过程。

然而有些时候，发现共性的过程并不像重复代码这么简单直观，需要对问题域有深入理解。例如，如果你不了解 CRM 领域，就很难做出「公海」和「私海」的抽象。有时，可能还需要动用非凡的想象力。

#### 8.5.2 提升抽象层次

当我们发现有些东西无法归到一个类别中时，该怎么办呢？此时，我们可以通过上升一个抽象层次的方式，让它们在更高的抽象层次上产生逻辑关系。

例如，你可以合乎逻辑地将苹果和梨归类为水果，也可以将桌子和椅子归类为家具。但是怎样才能将苹果和椅子放在同一组中呢？仅仅提高一个抽象层次是不够的，因为上一个抽象层次是水果和家具的范畴。因此，你必须提高到更高的抽象层次，比如将其概括为「商品」。

如果我们想把大肠杆菌也纳入其中，该怎么办呢？此时，「商品」这个抽象也不够用了，需要再提高一个抽象层次，比如叫「物质」（见图 8-3）。但是这样的抽象太过于宽泛，难以说明思想之间的逻辑关系。类似于我们在 Java 中的顶层父类对象（Object），万物皆对象。

图 8-3 抽象的层次性示例

在开发工作中，很多时候就需要通过抽象层次的提升来提高代码的可读性和通用性。

举个例子，现在有 Apple 和 Watermelon 两个类，都继承自 Fruit。对于苹果来说，我们认为甜度大于 60 就是好的；对于西瓜，我们认为水分大于 60 就是好的。两个类的代码如下所示。

1、Apple 类：

```java
public class Apple extends Fruit {
    private int sweetDegree;
    public boolean isSweet(){
        return sweetDegree > 60;
    }
}
```

2、Watermelon 类：

```java
public class Watermelon extends Fruit {
    private int waterDegree;
    public boolean isJuicy(){
        return waterDegree > 60;
    }
}
```

此时，我们需要把好的水果挑出来，不难写出一个 FruitPicker（挑选水果的类），其代码如下：

```java
public class FruitPicker {
    public List<Fruit> pickGood(List<Fruit> fruits){
        return fruits.stream().filter(e -> check(e)).collect(Collectors.toList());
    }

    private boolean check(Fruit e) {
        if (e instanceof Apple) {
            if(((Apple) e).isSweet()) {
                return true;
            }
        }

        if (e instanceof Watermelon) {
            if (((Watermelon) e).isJuicy()) {
                return true;
            }
        }
        return false;
    }
}
```

这里的代码有个问题，就是 instanceof 的使用。为了判断苹果和西瓜是否好，我们需要借用 instanceof 获得具体的对象才能完成。

面对这种情况，可以考虑是否要做抽象层次的提升。进一步考查，我们会发现，不管是 Apple 的 isSweet()，还是 Watermelon 的 isJuicy()，本质上都是在判断水果是否可口。因此，我们完全可以在 Fruit 上定义一个 isTasty()，如图 8-4 所示。

图 8-4 提升抽象层次示例

通过提升抽象层次，我们有了新的 Fruit 类：

```java
public abstract class Fruit {
    // 提升抽象层次，需要一个新方法来表达这个抽象
    public abstract boolean isTasty();
}
```

再回头看一下 FruitPicker，已经不再需要 instanceof 来做辅助判断了：

```java
public class FruitPicker {
    public List<Fruit> pickGood(List<Fruit> fruits) {
        return fruits.stream().filter(e -> check(e)).collect(Collectors.toList());
    }
    // 不再需要 instanceof
    private boolean check(Fruit e) {
        return e.isTasty();
    }
}
```

通过上面的示例可以看到，提升了抽象层次的代码的通用性也随之提升，程序更好地满足了 LSP（里式替换原则）。因此，每当我们有强制类型转换，或者使用 instanceof 时，都值得停下来思考一下，是否需要做抽象层次的提升。

#### 8.5.3 构筑金字塔

《金字塔原理》是一本教人如何进行结构化思考和表达的书，核心思想是通过归类分组搭建金字塔结构，这是一种非常有用的思维框架，让我们更加全面地思考，在表达观点时更加清晰。

书中提到，要自下而上地思考，总结概括；自上而下地表达，结论先行。其中，自下而上总结概括的过程就是抽象的过程，构建金字塔的过程就是寻找逻辑关系、抽象概括的过程。经常锻炼用结构化的方式去处理问题，搭建自己的金字塔，可以帮助我们理清问题的脉络，提升抽象能力。

金字塔结构让我们通过抽象概括将混乱无序的信息形成不同的抽象层次，从而便于理解和记忆，这是一个非常实用的方法论。

举个例子，你要出门买报纸，你妻子让你带点东西回来并列了一个清单，里面有葡萄、橘子、咸鸭蛋、土豆、鸡蛋、牛奶和胡萝卜。当你准备出门时，你妻子说，「顺便再带点苹果和酸奶吧」。

如果不用纸笔写下来，你还能记住妻子让你买的 9 样东西吗？大部分人应该都不能，因为我们的大脑短期记忆无法一次容纳 7 个以上的记忆项目并超过 5 个小时，我们就会开始将其归类到不同的逻辑范畴，以便记忆。

对于葡萄、橘子、牛奶、咸鸭蛋、土豆、鸡蛋、胡萝卜、苹果和酸奶，我们可以按照逻辑关系进行分类，搭建一个金字塔结构，如图 8-5 所示。

图 8-5 金字塔结构示例

分类的作用不只是将一组中的 9 个概念分成每组各有 4 个、3 个和 2 个概念的 3 组概念，因为这样还是 9 个概念。你所要做的是提高一个抽象层次，将大脑需要处理的 9 个概念变成 3 个概念。

这样，你无须再记忆 9 个概念中的每一个概念，仅需记忆 9 个概念所属的 3 个组。思维的抽象程度提高了一层，由于处于较高层次的思想总是能够提示其下面一个层次的思想，因而更容易理解和记忆。

### 8.6 如何提升抽象思维

讲了这么多关于抽象的概念，抽象思维又是如此重要。那有没有办法来锻炼和提升我们的抽象思维呢？

当然有，抽象思维也是可以习得的。婴幼儿没有抽象思维，你和他玩躲猫猫游戏，把他的眼睛蒙上，他就以为你消失了，再放开，他看到你就会很高兴。因为他只能意识到你这个具象的人，意识还到不了抽象的程度。理解具象的内容要更加简单容易，而理解抽象内容则要困难和复杂很多。

#### 8.6.1 多阅读

为什么阅读书籍比看电视更好呢？因为图像比文字更加具象，阅读的过程可以锻炼我们的抽象能力、想象能力，而看画面时你的大脑会被铺满，较少需要抽象和想象。

这也是我们不提倡小孩子过多地看电视或玩手机的原因，因为不利于锻炼其抽象思维。

抽象思维的差别使孩子们的学习成绩从初中开始分化，许多不能适应这种抽象层面训练的孩子可能选择去读职业技校，因为这里比大学更加具象 —— 车铣刨磨、零件部件等都是能够看得到、摸得到的。

#### 8.6.2 多总结

小时候，我们可能不理解语文老师为什么总是要求我们总结段落大意、中心思想。现在回想起来，这种思维训练在基础教育中是非常必要的，其实质就是帮助学生提升抽象思维的能力。

做总结最好的方式就是写文章，小到博文，大到一本书，都是锻炼自己抽象思维和结构化思维的机会。记录也是很好的总结习惯。以读书笔记来说，最好不要原文摘录书中的内容，而是要用自己的话总结归纳，这样不仅可以加深理解，还可以提升自己的抽象思维能力。

现实世界纷繁复杂，只有具备较强的抽象思维能力的人，才能够具备抓住事物本质的能力。

#### 8.6.3 领域建模训练

对于技术人员来说，还有一个非常好的提升抽象能力的手段 —— 领域建模。当我们对问题域进行分析、整理和抽象时，或对领域进行划分和建模时，实际上都是在锻炼我们的抽象能力。

关于这一点，我深有感触。当开始使用第 6 章中介绍的建模方法论进行建模时，我会觉得无从下手，建出来的模型也很别扭。然而，经过几次锻炼之后，我很明显地感觉到自己的建模能力和抽象能力有所提升，不但分析问题的速度更快了，而且建出来的模型也更优雅了。

## 0901. 分治

要把大象装冰箱，拢共分几步？

—— 小品《钟点工》

### 本章小结

软件产业正在变得越来越庞大和复杂，互联网正在变得越来越激进。我们在同一时间能够关注和处理的信息有限，所以学会分治思想很重要。学会如何对复杂问题进行分层和拆解，是我们解决复杂问题的第一步。本章只介绍了分治思想在软件领域中的一些应用，而实际应用场景要广泛得多，不仅限于软件领域。

### 9.0

分治和抽象一样，都是人类进化过程中形成的伟大智慧，也是我们解决复杂问题的不二选择。人的思维要从一个字节大幅跨越到几百兆字节，也就是 9 个数量级（现阶段，后面还要再加 N 个零）。如此复杂的问题域，如果不进行分治，是远远超出人类智力范围的。

分治的价值在于，我们不应该试着在同一时间把整个问题域都塞进自己的大脑，而应该试着以某种方式去组织问题，以便在一个时刻专注于一个特定的部分。这样做的目的是尽量降低在任意时间所要思考问题的复杂度。

本章将介绍分治思想在软件领域的一些典型应用，以此加深我们对分治的理解和认知，让分治的理念融入我们的潜意识中，使我们在开发工作中灵活地使用分层、分场景和分步骤等解决办法，化解软件设计中的复杂问题，从而写出可读性更好的代码，开发出可维护性、可扩展性更好的系统。

### 9.1 分治算法

我记得在学校上算法课时，老师介绍的第一个算法思想就是分治算法，这是一种高效、简洁、优美的算法思想。分治算法主要包含两个步骤 —— 分、治。「分」就是递归地将原问题分解成小问题；「治」则是在解决了各个小问题（各个击破）之后合并小问题的解，从而得到整个问题的解。

分治法解题的一般步骤如下。

1、分解：将要解决的问题划分成若干规模较小的同类问题。

2、求解：当子问题划分得足够小时，用较简单的方法解决。

3、合并：按原问题的要求，将子问题的解逐层合并，构成原问题的解。

#### 9.1.1 归并排序

分治算法一般都可以写成一个递归表达式。例如，经典的归并排序的递归表达式 T(N)=2T(N/2)+O(N)，T(N) 代表整个原问题，采用了分治解决方案后，它可以表示成如下形式。

1、分解成规模只有原来一半（N/2）的两个子问题：T(N/2)。

2、解决了这两个子问题 T(N/2) 之后，再合并这两个子问题，需要的代价是 O(N)。

归并排序的求解过程如图 9-1 所示。

图 9-1 归并排序的求解过程

#### 9.1.2　二分搜索

二分搜索又称为二分查找、折半查找，是一种效率较高的查找方法。比如，数据库中的索引查找方式（哈希索引除外）就是一种二分、三分或者多分查找的算法，分的多少和索引的数据结构相关。

二分搜索要求线性表为有序表，并且要用向量作为表的存储结构。二分搜索的基本思想是先确定待查找记录所在的范围，然后逐步缩小范围，直至找到或找不到该记录位置。

二分查找的步骤如下。

1、先确定中间位置：middle = (left+right)/2。

2、将待查找的 key 值与 data[middle].key 值相比较。若相等，则查找成功并返回该位置；否则，需要确定新的查找区间，继续二分查找，具体方法如下。

如果 data[middle].key 大于 key，由于 data 为有序线性表，可知 data [middle…right].key 均大于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 左边的子表中。

反之，data[middle].key 小于 key，因此若表中存在关键字等于 key 的节点，则一定在位置 middle 右边的子表中，下一次针对新的区域进行查找。

二分查找的 Java 代码实现如下：

```java
public staticvoidmain(String[]args) {
    int[] a = {1,2,3,4,5,6,7,8,9};
    intpos = bSearch(a, 0, a.length-1, 1);
    System.out.println(pos);
}

public staticintbSearch(int[]data,intleft,intright,intkey) {
    // 获取中间位置
    intmiddle = (left+right) / 2;
    // 比较 key 值如相等，返回当前位置，否则确认新的查找空间
    if (data[middle] == key) {
        return middle;
    }
    elseif (data[middle] > key) {
        return bSearch(data, left, middle-1, key);
    }
    else {
        return bSearch(data, middle+1, right, key);
    }
}
```

#### 9.1.3　K 选择问题

K 选择问题是指，给出 N 个数，找出其中第 K 小的元素。如果直接用穷举法，一共需要比较 K×N 次，当 K 与 N 有关时，比如 K 是中位数（K=N/2），那么时间复杂度为 O(N2)；采用分治，则可把复杂度降低为 O(N)。

首先，在 N 个数中选出一个枢轴元素，将比枢轴元素大的元素放到枢轴元素的右边，将比枢轴元素小的元素放到枢轴元素的左边。这样，N 个数被分成了两部分，比枢轴大一部分记为 S(1)，比枢轴小的部分记为 S(2)，这就是分治的「分」。

假设一种理想的情况，枢轴元素基本位于中间值，即它总是将原数组划分成两个大小基本相等的子数组 S(1) 和 S(2)。

要求解第 K 小的元素，有以下 3 种情况。

1、若 K < |S(1)|，则说明第 K 小的元素位于 S(1) 子数组中。其中，|S(1)| 表示 S(1) 数组中元素的个数。

2、若 K == |S(1)| + 1，则说明第 K小的元素刚好是枢轴元素。

3、否则，第 K 小的元素位于 S(2) 子数组中。

如果是情况 1 或者情况 2，可以继续递归分解子数组。分解问题之后，将 N

个元素分成了两个 N/2 个元素的子数组，只需要在其中一个子数组中进行查找即可，使用穷举查找，复杂度为 O(N/2)。

递归表达式为 T(N) = T(N/2) + O(N/2)，解为 O(N)，这说明采用分治算法可以将 K 选择问题的时间复杂度降低为 O(N)。

### 9.2 函数分解

函数过大过长是典型的代码「坏味道」，意味着这个函数可能承载着过多的职责，我们有必要「分治」一下，将大函数分解成多个短小、易读、易维护的小函数。第 3 章中已经介绍了大量函数分解的技艺。关于函数分解，在此强调以下两点。

1、函数长短是职责单一的充分不必要条件，也就是长函数往往意味着职责不单一，但是短函数也不一定就意味着职责单一。

2、在使用组合函数模式时，要注意抽象层次一致性原则（Single Level of Abstration Principle，SLAP），不同抽象层次的内容放在一起会给人凌乱、逻辑不协调的感觉。

### 9.3 写代码的两次创造

本书一直在强调，我们不仅要写实现功能的代码，还要写容易理解的好代码。「写出好代码」除了需要好的技艺之外，还要有好的方法论。以我的实践经验来看，优雅的代码很少是一次成形的，大部分情况下要经过两次创造：第一遍实现功能，第二遍重构优化。

#### 9.3.1 第一遍实现功能

不要试图一次就写出「完美的」代码，这样只会拖慢我们的节奏。就像写文章，第一遍可以写得粗糙一点，把大概意思写出来，然后再仔细打磨，斟酌推敲，直到达到理想的样子。

写代码也是如此，第一遍以实现功能为主，可以允许一定的冗长和复杂，比如有过多的缩进和嵌套循环，有过长的参数列表，名称可以随意取，还会有部分的重复代码。第一遍主要是为了理清逻辑，为第二遍的重构优化做好准备。

#### 9.3.2 第二遍重构优化

如果只是止步于功能实现，那么代码最多只是一个半成品。而实际情况是我们的代码库中有太多这样的半成品，导致系统的复杂度不断攀升，越来越难维护。因此，我们需要有第二次创造 —— 重构优化，即在第一遍实现功能的基础上，看一看是否可以做得更好：命名合理吗？职责单一吗？满足 OCP 吗？函数是否过长？抽象是否合理？

第二次创造通常要比第一次创造更费精力、更耗时间，所以很少有人愿意去做第二遍的事情。比如，要你回答 2 加 2 等于几，你凭直觉就知道是 4，但是如果把问题换成 37×189，你可能都懒得去算，在心里想没事费这劲干嘛。这也是康纳曼·丹尼尔在《快思慢想》一书中提出的重要理论：系统一（感性）和系统二（理性）。动用系统二会耗费能量，而人类是从贫瘠的远古时代进化而来的，为了保存能量，一般默认的是使用系统一思考，不到万不得已，是不会启动系统二的。

因此，最好的优化肯定不是等系统上线后再去做，因为这样往往就等于「再也不会去做」（later equals never）。优化工作本应该是我们编码工作的一部分，拆成两步，主要对编码效率上的考量。

### 9.4 分治模式

很多的设计模式都用到了分治的思想。例如，第 5 章中介绍的管道模式，以及没有详细介绍的责任链模式和装饰者模式，其中都有分治的思想。就责任链模式来说，我们不会把处理一件事情需要的所有职责都放在一个组件中，而是放在多个组件中完成，形成一个链条。这样不仅增加了可扩展性，也使每个组件的职责变得更加单一，更容易维护。

以我曾做过的一个服务机器人项目为例，机器人的应答内容会根据页面、场景、类目、租户的不同而展现出不同的内容。从优先级上来说，租户 Handler 的优先级最低，也就是如果前面的 Handler 都没有命中，那么租户 Handler 可以用来兜底，如图 9-2 所示。这种情况下，使用责任链的分治策略是一种比较好的选择。

图 9-2 服务机器人响应请求的责任链

### 9.5 分层设计

分层设计是架构体系设计中最常见和重要的一种结构。分层设计最大的好处是分离关注（Separation of concerns），这样我们就可以通过分层隔离简化一个复杂的问题，让每一层只对上一层负责，从而使每一层的职责变得相对简单。

#### 9.5.1 分层网络模型

网络通信是互联网最重要的基础实施之一，它是一个很复杂的过程，包括 TCP 协议 —— 在不可靠的网络上出现状况要怎么办，IP 协议 —— 把数据包传给谁。需要处理的事情有很多，我们可不可以在一个层次中都处理掉呢？当然是可以的，但显然不科学。因此，ISO 制定了网络通信的七层参考模型，每一层只处理一件事情，低层为上层提供服务，直到应用层把 HTTP 和 FTP 等方便理解和使用的协议暴露给用户。

但是，我们实际在 Internet 中使用的并不是七层模型，而是 TCP/IP 四层模型，如图 9-3 所示。因为七层参考模型过于理想化，过多的分层反而降低了效率，让问题变得更复杂。这里就涉及另一个问题：分层是不是越多越好？当然不是，分层有很多好处，但也有代价。在处理复杂问题时，不能不进行分层，但只分有必要的层。

图 9-3 七层模型和四层模型

#### 9.5.2 分层架构

分层架构的目的是通过分离关注点来降低系统的复杂度，同时满足单一职责、高内聚、低耦合、提高可复用性和降低维护成本，也是一种典型的分治思想。

在分层架构中，分层的使用可以进行严格地限制 —— 分层只知道直接的下层；或者可以宽松一些 —— 分层可以访问它之下的任何分层。Martin Fowler 的经验是在实际中使用第二种方式会更好，我的经验也可以验证这个说法，因为它避免了在中间分层创建代码方法（或者完整的代理类），也避免了退化成千层面的反模式。

有时分层会安排领域层将数据源完全隐藏，不让展现层看到。但是更多时候，展现层会直接访问数据存储，这虽然不那么纯粹，但实际却工作得更好。

这种灵活的分层机制实际上是一种开放的分层架构，如图 9-4 所示。这种不教条和 12.2.2 节中介绍的 CQRS 有着类似的作用，即领域层是可选的，允许应用层绕过领域层直接和基础设施层进行通信。关于架构的更多内容，将在第 12 章详细讨论。

图 9-4 开放的分层架构

### 9.6 横切和竖切

随着互联网的发展，用户流量呈指数型增长，单体应用已经不能适应发展的需要，分布式架构正在变得越来越重要。如果你经常参加一些技术峰会，可以看到这样的分享：一个小企业从一台应用服务器、一个数据库慢慢壮大，发展成独角兽公司，其架构也随之演变成一个大型分布式系统。

这不是偶然，而是企业架构演化的必然结果，因为只有分治才能应对网络高并发，实现水平扩展。

以分布式数据库为例，我们把原来放在一个数据库中的几千亿数据通过竖切、横切（水平拆分和垂直拆分），切分成相对较小的几十个乃至几千个小数据库，以便满足性能和可用性的要求。所谓竖切，就是按照领域将单体数据库拆分成多个数据库。比如，原来电商数据都是放在一个库中，我们可以按照领域拆分成商品库、会员库、交易库等，如图 9-5 所示。

图 9-5 数据库竖切

横切是通过一种数据路由算法对数据进行分片，从而减少一个数据库中的数据量。比如，我们要将会员的交易数据切分成 10 个库，可以用 userId 对 10 进行取模，如图 9-6 所示，这种水平扩展能力在理论上来说提供了无限扩展的可能。

图 9-6 数据库横切

## 1001. 技术人的素养

未经审视的人生不值得过。

—— 苏格拉底

### 本章小结

本章介绍了一些有用的思维模式、工作方法，以及我自己的一些人生感悟。写下这些，是因为我曾经迷茫过，不知道方向在哪里，不知道什么是正确的事，也不知道要怎么做正确的事。一路走来，回头望去，坑洼无数，伤痕累累。

好在，过去的磨难都是现在的财富。这些曾经的挫折帮我塑造了成长型思维；培养了我持续学习的习惯；磨炼了我的心智 —— 知道如何放平心态，同时又积极热爱生活；最重要的是给了我自由，让我不再轻易受环境的影响，做了自己命运的主人。

如果你也曾迷茫过，或者正在经历迷茫，希望这些文字可以带给你一些启发。

### 10.0

在我的工作经历中，会发现有一些技术人员成长很快，能够迅速成为团队的骨干，也有一些技术人员总是在原地踏步，工作十年和工作一年的区别并不大。渐渐地，我发现这些优秀的技术人员都有一些共同的特质和素养，从而帮助他们不断进步，脱颖而出。

### 10.1 不教条

在软件的世界里没有「银弹」，在技术人的众多素养中，「不教条」占有重要的地位。我在工作过程中看到过太多教条主义的错误，例如，我曾见过一个团队为了做微服务，将本来的一个不大的应用拆分成了几十个微服务应用。

教条的主要原因是我们还停留在有样学样的阶段，导致我们忘记了 软件的第一性原理是「控制软件复杂度」。但凡能提高代码可读性、可扩展性和可维护性的方法，都是值得考虑的，并不一定要拘泥于某种特定的开发过程或者编程范式。

就像 Effective Java 一书的作者 Joshua Bloch 说的，「同大多数学科一样，学习编程艺术首先要学会基本的规则，然后才能知道什么时候去打破规则」。

#### 10.1.1 瀑布还是敏捷

选择软件开发过程绝不是要么瀑布（Waterfall），要么敏捷（Agile）这么简单。实际上，软件开发的生命周期风格类似一个连续光谱 —— 有从瀑布式到敏捷，以及它们之间的多种可能性。

以我的工作经验来看，软件开发过程并不是软件工程中最大的障碍，不是你花了大量时间在需求分析和设计上，项目就一定会失败；也不是你每天早上花 5 分钟讨论「昨天做了什么，遇到什么问题，今天做什么」，项目就一定能成功。

敏捷开发是基于迭代模型发展起来的一套软件开发指导原则。我们在实际操作中应重视指导原则，弱化方法论。

就像 Scrum 的创始人 Jeff Sutherland 在其敏捷宣言中说的，「我建立 Scrum 模型就是为了把敏捷的价值观糅进一套工具集以便于更好地实践，敏捷模型没有方法论。」

敏捷还有一个误区，就是弱化设计。其实我对此事的认知也是有一个过程的，我是敏捷的极力拥护者，非常感激敏捷让我们摆脱了软件能力成熟度集成模型（Capability Maturity Model Integratio，CMMI）的沉重枷锁。凡事过犹不及，实施敏捷就可以「无设计」吗？设计可以在敏捷过程中自然涌现吗？实践告诉我们，似乎不能。就像盖房子，在盖之前要打牢地基，如果地基还没完工就匆忙建造房子，那么就很难摆脱糟糕的地基了。类似地，系统架构中的基础改动起来会变得困难，从而不得不做出各种妥协和临时方案。

因此，我们需要在大设计和无设计之间找到一种平衡。一个软件从无到有，不管你是瀑布、迭代，还是敏捷，一般会经历下面的过程。

1、需求：对于系统该做什么，建立并保持与客户和其他涉众的一致意见，定义系统的边界。

2、分析与设计：将需求转化为系统设计，设计将作为在特定实现环境中的规格说明，包括逐渐形成一个健壮的系统架构，建立起系统不同元素必须用到的共同机制。

3、实现：编码、单元测试以及对设计进行集成，得到一个可执行的系统。

4、测试：对实现进行测试，确保它实现了需求，通过具体的展示来验证软件产品是否像预期的那样工作。

5、部署：确保软件产品能被它的最终用户使用。

基于此，我推荐一种综合了瀑布模式、迭代模式和敏捷思想的软件开发过程。在此提倡根据迭代所处阶段的不同，在不同科目上花不同的时间，如图 10-1 所示，灰色部分代表一个阶段在当前迭代中所花时间的比重。

图 10-1 改良的迭代开发

#### 10.1.2 贫血还是充血

一提到事务脚本（Transaction Script）和 DDD，人们就习惯性地给它们扣上贫血 [1] 和充血的帽子。简单来说，贫血模式提倡模型对象只包含数据，并提供简单的 Getter 和 Setter；而充血模式提倡数据和行为放在一起，是一种更加面向对象的做法。两种模式都有自己的道理，也都有人支持。

在我看来，这种争执是没有必要的，因为没有抓住问题的本质。问题的核心不在于行为和数据是否在一起，而在于你能否有效地控制复杂度。如果你有很好的面向对象思维，使用贫血也可以写出好的代码；没有面向对象思维，即使采用 DDD，也会陷入复杂性的泥潭。

纠结于贫血还是充血，一方面是因为没有抓住问题的本质，另一方面也源于一种非黑即白的教条思维。就像 4.2 节中的 Rectangle 案例所展示的，行为和数据是否放在一起，只是表现形式的差别，并不是用来区分面向对象和面向过程的关键区别。

#### 10.1.3 单体还是分布式

在业务发展早期，因为用户少、流量少，功能相对简单。如图 10-2 所示，基本上单体（Monolithic）应用架构就足以支撑业务的发展。

图 10-2 单体应用架构

然而，随着业务的发展和用户的增加，单体应用的局限性开始显现。具有水平扩展性（scale out）的分布式系统架构几乎已经变成互联网公司的标配，如图 10-3 所示。

图 10-3 分布式应用架构

虽然面向服务的架构（Service Oriented Architecture，SOA）和微服务有一统天下之势，但是并不代表单体架构就会退出历史舞台，特别是在中台概念提出来以后。中台要求通过集中式的中台管控来提升软件系统的复用，避免趋同的业务重复造轮子的现象。中台的目的就是要通过中台能力来赋能前线业务，提升对前线业务的支撑效率，其架构如图 10-4 所示。

图 10-4 中台架构

可以看到，中台虽然也是对业务进行聚合，但并不是对单体架构的简单回归，而是综合了分布式理念之后升级版的「超级单体」。正是这种不教条和辩证的发展思维，才推动互联网架构不断地向前发展演进。

### 10.2 批判性思维

批判性思维（Critical Thinking）是一种谨慎运用推理去断定一个断言是否为真的能力。它要求我们保持思考的自主性和逻辑的严密性，不被动地全盘接受，也不刻意地带着偏见去驳斥一个观点。批判性思维也是一项能够被习得，并且通过训练和运用来提高的能力。

技术人员虽然有很强的逻辑推理能力，但不见得都有很强的逻辑思维，我也是如此。在知晓批判性思维之前，我曾吃过很多亏，明知道对方在强词夺理，可就是找不到很好的反驳理由。无论是在公司和同事争辩，还是在家里和老婆斗嘴，几乎没有赢过。后来我学习了一些批判性思维的知识，情况才有所改观，可以抓住对方的一些逻辑漏洞和推理谬误进行反驳，这使我在职场上拿回了不少话语主动权。不过在家里，我依然是输多赢少，后来我才发现，原来家不是一个讲逻辑的地方。

关于训练批判性思维的书有很多，我重点推荐两本，一本是尼尔·布朗写的被誉为批判性思维领域经典读物的《学会提问》，另一本是樊登读书会推荐的《思辨与立场：生活中无处不在的批判性思维工具》。我在读这两本书的时候，经常会有 aha moment（顿悟时刻），真的很有收获。

2『已下载书籍「2019095学会提问」，思辨与立场，目前未找到电子版。（2201-11-07）』

在《学会提问》一书中，有这样一个案例。

小张：「小王真不是个男人，酒吧里那个醉汉威胁说要揍他一顿，他吓得屁滚尿流。」

小李：「他要不是男人，你怎么解释他身上那些鼓鼓的二头肌呢？」

你觉得小李的话有道理吗？如果你觉得有点道理，但又觉得有点不对劲，那么就应该去好好读读这本书。这里小李犯了一个典型的推理谬误 —— 偷换概念谬误（Equivocation Fallacy），小张说的「男人」是指「男子气概」，而小李说的「男人」是指「男人生理」，这两个概念是不一样的，这就是问题所在。

### 10.3 成长型思维

成长的过程中不可能是一帆风顺的，肯定会有痛苦、有阻力、有挫折。面对逆境，我们应该怎么做？有些人也许不堪重负，就此沉沦了，而有些人可以越挫越勇，把每一次失败都当成学习的机会。研究发现，成长型思维（Growth Mindset）和固定型思维（Fixed Mindset）会极大地影响我们面对逆境的处理方式。我在最低迷的时候，正是成长型思维帮我渡过了难关。

斯坦福大学心理学教授卡罗尔·德韦克在经过数十年的研究后，发现了思维模式的力量。她在《终身成长》中提醒我们：我们获得的成功并不是能力和天赋决定的，更多受到我们在追求目标的过程中展现的思维模式的影响。

成长型思维和固定型思维体现了应对成功与失败、成绩与挑战时的两种基本心态。你认为才智和努力哪个更重要、能力能否通过努力改变，决定了你是会满足于既有成果，还是会积极探索新知。通过了解自己的思维模式并做出改变，人们能以最简单的方式培养对学习的热情，以及在任何领域内取得成功都需要的抗压力。

具有成长型思维的人相信自己可以通过学习来提升自我，相信学习和成长的力量，相信努力可以改变智力和能力。我们可以通过图 10-5 所示的对比来判断一个人是「成长型思维」还是「固定型思维」。

图 10-5 成长型思维和固定型思维对比图

我曾经就是一个典型的固定型思维的人，在遇到困难和挫折时很容易引发自我怀疑和自我否定。在了解了成长型思维之后，我开始逐渐转变思维模式，会用更加理性的态度看待一时的成败得失，内心坚定地相信成长和学习的力量。从某种意义上来说，你正在读的这本书也是我在习得了成长型思维之后，才得以写出来的。

技术人员的工作面临着很多的挑战，我们需要具备成长型思维才能应对工作和生活中的压力，这样在遇到问题时，我们才不会轻言放弃，而是会积极主动地去学习，去寻找解决方案。即使最终还是失败了，我们也不会一蹶不振，而是把失败当作学习的机会。

### 10.4 结构化思维

在日常工作中，我们时常会碰到有的人讲一件事情的逻辑非常混乱，前后没有逻辑性关联，甚至无法把一件事情说清楚。思维混乱是缺少结构化思维的典型表现。实际上，我们不仅在表达上要结构化，在分析问题时更要有结构化思维，这样才能分析得更全面、深刻。

什么是结构化思维呢？我给结构化思维的定义就是「逻辑 + 套路」。

1、逻辑。所谓逻辑，是指结构之间必须是有逻辑关系的。例如，你说话时用「第一、第二、第三」这个逻辑顺序是合理的，而如果用「第一、第二、第四」就会显得很奇怪。实际上，组织思想的逻辑只有 4 种。

1）演绎顺序：比如「大前提、小前提、结论」的演绎推理方式就是演绎顺序的。

2）时间（步骤）顺序：比如「第一、第二、第三」和「首先、再者、然后」等，大多数的时间顺序同时也是因果顺序。

3）空间（结构）顺序：比如「前端、后端、数据」和「波士顿、纽约、华盛顿」等，化整为零（将整体分解为部分）等都是空间顺序。在做空间分解时，要注意满足「相互独立，完全穷尽」（Mutually Exclusive Collectively Exhaustive，MECE）原则。

4）程度（重要性）顺序：比如「最重要、次重要、不重要」等。

只要我们的思想和表达在这 4 种逻辑顺序之内，就是有逻辑的，否则就是没有逻辑的。

2、套路。套路是指我们解决问题的方法论、路径和经验。比如，5W2H 分析法就是非常好的，是可以帮助我们分析问题的一个「套路」。试想一下，面对任何一个问题，你如果都能从「Why、Who、When、Where、What、How 和 How much」（如图 10-6 所示）这 7 个方面去思考，是不是比不知道这个方法论的人用点状模式思考要全面得多呢？

图 10-6 5W2H 问题分析法

逻辑是一种能力，而套路是方法论、经验；逻辑属于道，而方法论属于术。二者都很重要，只有熟练地掌握二者，我们才能有更好的结构化思维。接下来，通过两个案例来介绍结构化思维在实际工作场景中的应用。

#### 10.4.1 如何落地新团队

想象这样一个场景，你刚刚入职一家新公司或者转岗到一个新团队，作为一个技术人，你将如何落地开展工作呢？

这里就能用上结构化思维来帮助我们理清思路，从而有条不紊地开展工作。要知道对一个企业来说，核心要素无外乎就是 业务、技术和人。我们所要做的就是如何去熟悉业务、熟悉技术、熟悉人，然而每一部分又可以进行进一步的结构化拆解，如图 10-7 所示。

图 10-7 落地新团队的策略

1、熟悉业务。1）了解产品形态：任何一个团队都有自己要负责的产品，申请一个测试账号去用一下产品，是熟悉产品比较好的方式。2）了解业务流程：任何业务都有自己的业务流程，而业务流程中的核心是信息流。我们可以通过人员采访了解关键节点的信息输入和信息输出；通过画一些泳道活动图来理清楚系统的主要角色，以及它们之间的交互关系。3）走访客户：通过走访客户，我们可以获得业务的第一手资料，更加贴近业务和客户诉求。

2、熟悉技术。1）了解系统架构：可以让团队的技术人员介绍他们当初做系统设计和架构时的思路。2）了解领域模型：查看关键的核心表结构和系统 API，快速了解系统的领域模型。3）了解代码结构：下载系统工程，熟悉整个工程结构和模块职责；以一个最重要的流程为入手点，阅读代码，看清楚核心的执行逻辑；做一个小需求，掌握相关的流程和权限。

3、熟悉人。1）了解组织结构：查看公司的组织树，知道公司大概是如何运作的，以及哪些是关键人（Key Person，KP）。比如，一个典型的电商公司会包括产品部、运营部、销售部、技术部、人力资源部、财务部和法务部等。2）了解人员角色：了解公司都有哪些岗位，以及各岗位的职责范围。3）勤沟通：找出和自己工作息息相关的岗位，比如产品和运营，积极和这些同事沟通，向他们请教业务问题，多多交流。这样既可以建立良好的人际关系，也可以更快地熟悉业务。

#### 10.4.2 如何做晋升述职

我在阿里巴巴已经做了多年的晋升评委，发现很多人都缺乏结构化思维，讲着冗长的 PPT，却不能很好地把一件事情说清楚。实际上，做工作汇报或者述职是很容易结构化的。

最清晰和实用的结构化表达是「提出问题，定义问题，分析问题，解决问题，最后展望未来」。如果按照这个逻辑顺序去阐述一件事情，会比不知道这个「套路」的效果好得多。这也是麦肯锡常用的解决问题的框架。

另一个有用的思维框架是「zoom in / zoom out」。我们说事情时，应该像电影镜头一样，先从远拉近，再由近拉远。

「zoom in」是先从宏观背景开始，首先让大家知道你的事情发生的背景，为什么这件事情很重要？然后讲到具体细节，怎么做成的？解决了什么问题？后端思考是什么？最后「zoom out」，从细节调回到整体，结果是什么？带来的客户价值是什么？你对未来的思考是什么？

可以看到，这些结构化的方法论可以帮助我们做到事半功倍，经常锻炼结构化思维可以极大地提升我们的职场竞争力。

### 10.5 工具化思维

提到懒惰，很多人都会投去鄙视的眼光。殊不知，适当的懒比低效的勤奋更具智慧，是更难得的美德。

其实偷懒也有高低之分，可以分为 3 个境界。

1、最差的境界是「实在懒」，拖延不喜欢的任务。

2、其次是「开明懒」，迅速做完不喜欢的任务，以摆脱之。

3、最高的境界是「智慧懒」，编写某个工具来完成不喜欢的任务，以便再也不用做这样的事情了，从而一劳永逸。

懒惰的对立面除了勤奋，也可能是「硬干」或「苦干」。「硬干」或「苦干」并没有带着光环，而是一种徒劳、低效、大可不必的努力，只会说明你做事情很急切，但并不是在完成工作。人们容易混淆行动与进展、混淆忙碌与多产的概念。

在有效的工作中，最重要的是思考，而人在思考时通常看上去不会很忙。如果和我共事的程序员总是忙个不停，我会认为他并非优秀的程序员，因为他没用最有价值的工具 —— 自己的大脑。

我们提倡的「智慧懒」实际上是一种工具化思维，是「磨刀不误砍柴工」的智慧。有人说程序员和其他行业的最大区别是不仅使用工具，还能创造工具。可不是吗？理发师虽然会理发，但是不会制造剪刀。软件工程师却可以自己创造工具，用来提效，帮助自己更好、更快地完成工作。

我经常在团队中说，每当你重复同样的工作 3 次以上，就应该停下来问问自己：我是不是可以通过自动化脚本、配置化，或者小工具来帮助自己提效？

例如，我在 eBay 工作时，公司的应用依赖比较多，加上开发机器性能的限制，在本地启动服务通常都需要 3 分钟以上。一次 3 分钟不多，但是如果需要在本地频繁启动做测试，就会浪费很多时间。为此，我写了一个 TestContainer 的小工具，再配合 IDE 的热部署功能，在大部分情况下都不用重启服务，这个小小的创新为我和团队带来了极大的便利，节省了很多时间。为此，我还获得了公司当年的「突出贡献奖」。

所以，对于那些整天非常忙，忙到没有时间思考的读者，我真心建议你停下来，思考一下：我的方法有没有问题？是不是有更「偷懒」的方式可以帮助我提升效率？不要像图 10-8 中的拉车人，已经举步维艰了，还拒绝改变。

图 10-8 关于工作效率的漫画

### 10.6 好奇心

学习的动力不应该来自于外界的强力，而应该来自于内在，来自于我们内心对知识的渴望、对世界的好奇心。要想了解好奇心的重要性，可以去看看《列奥纳多·达·芬奇传》，看看这个 500 多年前被称为永恒史诗的「最好奇的人」，是如何在好奇心的驱使下在绘画、解剖学、地质学、机械设计、光学、植物学等多个领域都做出杰出贡献的。

1-2『显然作者是个喜欢读书的人，提到的不少书自己看过、没看过的之前基本也已经收录了。已下载书籍「2019595达芬奇传」。（2021-11-07）』

好奇心是创新的驱动力。首先，它使我们灵活思考，打破现有的思维局限，从而不断地突破自己，完善自己的工作方式。其次，机会总是留给有准备的人，好奇心会促使我们张开翅膀在未知的领域里飞翔，给自己和公司带来新的机会。再次，拥有好奇心的人常常是快乐的，因为一切事物都是那么新奇，你会因为工作中的一点小突破而感到快乐，你会因为同事或者领导的一句肯定而快乐，你更会因为在工作中获取新知识、新技能、创造价值而快乐。最后，好奇心能使我们在工作中不断学习、积累经验，从而提高工作效率。

好奇心是学习的起点。我自己也是个「好奇宝宝」，我曾写过一篇文章，是关于阿里巴巴所有缩写的英文全称和中文解释的，上面还配了一段文字：「 亲，我懂你，不了解缩写背后的全称，你晚上睡不着。」我本来是自己整理备用，但是没想到这篇文章到目前为止总共获得了超过 35 万的浏览数和 2000 多个赞。我当初怎么也没有想到，一个出于好奇的总结，能帮助这么多人。

做技术这一行，应该没有比持续学习更重要的了。因为有太多新的东西需要我们学习和了解，很多人工作了很多年，知道的东西还很少，对很多东西的理解不透彻，就是因为缺少一点好奇心，没有深入钻研。

好奇心是学习的起点，是创新的原动力。我们每个人都应该像小孩子一样保持对知识的渴望，对世界的惊奇。

### 10.7 记笔记

好的学习方法也很重要。我记得几年前在阿里巴巴的一次内部会议上，主持人问一个副总裁：「你成功的秘籍是什么？」这个副总裁只说了一点：「 好记性不如烂笔头。」这个会议的内容我已经完全不记得了，但是这句话我一直记到现在，因为它对我的触动很大。

后来在工作中，我每每遇到比较欣赏的人，都能发现他们有一个共同的习惯 —— 勤做笔记。这不是一个偶然现象，里面有其必然的因素。首先，做笔记的人基本都是持续学习的人；其次，记录本身也有很多好处。

1、知识内化：记笔记的过程是一个归纳整理、再理解、再吸收的过程，可以加深我们对知识的理解。

2、形成知识体系：零散的知识很容易被遗忘，而形成知识体系之后，知识之间就能有更强的连接。

3、方便回顾：笔记就像我们的硬盘，当缓存失效后，我们依然可以通过硬盘调回，保证知识不丢失。

我真正养成记笔记的习惯是在两年之前，在前言中，我写了「如果能更早地了解这些知识、掌握这些方法该有多好」，记笔记就是其中一项。不过还好，有觉悟也不算太晚，在这短短两年中，我记了上千篇笔记 —— 从哲学、工作到银行卡密码，可以说我现在的工作和生活已经完全不能脱离笔记了。好处是，我很明显地感受到自己归纳总结的能力和文笔都比以前好了很多。

那么如何记笔记呢？是的，如何记好笔记也是有方法的。在此，我将自己有限的记笔记经验分享出来，希望这些细节能帮助你提高笔记质量。

1、使用云笔记：云笔记要能在多端使用，要有目录的层次结构、标签和搜索功能。如果有些场合只能用笔做记录，也没关系，回来之后再整理到云笔记上。

2、归类分组：要定期回顾笔记内容，尽量按照合理的方式对笔记进行重组，形成一个有逻辑关系的树形结构。这样既方便记忆检索，也可以逐渐形成自己的知识体系。对于归于 A 组或 B 组都没错的笔记，可以使用标签来辅助分类。

3、不要复制粘贴：好的笔记最好是自己消化后的总结，而不是简单的照抄。如果有引用和参考，建议把链接也放在笔记下面，方便溯源。

4、结构化表达：对于简短的内容要重点突出，粗体显示重点部分；对于篇幅较长的内容，最好有目录，这样可以更加结构化地呈现笔记内容。

### 10.8 有目标

目标的重要性，以前是被我低估的。实际上，我之前的很多焦虑和迷茫都是目标不清晰导致的。例如，在我进入技术管理岗位之后，不知道后面的方向是什么，是继续在技术上专研呢？还是要研究管理之术呢？直到我再次翻开史蒂芬·柯维的《高效能人士的七个习惯》一书，仔细阅读才发现，「你要做一个什么样的人」并不是一个可有可无的次要问题，而是首先要回答的头等大问题，这时我才意识到目标的重要性。

在《高效能人士的七个习惯》中，柯维博士提到，「所有事物都要经过两次创造的原则，第一次为心智上的创造，第二次为实际的创造」。直观的表达就是：先想清楚目标，然后努力实现。不管是人生大问题，还是阶段性要完成的事情，都需要目标清晰、有的放矢。

例如，你需要提高自己的思辨和逻辑能力，那么就应该制定一个学习计划，多去看一些批判思维、逻辑学和哲学的书。

又如，很多人表示看过很多技术文章，但是总感觉自己依然一无所知。一个很重要的原因就是，没有带着目标去学习。在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，学习效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把 Redis 的持久化原理搞清楚？还是把 Redis 的主从同步机制弄明白？抑或是想学习整个 Redis Cluster 的架构体系？如果我们能够带着问题与目标去搜集相关的资料并学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好得多。

### 10.9 选择的自由

自由并不是想做什么，就做什么。自由是一种价值观，是一种为自己过去、现在及未来的行为负责的价值观。自由是一种责任，是一种敢于做出选择，并愿意为自己的选择承担后果的责任。

责任感（Responsible），从构词法来说是「能够回应」（Response—able）的意思，即选择回应的能力。所有积极主动的人都深谙其道，因此不会把自己的行为归咎于环境、外界条件或他人的影响。他们根据价值观有意识地选择待人接物的方式，不会因为外界因素或一时情绪而冲动行事。

消极被动的人会受到「社会天气」的影响。别人以礼相待，他们就笑脸相迎，反之，则摆出一副自我守护的姿态。心情好坏全都取决于他人的言行，任由别人的弱点控制自己。但这并不意味着积极主动的人对外界刺激毫无感应，只不过他们会有意无意地根据自己的价值观来选择对外界物质、心理与社会刺激的回应方式。

积极主动的人有选择的自由，而消极被动的人往往是被动地接受影响，忘记了自己的主观能动性，忘记了在刺激和回应之间还有选择的自由（There is always a space between stimulus and response）。如图 10-9 所示，当外界的刺激到来时，我们总是可以用自我意识、想象力、良知和独立意志做出自己的选择。

图 10-9 积极主动的选择模式

但凡成大事者，都能够「处乱世而不惊，临虚空而不惧，喜迎阴晴圆缺，笑傲雨雪风霜」。正因为他们是自己思维的主人，而不是被思维所控制，他们知道不管身处什么样的境地，都有「选择的自由」。

### 10.10 平和的心态

我的座右铭是「动机至善，了无私心；用无为的心，做有为的事」。

首先，我们做事情的出发点必须是善的。其次，「有为的事」是指要认真做事，认真生活；「无为的心」代表一种平和的心态，一种活在当下的智慧。也就是做事要积极，但是心态要放平。

关于心态的重要性，我有过一段难忘的经历。曾经有一段时期，我非常焦躁，整夜睡不着觉，情绪低落，工作做不好，书也看不进去…… 这种状态反过来让焦虑变得更加严重，恶性循环。最主要的原因是「心」出了问题，是我太在乎他人的眼光，太在乎面子，太在乎外界的宠辱得失，导致心态失衡。当我放下得失心，让自己平静下来，整个人仿佛获得了重生，我第一次真正感受到什么叫自由，什么叫作生活的主人。

真正平和的人了解自己所有的主观感受都只是一瞬间的波动。虽然疼痛，但不再感到悲惨；虽然愉悦，但不再干扰心灵的平静。于是，心灵变得一片澄明、自在。心灵平静的力量十分强大，那些穷极一生疯狂追求愉悦心情的人完全难以想象。

就像有人已经在海滩上站了数十年，总是想抓住「好的海浪」，让这些海浪永远留下来，同时又想躲开某些「坏的海浪」，希望这些海浪永远别靠近。就这样一天又一天，这个人站在海滩上徒劳无功，被自己累得几近发疯。最后终于气力用尽，瘫坐在海滩上，让海浪就这样自由来去。忽然发现，这样多么平静美好啊！

### 10.11 精进

精进就是你每天必须进步一点点！记住，慢就是快。如图 10-10 所示，千万不要忽视每天进步一点点的力量，也不要试图一口吃成胖子，真正的进步是滴水穿石的累积，这就是精进。

图 10-10　每天进步一点点

巴菲特说：「人生就像滚雪球，关键是要找到足够湿的雪，和足够长的坡。」我觉得在技术领域，「雪」是足够多的，「坡」也足够长，关键是我们能不能坚持下去。但凡能持续学习和精进的人，其结果都不会差。

[1] 贫血模式（Anemic Domain Model）是 Martin Fowler 在 2003 年提出的概念。

## 1101. 技术 Leader 的修养

Leader，就是走在队伍的最前面，带领者，领路人。

—— 金一南《胜者思维》

### 本章小结

做一个 Leader 不容易，因为你不仅要管好自己，还要成就他人。做一个技术 Leader 更不容易，因为技术的发展日新月异，你没有退路，如果不持续学习，你就会落伍；如果不深入技术细节，你就很难赢得下属的尊重。

普通的 Manager 到处都是，但是好的 Leader 并不多见。我们很多人在还没有准备好的时候，就被推上了 Leader 的位置，我本人也是这么过来的。关键是我们要清楚地认识到自己想要什么，要成为什么样的 Leader，路走对了，就不怕远。

### 11.0

从我开始带团队的第一天起，有几个问题就一直在等我回答。

1、什么是 Leader？

2、Leader 和 Manager 之间的区别是什么？

3、什么是技术 Leader？

4、技术 Leader 和其他 Leader 有什么不同？

本章内容主要是围绕我作为技术 Leader 对这几个问题的思考，以及对技术 Leader 的理解和定义。希望你看完本章以后，也能有一个自己的答案。

### 11.1 技术氛围

一个技术团队，不管大小，如果没有「技术味道」，那么技术 Leader 负有很大的责任。「技术味道」的缺失，是目前技术团队存在的最大问题。特别是做业务开发的技术团队，如果管理者完全不关心技术细节，绩效完全和业务 KPI 绑定，就会导致工程师们整天只会写 if-else 的业务代码，得不到技术上的成长。在这样的技术团队，团队的战斗力和凝聚力都会每况愈下。

那么作为一个技术 Leader，我们要如何去提升团队的技术氛围，重燃团队对技术的热情呢？下面是我在日常带团队的过程中使用的一些提升技术氛围的方法，方法并不难，在任何的技术团队都可以操作落地。

#### 11.1.1 代码好坏味道

在我们团队周会中，有一个固定的环节是「代码好坏味道」：当天的会议主持人（我们的周会是轮值主持的，每个团队成员轮流组织一期）要给大家分享 3 个代码好味道和 3 个代码坏味道，这些代码既可以是来自我们工作中的代码，也可以是来自开源软件的源码。

这个活动非常有意义，一方面每个人都会更多地去读他人的代码，另一方面自己在写代码时也会比较注意。因为一不小心，自己写的代码就可能成为反面典型被拿出来「晒」。晒代码不是关键，关键是通过晒代码，我们可以互相分享写好代码的心得和经验，特别是一些来自开源软件的好味道，对我们写好代码有非常重要的指导意义。这样整个团队的技术能力都会提升，当然，也包括 Leader 自己。

#### 11.1.2 技术分享

分享是倒逼我们去学习和总结的有效手段。在准备分享的过程中，我们要去阅读很多资料，要把原理弄清楚，还要用别人能听得懂的方式表述出来。最重要的是，通过分享，整个团队都能学到新的知识，分享人和倾听者都会收益颇丰，何乐而不为呢？

例如，我所在团队的近几次技术分享分别是关于 Service Mesh、FaaS 和 Cloud Native 的（见图 11-1）。这些概念虽然很重要，但是日常工作中暂时还没有使用场景，没有必要每个人都去研究一遍，因此分享学习是一种非常经济的团队学习模式。一个人学，然后整个团队都能有了解和认知。期间大家还可以有讨论和碰撞，这样既学到了东西，又增加了团队成员之间的连接，其作用不亚于一次团建。

图 11-1 团队正在分享 Cloud Native

#### 11.1.3 CR 周报

代码审查（Code Review，CR）是保证代码质量和架构风格一致性的重要手段。我们试过很多 CR 的方式，有 Peer Review（点对点地审查），也有 Group Review（团队成员一起审查）。这些方式都很好，但有一个共同的缺点，就是很难将过程透明化。

CR 周报就是要把 CR 的结果透明化，通过周报的形式展现团队在一周中的 CR 成果，包括团队成员的 CR 评论数排名、代码分支的质量情况，以及 CR 中的典型案例。这种透明化非常有价值，既可以帮助技术 Leader 了解代码质量的概况，也能极大地调动团队成员进行 CR 的积极性。

如图 11-2 所示，这是我所在团队一期 CR 周报的节选。同样，CR 周报的发送人也是轮值的，通过这种方式，我们真正做到把 CR 变成我们工作的一部分。

图 11-2 CR 周报示例

#### 11.1.4 读书会

在一个人的能力象限中，我非常看重学习能力。原因很简单，一个人一旦停止了学习，就停止了进步。读书虽然不是学习的唯一方式，但一定是不可或缺的方式。我在面试候选人时，会经常问「你过去一年都看了哪些书」，如果一本都没看过，基本该候选人就不在我的考虑范围之内了。

因此，我的团队中是非常重视读书这件事的。首先，作为一个技术 Leader，我们要带头读书，现在很多的下属不信服老板，就是因为老板不读书、不学习，不能给团队带来新的输入和营养；其次，要鼓励团队多读书，成立读书会就是一个很好的形式。

关于读书会的运作，在此分享以下 3 点经验。

1、书的范围可以放宽一点，不要只局限在技术类书籍，毕竟除了技术，我们还有很多东西要学。例如，我们最近一次读书会选的书是《高效能人士的七个习惯》。

2、读书的方式，可以是同读一本书，也可以拆书，就是每个人分别读书的一章或者几章，然后互相分享书中的内容和读后感。拆书的效率更高，比较适合工具类的书。

3、读书会的举办频率可以灵活一些，工作任务紧的时候，频率适当放低，甚至暂停。

### 11.2 目标管理

目标管理应该是 Leader 管理事务中最重要的事情之一。以我的经验来看，很多管理者（不乏很多高阶管理者）在目标管理上是缺少方法和经验的。一个好的 Leader，应该是愿意花时间和下属一起讨论、制定目标的。在过程中，给予帮助和指导，及时对焦纠偏，确保目标的达成。这样做是对下属负责，也对自己负责，至少不至于在谈绩效时造成意外，出现管理事故。

接下来，我们看看如何使用 OKR 对技术团队进行目标管理。

#### 11.2.1 什么是 OKR

目标管理的常见手段有关键绩效指标（Key Performance Index，KPI）和目标与关键成果（Objectives Key Results，OKR）两种方法。相比较而言，一味地追求 KPI，可能会导致短视；OKR 更注重短期利益和长期战略之间的平衡。

OKR 主要有如下两个特点。

1、OKR 可以不和绩效挂钩，主要强调沟通和方向。

2、OKR 比 KPI 多了一个层级的概念，O（Objective）是要有野心的、有一定的模糊性，但是 KR（Key Results）需要是可量化的，并且 KR 一定要为 O 服务，不能偏离 O 的方向。

举个例子，我们希望用户喜欢我们的产品，但「喜欢」无法测量，所以，把页面浏览量（Page View，PV）写进了 KPI 里面。但在实际执行过程中，我们可以把用户原本在一个网页上就能完成的事情分到几个网页上完成，结果 PV 达到了 KPI 制定的目标，但其实用户更讨厌我们的产品了。大家如此应付 KPI，可能是因为 KPI 和绩效考核挂钩。

#### 11.2.2 SMART 原则

不管是 KPI 的目标设定，还是 OKR 的 KR 设定，都需要满足 SMART 原则。如图 11-3 所示，S 代表 Specific，表示指标要具体；M 代表 Measurable，表示指标要可衡量；A 代表 Attainable，表示指标是有可能达成的；R 代表 Relevant，表示 KR 和 O 要有一定的相关性；最后，T 代表 Time bound，表示指标必须具有明确的截止期限。

图 11-3 目标设定的 SMART 原则

在目标制定上，Intel 的创始人戈登·摩尔给我们提供了一个很好的范例。他提出了摩尔定律 ——「当价格不变时，集成电路上可容纳的元器件的数目大约每隔 18-24 个月便会增加一倍，性能也将提升一倍」。这是一个堪称完美的 SMART 目标，引领着 Intel 半个多世纪的快速发展。至于摩尔定律本身是否科学合理，反而不那么重要了。

#### 11.2.3 OKR 设定

OKR 中的目标必须是有野心的。因为只有高远的目标 ，才能最大程度地激发人的潜能。目标是否足够有野心也是区分 OKR 与 KPI 的一个标志，KPI 拿 100 分的员工，OKR 可能只有 0.5 分（OKR 的得分是 0-1 分），这才是正常的结果，证明该员工的目标（O）比其他人的 KPI 要高很多。

例如，通常网站速度只能提高 20%，但是在 OKR 中，提高 30% 才是最合适的 O。这个目标肯定不是稍加努力就可以拿满分的，而必须很努力才能完成。拿到 0.6-0.7 分才是最优秀的目标设计。

表 11-1 是我给团队设置 OKR 的一个范例，可以看到，每一个 KR 都不是唾手可得的，都具有一定挑战性，而这正是 OKR 的价值所在。

表 11-1　OKR 示例

| 目标（O）| 关键结果（KR）| 得分 |
| --- | --- | --- |
| 提升 CRM 商家自运营能力 | 1）实现 EDM 一键开通功能；2）开通 EDM 功能商家达到 1 万家；3）在 S1 结束通过 EDM 发送邮件 1 亿封，订单转化　GMV 100 万。 | - |
| 打造 PaaS 基础设施，提升业务支撑效率 | 1）定义 PaaS 平台的职责；2）实现 PaaS 平台，并对外提供服务；3）完成至少 3 个 SaaS 业务的接入。 | - |
| 控制复杂度，提升工作效率 | 1）使用 COLA 重构 3 个老系统，消除重复代码，将复杂度超过 10 的函数控制在 0.5%；2）完善 ColaMock，提升核心代码单元测试覆盖率到 90%，提升测试代码编写效率 70%；3）对外演讲 5 次，宣扬工匠精神，并推广 COLA 在集团 5 个部门落地。 | - |

### 11.3 技术规划

技术规划和目标管理有一点共同之处，都是要在技术团队中理清接下来要做的事情。不同之处在于，技术规划更多的是从团队视角去看接下来要做的事情，而目标管理是要把规划要做的事情进行拆解，和个人目标对齐。对于技术 Leader 而言，做好技术规划是非常重要的事情，一个团队有没有价值，最终还是要通过做出来的事情来体现。

关于技术规划，我并没有多少经验，以下内容主要来自我的同事马俊锋（阿里巴巴资深技术专家）的分享。

技术规划是一个大命题。

对待这种大问题 ，我们要分而治之，将其分解成几个不同层次的、相对较小的问题来看。

如图 11-4 所示，我们可以从时间和重要性的维度，将其拆解成当前问题、技术领域、业务领域和团队特色 4 个层次的问题，然后分别定义问题、制定策略，这样就会清晰很多。

图 11-4 技术规划的 4 个层次

#### 11.3.1 当前问题

第一层问题解决是最直接的，主要看团队中现在有什么迫切、紧急的问题需要解决，有哪些坑要去填。例如，业务增长比较快、当前架构缺乏弹性、要做服务化拆分、加入分布式缓存、分表分库等。又如，因为代码质量（可读性、可维护性）差，要建立一个代码审查机制，提升代码质量。

#### 11.3.2 技术领域

技术领域要做的是在这些常规领域中，根据业务情况和团队情况选择一些领域和命题（比如稳定、性能、效率等），并在这些命题和方向中根据优先级做判断。比如，完善监控体系提升系统稳定性、使用 CDN 提升性能、通过测试自动化提升研发效率等。

#### 11.3.3 业务领域

让业务先赢是技术的首要使命，即使我们身处技术团队，也要充分理解业务、关注业务，要分析业务数据和发展趋势，和业务同事充分交流，总结和抽象出业务的发展对技术会提出什么诉求，需要技术做什么布局和建设以应对业务发展的需求。

#### 11.3.4 团队特色

作为技术团队，我们要对比团队内外技术的异同，最终圈定一个差异化区域。这块区域是团队的特色技术，是团队借外力之外要修内功的部分，是不依赖别人而主要靠自己突破的部分，是团队相比外面的差异化竞争力。这一层很重要，对团队的口碑、影响力和稳定性都有较大的影响；同时这一层又是最难的，很多技术团队在这一层次是空白的。

例如，在我的团队中，我们一直把攻克软件复杂度作为首要技术目标，所以在「工匠精神」方面，我们团队在阿里巴巴集团是有一定影响力和口碑的。在 2018 年，我们仅有 8 个人的团队支撑了业务项目，打造了 COLA 架构，还为集团贡献了工匠平台，这和我们一开始的技术信仰和技术规划是分不开的。

### 11.4 推理阶梯

在日常生活中，个人的判断大部分基于自身的主观认识而非事实，这会产生许多误会。在企业的日常运转中，管理者在对待员工时也会犯一些主观性的错误。例如，管理者要批评一个员工，前提是管理者认为员工做的事情是错误的，但是有没有可能管理者本身的认知就是错误的？因此，作为管理者，一定不要轻易对员工做推理，一些错误的推理如果不能及时被澄清，会激起员工的反感。要实事求是，尊重事实。

这种推理的情况在团队管理中比比皆是。很多情况下，我们推理别人的「结论」让自己非常生气，但是后来发现事实并非如此，这源于我们习惯用自我推理而非沟通的方式来解决问题。这种推理也被称为「推理阶梯」，如图 11-5 所示。

图 11-5 推理阶梯

一般而言，「推理阶梯」的发生会经历以下步骤。

1、收集数据：每个人每天都会接受来自外界的大量信息，这些是产生推理的基础。

2、选择性接收数据：尽管我们不愿意承认，但「选择性接收」才是大脑处理信息的固有方式。有句老话：「顺眼的人越看越顺眼，讨厌的人越看越讨厌。」「情人眼里出西施」，说的就是这个道理，没人能避免。就像 2002 年诺贝尔经济学奖获得者丹尼尔·卡尼曼说的：「我们根本不是理性的人，很多决定都是在稀里糊涂的状态下做出的感性决定，崇尚理性思维的博弈论很少在实际生活中得到应用。」

3、做出假设，得出结论，采取行动：在选择性接收数据之后，我们自然而然地就会想要赋予这些数据意义，从而做出种种假设，并得出相应的结论，然后采取行动，这就是大脑中「推理阶梯」的整个过程。比如，一个熟人迎面走来，没有打招呼，我们会很生气，感觉这个人没有礼貌。但实际情况可能是他没戴隐形眼镜、昨晚没睡好、加班了、走神了等各种情况。我们不要因为自己的好恶对别人进行推理，然后自己生气。

因此在做决定之前，我们一定要问问自己：「此事是否可能只是我的推理，实际情况并非如此？」这个问题对于管理者非常重要，因为人与人之间的沟通是非常复杂的过程。别人的一个眼神、一个动作，就有可能让我们在大脑中产生不客观的推理。

#### 11.5 Leader 和 Manager 的区别

简单来说，Manager 是管理事务，是控制和权威；而 Leader 是领导人心，是引领和激发。Leader 要做一些 Manager 的管理事务，但是管理绝对不是 Leader 工作的全部。

我在阿里巴巴内部曾发表过一篇言辞激烈的文章，其中指出：

我们不需要这么多「高高在上」、「指点江山」的技术 Manager，而是需要更多能真正深入系统里面，深入代码细节，给团队带来改变的技术 Leader。

并配有插图，如图 11-6 所示。我个人凭借此文获得了 2018 年阿里巴巴技术协会（Alibaba Technology Association，ATA）年度作者，这充分说明大家对这个理念的支持和认可。

图 11-6 Leader 和 Manager 的区别

技术 Leader 是专业性非常强的工作。技术 Leader 区别于其他 Leader 之处是你不仅要「以德服人」，还要「以技服人」。要带好一个技术团队，技术 Leader 首先要对技术有热情，有一定的技术能力，并使用一些 11.1 节中介绍的管理手段，帮助团队成员提升自我，有所成长。

实际上，这不仅是我个人的看法，从阿里巴巴的组织角度来看，我们也在强调技术 Leader 要「重技术、轻管理」。比如，以前在技术栈是有 P 线和 M 线 [1] 的，当你从个人贡献者（Individual Contributor，IC）晋升到管理岗时，可以选择 M 线。但是在 2018 年，组织上做了一个调整，在技术岗位取消 M 线，也就是不论你是不是带团队，都必须要在专业技术上过硬。

### 11.6 视人为人

在阿里巴巴有句话：「一群有情有义的人，做一件有意义的事」。我很喜欢这句话，俗话说「做事先做人」，我们唯有尊重自己，尊重他人，视人为人，视己为人，对团队倾注感情，和团队成员建立信任关系，才有可能做一个好 Leader。

只有和团队建立了情感链接和信任关系，才能更好地开展工作。我们在公司工作，实际上是在给两个账号存钱：一个是绩效货币（Performance Currency），这是对事的；另一个是关系货币（Relationship Currency），这是对人的。所有的判断都有人的主观因素在里面，因此第二个货币也很重要。

在此提醒一点，搞好关系并不是拉帮结派，还是那句话：「动机至善，了无私心」。我们做事情的出发点必须要是正的、善的。在这个大前提下，我们可以积极地拓展自己的人脉关系和影响力。

视人为人不仅是和他人处好关系，也是一种原则和勇气，你不能视一部分人为「人」，视一部分人为「神」，视一部分人为「物」。最后，我想用阿里巴巴「中供铁军」的副总裁余涌在一次管理者会议上，让我们所有 Leader 起立宣誓的一段话与所有在管理岗位的朋友们共勉。

对待上级 —— 有胆量。

对待平级 —— 有肺腑。

对待下级 —— 有心肝。

[1] P 线：Profession，专业线。M 线：Manager，管理线。
