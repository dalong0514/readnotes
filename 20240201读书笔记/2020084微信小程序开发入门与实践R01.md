## 记忆时间

2020.03.07

## 卡片

### 0101. 主题卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡 —— 数据绑定

### 0202. 术语卡 —— 真实项目的数据获取

在真实的项目中，业务数据通常都放置在自己的服务器中，然后通过 HTTP 请求来访问服务器提供的 RESTFU API，从而实现数据获取。

### 0203. 术语卡 —— 事件

要从 welcome 页面跳转到 post 页面，需要使用事件来响应点击「开启小程序之旅」这个动作。什么是事件？严肃一些的定义是：事件是视图层（wxml）到逻辑层（js）的通信方式。简单一些理解，事件可以让我们在 js 里处理一些用户在界面上的一些操作并对这些操作做出反馈。比如点击 Welcome 页面「开启小程序之旅」按钮后，需要在 js 里调用 MINA 框架的 API，使页面从 welcome 跳转到 post。

要实现这样的机制，需要做两件事情：1）在组件上注册事件。注册事件将告诉小程序，我们要监听哪个组件的什么事件。在本例中，需要监听「开启小程序之旅」这个组件的 tap 事件。2）在 js 中编写事件处理函数响应事件。也就是说，监听到事件后，需要编写自己的业务。在本例中，我们将调用 MINA 框架的导航 API，让 welcome 页面跳转到 post 页面。更改 welcome.wxml 页面的代码，如代码清单 4-28 所示。

### 0301. 人名卡 —— 张小龙

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡 —— 永远不要相信外部环境

最后根据他写的非常震撼的话语——产生一张金句卡。

在以上代码中，我们没有考虑数据加载失败的情况。如果数据加载失败，程序就无法进入 processDoubanData 方法中，从而导致无法执行 wx.hideNavigationBarLoading 方法，导航栏的 loading 图标一直显示。Orange Can 只是一个示例项目，如果完全模拟真实项目，需要写太多同小程序无关的代码，所以建议开发者在真实的项目中注意容错处理。「永远不要相信外部环境」是每个开发者要时刻牢记于心的真理。开发者可以尝试将隐藏 loading 图标的代码放在 wx.request 请求的 complete 函数中，这样无论数据加载是否成功都将隐藏 loading 图标。

### 0402. 金句卡 —— 在构造函数的原型链上添加一个对象，这个对象的所有属性和方法都会被构造函数的实例继承

我们在构造函数的原型链上添加一个对象，这个对象的所有属性和方法都会被构造函数的实例继承。比如，我们在这个对象中增加了一个 getAllPostData 方法，这个方法将可以获取缓存数据库中所有的文章数据。在 getAllPostData 中，我们做了一个判断，如果缓存不存在将重新加载 data.js 数据文件，并存入到缓存数据库中。最后，还是使用 module.exports 将 DBPost 输出。

当然这里最好的写法还是使用 ES6 的 Class 和 Module 来编写。使用构造函数和 prototype 原型链构建对象，总是会让那些熟悉 Java、C# 等现代经典面向对象的开发者觉得很奇怪。ES6 的 Class 优化了 Javascript 的对象构建方式，让对象看起来更加符合现代的面向对象写法。但是，ES6 大多特性只是一种语法糖，在本质上 Javascript 的运行和解析机制并没有被改变。所以理解 Javascript 的构造函数与原型链 prototype 依然非常重要。

## 总体

本书主要围绕 Orange Can 项目展开一系列编码工作，用几近真实的项目介绍小程序的各个 API、组件用法，并附带一些小程序开发的经验、技巧以及常见的误区说明。整个 Orange Can 项目分为三部分：文章阅读、电影资讯以及设置。文章阅读包括文章列表、文章详情以及评论，通过编写文章阅读功能的代码，读者将学会 swiper 组件的裁剪模式、image 组件的裁剪模式、缓存的使用技巧、列表渲染、数据绑定、模板、音乐播放、录音、分享等知识。

除此之外，读者将对小程序页面的生命周期有一个大致了解。学习完这部分内容，读者将可以轻松做出一个内容型小程序应用。电影资讯功能主要介绍如何调用服务器数据及 template 模板的使用技巧。设置页面功能包含大量功能示例，包括获取硬件设备信息、罗盘与重力感应的应用、扫描二维码、用户登录、用户信息校验、解析用户加密数据、获取用户 openid、发送模板消息、微信支付等功能。本书还提供部分服务器的 PHP 代码，主要供用户登录、校验、解析加密数据、模板消息、微信支付等功能调用。本书内容丰富、注重实战，讲解通俗易懂。适合小程序开发人员、培训机构和企业内部培训使用。

1『获取用户 openid，化工 101 产品发现很多地方用到，mark 一下。』

什么是小程序？小程序在内测的时候，微信之父张小龙曾写了这样一段文字：「小程序是一种不需要下载、安装即可使用的应用，它实现了触手可及的梦想，用户扫一扫或搜一下就能打开应用，实现了用完即走的理念，用户不用安装太多应用，应用随处可用，但又无须安装卸载」。

有些人说：「轰轰烈烈的小程序其实也就真正火了一天。」2016 年，小程序预热，张小龙第一次提前一年高调把小程序拿出来讲（当时还叫应用号），被媒体炒得沸沸扬扬。一年后，上线的当天刷爆朋友圈和微信群。一周以后，当初轰轰烈烈的小程序并没有带来想象中的轰动，很少见到讨论它的内容。上线オ 4 天「罗辑思维」就宣布撒出，「今日头条」的小程序暂停了又恢复，剧情变化得太快，让人看不清小程序的前景，于是「小程序已死，张小龙或走下神坛」的论调随处可见。

但真的是这样的么？我认为还言之过早。第一批尝鲜小程序的开发者大多是互联网 App 的开发者，已经习惯了从平台获取流量的思路，在日活跃用户 7 亿的微信平台上推出新产品，大家都想占据先机，获取用户和流量。然而小程序不提供入口，不提供推荐，分享也不能分享到朋友圈。这无疑让早期抱着「蹭」流量目的的小程序开发厂商大失所望。

小程序适合的是场景化、服务型的产品。张小龙在演讲中清楚地描述了他想象中小程序应用的典型场景：在汽车站购买车票的时候扫码购票，无须在售票窗口排队；等公交时扫码启动程序，查询一下一辆车到达的时间。「摩拜」单车的小程序就是一个很好的基于场景化的应用。当你在马路上走累了看到一辆「摩拜」单车时，可直接通过微信的「扫一扫」扫描「摩拜」单车上的二维码，进入摩拜小程序页面，轻松解锁身边的「摩拜」单车开始使用，而不用从 App Store 里下载一个几十兆的 App 安装。

在我看来，小程序是张小龙对未来应用程序形态的希望。如今 App 实在是太多了，正如 2009 年 Phone 广告语所说「there's an app for that」。2016 年 6 月，IOS App 已经超过 200 万个，几乎做到了「there is an app for just about anything」。作为ー个智能手机的重度使用者，我的 Phone 手机里安装的 App 超过了 400 多个，很多 App 需要通过搜索找到后启动，但是常用的不超过 20 个，每天都使用的不超过 10 个。很难想象 5 年后、10 年后的应用程序还是这种形态，最好的状态莫过于当我有需要的时候它出现，解決我的需求之后它消失，大概就是张小龙所谓的「触手可及、用完即走」吧。

小程序不论后面的发展怎么样，都是微信团队对于未来应用形态的一种探索和尝试。难怪张小龙在小程序内测的时候在朋友圈晒了一张图，并配文说「程序猿的一小步，程序的一大步」。作为开发者，要时刻保持学习，保持对技术的敏感、对变革的敏感，只有这样在未来才不会掉队。遇到一个问题，先用最简单粗暴的方式解決，然后分析这个方案的优缺点，再找出更优秀的解決方案，通过不断「重构」，渐进式地加入对知识的理解。学会这种思维方式之后，在自身技术成长的道路上必将终身受用。

直到 2016 年 12 月 28 日微信公开课上，张小龙终于用一连串「没有」告诉了所有媒体和开发者，你们都是错的。小程序并不是你们想的那样：我说它只是用完即走的服务，那它就一定是用完即走的服务，不会帯有很强的媒体属性；我说没有应用市场，那官方就没有应用市场；我说扫一扫、搜一下就能打开小程序，那就没有第三种途径可以触及小程序。在当时，这些「没有」确实让很多开发者大吃一惊。

现在的小程序已初步具备了线上线下同步的雏形。微信绕了一大圏儿，最终还是回归到了线上线下结合这个互联网运营的经典套路。此次推出新特性的意图也较为明显线下开疆拓土，线上现固固有优势和辅助线下发展。至于开发者到底是重线上还是重线下，或是二者结合，这就在于开发者的抉择了。反正线上线下都给了开发者，那就自己看着办吧。但以现在线上产品的完备程度来看，留给新产品的空间已经很小了。尝试着将目光投向线下也许是一个不错的选择，转变ー下思维也许会有一片新天地。

以前我们的思维是线下什么不方便，那就把线下移植到线上。比如交水电费不方便，那就线上交；火车飞机出行购票不方便，那就线上买。这些服务亳无疑问是互联网发展的必然衍生物。可还有很多活动是线上做不了的，或者说很多线下活动如果放在线上，就会变得索然无味。比如看电影，如果线上能代替线下，为什么还有那么多人购买电影票去看大荧幕？因为电影是一门光与影结合的艺术，需要环境和氛围的辅助才能体会光、影、音结合的美妙和震撼；再比如朋友聚会、同学聚会，大家在线上用微信视频一起聊个天行吗？这自然不行，因为感觉不到位。我们无法脱离线下，却又被线下的不方便所困扰。

在我看来，线上线下结合是一个必然趋势，微信希望的也是从线下挖掘新的流量与场景。线上的服务虽然很方便，但场景有限，人不可能纯粹地活在线上环境里，我们依然有大量线下活动。目前，互联网所能提供的服务品质和服务种类其实已经达到了一个极限，在科技没有革命性进步的情况下，还想从线上有所突破是不太现实的。看似 AI、物联网、VR 很火热，但它们离真正的普及还有很长一段路要走。当然，哪天人类的科技真能发展到像电影《星际穿越》中所描绘的智能、多维的层级，这就另当别论了。目前来看，线下的活动场景和机会还是挺多的，只不过还没有被充分挖掘。

所以，不要太过于执着于线上，换一种思路，挖掘一下线下的场景，也许是创业的一个突破口。线下有太多小程序非常适合的场景，拥有巨大的想象空间。虽然现在有不少 H5 服务于线下场景（如很多餐饮业提供的排号及点餐服务），但无论是从体验还是产品闭环上，都远远不及小程序。这点希望开发者能够去思考一下，不要强行用固化的思维看待小程序。这和技术无关，只和场景有关。

那么原生 App、H5 和小程序该如何抉择？至少从目前来看，如果只是一个纯粹的单一的线上小程序，相比于原生 App 还是有一定的劣势的，但在微信将小程序与公众号做了「强绑定」后，小程序的应用又变得非常的多元化，它们之间不再是「非此即彼」了；而在对比 H5 页面时，小程序的体验（使用体验与服务体验）还是要略有优势的，毕竟小程序是一个体系，但缺点是没有 H5 开放和自由，H5 依然是最佳的粘合剂，很适合嵌入到各个种类的产品与应用中。

无论创业者选择 App 还是小程序，或者二者齐头并进，都应当把做好产品放在第一位。不是说选择不重要，而是过分在意选择载体而忽略了本质，多少有些舍本逐末。回归产品本质，解決用户的问题也许才是每个开发者应该斟酌和思量的事情。对于小程序，更多时候我只是一个看客，它发展得好与不好对我而言没有太大影响。它发展得好，我这本书就有一定价值和意义，它发展得不好，未来这本书就如废纸一般，被读者丢弃在角落，蒙上一层厚厚的灰尘。我只是一个普通的开发者，这本书的内容也主要是讲解和技术本身相关的知识。它不是一本运营手册，仅仅是一本技术书籍，无论小程序未来发展如何，读者都可以从这本书里获取一些有用的知识。平台是多变的，但技术思维是相通的。

抛开繁杂的因素，仅从开发体验上讲，我非常喜欢小程序的灵巧。下载源代码后，不用配环境，只需要一个开发工具就能跑起小程序，这在现在越来越复杂的开发平台中是不多见的。也许小程序以后专业用来做原型代替 Axure 也不是不可能。此外，小程序非常适合开发者去践行自己的想法，以前移动端的开发成本太高，有很多想法因此都无法实现。但现在有了小程序就不同了，完全可以快速编写一个 MVP 产品，然后迅速投向市场去试错，再逐步送代、完善，最终考虑是否要推出自己的原生 App。

也许未来真的像张小龙所言，处处都是二维码；也可能未来的小程序就像历史上无数被技术更迭的浪潮所淹没的语言和平台一样，通于无形。可谁又能预测未来呢？互联网每天都有新贵诞生，也有王者陨落，成与败都在弹指之间，这在互联网的世界里是再平常不过的事情。对于一个寄生于超级 App 的平台而言更是如此，一切都是未知数。但无论如何，小程序这种即用即走的理念确实是现今主流 App 所缺失的。世界和科技总在不断变迁和进步，小程序这种形态的应用能否打破现在移动端的格局，我们目前还不得而知，但我相信这种理念确实值得认真思考一下，至于移动端的未来，还是交给时间吧。

本书的特点与特色。如果能让读者身临其境地开发一个几近真实的项目，在不知不觉中就可以学会小程序开发，那该多好。庆幸的是，小程序不是一门语言，它不需要像 Java、Python、Javascript 等基础语言教学一样罗列一个个基础语法，它最好的学习方式就是本书的「实践式」学习。因此，本书将用一个较为完整的「案例项目」把小程序的各个知识点「串接」起来，一边做项目，一边学习小程序的开发。做完一个项目就可以入门小程序是本书的目的。

我喜欢这种「实践式」学习所带来的「代入感」（如果你玩过各类角色扮演游戏，你就明白什么是代入感），跟着本书一步步 coding，你不仅收获了知识，更是直接完成了一个像模像样的小程序，这种成就感是学习编程最大的动力。即使你是一个基础较好的开发者，只看官方的文档也能学会小程序的开发，我依然建议你认真阅读本书，因为本书将为你节约大量「试错」时间。

本书在很多时候并没有直接给出一个问题的最优解決方案，而是首先给出一个看似很蠢的思路来解決问题。因为这是我们最直接的思维，也是最简单的解決方案。通过分析这个解決方案有什么缺点，最后给出一个更加优秀的解決问题的建议。我想，这符合我们编程里「重构」的概念。相比于直接给出最优解（事实上编程里很难有最优解，只是相对「优秀」），渐进式的解決问题更加能让读者体会到优秀解决方案的优势，避免对知识的生搬硬套。

我一直认为，本书的编写思路也是程序员自学的思路，由点及面、由具体到抽象。在工作中遇到了问题，想办法解决问题，查阅资料学习这个问题的相关知识点，最后把这些知识点总结、归纳，形成自己的知识体系，这是一个通用的学习「套路」。编程的各类语言、框架太多了，技术发展的速度也快得惊人，即使类似功能的框架也多达十几个，我们很难像学习经典数学、基础物理学、现代经济学这样先学习理论再付诸实践。Coder 有时就要有这种直面未知的勇气：先解决再学习，管它三七ニ十。

本书虽然定位于入门，但其中不乏一些小程序的进阶知识，这主要体现在微信开放接口上。学习微信开放接口不仅需要你拥有前端的知识，更要有一定的服务器编程经验，否则你很难理解为什么微信要这么设计开放接口的调用流程？为什么需要这么复杂的签名与令牌体系？

退一步讲，不理解也没关系，遇到类似问题和功能时，你知道怎么去解決即可。在编程里，我们不理解的东西太多了，谁能保证我们将做过的项目、产品每一个细节都理解得清清楚楚、明明白白？有时候记住怎么去做，比为什么这么做更加重要。理解清楚只是一个相对的概念，没人能够准确定义理解到什么程度才能称为「理解清楚」，也没有人能够说明深入到什么程度才算是「深入学习」。所以，有选择地学习原理，把更多精力放在解决问题上，我认为是一个正确的选择。

如果不考虑服务器，小程序开发只需要开发者具有 Javascript 和 CSS 相关知识即可。有很多文章说，开发者开发小程序还需要掌握 Vue、Angularjs，这有些强人所难了。小程序确实有很多和 Vue、Angularjs 相似的地方，这主要体现在数据绑定上。但 Vue 和 Angularjs 远比微信小程序要复杂得多，为了开发一个简单的小程序，学习远比这个简单的东西复杂多倍的框架实在没有必要。

从先来后到的角度看，Vue、Angularjs 等经典框架确实先于小程序出现，且小程序借鉴了许多这些框架中的经典思想。但对于既没有开发过小程序，也没有任何 Angularjs、Vue 经验的开发者，这个先来后到的理念对你没有任何意义。反正都不会，自然是优先学习简单的，再进阶复杂的框架。如果你是一个 iOS 和 Android 转型过来的开发者，完全没有必要理会 Vue 和 Angularjs，小程序开发中的很多思想相信你在自己的 iOS 和 Android 领域已有体会。

如果你只是为了开发小程序前端部分，更没有必要学习 Nodejs。前端是前端，服务器是服务器，我们能把一端做到极致就已经非常了不起了。如果你想一个人开发一个完整的小程序，那服务器语言也没有规定必须是 Nodejs。选择一个你喜欢的服务器语言，PHP、Nodejs、Python、Java、C#、Ruby 都是可以的。

小程序开发需要掌握什么，在我看来是一个伪命题。小程序应该成为零基础入门开发者学习前端的首选开发平台（以学习与实践为目的），因为它足够简单，又同现在的主流 MVVM 框架非常类似，学习曲线很平滑。它应该成为入门其他更复杂、功能更强大的框架的「垫脚石」。

对于一个传统的 Web 开发者，在编写小程序时只需要注意以下两点：1）小程序中没有 DOM，请放弃「首先获取 DOM，再操作 DOM」的思维。2）替代 DOM 操作的方法是「数据绑定」。控制组件显示隐藏、切换 CSS 样式、控制滚动条，这些很容易用 DOM 思维思考的常见功能，在小程序中都是通过「数据绑定」实现的。如果你想将代码写得更加优美和简洁，那么补充一些 ES6 和 LESS 的知识就更好了。

小程序开发难吗？说小程序是所有开发框架 / 平台里最简单的可能略微有些夸张，但说小程序是目前所有主流移动开发技术中最简单的亳不夸张。这种简单来自于两个方面：

第一，编写小程序只需要掌握 Javascript 和 CSS 两门语言。前端最难的是有太多 Web 前端框架、类库需要学习。但是，小程序里的 Javascript 是「裸奔」的，我们在 Web 开发中常用的各类框架 / 类库在小程序中统统无法使用。jquery、Zepto、Angularjs、Hightcharts、Echarts，这些 Web 前端学习中的一座座大山，小程序已经全部「干掉了」——小程序运行在一个 JSCore 中，它本身不支持 Web 中的 window 及 DOM 对象。有些 Javascript 库还是可以使用的，但真的没有必要了，小程序已经提供了简单的架构和内置的特性避免使用这些框架。例如，小程序默认使用 babel 将开发者代码所使用的 ES6 语法转换成三端都能很好支持的 ES5 代码，帮助开发者解决环境不同所带来的开发问题。你所需要掌握的是 Javascript 和 CSS，原则上讲，不再需要学习各类框架和库了。这无疑减轻了很多初学者的负担。

第二，小程序本身就是为轻量级应用所设计的平台，无论是开发工具、设计规范、API 设计，无不散发出一种「大道至简」的气息。你只需要从官方下载一个开发工具即可立即开始开发小程序，没有复杂的安装环境，没有复杂的目录结构，也没有复杂的打包、部署流程。小程序很多近似死板的规范无疑让开发者減少了很多工作量（不给你选择，自然简单）。关于对于开发者的约束，这个仁者见仁、智者见智，有人喜欢它的简单，也有人憎恨它的「不自由」。

我甚至认为小程序完全可以成为那些完全没有编程经验又想进入前端开发领域的人最好的入门平台。完全可以从小程序入手，通过小程序平滑的学习曲线，在熟悉编程逻辑后，再反向学习 Web 前端庞大的知识体系，从而进入这个行业。

本书与官方文档的区别。本书并不想成为官方开发文档的「搬运工」，除了一些非常必要的地方会引用官方文档的说明，本书几乎不会大段复制官方文档。本书更多使用官方 API 文档完成一个项目，对官方文档的主要内容做详细的补充说明，并附带对文档内容的经验性总结。官方的 API 文档通常定位于工具类的速查手册而非教程。当然对于开发功底深厚的开发者，只靠开发文档也可以完成一个小程序项目，但通常需要耗费较长时间。开发文档只会告诉开发者有哪些能力，但这些能力如何使用还需要开发者自己探索。本书可以告诉开发者如何使用官方 API 完成我们自己的业务逻辑，并在这个过程中逐步熟悉官方 APl，从而达到入门小程序并自己开发一个小程序的目的。除此之外，目前来说，小程序的开发还是有不少「坑」的。本书尝试为开发者提前把这些「坑」踩踩，填实了，以帮助开发者集中精力开发业务，减少浪费在小程序 bug 上的时间。

总体的建议是，对于 Orange Can 顼目的文章和电影部分，应该一步步跟着书籍逐步实现这两个核心功能；而对于「设置」页面，结合源代码「看懂」本书中的内容即可。此外，对于 Orange Can 项目的 CSS 样式，建议开发者不要完全照搬本书的 CSS 样式，每个人编写 CSS 样式的思路干差万别，本书无法保证所有 CSS 样式都是有意义的，少部分 CSS 样式是为了「防御性」而编写的。重点是小程序相关的知识点和 Javascript 代码。

3『

源码下载地址：[TaleLin/orange-can: 《微信小程序开发入门与实践》第二版源代码](https://github.com/TaleLin/orange-can)

作者的博客：[林间有风](http://7yue.pro/)，目前里面有 3 个 专栏都可以好好看看。（2020-02-29）

[小程序交流专区 | 微信开放社区](https://developers.weixin.qq.com/community/develop/mixflow)

[微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)

[Blink API — 林间有风 v0.1 documentation](http://bl.7yue.pro/dev/index.html)

』

## 01. 微信小程序简介

### 1. 逻辑脉络

小程序适合于开发「简单的」、「低频的」、「对性能要求不高的」应用。

### 2. 摘录及评论

小程序无论从技术上还是从理念上都不是一个新事物：从技术上讲，它借用了 React Native 的一些概念，定义了一套微信自有的组件并根据运行环境的不同（PC、iOS、 Android）将这些组件编译 / 转化为对应平台的可运行组件；从理念上讲，百度早年的「轻应用」、QQ 右下角的「应用宝」还有支付宝里的各类小服务，早已是小程序的雏形。

我们要清楚地认识到，能不能做和合不合适做是两个概念，这取決于小程序版本的各类应用相比原生 App 到底有哪些优势。可能是成本上有优势，可能是推广上有优势，也可能是同微信原生功能结合有优势，这需要开发者均衡考虑。本书还是以官方所谓的「用完即走的轻服务」为基本出发点进行论述。

「简单的」、「低频的」、「对性能要求不高的」应用适合用小程序来开发。小程序特别适合做线下的场景化应用，官方的一切措施都是为了将小程序导向线下。

「简单」是指应用本身的业务逻辑并不复杂，比如外卖应用「饿了么」，业务逻辑就非常简单：挑选想吃的菜肴，下单、付款；再比如在线购买电影票应用「猫眼」，就是为用户提供在线购买电影票的服务，整个服务的时间是短暂的，「买完即走」。还有各类 O2O 家政服务、打车类应用、天气预报类应用，都符合「简单」这个特性。相反，一些游戏类、社交类、视频直播类应用则业务相对复杂很多，用户在应用里停留的时间也会较长，这类应用就不太符合「简单」这个特性。对于业务复杂的应用，小程序无论从性能上和体验上都没有办法满足这类应用。

「低频」是小程序使用场景的第二个特点。如果某种应用的使用频度很高，比如社交类的 QQ，金融类的支付宝、招商银行，社区类的百度贴吧、知乎等，由于使用的频度较高，以 iOS 或者 Android 的形式提供给用户会更好。当你使用小程序时，需要先打开微信再进入小程序，这对于高频的应用并不是太方便。小程序目前来看，还是适合做一些如手机充值、电影购票这类使用频度不高的服务。举个例子，当你正在微信中聊天，突然想起手机没话费了，那么就「顺手」点开小程序为你的手机充值。但是，如果你经常需要特意地去寻找某类应用，又长期需要这类应用，那么还是以原生 App 的形式提供给用户比较好，用户为这类应用去下载、安装和管理这个应用的系列操作是值得的。

「对性能要求不高」是因为小程序寄生于微信这个原生 App 中，又受限于 Web 技术的性能制约，注定它无法去开发对性能、体验要求很高的应用，比如「保卫萝ト」、「阴阳师」等这类游戏应用。此外，小程序还处于发展初期，没有太好的技术和工具去支持这类复杂度较高的游戏（没有类似于 Unity3D 这样的专业游戏开发工具）。

首先，从技术上来讲，目前 App 的主流开发方式有三种：Web App、Native App 和 Hybrid App。

1、Web App。在微信「发现」里面有一个《购物」入口，点击进去打开的是京东的移动购物页面，这个页面实际上就是一个 Web App。支付宝的众多小服务也是 Web App，还有「海底捞」在微信中的排号应用，这类 App 其实就是我们经常在 PC 上浏览的网页，只不过加入了响应式的设计让它适合在移动端显示和运行，所采用的技术依然是 Javascript CSS 和 HTML。相对于其他两种 App，Web App 具有开发简单、高效，更新灵活、跨平台，大量的网页应用稍作调整即可放在移动端运行。但缺点与优点并存，Web App 性体验极差（对，是极差），无法使用照相机、系统通知、本地缓存等原生特性。

2、Native App。也称为原生 App。这种 App 不是采用 Javascript、CSS 及 HTML 开发，而是使用 Objective-C (iOS）或者 Java (Android）开发。微信、支付宝、斗鱼 TV 等都属于这类 App，是目前主流的开发方式。Native App 具有性能、体验非常良好，组件支持完善、接口丰富等特点。但 Native App 最大的缺点在于，不能跨平台，有多少个平台就要开发多少个版本，现在主要有 iOS 和 Android 两个主流平台，还好 Windows Phone 已没了踪影。

3、Hybrid App。也称为混合式 App。Hybrid Appa 看上去像一个 Native App，但实质上 Native 技术在这里只是作为一个容器，将 Web App 包裹了起来，在容器内部实质上运行的还是网页。Hybrid App 更像是 Web Apps 与 Native Appa 的混合体。与纯粹的 Web App 相比，Hybrid App 会有一部分访问原生组件（相机、加速器）的能力。事实上，目前主流的应用中，纯粹的原生 App 很少，绝大多数都属于混合式 App。比如，我们常见的京东、淘宝等电商类 App，由于商品及业务变化非常频繁，需要经常调整，所以这类 App 的主要页面都是采用 Web 技术来构建，只是用 Native 包装了ー下。那我们如何界定，哪些 App 属于「原生」，哪些 App 属于「混合」呢？答案是：看 Web 页面在 App 中所占的比例，如果绝大多数页面都采用 Web 技术构建，那么我们称为混合式 App；而如果只有少数页面采用 Web 技术，我们称为原生应用。举个例子，今日头条这类新闻应用中绝大多数页面都采用原生技术实现，笔者倾向于称它为 Native App；而对于淘宝、京东等 App，笔者更倾向于是 Hybrid App。Hybrid App 具有接近于 Native App 的体验、开发效率高、跨平台等特性。

有一些开发者认为微信服务号里的网页应用也属于 Hybrid App，这种说法也不无道理。因为这些网页应用也属于微信这个 Native 应用的一部分，同样运行在微信内置的浏览器中，但这是个 App 所有者的问题。对于微信，确实是 Native App 中加入了部分「网页」，具有 Hybrid App 的特点。但我们上面讲到，目前主流 App 里很少有纯粹的 Native App，是不是算作 Hybrid App，应该看 Web 页面在 App 中的所占比例。微信是一个以社交为主要业务的 App，微信中的绝大多数核心社交与聊天功能都是原生的，所以我们还是称微信为 Native App。但是，对于服务号应用的开发者，微信并不是开发者开发的，开发者只拥有其服务号。而且服务号应用所用到的所有技术都只局限在 Web 技术里，从这一点来讲，服务号的应用应该归属于 Web App 的范畴。

此外，我们说 Hybrid App 具有一部分可以访问原生设备组件的能力。微信的 JS-SDK 确实提供了一些如拍照、录音、扫一扫等功能的接口，但相比于其他 Hybrid App 能调用的原生功能，实在是有限。从这个角度来讲，也应该将这些服务号的应用归属到 Web App 中。其实，到底归属于什么并不重要。互联网技术中的概念层出不穷，对很多事物的定义本来就不是很明确。这里用一些篇幅解释 3 种主流类型的 App，是希望大家在对比小程序和其他类型 App 时，能有一个较完整的知识背景。

那么小程序属于以上 3 种的哪一种？严格意义上来说，它不属于以上 3 种中的任何一种，在实现技术上小程序同传统的 Hybrid 还是有很大的不同的。小程序采用 Javascript 和 CSS 这类常见的 Web 技术开发，但它又不使用 HTML，它同 Web 没有直接的联系。小程序实际上是将一系列自己定义的组件编译成了对应平台（iOS、Android、PC）的相应可运行组件，以提高运行性能。如果一定要将小程序归并到以上 3 类 App 中，可能 Hybrid Appe 更合适：非原生，但使用到了 Web 技术（Javascript 和 CSS）。

相比于 Native App，小程序具有 hybrid App 的一些优势：1）跨平台（对于 iOS 和 Android 两个平台只需要开发一套程序）。2）具备接近于 Native Appe 的体验（注意只是接近）。3）对原生组件有访问能力。4）具备缓存能力。5）上手容易，开发逻辑较为简单。

但是，世间没有完美的事物，计算机世界里也没有完美的技术，你以为的优势在另一方面却成了缺点。我们一起来看下：

1）小程序为了简化复杂性，做了一些 UI 上的设计规范，确实方便了很多对要求不高的应用。但这也限制了那些对 UI 要求极高的产品发挥。

2）小程序很遗憾地不支持现有的 HTML DOM 结构，而是自己给出了一系列的组件，造就了一个封闭的开发环境，这直接导致了现有的经典 Javascript 框架、类库都无法使用。小程序现在的生态几乎是荒芜一片，等待着开发者们去耕耘（挑战与机遇并存，正因为没有，才有机会）。如果你想用小程序实现一组图形来展现股票或者天气的曲线，目前来看，相当烦琐。你无法使用经典的 echart 或者 highchart，你只能自己用 Canvas 来一点点地绘制。

3）截止到笔者编写本书时，小程序还不支持 webview，这是相当头疼的一个问题。现在很多新闻类型的应用，都是将文章数据静态化成 HTML 存储在服务器或者是 CDN 中，然后再利用 webview 直接加载这个 HTML 来显示。不支持 webview 直接导致了很多内容型应用没办法加载已存在的大量 HTML 页面。内容型应用现在大量的静态化页面需要被转化（已有一些第三方的组件实现了 HTML 转 WXML，基本思路是用正则表达式替换 HTML，但效果并不能让人满意）。至于微信会不会官方支持，这个很难抉择。不支持 webview 对现在的静态化 HTML 页面是致命的打击；但兼容 Webview 就意味着在小程序里你还可以运行 Web App，而 Web App 很难去监管，性能体验也不够好，这对于小程序的发展是不利的。也许开放一个只解析 CSS 不允许运行 Javascript 的 Webview 可能是个不错的选择，微信如何平衡这个问题，我们拭目以待。

1『

企业类型的小程序已经支持了：[web-view | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html)

web-view，基础库 1.6.4 开始支持（2017-10-30），低版本需做兼容处理。承载网页的容器。会自动铺满整个小程序页面，个人类型的小程序暂不支持使用。客户端 6.7.2 版本开始，navigationStyle:custom 对 web-view 组件无效。

』

4）小程序只实现了模板化并没有实现自定义组件，这是最令人不满意的地方。如果我们想实现个自定义逻辑的组件，通常希望把这个组件的标签、样式以及业务逻辑打包在一起，然后可以放在项目中多个地方使用。外部客户端调用组件时，只需要传入组件所需要的参数，由组件自己来完成数据获取、转化、绑定并和层通信等操作。但小程序里的 template 只能将标签和样式（WXML 和 WXSS 文件）提取出来作为一个「模板」，却无法把组件的业务逻辑（js 文件）放在起。也就是说，组件的业务逻辑不能够写在组件的模块儿中，只能写在「调用」组件的业务代码中，这就无法很好地复用组件的业务代码。原因我们会在后面讲到模板「template」时再来详细讲解。

3『

[自定义组件 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

从小程序基础库版本 1.6.3 开始（2017-10-23），小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。创建自定义组件。类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）：

```
{
  "component": true
}
```

同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 组件模板和样式 。

1（上面的代码自动生成的 json 文件里默认有的。自定义组件好好研究下，单独形成一个书籍附件「附件01自定义组件」。）

』

小程序会淘汰原生 App 吗？不会。连 Hybrid App 都无法撼动 Native App 的地位，又何况小程序本身只是 Hybrid App 的一个子集，运行在微信这个 Native App 之下呢？除了 Hybrid App 本身与 Native 技术的差距，微信对小程序还附加了诸多限制，比如安装包大小不能超过 1MB，不能做直播类和游戏类应用等。小程序的定位也非常明确 一一 做低频和业务逻辑不复杂的应用，原生 App 与小程序之间更多地将是一种互补的关系，绝对谈不上取代。

预计小程序将是 MVP 产品的践行地，是一个快速试错和调整产品思路的平台；同时绝大多数的产品也将推出自己的小程序，将全部或部分功能移植到小程序上占领更多的入口。一个平台是否流行，真的不取决于技术本身是否优秀，更多的时候开发者需要一个「理由」，无论是技术上还是商业上的理由，而微信海量的用户、全新的应用市场就是微信给开发者的一个理由。公正的评价，小程序确实在技术上无创新，但也的确具备巨大的商业价值。

相比于 iOS 和 Android，Web 前端对技术的需求度确实要高出很多。iOS 和 Android 是为移动端量身定做的系统，移动端的局限性本身就决定了它很难作为主要的生产力工具。虽然这些年有很多移动端 App 致力于将手机变成生产力工具，但诚实地讲，如果自然语言或者其他更先进的人机交互方式不出现，移动设备很难成为「名副其实」的生产力工具。「PC 已死论」、「微软已亡论」流传了好多年，可无论是 PC 还是微软现在都活得很好。这其中一个原因还是在于人类不能只消费，还需要生产，而 PC 作为信息化社会的主要生产力工具，这是移动端无可替代的。

我们在移动端更多的时候是去用眼晴「看」，而我们在 PC 端更多的是用手去「操作」。从信息的角度讲，移动端主要负责信息的输出，而 PC 端主要负责信息的输入。有过开发经验的朋友应该体会到，相对于纯粹的显示，有「输入」操作的应用开发难度和开发成本是要高很多的。目前市场上对于 iOS 和 Android 开发者的需求量已经接近饱和了，而 Web 前端由于其本身的特性，优秀的开发者相对偏少，市场的需求量是巨大的。即使一个公司的产品以 App 为主，也不可能缺少 Web 前端开发者。

1）我们之前讲过，混合式 App 是现在的主流 App，一个 App 很难只用 Objective-C 或者 Java 来开发，必然会有 Web 技术介入。你只看几乎所有应用都有「分享到微信、QQ、微博」（分享的内容大多数都是一个网页）等功能就知道，Web 技术是必不可或缺的。2）大多数移动端应用也都有一个对应的 Web 网站。3）现在的公司做营销和推广都离不开做信，无论是 H5 页面还是做微信服务号、企业号都是纯粹的 Web 技术。

在小程序推出之前，Web 技术在移动端时代更像是一个「黏合剂」，无处不在却又不能够独立地承担移动端的开发。Web 技术和 Web 开发者一直处于移动时代的边缘，不能没有它们，却也无法自成一体。但以 React 为代表的 React Native 和微信小程序的出现，给了 Web 开发者希望。虽然在性能体验上依然不及原生应用，但已经相当地接近了。Web 开发者终于可以在主流的移动平台中占据一席之地了。

笔者常常惊叹于 Javascript 顽强的生命力，作为最早的浏览器交互语言，当初仅仅被当作一个玩具。这个玩具却经历了漫长的 Web 时代，抗住了 Adobe 的 FIex 和微软的 Silverlight 这些所谓「富客户端应用程序」技术的猛烈攻势，不仅在移动端时代没有消亡，反而「溜到」了「后台」，以 Nodes 的形式开始了自己的服务器之旅，现在又不「甘心」蜗居在 Web 的两端（浏览器和服务器），反而以混合式的技术形态强攻移动端。这个被 Brendan Eich 用了 10 天设计出来的脚本语言，以惊人的生命力横贯 Web 和移动时代，甚至还可以以「寄宿」的方式成为一个桌面应用程序。Javascript 在很长一段时间，由于设计时间太短，细节考虑的不够严谨，导致 Javascript 都是「程序混乱」的代名词，但即使这样，也无法阻挡它前进的脚步。

随着 ES 2015 的普及，Javascript 变得更加完善与强大。而现在 Web 前端的发展呈现出的是一种百花齐放的姿态，发展与更新速度远超服务器技术的更迭速度。好事还是坏事，大家各抒己见，没有定论。但有一点可以确定，Web 前端开发将是一个非常具有挑战和想象力的工作，如果你刚好走在前端开发的路上，那么恭喜你，你正行走于时代的技术浪潮上。

有没有可能未来会出现小程序开发者工程师这个职位？除了专业做微信开发的公司，小程序工程师这个职位在短期之内不会成为独立的一类职位，绝大多数的小程序将由 Web 前端工程师来开发。未来，你将看到的 Web 前端岗位要求会添加一句话：熟悉微信小程序开发者优先。正如现在的 Web 前端职位都要求应聘者精通 jquery、熟悉 AngularJS、Grunts 等一样，小程序也将是 Web 前端职位的一项加分项。微信小程序更多的是 App 或者 Web 网页的另一个流量入口，但绝不会替代原生 App 或者 Web 网页（至少很长一段时间内是这样，未来小程序怎么发展还有待观察）。正如我们描述的微信对现在公司营销的重要性，小程序也将成为 Web 前端开发者应该掌握的一门技术。

笔者认为，每个 Web 前端开发者都应该至少了解一下小程序，可以不精通，但至少应该写一个简单的 Demo，跑一跑，完善一下自己的技术栈和知识体系。你完全不需要把小程序当作一个平台或者是生态，你只需要把小程序当作和 jquery、AngularJS 一样的一个 Javascript 类库或者框架来学习即可。反正现在的前端框架多得泛滥。

MINA 框架与微信小程序。MINA 是官方小程序的内部开发代号，也是小程序运行框架的别名。据说 MINA 有 MINA is Not App 的意思。到目前为止，许多开发者并没有正确理解什么是微信小程序，它和我们在网页开发中常用的 Angularjs 和 vue 又有什么区别？微信小程序并不是一项技术或者一个框架，微信小程序是一个生态，与之对应的应该是 iOS 生态和 Android 生态，其中微信小程序又与 iOS 生态极为相似，它们都非常封闭，而且审核非常严格微信小程序的审核比苹果还要严格。而 MINA 是小程序的一个框架，它提供了小程序运行所需要的接口、模型和机制。

## 02. 小程序环境搭建与开发工具介绍

### 1. 逻辑脉络

编辑选项卡、调试选项卡、项目选项卡以及正上方顶部的工具栏。

### 2. 摘录及评论

『勾选「不使用云服务」（注意: 你要选择一个空的目录才可以创建项目）』

在主界面最左侧垂直分布着 5 个选项卡：编辑、调试、项目、编译和关闭。当点击（调试后，左侧下半部分还会出现「后台」和「缓存」这 2 个选项卡。下面依次来介绍这 7 个选项卡。

如图 2-6 所示的界面就是编辑选项卡的主界面。编辑界面分为左、中、右 3 部分。左边是模拟器的预览视图，中间是代码的树状目录，右边是代码编辑区（也就是写代码的地方）。

可以在（区域 3) 中点击每行代码前的行号设置断点。当代码运行到断点处后，将停止。常用快捷键有 F10 单步执行，F11 进入方法，F8 继续运行到下ー个断点。更多快捷键可自行在（区域 4) 中查看。在整个调试选项卡中，最重要的部分还是（区域 2) 和（区域 3）顶部的 6 个功能模块。

1）Sources Panel 是默认的 panel，用于显示当前项目的脚本文件。如图 2-13 所示区域 2、区域 3、区域 4 就是 Sources Panel 的内容。2）Console Panell 用于调试和输出信息，开发者也可以在这里输入代码。这个 panel 在 Sources 模块中同样存在，如图 2-13 中的区域 5。当点击 Console 后，console Panel 将变大，使开发者可以浏览到更多信息，如图 2-15 所示。3）Network Panel 主要用于观察和显示网络连接的相关情况。这里的 Network Panel 和 Chrome 浏览器里的 Network Panel 几乎一样。如图 2-16 所示。

4）Storage Panela 用于显示当前项目的数据缓存情况，如图 2-17 所示。关于数据缓存将在项目开发中具体讲解。5）Appdata Panel 用于显示项目中被激活的所有页面的数据情况，这些数据主要是用来做数据绑定，如图 2-18 所示，关于数据绑定我们同样放在项目开发中具体讲解。在这里不仅可以查看数据情况，还可以更改数据，小程序框架会实时地将数据的变更情况反馈到 UI 界面上。6）Wxml Panel 是非常重要的一个功能模块，如图 2-19 所示。这个模块类似于 Chrome 调试工具下的 Elements 模块，主要用于调试 wxml 标签和相关 CSS 样式，调试方法同 Chrome 一样。如果你是一个前端新手，那么建议好好地摸索一下这个功能模块的调试技巧，绝大多数和样式、标签相关的问题，都需要依靠这个 Panel 来调试。

以上的 6 个模块功能对我们开发非常有帮助。如果你在开发中遇到一些稀奇古怪的问题，那么最好的解决办法就是使用这 6 个 panel 来解決。我们在后面的章节中也会经常回过头来讲解这些 panel 的使用技巧，并使用这些 panel 解决我们的问题。以上 6 个 panl 包含的功能非常多，不需要现在就把每个 panell 的细节了解的非常清楚。笔者的建议是知道以上 6 个 panel 是做什么的以及它们简单的使用方式即可，在后续的内容中将会用实际的数据来演示如何使用这些 panel，开发者无须担心。

1『新版本多个好几个模块。（2020-02-20）』

项目选项卡主要有 3 大功能：显示当前项目细节、预览及上传项目以及项目配置。在目前版本中，项目配置总计有 5 个配置选顼。

1）开启 ES6 转 ES5。小程序支持使用 ES6 来编写代码。如果使用 ES6 来编写代码，框架会默认使用 babel 将开发者的代码转化为 ES5 代码（这样做的主要原因是为了保持对三端：iOS、Androidi 和开发工具模拟器的良好兼容性）。开发者可以在项目中关闭这个选项。2）开启上传代码时样式自动补全。开启此选项，开发工具会自动检测并补全缺失样式，保证在 iOS 8 上的正常显示。3）开启代码压缩上传。开启此选项，开发工具在上传代码时将会帮助开发者压缩 Javascript 代码，减小代码包体积。

4）监听文件变化，自动刷新开发者工具。开启此选项后，如果代码发生了改变（需要 CtrI+S 先保存），小程序开发工具会自动帮助开发者刷新调试模拟器，从而提高开发效率。也就是说，开发者不再需要手动地点击编译按键即可实时预览小程序运行效果，这是非常好用的一个功能。5）开发环境不校验请求域名以及 TLS 版本。开启此选顼，开发工具将不会校验安全域名以及 TLS 版本，帮助在开发过程中更好地完成调试工作。我们前面提到过，在开发工具里如果选取了「无 APPID」模式，那么开发工具的安全限制级别非常低，不需要使用 https 访问服务器，也不会校验 TLS 版本。但如果我们填入了「APPID」，那么默认情况下开发工具的校验行为会和真机环境保持一致，比如，必须使用 https 访问服务器且服务器域名必须加入到微信小程序账号中的可信任域名列表中。如果我们不想接受这样的限制，又想使用「APPID模式」，那么需要把「开发环境不校验请求域名以及 TLS 版本」这一项给勾选上。

ES6 转 ES5 的转换，只会帮助开发者处理语法上的问题，新的 ES6 的 API 例如 Promise 等需要开发者自行引入 Polyfill 或者别的类库。同时，为了提高代码质量，在开启 ES6 转换功能的情況下，默认启用 Javascript 严格模式。开发者可以自己査阅资料了解什么是 Javascript 的严格模式。

1『新版已经改成右上角的「详情」面板里了。』

同「编译」选项，「后台」也是一个功能按键，可以在模拟器中模拟应用程序的前后台切换操作。以 iphone 为例，当我们运行一个应用程序时，点击 iphone 的「Home」键，应用程序将被切换到后台，但并没有关。具体的功能作用我们会在后面章节介绍小程序生命周期时讲解。

缓存是非常重要的一个功能选项。点击「缓存」会出现一个子菜单，包括 4 个选项：清除数据存储、清除文件存储、清除工具授权数据和清除手机授权数据。缓存选项是开发工具提供给我们用来进行数据存储的小工具。关于数据缓存和文件缓存我们将在后面的项目章节中深入讲解。

官方 API 文档除了用于经常查阅 API 外，推荐大家在版本更新后第一时间去查看更新内容。最新的更新内容对我们开发者来说尤其重要，更新内容通常会出现在官方 API 文档的「历史更新日志」里。

## 03. 从第一个简单的「Welcome」页面开始小程序之旅

### 1. 逻辑脉络

小程序的基本文件结构、CSS 的使用限制、自适应单位 rpx、全局样式、App.json 配置文件以及 Flex 布局等小程序开发的必备知识。

### 2. 摘录及评论

认识小程序的基本文件结构。我们看到根目录下面有 3 个文件：app.js、app.json 和 app.wxss。一个小程序项目必须有这 3 个描述 App 的文件，它们必须放在应用程序的根目录下，否则小程序会提示找不到 app.json 文件。app.js 是小程序逻辑文件（必填）；app.json 小程序配置文件（必填）；app.wxss 全局公共样式文件（非必填）。这 3 个文件是应用程序级别的文件。

接着是和这 3 个应用程序级别文件平行的 pages 文件夹。一个小程序由若干个页面文件构成，如图 3-1 中 pages 文件夹下就有 2 个页面，分别是 indexI 页面和 logs 页面。每个页面可以由 4 个文件构成，分别是：js、xml、wxss 和 json 文件。js 是页面逻辑（必填）；wxml 是页面结构（必填）；wxss 是页面样式表（非必填）；json 是页面配置（非必填）。其实，这 4 个文件的作用大家并不陌生。我们可以和熟悉的 Web 前端开发技术做一个对比。

1）wxml 文件类似于我们熟悉的 HTML 文件，用来编写页面的标签和骨架，不同的是 wxml 文件里的标签元素不可以使用 HTML 标签，只能使用小程序自己封装的一些组件，这些组件也是我们后面要重点学习的知识。2）wxss 文件的作用类似于我们熟悉的 CSS 文件，用于编写小程序的样式，实际上小程序的样式编写语言就是 CSS，只是把 CSS 文件换成了 wxss 文件。3）json 文件用来配置页面的样式与行为。4）js 文件类似于我们前端编程中的 Javascript 文件，用来编写小程序的页面逻辑。以上 4 种类型的页面文件的文件名称必须相同，这是要注意的一个地方。

我们可以看到，小程序的 4 种页面级别文件同 3 个应用程序级別文件相比，多出了ー个 wxml 顶面标签文件，其他 3 个的作用基本相似，只不过页面文件作用于页面本身而应用程序文件作用于应用程序整体。除了 pages 文件夹外，官方的示例项目中还有一个 utils 文件夹，这个文件夹用来存放一些公共的 js 文件，如 utils 下面的 util.js。我们可以任意定义类似于 utils 文件夹的目录，并放在小程序的任意位置，小程序对此并没有任何限制。

每个项目都有一个自己的名字，比如 Google 的 Tensor Flow（一个机器学习项目）、淘宝的 Ocean Base（一个分布式数据库）、微软的 Azure（云计算「蔚蓝」），还有大家写代码使用的各类框架：Flask、Spring、jquery。在 pages 文件夹下新建一个名为 welcome 的文件夹，接着再在 welcome 文件夹下新建 4 个页面文件：welcome.js、welcome.wxml、welcome. wxss 和 welcome.json。新建后的文件目录结构如图 3-3 所示。

要显示 welcome 这个页面，必须让小程序的 MINA 框架知道这个页面的「存在」以及这个页面的具体位置（文件路径）。所以，我们需要在某个应用程序级别配置文件中注册这个 welcome 页面。那么哪个文件是用来做应用程序级别的配置的呢？回顾上ー小节中所讲的内容就应该知道，app.json 文件就是小程序提供给我们的全局配置文件。如何在 app.json 中注册 welcome 页面。在 app.json 中加入如下代码：

```
{
  "pages": [
    "pages/index/index",
    "pages/logs/logs",
    "pages/welcome/welcome"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "WeChat",
    "navigationBarTextStyle": "black"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

上面这段代码将 welcome 页面注册到了小程序中。代码是一个典型的 json 对象。这个对象的第一个属性 pages 接受一个数组，数组的每一项是一个字符串，用来指定我们的小程序将由哪些页面组成。每一项由对应页面的「路径 + 文件名」组成。比如上面这段代码中的 pages/welcome/welcome，就指定了 welcome 页面的页面路径。注意，页面路径前面不要加「/」。形如「/pages/ welcome/welcome」这样的路径是错误的。如果加入了「/」，小程序会提示错误：无法找到 welcome 页面。

这里要特别强调，路径最后一段 welcome，不需要指定具体的文件扩展名，无须写成 pages/welcome/ welcome.wxml。MINA 框架将会自动去寻找页面路径，并将页面的 json、js、wxml 和 wxss 这 4 个文件进行整合。如果有多个页面，需要将每个页面的路径加入到 pages 这个数组下，否则小程序不会加载这些页面。

页面的添加或者删除都需要在 pages 数组下面增减对应的页面路径，否则小程序会报错。当然现在只有一个 welcome 页面，那么 pages 下面先加入一个页面就可以了。随着 Orange Can 项目的不断开发，我们将在 pages 下面加入越来越多的页面路径。

出现这个错误的主要原因是，welcome.js 文件是一个空文件，这是小程序所不允许的。即使我们门的 welcome 页面中没有任何 Javascript 代码，依然需要在 welcome.js 中主动调用一下 Page() 方法。我们在 welcome.js 文件中加入以下代码：

```
Page({

})
```

关于 Page() 方法的用法，我们将在编写 welcome.js 页面的 Javascript 代码时具体讲解，现在只需要知道页面的 js 文件是不可以完全为空白的，否则小程序会报错。这个时候，我们的「Welcome，桔子罐头」这段文本还是没有在小程序中正确显示。那么试着在 welcome.json 中加入如下代码。

```
{

}
```

是的，正如 welcome.js 文件不能为空一样，welcome json 文件同样不可以为空，即使你目前不想在 json 文件中配置任何属性，也需要加入ー个空的，以保证小程序能正确执行。当我们完成以上所有的操作后，Ctrl+S 保存一下项目。此时，我们的小程序应该不会再报错了同时在模拟器中也应该能够正确地显示出「Welcome，桔子罐头」这段文本。这说明 welcome 页面已经被 MINA 框架正确地加载和运行了。

我们每次创建一个新页面时，都需要手动地新建一个目录 + 4 个文件，这是相当麻烦的事儿。这里告诉大家一个一次创建 4 个页面文件的小技巧（官方文档里没有提到过，开发工具也没有显示的标识）。如果 app.json 文件下 pages 数组里的页面路径，指向的是一个不存在的文件，那么 MINA 框架会自动创建这个页面的 4 个文件。我们可以试一下，在 app.json 文件的 pages 数组里添加一项「pages/orange/orange」，然后保存项目，会发生什么呢？通过这样的方式新建的页面文件将自动补全每个页面文件里必须的基本代码，不会出现错误。本小节讲解手动创建文件的例子，是为了向开发者展示一些常见的错误提示并解释错误的原因。后续页面文件的创建将采取这种比较方便的方式。

1『注意，是在小程序的 IDE 里选上 app.json，然后按 Ctrl+S 保存。而且自动生成的文件里都有基本的代码，哈哈，这是个好技巧。』

构建 welcome 页面的元素和样式。在本节中，将尝试为 welcome 页面添加一些标签元素。首先编写 welcome.wxml 文件，在该文件中键入以下代码，这段代码将 welcome 页面所需要的标签元素全部填入到页面源文件中。

```
<view class="container">
  <image></image>
  <text class="motto">Hello, 大龙</text>
  <view class="hi">
    <text>开启小程序之旅</text>
  </view>
</view>
```

1『小程序的代码跟 HTML 的代码一样，缩进都是 2 个空格，这个在 vscode 里直接点右下角的「空格」选项设置，不要太方便。』

这段代码总共使用了 3 个微信小程序的组件，分别是 view、text 和 image 组件。view 组件通常作为容器来使用，类似于 HTML 中的 dⅳ 标签；text 组件用来显示一段文本，类似于 HTML 中的 span 标签，本例中第一个 text 组件用来显示一段文本「Hello，桔子罐头」；而 image 组件用来显示一张图片，类似于 HTML 中的 img 标签。

1『 HTML 里与其称为标签不如称为「元素」更合适。』

大家应该注意到了，笔者在描述这些元素时的用词区别。描述 wxml 元素使用的是「组件」，而描述 HTML 元素使用的是「标签」，这是符合规范称呼的。HTML 是标记语言，它的标签主要是用来标记页面骨架，标签的属性也比较少。但组件不同，组件除了标记的作用，它的属性一般也是非常丰富的。小程序官方文档中也将 view、text、image 称为组件，而并没有称为标签。

同 HTML 中的 img 标签一样，images 组件需要设置一个 src 属性，该属性指向长图片的路径，用来显示该图片。我们在项目的根目录下新建一个名为 images 的目录，用来存放 Orange Can 的所有图片资源。在 images 目录下新建 avatar 目录，然后将一些适合做头像的图片拷贝到 avatar 目录中。

如何将图片放入到小程序的目录中？微信 Web 开发者工具无法通过 Ctrl+C/Ctrl+V 的功能复制粘贴图片，也没有提供导入图片的功能。我们需要在操作系统中打开项目的目录，并将图片拷贝到对应的 avatar 文件夹中，小程序会自动刷新目录，并在开发工具中显示这些图片。

当保存项目后，模拟器立刻会出现这张图片，但图片显示的高宽并不是图片本身的高宽。它被 MINA 框架设置成了宽度 300 px、高度 225 px，这也是小程序默认的图片高宽。如果我们不显示地指定图片高宽，所有图片都将保持这个默认值。

相对路径与绝对路径。在小程序中同样有相对路径和绝对路径的区别。上面我们在设置 image 组件的 src 属性时，使用的是绝对路径，它以「/」开头，「/」代表根目录。我们也可以使用相对路径来为 image 指定图片路径，比如，将代码中 image 组件的 src 属性改写为相对路径：

    <image src="../../images/avatar/avatar-1.png"></image>

路径中的「..」表示向上一级。这里由于使用绝对路径更加简洁，所以我们使用绝对路径。代码中间部分使用一个 view 组件包裏一个「开启小程序之旅」的 text 组件来实现按钮部分。由于还没有编写样式，所以暂时它还不能呈现为一个按钮的形状。

1『

显示错误：

VM673:1 Failed to load local image resource /images/avatar/avatar-1.png 
the server responded with a status of 500 (HTTP/1.1 500 Internal Server Error) 

被书的源码坑了，下面的绝对路径还是识别不了。

      <image src="/images/avatar/avatar-1.png"></image>

改为相对路径：

    <image src="../images/avatar/avatar-1.png"></image>

复核：最后发现是自己弄错了，把 images 文件夹放到了 pages 文件夹下面，应该是放在根目录下的，跟 pages 文件夹是平行关系，作者的源码没问题。

』

现在来编写 welcome 页面的样式。小程序编写样式的语言就是 CSS，我们应该将 CSS 代码写在页面的 wxss 文件中。在编写 welcome.wxss 文件之前，首先在 welcome.wxml 文件中给每个需要样式的组件加入样式名称 class name。就和我们在 HTML 中编写 CSS 名称一样，不是吗？接着我们将下面这段 CSS 代码加入到 welcome.wxss 文件中。

```
<view class="container">
  <image class="avatar" src="../images/avatar/avatar-1.png"></image>
  <text class="motto">Hello, 大龙</text>
  <view class="journey-container">
    <text class="journey">开启小程序之旅</text>
  </view>
</view>
```

让我们保存一下，看看页面发生了什么变化，如图 3-7 所示。

```
.container{
  display: flex;
  flex-direction: column;
  align-items: center;
}

.avatar{
  width: 200rpx;
  height: 200rpx;
  margin-top: 160rpx;
}

.motto{
  margin-top: 100rpx;
  font-size: 80rpx;
  margin-top: 100rpx;
  color: aqua; 
}

.journey-container{
  margin-top: 200rpx;
  border: 1px springgreen;
  width: 200rpx;
  height: 80rpx;
  border-radius: 5px;
  text-align: center;
}

.journey{
  font-size:22rpx;
  font-weight: bold;
  line-height:80rpx;
  color: blueviolet;
}
```

下面简单介绍一下这些 CSS 代码的作用：1）container 是所有组件元素的容器样式。这里使用 Flex 布局的方式，来控制容器下子元素的排布规则。关于 FIex 将在下个小节里具体讲解。2）avatar 设置头像图片的大小和位置。3）motto 设置「Hello，桔子罐头」这段文本的样式。4）journey-container 设置了「开启小程序之旅」的外边框，使它们看起来更像一个按钮。border-radius 让这个外边框変成一个「圆角」的矩形。5）journey 则设置了圆角矩形内的文本样式。

本书的主要目的是讲解小程序的核心知识，并不是一本 CSS 和 Javascript 的基础语法书。限于书籍的篇幅，我们只对 CSS 样式中的核心内容作较为深入的讲解。下个小节，我们来学习小程序官方推荐的布局方式：FIex 布局。真实项目中，图片资源尽量不要存储在小程序的目录中，因为小程序的大小不能超过 1 MB，超过则无法真机运行和发布项目。应该将图片都存放在服务器上，让小程序通过网络来加载图片资源。

2『图片放在服务器上，这点很重要，因为小程序的大小不能超过 1 MB。』

小程序所支持的 CSS 选择器。需要特别注意的是，小程序中的 CSS 只支持表 3-3 所示 6 种 CSS 选择器。虽然 CSS1、CSS2 和 CSS3 的选择器种类加起来总计几十种，但在小程序中只能支持以上几种。同时需要注意的是，本地资源在 wxss 中是无法使用的。比如 background-image，如果使用的是本地图片，则无法显示，可以使用网络图片来代替本地图片。

1『支持的 6 种选择器：1）class 属性选择器，「.class」。2）id 属性选择器，「#id」。3）组件选择器，「element」。4）逻辑或，「Element,element」，比如「view,checkout」表示选择所有 view 组件以及 checkout 组件。5）伪类，「::after」，比如「view::after」表示在 view 组件后边插入内容。6）伪类，「::before」，比如「view::before」表示在 view 组件前边插入内容。』

Flex 布局。welcome.wxss 文件中的 container 样式使用了一个 display: flex 的样式。那么，什么是 FIex？FIex 布局是 W3C 组织在 2009 年提出的一个新的布局方案，其宗旨是让页面的样式布局更加简单，并且可以很好地支持响应式布局。这并不是小程序所独有的技术，它本身是 CSS 语法的一部分。只不过早期时候，主流的浏览器对 Flex 布局的支持并不完善，造成了很多开发者不知道有这种布局的存在或者使用非常少，我们还是习惯使用传统的 position 和 foat 属性来布局。但传统的布局方式有它的缺陷，比如像垂直居中就不是那么容易实现，Flex 可以很好地解決这些问题。

小程序能够非常好地支持 Flex 布局，并且这也是官方推荐的布局方式。FIex 也称为「弹性布局」，主要作用在容器上，比如代码清单 3-7 中样式为 container 的 view 组件，就是一个容器，它将页面中所有的元素都包裏起来。我们使用 display: flexy 将这个 view 変成了一个弹性盒子。设置 display: flex 是应用一切弹性布局属性的先决条件，如果不设置 display: flex，那么后续的其他相关弹性布局属性都将无效。

接着我们使用 flex-direction 这个属性指定 view 内元素的排列方向。这个属性可能的值有 4 个：1）row；2）column；3）row-reverse；4）column-reverse。要理解这 4 个属性，首先要了解一个 Flex 布局非常重要的概念：轴。我们知道，在一个平面直角坐标系里，轴有两个方向（就是 X、Y），分别是水平方向和垂直方向。一个弹性盒子，需要确定一个主轴。这个主轴到底是水平方向还是垂直方向，就由 flex-direction 这个属性的值来确定。如果 flex-direction 值为 row 或者 row-reverse，那么主轴的方向为水平方向，相反，如果值为 column 或者 column-reverse，那么主轴为垂直方向。选定主轴的方向后，另外一个方向的轴我们成为「交叉轴」。也就是说，主轴并不ー定就是水平方向，交叉轴也并不ー定就是垂直方向，主轴的方向由 flex-direction 的取值来決定。理解这一点尤其重要。

图 3-8 到图 3-11 显示了当 flex-direction 取不同值时，主轴方向及子元素排布的情况。注意观察每张图里 3 个小 item 的排布顺序，主轴方向不同，子元素排布的方向也不同。1）flex-direction: row 时，主轴水平，方向为自左向右。2）flex-direction: row-reverse 时，主轴水平，但方向为自右向左。3）flex-direction: column 时，主轴垂直，方向自上而下。4）flex-direction: column-reverse 时，主轴垂直，方向自下而上。

虽然 welcome 页面的 3 个元素已经呈现出了垂直排列，但他们还没有居中显示。container 样式中的属性 align-items: center，可以让三元素水平居中。align-items 属性定义子元素在交叉轴上如何对齐。这里特别要注意，align-items 定义的是「交叉轴」这个方向上子元素的对齐方式。比如，由于我们在 container 样式中设置了垂直方向为主轴，那么交叉轴就是水平方向，所以 align-items: center 将设置三元素在水平方向上的对齐方式为居中。当然，align-items 属性值不是只有 center 这一种，还有其他若干种取值。本书主要讲解小程序相关知识，限于篇幅这里就不再展开赘述这些 CSS 的相关知识。由于 Flex 布局在小程序里地位相当之高，本小节权当抛砖引玉，各位读者可以自行查找资料，更详细深入的学习 Flex 布局。

这里推荐一个学习方法。编程里的知识点是非常细小而琐碎的，学习不同的知识应该掌握不同的方法。对于学习 CSS 这类知识，笔者认为较好的学习方法应该是在实践中学习，而不是像我们上学时那样先把理论知识认真的学习一遍，甚至要求全部记住，这一点是不可取的。比如 Flex 布局的学习，我们首先应当大致浏览一下整个 Flex 的知识树，知道 Fex 解決了什么问题，有什么特点，大致有几类属性就够了。当我们在做项目遇到布局问题时，脑海里就能意识到 FIex 可能可以解决这个问题。接着我们抱着试试看的心态，带着目的去查找 Flex 布局的相关资料，即解決了问题，又能在实践中加深对 Flex 布局的理解，这比单纯死记硬背效果要好很多。人脑总是对形象化的东西记忆特别深刻，所以我们应当尽量在实践中学习知识。当然，也有可能 Flex 不能解决问题，但你查找和尝试解決问题的这个过程本身就是很好的学习手段。

小程序自适应单位 rpx 简介。我们绝大多数的长度单位都设置的是 rpx 这个全新的单位，比如 margin-top: 100 rpx。在小程序里，长度单位既可以使用 rpx，也可以使用 px。使用 rpx 可以使组件自适应屏幕的高度和宽度，但使用 px 不会。要透彻地理解 rpⅹ 需要对移动端分辨率有一定的了解，比如物理分辨率 px、逻辑分辦率 pt 等概念。这里只需要记住结论即可，并不影响我们的开发。

建议以 iphone 6 的宽度 750 个物理像素作为标准，来做设计图。在此宽度下，这张设计图里每元素的尺寸转换到小程序样式时，转换比例为 1 物理像素 = 1rpx = 0.5px。rpx 和 px 就是小程序样式里可以使用的两种长度单位。举个例子，我们的 welcome 页面设计图的宽度总长是 750 像素，它是以 iphone 6 的尺寸来设计的，而其中的头像图片高宽为 200x200 像素。如果想在 iphone 6 里正确地显示这张 200x200 像素的图片，那么相应地 image 组件的高宽应该设置为多少呢？

答案是要不就设置为高 200 rpx，宽 200 rpx，要不就设置为高 100 px，宽 100 p×。这两个单位，在 Phone 6 下显示效果一样，但如果我们将模拟器切换到其他机型，这两种不同的单位就会出现差异。rpx 将随着屏幕尺寸的变化而变化，但 px 不会。那么到底选择 rpx 还是选择 pⅹ 呢？这取決于你需要元素随着移动设备尺寸的变化而变化，还是让元素始终保持不变，需要具体问题具体分析。对于 margin-top 或者是 image 组件的高宽，很多时候，需要他们随着设备的尺寸不同动态地变化，以保持页面元素之间的分布可以保持「一定的比例关系」，这种情况下应该使用 rpx。

2『对于 margin-top 或者是 image 组件的高宽，使用 rpx。做一张前端知识卡片。』

那是不是 rpx 就是万能的，我们可以将页面里的所有元素的长度单位都换成 rpx 呢？来看看下面这个例子，在 welcome.xxss 里有一段这样的代码；Journey-container 设置了「开启小程序之旅」这段文本的外边框。为什么其他的元素我们都使用 rpx 为单位而唯独 border 这个属性使用的是 1 px 呢？因为我们讲过，rpx 是自适应单位，它通常非常适合用来控制图片的高宽和元素之间的间距（通常这些元素需要随着屏幕尺寸的不同而动态变化）。但我们考虑一下，border 这个属性需要动态变化吗？不需要。如果 border 动态变化，那么它会在屏幕尺寸较大的手机上变得很粗，这并不是我们想要的效果。所以这里应当将 border 的单位设置为 px。同理，使用 px 作为 border-radius 的单位。

最后，我们为什么要强调最好是在 iphone 6 的尺寸下做设计图呢？因为只有在 iphone 6 的尺寸下，设计图里的 1 个像素才满足下面的转换关系：1 物理像素 = 1rpx = 0.5px。如果不以 iphone 6 的标准来做设计图，也是可以的。但非 iphone 6 的尺寸下，设计图与 rpx、px 的转换关系就不是整数倍的，计算起来比较麻烦，所以建议设计图最好以 iphone 6 的尺寸标准来设计，这样换算起来很方便。这也是官方建议的一个设计标准。如果我们足够细心，可以看到小程序的模拟器选择项下，给出了每种机型的分辨率。要强调的是，这里的分辨率指的是逻辑分辦率 pt，而非物理分辨率。以 iphone 6 为例，模拟器里给出的分辨率是：375x667；Dpr：2。

1『逻辑像素点即作者一直在说的 px。』

它的意思是：iphone 6 的水平方向有 375 个逻辑像素点，而竖直方向有 667 个逻辑像素点，每个逻辑像素点包含 2 个物理像素点。开发者一定要注意逻辑像素和物理像素的区别。我们通常在 PS 里做的设计图，它的像素可以简单理解为物理像素。再次提醒开发者，1 物理像素不等于 1 px。假设有一张图片在操作系统下显示宽度为 750 个像素，我们现在想让这个图片水平方向充满整个页面。如果你直接在页面里（iphone 6 模拟机型下）将图片宽度设置为 750 px，这是不对的。正确的设置方法为 750 rpx 或者 375 px，才能让图片水平填满小程序。因为，iphone 6 下 1 物理像素 = 1 rpx = 0.5 px。

全局样式文件 app.wxss。到目前为止，welcome 欢迎页面和实际图相比还有一些不一样的地方，比如字体。设计图里的字体使用的是微软雅黑，而目前的字体还是小程序默认的字体。最简单的更改字体的方法是在 WXSS 页面中加入如下代码；代码会将 Welcome 页面中的所有 text 组件的字体更改为微软雅黑。那我们思考一个问题，假如现在有 100 个页面，而 100 个页面里几乎所有的字体都应该是微软雅黑。在 100 个页面里重复设置字体这并不是一个很好的解决方案。所以，我们需要有一个全局样式表，可以为所有页面设置「默认」样式。小程序为我们提供了这样的样式表文件，就是前面提到过的 app.wxss 文件。

```css
text {
    font-family: Microsoft YaHei;
}
```

我们将代码清单 3-10 的代码，复制到项目根目录下的 app.wxss 文件中。虽然这段代码不在 welcome.wxss 页面样式表中，但依然可以使 welcome 页面的 text 组件字体更改为「微软雅黑」。还可以在这里设置一些其他的公共样式，比如字体大小 font-size、字体颜色 color 等。如果不想在某个页面中使用全局默认样式，那么只需要在相应页面的 wxss 文件中重新定义这个样式即可。小程序会优先选择页面的 wxss 文件，而不是 app.wxss 文件。

页面的根元素 page。到目前为止，我们的 welcome 页面已经像那么回事儿了。但页面的样式和设计图还不太一样，设计图中整个页面呈现的是橘红色，而现在的页面还是白色。那么，来修改一下页面的背景颜色吧。要修改页面整体的背景色，需要寻找一个包裹所有页面元素的容器，并设置这个容器的背景色。那么，首先尝试给页面最外层 view (class="container" 的这个 view）一个背景色。在 welcome.wxss 文件中的 container 样式里新增属性 background-color: #ECC0A8。

接着保存预览一下增加样式后的页面，它将呈现如图 3-18 所示的效果。并不是整个页面都呈现出橘红色，只是有元素占据的地方才呈现出橘红色。原因是因为最外层的 container view 没有固定的高度，它的高度由其内部子元素决定，所以橘红色部分的下边刚好和按钮的下边重合。如何解決这个问题呢？可以通过给 container view 一个固定的高度来解决这个问题，但这并不是最好的办法。因为在不同的机型上，屏幕的尺寸是不ー样的，固定的高度无法去适配不同的机型，可能出现滚动条，也可能橘红色无法覆盖整个页面。

当然，用我们前面学到的 rpx 是可以解決这个问题的，将 container view 的高度单位设置为 rpx，就可以让它随着不同的机型进行自适应调整。但这看起来很蠢，高度具体设置多少，还需要我们了解 iphone 6 的屏幕分辨率。所以，这依然不是一个很好的解决方案。其实，在 container view 的外边，小程序还有一个默认的容器元素：page。我们可以在开发工具中的 Wxml 这个 Pannell 中看一下 welcome 页面的页面结构，如图 3-19 所示。

在 class="container" 这个 view 的外边还有一个容器元素：page。这是 MINA 框架为大家默认添加的。每个小程序页面的最外层都有这个 page 元素。page 元素代表着页面这个整体，所以只需要对 page 设置背景色即可实现设计图里的效果。在 welcome.wxss 文件的尾部追加以下样式。保存后，页面将呈现出如图 3-20 所示的效果。page 代表着整个页面的容器，如果想对页面整体做样式或者属性设置，那么应该考虑 page 这个页面的根元素。

1『发现戴强他们写的小程序里，直接都是在 wxml 里最外层容器用的 page。』

app.json 中的 window 配置项。图 3-20 的顶部黑色长条是小程序默认的导航栏。很遗憾这个导航栏不可以隐藏或者取消，它必须存在。我们之所以说小程序无论从开发还是设计上都比较简单，有很大一部分原因是因为小程序做了很多这样的「强制性约束」，不给开发者很大的自由度，自然简单。这固然是因为小程序设计初衷就是用来快速开发轻量级应用的，但也有一部分原因是因为小程序目前还处于生态的早期阶段，官方没有那么多精力支持非常丰富的组件接口。

既然这个导航栏无法取消，如何让整个页面只有一种颜色呢？下面我们考虑将导航栏的颜色和页面的背景色设置成同一个颜色。还记不记得在 3.2 小节中，我们使用了 app.json 的一个配置项 pages，用来注册小程序页面文件？app.json 的另外一个配置项 window。window 配置可项用来设置小程序的状态栏、导航栏、标题和窗口的背景色。配置项下能够更改导航栏颜色的属性：navigationBarbackgroundcolor。在 app.json 文件中加入一个 window 配置项，并设置 window 的属性 navigationbarbackgroundcolor 值为 #ECC0A8。更改后的 app.json 文件代码如下：

```
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#ecc0a8",
    "navigationBarTitleText": "WeChat",
    "navigationBarTextStyle": "black"
  }
```

小程序顶部的导航栏已经被「隐藏」了。当然这不是真的被隐藏，导航栏依然存在于小程序中，只不过我们通过设置导航栏和页面的颜色模拟了这种效果。window 这个选项下并不是只有 navigationbarbackgroundColor 这一个属性，它还有以下几种属性：1）navigationbarTextstyle 配置导航栏文字颜色，只支持 black/white。2）navigationBartitleText 配置导航栏文字内容。3）backgroundColor 配置窗口颜色。4）backgroundtextstyle 下拉背景字体，仅支持 dark/light。5）enablepulldownRefresh 是否开启下拉刷新。

读者朋友应该关注本书章节的标题，每个标题代表着小程序的一个重要知识点，整本书的标题将构成小程序的知识体系框架。但每个知识点下有很多的属性，本书并不会一一列举，因为这些属性的使用方式都可以通过本书的案例并结合官方的文档一目了然。对于每个小程序的知识点，我们在学习阶段最需要关心的只有两点 一一 有什么用和怎么用。比如 window 这个配置项，我们只需要关心以下两点即可：1）window 是做什么的？2）怎么使用 window 这个配置项？

至于 window 下面的属性值，建议具体问题具体对待，不需要现在就搞明白。把这些属性值放到实际的工作项目中学习，不仅节约时间而且印象更加深刻。比如，我们这里需要用到 navigationbarBackgroundColor，把这个属性配置到项目后，就知道 navigationBackgroundColor 的意义了。

书籍绝大多数是用来引导入门和分享思想的，它不应该替代官方的 API 文档。API 文档不同于 tutorial 或者 get started（优秀的开发文档都有这两个部分），它一般用于査，是工具而非教程，通常都非常简洁。这里分享一个学习 API 的方法，就是「试」。对于 window 这个配置项，你只需要将其他几个属性加入到 window 中，再更改几个可能的属性值，就可以立刻即时地预览到属性值的效果。如果属性值的效果不符合你的预期，就具体去分析为什么会出现这种情況。不知不觉中，你对整个 API 就会越来越熟悉。

## 04. 文章列表页面

### 1. 逻辑脉络

使用 swiper 组件构建 banner；image 组件的 4 种缩放模式与 9 种裁剪模式；数据绑定，几乎所有和数据相关的操作都只能使用数据绑定来完成；重温在传统网页中经常使用到的「事件」。

### 2. 摘录及评论

文章列表部分展示了一个 banner 轮播图与一组文章。在编写此部分功能时，我们会介绍使用 swiper 组件构建 banner！轮播图以及 Swiper 组件的其他属性；详细介绍 image 组件的 4 种缩放模式与 9 种裁剪模式。除此之外，小程序最重要的数据绑定将出现在本章中。数据绑定是小程序中最重要的概念，它是和传统的 Web 网页编程相比最大的不同。在小程序中，几乎所有和数据相关的操作都只能使用数据绑定来完成。本章我们还会重温在传统网页中经常使用到的「事件」，一起来看看小程序中的事件和传统网页中的事件有什么异同。

文章列表页面元素分析及准备工作。本章我们来构建第二页面：文章页面。文章页面主体部分由两部分构成，上半部分是一个轮播图，下半部分是文章列表。轮播图每隔几秒钟图片会自动更换一张。在小程序中，我们不需要自己编写代码来实现这样的轮播图效果，小程序已经提供了一个现成的组件 —— Swiper。下半部分是多篇文章构成的文章列表。每篇文章包含文章标题、文章头图、文章概要、评论数和阅读数。我们依然只需要使用在上一章中介绍的 3 个组件：view、image 和 text，即可实现这个文章列表。

先来创建文章列表页面的相关文件。在 pages 目录下新建一个名为 post 的目录，然后依次在 post 目录下新建阅读页面所需要的 4 个文件。现在有个问题，我们要编写阅读页面，但我们的启动页面已经设置成了 welcome 欢迎页面。在不编写「开启小程序之旅」这个 button 跳转页面功能之前，我们没办法看到文章页面。实现 button 跳转页面的功能，需要用到小程序事件和 Javascript 代码，我们先尽可能地熟悉小程序页面骨架的编写，稍微复杂一些的事件和 Javascript 代码留在后面的章节讲解。

先做一个调整。在之前章节里我们提到过，小程序启动后显示的首页，由 app.json 文件里 pages 数组的第一个元素決定。我们暂时先将首页调整成 post 页面。在 app.json 的 pages 数组里加入 post 页面路径，注意它必须是 pages 数组的第一个元素，位于 welcome 页面之前。代码清单如下；更改完成后，现在保存或者重新编译项目，启动页面将不再是 welcome 页面，而变成了 post 页面。在小程序的 images 目录下新建一个子目录 post，并将阅读页面所需要的图片素材拷贝到该目录下。图片的像素大小要大于或者等于 750（宽）和 600（高），过小的图片会出现「留白」的情况。

小程序提供的滑动视图容器 —— swiper 组件，在 post.wxml 中加入以下代码：

```
<view >
<swiper >
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

最外层的 \<view>\</view> 将作为整个页面的容器，在 view 的内部，我们加入了ー个 swiper 组件，swiper 组件主要由多个 swiper-item 组成，可以定义任意多个 swiper-item。同时，需要注意的是，swiper 组件的直接子元素只可以是 swiper-item，如果放置其他组件，则会被自动删除。但 swiper-item 下是可以放置其他组件或者元素的。swiper-item 元素仅仅只是一个容器，如果要显示内容，需要在 swiper-item 容器下再添加元素内容。如代码清单 4-2 所显示的一样，我们在每个 swiper-item 内都加入了一个 image 组件，用来显示 UI 效果图中的轮播图片，图片路径请根据自己顼目的实际情况做出相应的修改。

swiper 组件的第一个 swiper-item 元素图片已经显示出来了。在动手设置 swiper 组件的样式前首先在 post.wxss 文件内，将 swiper 组件的宽度和高度设置好。添加完代码后，保存预览，发现图片的显示尺寸依然不正确。宽度没有呈现 100%，高度也不是期望的 600 rpx。还需要对 image 组件设置同样的样式，在 post.wxss 中添加 image 组件的样式，添加完成后的页面代码如代码清单 4-4。这里需要同时设置 swiper 组件和 image 组件的高宽，才能达到预期的效果。如果只设置 image 组件的高度同样是不可以的。

```
swiper{
  width: 100%;
  height: 600rpx;
}

swiper image{
  width: 100%;
  height: 600rpx;
}
```

要实现轮播效果，还要为 swiper 组件添加一些属性，分别是：indicator-dots、autoplay、interval，如代码清单 4-5 所示。

```
<view >
<swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="5000">
<swiper-item >
<image src="/images/post/post-1@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-2@text.jpg" />
</swiper-item>
<swiper-item >
<image src="/images/post/post-3@text.jpg" />
</swiper-item>
</swiper>
</view>
```

3『

[微信小程序学习笔记 - 简书](https://www.jianshu.com/p/e66f9e1cd078)

[小程序 bindtap 和 catchtap，target 和 currentTarget - 简书](https://www.jianshu.com/p/897f9c8ec847)

源码里额外设置了一个属性：catch:tap="onSwiperTap"，查了下资料说：冒泡机制就是如果点击 image 组件，会依次触发 swiper-item→swiper→view。catchtap 可以阻止冒泡，在 swiper 中用 catchtap 绑定事件，就不用继续往 view 那一层冒泡了，bindtap 是不会阻止冒泡的，在 image 组件中用 bindtap 绑定事件，在代码执行过程中，点击 image 组件，不仅会触发 onSwiperItemTap，还会向上一步触发 onSwiperTap。现在还无法理解，mark 下。

』

保存后预览一下效果。图片开始了轮播，每隔 5 秒钟更换一张。同时 swiper 组件上出现了 3 个小圆点，用来指示当前图片。简单介绍一下这 3 个属性。1）indicator-dots，Boolean 类型。用来指示是否显示面板指示点（上文提到的 3 个小圆点就是面板指示点，默认为 false。2）autoplay，Boolean 类型。用来决定是否自动播放，默认为 false。3）interval，Number 类型。用来设置 swiper-item 的切换时间间隔，默认为 5000 毫秒。

3『[swiper | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)』

除了自动切换图片，swiper 组件还可以通过拖动图片来进行切换，也可以通过点击面板指示点来切换。官方在 0.11.12210 版本中为 swiper 组件新增了一个 circular 属性，这个属性可以使轮播图循环滚动。如果 circular 为 false，那么当 swiper 组件滚动到第三张图片后就无法继续滚动了；但如果增加一个 circular 为 true 的属性，则当 Swiper 组件滚动到第三张图片后，会继续向第一张图片滚动，从而形成循环滚动。swiper 组件的属性使用方式都比较简单，更多属性请参考官方 API 文档。

Boolean 值的陷阱。这里介绍一个文档里没有提到的属性：vertical。这个属性将指明 swiper 组件面板指示点的排布方向是水平还是垂直，将 vertical="true"，加入到 swiper 的属性中。保存后，我们发现 swiper 组件的面板指示点由原来的水平排布更改为垂直排布，出现在组件的右侧。

那如果把 vertica 属性改为 False！呢？形如，vertical-="false"。此时，面板指示点如何排列？它依然和 vertical="true" 时的排列方向一样，呈垂直排布。为什么会出现这样的情况？我们可以把 vertical 的属性值更改为任何字符串，再看看效果。形如 vertical="aaa"、vertical="bb" 等属性值都会让指示面板呈垂直分布。而 vertical=" " 则呈水平分布。我们应该可以从上面的属性举例中找出原因了。即使我们将 vertical 的值设置为 false，但这里的 false 并不是 Boolean 类型，而是一个字符串。只要不是空字符串，那么在 Javascript 里都会认为这是一个 true。所以，设置效果是一样的，vertical 属性被认为设置成了 true。

如果想让面板指示点水平排列，有以下几种方式：1）不加入 vertical 属性。2）vertical=" "。3）vertical="{{false}}"。以上几种写法，小程序都会认为你将 vertical 属性设置成了 false。第三种写法，是我们后面要学习到的核心知识：数据绑定。这种写法，让 "{{false}}" 里的 false 被认为是一个 Boolean 类型的变量，而不是一个字符串，从而实现 false 即是假，true 即是真的效果。

当然，swiper 的 vertical 属性如果设置错误，一眼就能看出问题来。但如果是其他无法直接在 UI 上表现的属性出现了真假错误，就不是那么容易排查了，可能会浪费掉我们大量的时间。所有组件的 Boolean 类型属性都有这样的 Boolean 陷阱，比如，本例中的 indicator-dots 和 autoplay 也存在这个问题。

构建文章列表的骨架和样式。构建文章列表依然只需要我们熟悉 3 个组件：view、text 和 image。保存后，效果如图 4-6 所示。由于还没有加入 CSS 代码，所以整个页面的布局乱七八糟，但文章列表所有的元素都已经呈现在了页面中。将代码清单 4-7 的代码加入到 post.wxss 文件中。保存预览一下，效果将如图 4-7 所示。还有些小小的问题：「Jan 28 2017」和「108、92」这几个文本的字体大小与颜色都不太好看。我们可以将一些默认的字体样式放在 app.wxss 全局样式表里。保存后，日期和数量都呈现出 app.wxss 里设置的样式。

image 组件的 4 种缩放模式与 9 种裁剪模式。4 种缩放模式和 9 种裁剪模式如果从理论上完全精确理解，还是有稍许的难度的。但这里笔者建议各位开发者，没有必要完全从理论上搞清楚这些模式。当遇到具体问题时，尝试多去更换几个属性，找到最适合自己需求的属性即可。

来看看上个小节中雪糕图片的显示问题，很明显整个图片被压缩变形了。这并不是我们想要的结果。post-image 这个元素的高宽分别被设置成 340 rpx 和 100% (iphone 6 下就是 750 rpx），而雪糕图片素材原始高宽分别为 600 px 和 750 px。在现实的项目中，我们经常要面对原始图片的尺寸和设计图里的尺寸不一样的情況（尤其是原始图片高宽是未知和不固定的情况，比如动态从网络获取图片）。在这种情况下，我们必须要有所舍弃，或放弃等比例，或裁剪掉图片的一部分。接受不完美，也是编程中很重要的心态，如何选择，需要看业务上的需求。具体到文章列表图片，我们需要的是保持宽高比，接受部分裁剪（现实项目中，绝大多数情况下，图片保持比例、允许裁切是最普遍的需求）。

4 种缩放模式：1）scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素。2）aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。3）aspectfill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。4）widthFis 宽度不变，高度自动变化，保持原图宽高比不变（0.11.122100 版本新增）。

9 种裁剪模式：1）top 不缩放图片，只显示图片的顶部区域。2）bottom 不缩放图片，只显示图片的底部区域。3）center 不缩放图片，只显示图片的中间区域。4）left 不缩放图片，只显示图片的左边区域。5）right 不缩放图片，只显示图片的右边区域。6）top left 不缩放图片，只显示图片的左上边区域。7）top right 不缩放图片，只显示图片的右上边区域。8）bottom left 不缩放图片，只显示图片的左下边区域。9）bottom right 不缩放图片，只显示图片的右下边区域。

scaleToFill。保存预览一下，文章图片好像并没有发生任何变化。这是因为 scale ofill 模式是缩放的默认模式，如果缺省了 mode，则小程序也会以 scaletofilll 的模式来缩放图片。scaletof 模式将改变图片的高宽比，强行让图片更改为样式指定的尺寸，使图片变形（如果原始图片的宽高比例和要缩放的目标宽高比例相同，则不会变形，只是整体上放大或者缩小了）。

mode= aspectFit 的情况。同样不是我们要的效果。官方文档的解释：aspectFit 模式保持纵横比缩放图片，使图片的长边能完全显示出来。这个解释从字面上来看，并不是很容易理解，我们可以这样理解这种模式，假想有一个容器，这个容器的高宽等同于 image 将要被缩放的目标尺寸。比如在当前的事例中，这个容器的高宽就是样式 post-image，所设置的高 320 rpx，宽 100%（iphone6 下为 750 rpx）。aspectfite 的特点就是保持图片不变形，且容器要「刚好」将这个图片装进去。注意是「刚好」。如果原始图片比容器大，就要被等比例缩小；而原始图片如果比容器小，则要被等比例放大。一直放大或者缩小到图片的某一条边刚好和容器的一条边重合，而另一条边不能超出容器，也不能小于容器太多。

再回头看看图 4-8，宽刚好和容器相贴合，而高则刚好能被容器装进去，既没有超出容器，也没有比容器矮太多。同时整个图片保持了原始图片的宽高比，没有変形。所以官方文档的解释，没有把这种模式的特点完全描述出来。事例里用到的图片是大于容器的，所以图片会被缩小；开发者们可以尝试着用一张小于容器的图片替换这张雪糕图，试试 aspectFit 的效果如图 4-9 和图 4-10 所示。

aspectFill 同样保持图片的高宽比不会变形。但它有个特点，它会让图片完全填满整个容器，类似于 scaletofill 这种模式。不同的是 scaletofill 会改变图片的高宽比，而 aspectfill 不会。用我们上面提到的「容器」的观点来理解 aspectFill，既然 aspectFill 定要填满整个容器，那么首先要让这张图片的整体尺寸是大于这个容器的，不能留下任何的空白。对于原始尺寸小于容器的，就等比例放大图片（任意一边小于容器都需要放大，否则就会留下空白），让图片的某一边刚好接触容器的一边，同时另外一边又不会小于容器（可以超出，因为这边会被截取）。

如果原始尺寸大于容器，则需要等比例缩小，缩小的要求同样是一边刚好接触容器，另外一边要等于或者超出容器。这样就保证了图片可以完全填满整个容器，但某一边要发生截取。那么问是题来了，如何截取？在超出容器的这一边上，是保留图片的上部、中部还是下部？答案是：中部。注意观察图中的雪糕和原始图片，发现正中间部分被保留了下来。开发者可以自行多換几张素材图看看截取的效果。

widthFix 属性是小程序 0.11.122100 版本中新增的属性。这个属性的最大特点是，图片将不会按照设定的尺寸呈现，比如设置 image 宽度为 750 rpx，高度为 340 rpx，如果设置 mode= widthFix，则图片最终不会按照 750 rpx 和 340 rpx 呈现，除非原始图片恰好是这个尺寸。这个属性让宽缩放至指定尺寸，再动态计算高度，如图 4-12 所示。虽然宽度按照我们设定的尺寸呈现，但高度突破了 340 rpx。

9 种裁剪模式非常容易理解，我们举例看看其中的几种。同样建议开发者参考上ー小节中，我们想象的一个容器，这个容器用来裁剪图片的不同部位。将 post-image 的 mode 属性设置为 top，效果如图 4-13 所示。top 模式只保留图片的上部，裁剪掉了剩余部分。注意，这种模式不会缩放图片。我们可以仔细地再观察一下图中的图片，不仅仅是裁剪掉了图片的下部，上部水平方向也发生了裁剪。因为图片不会缩放，我们所设置的容器不能够在水平方向上完全把图片装进去，所以水平方向也发生了裁剪。这点是大家要注意的。

不同于 4 种缩放模式，裁剪模式是不会缩放图片的。用一张小图片来替换上面的大图，比如用 avatar 头像图片，替换后的效果如图 4-14 所示。明显可以看到，由于图片的原始尺寸小于容器的尺寸，裁剪模式也不会使图片发生缩放，所以结果就是不会裁剪图片。接着我们再将 mode 设置为 bottom right，效果如图 4-15 所示，图片只被保留了右下角部分，其余部分全部被裁剪掉了。其他几种裁剪类型从字面意思上都非常好理解，就不在这里 一一 列举了。

完成静态文章列表。先把上节更改的 post-image 的 mode 属性恢复成我们需要的 mode=aspectFill，现在，文章列表还只有 1 篇文章。1 篇文章如何叫做文章列表？为了多几篇文章，我们将代码清单 4-6 的代码再复制几份，依次加入到 post.wxml 文件中。这里再复制两份，形成一个有 3 篇文章的文章列表。如果 CSS 代码编写足够健壮，无须更改 CSS 代码，重复复制 post.wxml 中的文章代码即可迅速新增文章，且样式不会错乱。保存后，模拟器将呈现出 3 篇一模一样的文章来。效果如图 4-16 所。开发者可任意复制若干数量的文章，让页面看起来更像是一个文章列表。

js 文件的代码结构与 Page 页面的生命周期。是时候来学习一下小程序逻辑层代码的编写了。如果开发者是使用 3.2 小节中介绍的快速新建页面文件的方法来创建的 post 页面，那么由开发工具生成的 post.js。文件内默认将包含代码清单 4-11 所示的代码。

页面 js 文件默认代码包含了我们可能使用到的代码结构，整个页面执行了ー个 Page (..) 方法，参数是一个 Object 对象，用来指定页面的初始数据（data）、生命周期函数（on 开头的函数）、事件处理函数等。本节主要介绍页面的生命周期。

什么是页面的生命周期？如同人的成长需要分为出生、童年、青年、中年、老年一样，一个页面从创建到卸载，同样会经历以下 5 个周期：1）加载。2）显示。3）渲染。4）隐藏。5）卸载。MINA 框架分别提供了 5 个生命周期函数来监听这 5 个特定的生命周期，以方便开发者可以在这些特定的时刻执行一些自己的代码逻辑，它们分别是：1）onLoad 监听页面加载，一个页面只会调用一次。2）onShow 监听页面显示，每次打开页面都会调用（一个页面生命周期内可执行多次）。3）onReady 监听页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。4）onHide 监听页面隐藏（一个页面生命周期内可执行多次）。5）onUnload 监听页面卸载。

可以看到，一个页面要正常显示，必须经历以上 3 个生命周期：加载、显示、渲染。注意这 3 个生命周期函数的执行顺序，首先是 onLoad，其次是 onShow，最后才是 onReady。这里要特别提醒各位开发者，onShow 的执行时刻是在 onReady 之前的，但官方文档在编写时，将 onReady 放置在 onShow 之前（截止 0.11.122100 版本）。虽然只是顺序不同，但极容易让开发者误以为 onReady 是在 onShow 之前的，但这是不正确的。

那么 onHide 和 onUnload 呢？这两个函数的触发需要执行一些 API 的操作，比如当页面执行 navigateTo 方法或者使用小程序 tab 栏切换页面时会执行 onHide 函数；而当页面执行 redirectTo 或 navigateBack 的时候会执行 onUnload 函数。除了以上 5 个生命周期函数外，还有以下 3 个小程序特定事件的处理函数：1）onPullDownRefresh 监听用户下拉动作的事件处理函数。2）onReachBottom 页面上拉触底事件的处理函数。3）onShareAppMessage 用户点击右上角分享。开发者还可以添加任意的函数或数据到这个 Page 方法的 Object 参数中，在页面的函数中用 this 即可访问这些自定义函数或者数据。

1『在页面的函数中用 this 即可访问这些自定义函数或者数据。这句话很关键，「页面的函数中」这个范围还不是很清楚，不过应该就是指在 js 文件里。（2020-03-05）』

关于 onHide 和 onUnload 以及 3 个特定事件的处理函数，我们将在后面介绍到导航、tab 栏、刷新、分享等项目需求时，再具体演示和讲解。放在具体的示例里演示，效果远比用文字理论描述要好。

官方文档中，还给出了ー个较为全面的 Page 实例生命周期图解，如图 4-18 所示。我们大概可以看到整个图分为左右两侧，左侧是视图层，右侧是服务逻辑层。整个页面的生命周期都是围绕着这两个层来进行的。他们之间不是孤立的，而是有很多的事件与通知交互的。目前，我们所学的知识还不足以完全解释页面的整个生命周期。我们所讲的 5 个生命周期函数就在图 4-18 右侧多次出现，如果仔细观察，会发现以下几个特点：1）onload、onshow 和 onready 确实是按照前面所讲到执行顺序依次执行。2）onload 与 onready 在整个页面的生命周期中只会执行 1 次，除非这个页面被执行了 onunload 载掉了（卸载掉后这个页面的生命周期就结束了）。3）onhide 与 onshow 在一次生命周期内可能会执行多次。

除了 First Render 第一次渲染，页面还有可能会 Rerender 再次渲染多次。数据更新会造成页面的重新渲染。开发者还要注意，小程序仅在第一次 First Render 完成后，提供了监听函数 onready，对于以后的 Rerender 并没有提供相应的监听函数。所以，onReady 仅用来监听「第一渲染」完成。

3『学爬虫的时候，动态网页里的数据涉及到客户端里 JS 的 Render，原来 Render 是指渲染，哈哈。』

现在无法看明白这张图是很正常的事情，开发者不需要太过于担心。正如官方文档中所说：「此图你不需要立马完全弄明白，不过以后它会有帮助」。笔者的建议是，当遇到问题或者业务需要时，再回过头来研究这张完整的生命周期图更有意义。

事实上，如果开发者只想单纯的开发业务项目，只需要理解 5 个生命周期函数发生的时机与意义即可。通过大量的编码，可以让经验来弥补一些知识上的缺陷，这就是所谓的熟能生巧。但如果开发者想去做一些与小程序编译相关的框架时，深入了解这张图就很有必要了。当然，无论你想做什么，能够完全看懂和理解这张图，自然是再好不过了。我们会在后面的项目实践中，不断验证这些生命周期的特性，开发者只需要记得到时侯回过头来看看即可。

1『看来这张小程序的页面生命周期图真的很重要。在真实的项目中，业务数据通常都放置在自己的服务器中，然后通过 HTTP 请求来访问服务器提供的 RESTFU API，从而实现数据获取。』

数据绑定。在真实的项目中，业务数据通常都放置在自己的服务器中，然后通过 HTTP 请求来访问服务器提供的 RESTFU API，从而实现数据获取。现在我们的 post 面里的内容，全是一些被直接编码在 wxml 里的数据，这样的代码写法我们通常称为「硬编码」。这当然是一种非常不好的编码方法。我们现在尝试将编码在 post.wxml 文件里的数据移植到 post.js 中，在 post.js 中加入一个临时变量 postData 用来模拟文章数据，并将上ー小节中测试生命周期的代码移除。编写完成后的代码如下：

那么如何将 data 中的这些数据「填充」到页面中，并显示这些数据呢？如果是开发传统的网页，肯定会使用以下思路：首先获取到 HTML 文档的 DOM，然后对 DOM 标签进行赋值，从而实现数据的显示。但在小程序中，是没有 DOM 结构的，所以这个思路行不通。在许多流行的 MVC 或者 MVVM 框架中，比如 AngularJS、Vue.js 中，都有数据绑定的概念。小程序也借鉴了这些流行框架的思想，采用数据绑定的机制来做数据的初始化和更新。

只不过小程序做得更加决绝。AngularJS 中，虽然官方不推荐使用 DOM，但至少还有一个内置的 jQLite 用来支持获取 DOM（虽然有很多的限制），开发者也可以自行集成 jQuery。但小程序的腳本逻辑是运行在 JSCore 中，JSCore 是一个没有 DOM 的环境，它完全抛弃了 DOM 结构，我们只能使用数据绑定来做数据的相关操作。不同于 AngularJS 的双向数据绑定，小程序仅实现了单向数据绑定，即只支持从逻辑层传递到渲染层的数据绑定，反之则不可以。小程序使用 Page 方法参数里的 data 变量作为数据绑定的桥梁。如代码清单 4-13 所示，data 里已经被我们放置了一些数据，这些直接写在 data 里的数据，被称为数据绑定的初始化数据。

注意，数据绑定有以下两种：一种是初始化数据的数据绑定，通常将这些数据直接写在 Page 方法参数的 data 对象下面；另外一种是使用 setData 方法来做数据绑定，这种方式也可以理解为数据更新。这样的数据更新将引起页面的 Rerender（重新渲染），参考图 4-18 中的 Rerender。

1『2 种数据绑定的方法都很重要，特别是 setData 方法。』

先来看看初始化数据绑定的写法。代码清单 4-13 中，我们已经为 Page 方法的 data 对象填充了一些属性数据。现在，只需要对 post.wxml 文件做一些改动，即可让 wxml 能够「接收」这些初始化数据。小程序使用 Mustache 语法双大括号 {{}} 在 wxml 组件里进行数据的绑定。我们试着用数据绑定的方式来显示《小时候的冰棍儿与雪糕》这篇文章，更改这篇文章的 wxml 代码，如代码清单 4-14 所示。注意，post.wxml 文件里总共有 3 篇文章，但我们只更改了第一篇文章的相关代码，其他两篇文章依然使用硬编码的方式来填充数据。

保存后可以看到，页面并没有变化，第一篇文章的数据正常地显示了出来，这说明数据绑定成功了。可以看到双大括号中写入了一些变量名。细心的开发者应该发现 {{}} 里的变量名称同 js 文件里 data 对象的属性名称是相同的。可见，数据绑定非常简单，只要将 data 对象的属性名填入到双大括号中即可。MINA 框架会自动在运行时用 data 数据替换这些 {{}}。比如 {{date}｝，在运行后将被替换为「Jan 28 2017」，而 {{readingNum} 将被替换为「92」。

我们用图 4-18 页面生命周期图解这张图，解释一下初始化数据绑定的过程。当页面执行了 onshow 函数后，逻辑层会收到一个通知（Notify）；随后逻辑层会将 data 对象以 json 的形式发送到 View 视图层（Send Initial Data），视图层接收初始化数据后，开始渲染并示初始化数据（First Render），最终将数据呈现在开发者的眼前。这里需要注意，如果数据绑定是作用在组件的属性中，比如 \<image src="{{avatar}}"/>，则定要在 {{}} 外边加上双引号，否则小程序会报错。如果是内容型的数据绑定，则不需要加双引号，比如 \<text>{{date}}\</text。

在哪里可以查看数据绑定对象。开发工具为我们提供了一个面板专门用来查看和调试数据绑定变量，这个面板就是在第 2 章中介绍的 AppData 面板。请开发者注意，Appdata 面板对于调试和理解数据绑定有非常重要的作用，建议当开发者遇到数据绑定相关问题时，一定要首先打开这个面板来査看具体的数据绑定情况。

Appdata 下的数据以页面为组织单元。因为现在只在 post 页面里做了数据绑定，所以 Appdata 下边只出现了 pages/post/post 这一个页面的数据。如果同时有多个页面进行了数据绑定，那么这里将出现多个页面的数据绑定情况。如图 4-19 所示，可以看到在 bages/post/post 下显示了 post 页面的数据绑定变量情况，它的属性和 post.js 文件中所设置的 data 对象属性是一模一样的。

可以在这里更改某一项数据的值。更改是实时进行的，改变任何一个值，开发工具都能实时地将变化更新到模拟器 UI 里显示。开发者可以自行尝试，更改一下 title、date 或者 content 等的属性值，并注意观察模拟器的变化。

这里还有一个小技巧，让页面的数据以 json 的形式呈现：点击图 4-19 中的「Tree」这个选项，将打开如图 4-20 所示的面板。点击「Code」后，数据将 json 的形式呈现，如图 4-21 所示。json 格式的数据，非常利于我们快速复制这些数据。

1『经验证，这里应该只能看更改的效果变化，更改的数据是同步不到「post.js」里去的。』

绑定复杂对象。4.8.1 小节中的 Page 参数下的 data 对象只是一个最简单的 js 对象，它的属性值都只是简单的文本与数字。在实际项目中，可能出现较为复杂的对象，将 data 对象更改为如下代码；此时，data 对象已不再是简单的对象，它的属性还包含有对象和数组。运行代码后，我们发现，小程序并不会报错，但 UI 上的数据无法正确显示。原因是被绑定的 data 对象数据结构改变后，相应的也需要在页面的 wxml 里做出和 data 数据结构等同的调整。调整之后的代码如下（注意，我们同样只更改第一篇文章的相关代码）。

现在，date 数据的绑定语法由 {{date} 变成了 {{object.date}｝；而 collection 数据的绑定语法由 {{collectionNum} 变成了 {{collectionNum.array[0]}}。这些相应的调整都是根据 data 数据结构的变化做出的，开发者请仔细对比。重新运行项目，文章数据又可以正常显示了。

数据绑定更新。还可以使用 setData 函数来做数据绑定，这种方法可以理解为「数据更新」。setData 方法位于 Page 对象的原型链上：Page.prototype.setData。大多数情况下，我们使用 this.setData 的方式来调用这个方法。setData 的参数接受一个对象，以 key 和 value 的形式将 this.data 中的 key 对应的值设置成 value。上面这句话要注意两点：1）setData 会改变 this.data 变量里相同 key 的值。2）setData 执行后会通知逻辑层执行 Rerender，并立刻重新渲染视图，参考图 4-18。

1『使用 this.setData 的方式来调用这个方法。』

在 post 页面中新增一个 onLoad 函数，并在其中执行 setData，更改后的代码如下：

```
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function () {
    this.setData({
      title:"一根雪糕的经济学原理"
    })

  },

```

1『原来 Page() 方法里，Data 数据里设置的 title 字段属性就变成了上面设置的了。』

运行后我们发现，第一篇文章的标题由 data 里所设置的 title:「小时候的冰棍儿与雪糕」，被更改成了「一根雪糕的经济学原理」，但其他的数据并没有改变。原因在于我们使用 this.setData 只更新了 title 这一个数据，并未改变其他诸如 date、avatar、content 等数据。

此外，当执行了代码清单 4-17 后，此时 this.data.title 的值将是「一根雪糕的经济学原理」，而不再是「小时候的冰棍儿与雪糕」，因为 this.setData 的执行也会改变 this.data 里的值。这就是 setdata 的基本用法。此外，setData 参数中的 key 是非常灵活的，来看看 key 可能出现的形式。修改代码清单 4-17 中的 onload 方法如下：1）Key 可以使用字符串来表示，代码如下；2）更改 collectionNum 数组子元素的值，代码如下；3）更改 object 下的 date 的数值。

用 this.setData 所绑定或者更新的数据，并不要求在 this.data 中已预先定义。看看下面的例子，将 post.js 文件中的代码改为代码清单 4-21 所示。上述代码中，去掉了 this.data 中的初始化数据，转而直接使用 this.setData 进行数据更新，从而实现数据绑定，这种方法也是可行的。但这时项目并不能正常运行，UI 上第一篇文章变成了一篇空白，且没有任何错误提示。原因在于，数据绑定的数据结构变了，wxml 里的 {{}} 也需要做相应的改变。

2『用 this.setData 所绑定或者更新的数据，并不要求在 this.data 中已预先定义。可以直接使用 this.setData 进行数据更新，从而实现数据绑定。这是一个关键知识点，做一张信息卡片。还有一点要注意，数据的更新一定要放在生命周期函数 onLoad 里面。』

借助我们之前讲到的 Appdata 面板来看一下现在的数据绑定情况，如图 4-22 所示。很明显，这个数据结构和之前的是不一样的。所有的属性都被 postData 对象包裹了起来，因为我们在 this.setData 的时候指定的 key 是 postData，value 是文章的数据。所以，wxml 里的 {{}} 需要如下修改：

只需要在每个 {{}} 里加入 postDatal 即可。比如 {{title}} 应当改为 {{postData.title}}。请各位开发者注意，关于数据绑定的错误，小程序目前不会给出任何的错误提醒。如果你发现整个页面是空白的又没有错误消息，多半是数据绑定出了问题。这个时候 Appdata 面板是最好的调试工具。

### 4.9 列表渲染 wx: for

到目前为止，我们只将第一篇《小时候的冰棍儿与雪糕》改为了数据绑定的形式，现在来尝试把所有的文章都改为数据绑定的形式。首先将其他两篇文章的数据提取到 post.js 文件中，同第一篇文章的数据组成一个数组。

注意，代码中 this.setData 的 key 更改为了 postlist，value 被更換成了一个包含 3 个元素的数组，每个元素代表一篇文章的数据。现在，我们已经有 3 篇文章的数据了。我们当然可以像改写第一篇文章一样，依次改写其他两篇文章的 {{}} 绑定。但这样好吗？

这里来考虑一个问题，如果我有 100 篇文章，怎么办？难道也像这样手动地去填写 100 篇文章的 {{}} 吗？如果可以在 wxml 里做 for 循环该有多好？小程序确实提供了一个 wxml 组件的 for 循环，称为列表渲染。我们一起来看看，如何使用列表渲染来改写文章列表，先给出改写后的代码。

重点关注 \<block> \</block> 这对括号内的代码。\<block> 标签没有实质意义，它并不是组件，所以我们称作「标签」，它仅仅是一个包装，不会在页面内被渲染，可以理解为常见编程语言里的括号，在 block 标签中被包裏的元素将被重复渲染。

在 block 标签上，放置了ー个 wx:for 的特殊属性，它的值为 {{postList}}。wx:for 将绑定一个数组，在本示例中，这个数组就是 postList，它对应 post.js 文件中 setData 的数组数据。wx:for-item 指定数组当前元素的变量名，我们将当前元素的变量名指定为 item。wx:for-index 指定当前元素在数组中序号的变量名，我们命名为 idx。当然，在本示例中，只是定义了这个 wx: for-index，并没有真正地使用它。

有了 item 这个数组子元素后，就可以按照上一小节中改写第一篇文章时所使用的 {{}} 语法来填写数据绑定了。在所有的 {{}} 填写数据绑定变量。保存运行后，发现三篇文章都可以正常显示，但代码的总量却大大减少了。

wx:for 并不是一定要作用在 block 标签上，如果把代码清单 4-24 中的 block 标签换成 view，一样可以正常运行。但并不推荐使用 view 等组件来做列表渲染。因为同 HTML 一样，我们希望标签或者组件元素是语义明确的。view 组件通常被用来当作容器或者是区域分隔，它有它的使命，不应该被滥用。

2『列表渲染 wx:for 用 block 标签来实现，养成习惯。这样做的理由做一张信息卡片。』

开发者可以尝试将 wx:for-item="item" 属性给去掉，文章列表依然可以正常显示。不定义 item，那么 {{}} 内的 item 是哪里来的？事实上，不定义数组子元素的变量名，小程序默认子元素的变量名就是 item。如果你不喜欢 item 这个变量名，可以将它替换为其他你喜欢的变量名，比如 wx:for-item="element"。如果更改了子元素的变量名，记得将 {{}} 中对应的 item 都更换为被指定的变量名，比如 element。

### 4.10 配置单个页面导航栏背景色

注意观察 post 文章页面，它顶部的导航栏并不是默认的黑色，而是呈现出和 welcome 欢迎页面相同的橘红色。原因在于我们在 app.json 中配置了全局导航栏的颜色为 #b3d4d。在项目设计图里，全局导航栏的配色应该是 #4A6141, 所以，我们现在将全局导航栏的颜色配置为 #4A6141。在 app.json 中更改全局导航栏配色，代码如下：

更改后发现，welcome 页面顶部的导航栏颜色也被更换成了新的颜色。所以，我们需要单独配置 welcome 页面的导航栏颜色，让它不受全局配置的影响。全局配置是在 app.json 中设置，那么对单个页面的配置应该在页面的 json 文件中配置。在 welcome json 中添加如下代码：

保存后发现 Welcome 页面的导航栏颜色已经被更改成了橘红色。那么页面的 json 文件配置和 app.json 文件的配置有什么不同？1）页面的 json 文件只能够配置和 window 相关的属性。window 属性的配置项请参考 3.9 小节。但 app.json 除了可以配置 window 外还可以配置 pages、tabBar 等选顼。2）页面的 json 配置不要像 app.json 那样，加上 window 这个对象，直接编写 window 下面的配置项即可。请仔细对比代码清单 4-25 和代码清单 4-26 的区别。修改完成后，以后再新建任何页面，页面的导航栏背景色都将被配置为 #4A6141 这个颜色。当然，可以将颜色修改为任何你喜欢的颜色。

### 4.11 从欢迎页面跳转到文章页面

我们现在一共编写了两个页面：welcome 欢迎页面与 post 文章页面。来尝试将两个页面连接起来，通过点击 welcome 页面的「开启小程序之旅」跳转到 post 文章页面。首先将 welcome 页面重新调整为启动页面，代码如下；调整启动页面的方法很简单，将启动页面的路径放在 pages 数组下的第一个元素即可。

事件。要从 welcome 页面跳转到 post 页面，需要使用事件来响应点击「开启小程序之旅」这个动作。什么是事件？严肃一些的定义是：事件是视图层（wxml）到逻辑层（js）的通信方式。简单一些理解，事件可以让我们在 js 里处理一些用户在界面上的一些操作并对这些操作做出反馈。比如点击 Welcome 页面「开启小程序之旅」按钮后，需要在 js 里调用 MINA 框架的 API，使页面从 welcome 跳转到 post。

要实现这样的机制，需要做两件事情：1）在组件上注册事件。注册事件将告诉小程序，我们要监听哪个组件的什么事件。在本例中，需要监听「开启小程序之旅」这个组件的 tap 事件。2）在 js 中编写事件处理函数响应事件。也就是说，监听到事件后，需要编写自己的业务。在本例中，我们将调用 MINA 框架的导航 API，让 welcome 页面跳转到 post 页面。更改 welcome.wxml 页面的代码，如代码清单 4-28 所示。

```
<view class="container">
  <image class="avatar" src="/images/avatar/avatar-1.png"></image>
  <text class="motto">Hello, 大龙</text>
  <view catch:tap="onTapJump" class="journey-container">
    <text class="journey">开启小程序之旅</text>
  </view>
</view>
```

1『新版微信已经更新了 tap 事件的写法，catch:tap="onTapJump"，放到 view 下面的 text 里也可以实现跳转。』

和之前的代码相比并没有太大的改动，仅仅是在 Class="Journey- container" 的这个 view 组件上添加了ー个 catchtap="onTapJump" 的事件绑定。事件绑定的写法同组件的写法相同。它的意思是，监听点击这个动作，当用户点击这个动作后，将执行一个 onTapJump 的函数，这个函数必须在页面的 js 中定义。下面的代码定义了 tap 事件的处理函数。

1『看到下面的代码突然领悟到，page() 方法的参数是一个对象 {}，而对象是一个索引型的数据结构，onTapJump 是键，后面的具体方法实现是一个函数型的键值。同理，微信 API wx.redirectTo() 这个方法的传入参数也是一个对象，对象里包含这官方规定的各种「键-值」对。（2020-03-06）』

```
Page({
  data:{},

  onTapJump: function (event) {
    wx.redirectTo({
      url: '../post/post',
      success: function (){
        console.log("jump success")
      },
      fail: function () {
        console.log("jump failed")   
      },
      complete: function () {
        console.log("jump completd")    
      }
    });
  }
})
```

1『被找到的源码坑了，它用的是 switchTab，跳转不过去，改成书里的 redirectTo 函数即可跳转。备注：看完书后知道的了原因，switchTab 只适用于跳转到有 tab 栏的页面。』

代码中为 Page 方法的 Object 参数定义了一个函数：onTapJump。函数的名称可以任意指定，但必须和代码清单 4-28 中定义的 catchtap="onTapJump" 保持一致。当用户点击或者触碰「开启小程序之旅」这个按钮后，MINA 框架将执行 onTapJump 这个函数，并将一个 event 对象作为参数传递到函数里。保存运行代码，点击「开启小程序之旅」，页面将从 welcome 欢迎页面跳转到 post 文章页面。

1『event 是个形参。』

redirectTo 与 navigateTo。在上一小节中，我们在 onTapJump  函数里调用了 wx.redirectTo 方法从而实现了页面跳转。小程序共提供了 3 个导航 APl，以帮助开发者实现页面跳转：wx.redirectTo、wx.navigateTo 和 wx.switchTap（122100 版本新增）。他们之间的区别是：wx.redirectTo 将关闭当前页面，跳转到指定页面；wx.navigateTo 将保留当前页面，跳转到指定页面；而 wx.switchTap 只能用于跳转到帯 tabbar 的页面，并关闭其他所有非 tabbar 页面。 

switchTap 页面将在后面学习 tabbar 选项卡时再具体介绍，本节主要来看看 redirectTo 利和 navigateTo 的区别。redirectTo 和 navigateTo 在使用方式上完全相同，他们都接受一个 Object 对象作为参数。Object 对象中最重要的属性是 urI，它将指定要跳转的页面路径。请注意 url 是页面的路径，不要加上文件的扩展名（如同 app.json 中定义 pages 一样）。如果在页面路径后加上ー个「.wxml」，比如将 url 设置为 ur: "../post/post.wxml"，页面无法跳转，并会报错。

Object 参数还可以接收 3 个方法，分别是：1）success 跳转页面成功时 MINA 框架将调用此函数。2）fail 跳转页面失败时 MINA 框架将调用此函数。3）complete 无论成功或者失败，MINA 框架都将调用此函数。具体写法可参考代码清单 4-29。将这 3 个方法拿出来单独列举是因为在小程序中，几乎所有异步类型的 API 都配备有这 3 个方法。比如后面要学习的操作反馈 API：wx.showToast，获取用户信息 API：wx.getUserInfo 等。在以后的其他 API 学习过程中我们就不再一一列举这 3 个方法了。

1『几乎所有异步类型的 API 都配备有 3 个方法：success、fail 和 complete。』

再次保存并运行以上代码，点击跳转后，页面将跳转到 post 文章页面。此时我们发现没有办法再返回到 welcome 页面了。这就是 redirectTo 的特点，它将卸载 welcome 页面，并执行页面的 onUnload 事件函数。可以来验证一下，在 welcome.js 里加入ー个 onUnload 函数和一个 onHide 函数。

运行代码，发现 Console 将输出 「page is unload」，但并不会输出「page is hide」。再来看看 navigateTo。将代码清单 4-29 中的 wx.redirectTo 更改为 wx.navigateTo。保存运行代码后将发现，navigateTo 跳转到 post 页面后，页面左上角有一个返回按钮，如图 4-23 所示。点击返回后还可以再返回到 welcome 页面。除此之外，navigate 将执行 onHide 事件回调，并输出了「page is hide」。所以，redirectTo 将关闭当前页面并将页面卸载；而 navigateTo 仅仅会隐藏当前页面，还可以再次返回到被隐藏的页面。这是他们最重要的区别。

1『选择 navigateTo 还是 redirectTo 得看具体的应用场景，目前个人的理解绝大多数情况下应该使用 navigateTo，这样可以点返回到父页面。』

再来考虑一个问题。当 navigateTo 跳转到 post 页面后，再次从 post 页面返回到 welcome 页面时，post 页面会执行 onHide 还是 onUnload 呢？答案是会执行 post 页面的 onUnload 函数（不能保证以后的版本是否还会更改，但目前的 130400 版本确实是会执行 onUnload 函数。也就是说，当从子页面返回到父页面时，子页面会被卸载。开发者可以仿照 welcome 页面自行验证。

但事实上，子页面执行 onUnload 函数的行为是从 122100 版本后才更改的，在之前的版本中子页面返回到父页面并不会执行 onUnload 函数，造成大量的子页面残留在小程序中。这在当时给开发者带来了巨大的困抗，还好官方在后续版本中更改了这个行为。页面是否被卸载是非常重要的行为，不卸载页面将使全局性的一些行为，比如音乐播放的处理，变得非常复杂。所以，了解这些页面的生命周期对于开发者来说是很重要的，否则极易引起 bug。

1『页面是否被卸载是非常重要的行为。在工作台 console 面板里可以看页面的各种行为。』

我们还可以再试试 wx.switchTap 这个方法，将 welcome.js 中的 wx.navigateTo 更改为 wx.switchTap，其他保持不変，运行一下代码。页面无法执行跳转，且 Console 将输出 jump failed。原因之前我们解释过，wx.switchTap 只能跳转到带有 tabbar 选项卡的页面，而 post 页面并不带有选项卡，所以无法执行跳转。tabbar 的配置将在后面讲到，现在开发者无须关心。

小程序最多只能有 5 层页面。当我们使用 wx.navigateTo 从父页面跳转到子页面后，就形成了 2 个页面层级。可以继续在子页面里使用 wx.navigateTo 跳转到子页面。但小程序里强制规定，只允许有最多五层父子页面。所以请开发者注意，尽量避免多层级的交互方式。事实上，太多的子页面将严重影响用户的产品体验。建议页面最多不要超过 3 层。redirectTo 不存在这个问题，因为当跳转到另一个页面后，上一个页面被强制卸载掉了。

冒泡事件与非冒泡事件。什么是冒泡事件？冒泡事件指某个组件上的事件被触发后，事件还会向父级元素传递；父级元素还会继续向父级的父级传递，一直到页面的顶级元素。而非冒泡事件则不会向父级元素传递事件。在 4.114 节中，我们使用了 tap 事件，监听点击或者触摸动作，而 tap 是一个冒泡事件。常见的冒泡事件类型还有下面几种：1）touchstart 手指触摸动作开始。2）touchmove 手指触摸后移动。3）touchcancel 手指触摸动作被打断，如来电提醒、弹窗。4）touched 手指触摸动作结束。5）tap 手指触摸后马上离开。6）longtap 手指触摸后，超过 350ms 再离开。

相对于 PC 上的 Web 浏览器，小程序的事件并不多。需要注意的是，在 wxml 组件里注册事件时。不可以直接使用 tap="function"' 或 touchmove=" function"，需要在事件名之前添加 catch 或者 bind 前缀。比如在 welcome 页面跳转时，我们就使用了 catchtap 而并没有直接使用 tap。

bind 和 catch 有什么区别？区别在于，对于以上几个冒泡事件，catch 将阻止事件继续向父节点传播，而 bind 不会阻止事件的传播。基本上所有的组件都有以上这些冒泡事件。除以上 6 种事件外，如无特殊申明都是非冒泡事件，非冒泡事件大多不是通用事件，而是某些组件特有的事件。如 \<form/> 的 submit 事件，\<Input/> 的 input 事件，\<scroll-view/> 的 scroll 事件等。

## 05. 模块、模板与缓存

### 1. 逻辑脉络

用模板大幅提高代码的复用性与可维护性，避免开发者编写重复的代码；缓存的应用，小程序里的缓存与数据库的功能类似；使用 ES5 和 ES6 语法编写「数据库」访问类。

### 2. 摘录及评论

主要介绍了模块、模板和缓存的概念以及使用方法。模板是小程序中的重点和难点，它将大幅度地提高代码的复用性与可维护性，避免开发者编写重复的代码。本章也特别指出了模板与组件的区别，小程序仅仅实现了模板化而不能自定义组件，这是非常遗感的一件事儿。缓存的应用也是小程序中的一个特色，开发者的很多业务都需要借助缓存来实现，比如用户的令牌、城市列表数据等都可以写入小程序的缓存中。本章我们还分别尝试使用 ES5 和 ES6 语法编写「数据库」访问类，开发者可以自行体会一下 ES6 编写 Class 的优越性。

### 5.1 将文章数据从业务中分离

现在，所有的文章数据都被强行写在 post.js 里，这污染了我们的业务层。我们尝试将这些数据分离到一个单独的 js 文件中。在 Orange Can 项目的根目录下新建一个文件夹，命名为 data。然后在 data 目录下新建一个 js 文件，命名为 data. js。将 post.js。文件中 onLoad 函数下的 postList 数组数据整体剪切到 data.js 文件中，并将其中的 collectionNum 和 date 等数据改为最简单的字符串（此前为了演示复杂对象的数据绑定，我们在「4.8.3 绑定复杂对象」这一小节中将 collectionNum 和 date 改为了对象的形式）。新的 data.js 文件代码如下。

1『数据从业务从剥离。』

### 5.2 小程序的模块

上ー小节中我们提取的数据文件 data.js 可以视作是小程序的一个模块，但现在还没有办法从其他文件访问这个模块。我们还需要使用 module.exports 向外部暴露一个接口。在 data.js 文件的最下部添加以下代码：

```
 module.exports = {
    postList: postList
  }
```

定义好模块后，接下来就可以在其他 js 文件中引用这个模块。我们需要在 post.js 中引入 data.js 这个模块。代码第一行的 require (path）将模块引入到 post.js 中，并将模块对象赋值给 dataObj。随后在 onLoad 函数里取出 postList 数据，并进行数据绑定。

```
var dataObj = require("../../data/data.js")

Page({

  data: {

  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function () {
    this.setData({
      postList: dataObj.postList
    })

  },

})
```

使用 require 引用 js 模块时，要特别注意以下几点：1）被引用的文件一定要带有扩展名 js，这一点是不同于页面路径的。2）path 路径不可以使用绝对路径，否则会报错。应该使用相对路径。3）在 Javascript 文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响。所以，如果使用 require ('/data/data.js），小程序会找不到 data.js 这个文件。

1『经验证，选择这个数据文件不加扩展名也可以被应用，不过最好还是加一下。（2020-03-06）』

注意为什么是 dataObj.postList？因为在输出模块时，我们是将 postList 作为一个 object 的属性赋值给 module.exports 的，参考代码清单 5-2。所以在 require 时，得到的也是一个 object 并非是 postList，需要使用 dataObj.postList 才能获取到真实的文章数据。这样的做的好处是，object 不仅可以包含 postList，你还可以在 data.js 文件中定义除 postList 外的其他数据，并作为 object 的属性一起输出。我们在上ー小节中更改了 postList 的数据结构，所以要调整 post.wxml 里的 {{}} 的语法才可以正常显示数据。

3『

运行后显示：wx:key 的警告。

[微信小程序----wx:key（Now you can provide attr wx:key for a wx:for to improve performance.）_Rattenking的博客-CSDN博客](https://blog.csdn.net/m0_38082783/article/details/79262294)

[微信小程序 wx:key_微信小程序_酸柠檬的博客-CSDN博客](https://blog.csdn.net/sinat_31177681/article/details/53557642)

官方解释 wx:key 如下：如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 \<input/> 中的输入内容，\<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。

网上资料，wx:key 的值以两种形式提供：1）wx:key="property" 其中 property 是代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。类似于字典的 key 值。2）wx:key="\*this"， 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。

如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。推荐 array 的每一个 item 都添加一个唯一识别的 property 来管理，这样就可以去掉 warning，如果使用保留关键字，好像会出现显示的 item 都是最后一个的：

    <block wx:for-items="{{userInfoList}}" wx:key="userInfoListId" 或者 wx:key="{{index}}">

』

保存运行代码，项目正常地显示出了 3 篇文章数据。事实上，require 只是模块化的一种方式。还可以使用 ES6 的 Module 来编写模块。开发工具默认使用 babel 将开发者的 ES6 代码转化成 ES5 代码。

### 5.3 小程序的模板化

使用列表渲染展现文章列表是最好的方法吗？恐怕不是。如果其他页面同样需要显示文章列表怎么办？把代码清单 5-4 中的代码到处拷贝吗？这当然是最差的选择。借助ー下函数这个思想。我们通常会将一些公共的、经常使用的业务逻辑提取成一个公共的函数，当在多个地方需要使用函数时，只需要调用这个函数即可完成相应的业务。使用函数的好处是不言而喻的。事实上，有一句话是这么描述软件开发的：编程世界里遇到的绝大多数问题都可以用封装的思想来解决。夸张一点儿来说，你所能看到的代码，其实全是封装过的代码。

小程序也提供了一个称作模板的技术来支持对 wxml 组件的封装，但是这种封装仅仅只是 wxml 的代码片段，并没有实现像 AngularJS 里的完整模块儿。在 AngularJS 里 HTML、js 可以作为一个整体被封装起来。但是在小程序中，我们只能将 wxml 封装，无法将模板的业务逻辑（js）也封装起来。

首先来看看如何使用模板，随后再讨论封装模板业务逻辑的问题。要使用模板，自然需要先新建模板文件。在 /pages/post 下新建目录 post-item，作为模板文件目录。接着在该目录下新建 2 个文件：post-item-tpl.wxml 和 post-item-tpl.wxss。这里使用 tpl 来结尾，只是一种建议和习惯，并不是强制要求，开发者可以自行定义模板名称。

2『以后模板命令都已 -tpl 来结尾。』

使用模板是为了简化 post.wxml 中文章的写法，让文章可以成为一个单独的「组件」（但不是真的组件，只是模板），供其他多个地方使用。想想我们在使用 mage、text 等组件时是不是很简单，只需要一个简单的 \<image>\</image> 就可以实现图片的显示功能。同样，我们也可以尝试将文章编写成一个「组件」。

```
<template name="postItemTpl">
  <view class="post-container">
  ......
  ......
  </view>
</template>
```

1『注意，书里的源码漏掉了最后一行，体现了模板相关内容必须被包裏在 \<template> \</template> 标签内。』

现在，尝试将 post.wxml 中 \<block> 标签中关于文章的代码剪切到 post-item-tpl.wxml 中，让这段代码成为一个可复用的「组件」。\</template> 模板相关内容必须被包裏在 \<template> \</template> 标签内，使用 name 属性指定 template 模板的模板名。这个模板名将在引用模板时被使用当定义好一个 template 后，可以在其他页面引用这个 template。现在我们在 post.wxml 中引用并使用这个 template。

```
<import src="post-item/post-item-tpl.wxml"></import>
<view >
  <block wx:for="{{postList}}" wx:for-item="item" wx:for-index="idx">
    <template is="postItemTpl" data="{{item}}"/>
  </block>
</view>
```

我们来分析一下上面这段代码是如何引用和使用 template 模板的。在 post.wxml 的顶部使用 \<import src="post-item/post-item-tpl.wxml">\</import> 来引用模板。对于 templatePath 路径，这里需要注意，在当前版本中，可以在后面加 wxml 文件扩展名，也可以不加扩展名。但官方示例中是带有扩展名的，所以建议开发者带上模板文件的扩展名。引用后模板就可以在页面中使用这个模板了。在需要模板的位置使用 template 标签引入模板 template 的 is 属性指定要使用哪个模板。

再次类比一下函数，函数通常可以定义若干个参数，并从函数调用方传入一些数据。同样，模板也可以传入数据。通过 template 的 data 属性，可以向 template 传递数据。这里将 wx:for 得到的 item 传入到 template 里，这样就可以在 template 内部使用这个 item 了。要注意的是，向模板里传入数据，同样要使用 {{}} 的数据绑定语法，比如 data={{item}}。

### 5.4 消除 template 模板对外部变量名的依赖

来看一个有趣儿的问题。我们之前讲过，列表渲染中 wx: for-item 可以指定数组子元素的变量名。现在，尝试将代码清单 5-6 中的 wx: for-item="item" 改成 wx: for-item="item1"。此时，如果要将数据传入到 postltemTpl 中，则应该设置 data-"tem1"。做完以上变更后，再次保存运行代码，会发现文章数据将消失，并且没有任何错误提示。没有显示数据，肯定是有问题的，再次强调很多时候数据绑定的相关问题，小程序不会做任何的错误提示。

那么，问题出在什么地方？之前代码可以正常运行是因为我们向 template 传入的变量名 data={{item}}，恰好和 template 里面数据绑定的变量名 item 一样，开发者可以回顾一下代码清单 5-5 和代码清单 5-6。但一旦更改了 item 为 item1 后，template 就找不到这个 item 了。

1『即要与文件「post-item-tpl.wxml」里定义的名字一样。』

类比一下函数，函数的参数名是可以由函数自己自定义的，这保证了函数不受外部变量名的影响。但是 template 模板却并没有提供一个定义参数名的地方，没有办法更改从外部传入的 item1 为 item。当然，可以通过将 postltemTpl 这个 template 内部的 item 更改为 item1 来让代码重新正常运行，开发者可以自行尝试一下。但这并不是一个好的办法，看起它非常的蠢。我们讲过模板的好处是它可以让多个调用方来调用，不可能要求每个调用方都使用同样的变量名来调用模板，这种由定义方要求调用方遵守变量名命名的做法是不太合理的。

要解决这个问题，就必须消除：template 对于外部变量名的依赖，可以使用扩展运算符「…」展开传入对象变量来消除这个问题。将 post.wxml 中使用模板的地方更改为：接着去掉 post-item-tpl.wxml 文件中 {{}} 里所有的 item。保存并运行，文章列表可以正常显示了。{{...item}} 可以将 item 这个对象展开。展开之后再传入到 template 里，就可以保证 template 不再依赖 item 这个变量名。

1『测试发现 wx: for-item="item" 改成 wx: for-item="item1" 还是显示不出图片。已解决，传入的数据说明也要跟着改 {{...item1}}。』

```
<block wx:for="{{postList}}" wx:for-item="item" wx:for-index="idx">
<template is="postItemTpl" data="{{...item}}"/>
</block>
```

### 5.5 include 与 Import 引用模板的区别

5.3 小节中，介绍了如何使用 import 来引用模板。小程序还提供了另外一种引入模板的方式 include。include 在使用上同 import 有以下区别：1）import 需要先引入 template，然后再使用 template；但 include 不需要预先引入，直接在需要的地方引入模板即可。2）include 模式非常简单，就是简单的代码替换，不存在作用域，也不能像 import 一样使用 data 传递变量。

如果要在 post.wxml 中使用 include，我们需要做一些改动。以上代码将 block 标签中的 template 更换成了 include 标签。includel 同样使用 src 属性指向模板文件。更改以上代码后，界面无法显示任何数据。来排查下问题，首先判断模板文件有没有正常地加载到页面中，可以使用调试中的「wxml」面板来看一下 post.wxml 中有没有 postItemTpl 的相关代码，如图 5-1 所示。并没有显示 postItemTpl 的相关代码。

1『发现「wxml」面板与 Chrome 开发工具里的 element 面板功能相似。』

为什么呢？原因在于 include 无法引入包含有 template 标签的代码，而现在 post-item-tpl.wxml 里的所有代码都是被 template 标签包裏起来的。如果想使用 include 代替 import，那么模板文件内就不能使用 template 标签。将 post-item-tpl.wxml 里的 template 标签删除，只保留文章本身的 wxml 代码。再次使用调试下的 wxml 面板查看 post.wxml 页面，发现 post-item-tpl.wxml 代码已被成功地引入到了 post.wxml 中。但现在文章的数据并没有显示出来，原因在于 include 无法向模板里传递变量，它仅仅只是一个占位符，当小程序运行时，会用 include 的 src 属性所指向的文件替换 include 自身。这一点同样可以从调试下的「wxml」面板里看到。

回顾一下代码清单 5-9，假想 include 已经被替换成了 post-item-tpl.wxml  里的代码，那么要想显示出文章数据，就必须再一次在 post-item-tpl.wxml 中的中加入「item」这个变量名，就像代码清单 5-5 所做的那样，开发者可自行尝试ー下。除了在使用上有所不同，include 和 import 还存在其他不同之处：import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 Import 目标文件 Import 的 template。例如：C import B，B import A，在 C 中可以使用 B 定义的 template，在 B 中可以使用 A 定义的 template，但是 C 不能使用 A 定义的 template。而 include 就很简单了，它只是一个占位符，仅做简单的代码替換。

那么，何时使用 include 何时使用 Import，这里笔者的建议是，如果模板仅仅是静态 wxml，不涉及数据的传递，可以使用 include。但如果模板涉及数据绑定，还是建议使用 import。所以，这里选择使用 import 来引用 postItemTpl 模板。

### 5.6 CSS 的模块化

在之前的几个小节里，已经成功地将 wxml 代码做成了模板。既然是模板，就应该有模板的样式。我们当然可以维持现在的代码不做改变，因为现在整个项目运行正常，但这样并不合理。样式同样应该作为模板的一部分被「打包」起来。将 post.wxss 中同文章相关的样式（所有以 post - 开头的样式）全部剪切到 post-item-tpl.wxss 文件中，post.wxss 文件只留下 swiper 组件相关的样式。保存运行，发现 post 页面的样式乱掉了。

1『模块化包括 wxml 模块化以及 wmss 模块化两部分。模块化的思维实在太赞，太多地方用到了。』

在定义了 postItemTpl 后，我们需要在 post.wxml 中引用它。同样，当定义了模板的 wxss 文件后，也需要在 post.wxss 文件中引用它。引用样式文件的语法是 @import "src"。在 post.wxss 文件的顶部添加如下代码：

```
/* pages/post/post.wxss */
swiper{
  width: 100%;
  height: 600rpx;
}

swiper image{
  width: 100%;
  height: 600rpx;
}

@import "post-item/post-item-tpl.wxss";
```

在引入 CSS 文件时，既可以是以上代码中所使用的相对路径，也可以是绝对路径。保存后，文章列表的样式恢复正常。

### 5.7 令人遗憾的模板化而非组件化

在组件化的编程思维里，一个前端组件必须要同时满足视图层代码的组件化和逻辑层代码的组件化。在小程序里勉强可以实现 view 的组件化（template 模板），但是模板却不可以实现业务逻辑 js 代码的组件化。开发者可以自行尝试一下，如果在 /bages/post/post-item 下再新建一个 post-item-tpl.js 文件，尝试将此文件作为模板的业务逻辑代码是行不通的，小程序无法自动运行这个 js 文件。也就是说，小程序只实现了模板化而并没有实现组件化。当然，我们同样可以像引入 wxss 样式文件一样，在 post.js 中通过 require 来引用模板的 js 文件，这样可以将模板的业务代码集中在一个模块儿中。

但对比一下官方提供的 image、swiper 等组件，他们的业务逻辑并不需要在 js 代码里引入，而是被很好地封装起来了，我们只需要在 wxml 中添加这些组件就可以很好地应用组件。同时，这些组件的数据交互也是通过组件的自定义属性来传递的，比如 swiper 组件的 autoplay 和 interval 等属性。很期待官方能够支持自定义组件，而不仅仅是现在的模板。自定义组件将大幅提高代码的复用性，并且使业务代码变得更加简洁。在官方的一个 Q&A 列表里，提到了打算支持自定义组件，但并没有说明准确的时间点。

1『官方已经新增「自定义组件」了。』

### 5.8 使用缓存在本地模拟服务器数据库

在之前的小节中，我们将文章相关数据分离到了 data.js 文件中，并在 post.js 文件里通过 require 来加载 data.js 文件。引用并读取 data.js 当然没有问题，但我们考虑一个问题，如果要修改数据怎么办？修改后的数据，还想共享给其他页面使用，并长期保存这些数据怎么办？

比如，在后面的内容中，我们会增加文章的评论、阅读量计数、文章收藏数等动态计数功能；且当用户重启应用后这些用户数据并不应该丟失。我们需要一个类似于数据库的概念，可以读取、保存、更新这些数据，且这些数据不会因为应用程序重启或者关闭而消失。小程序提供了一个非常重要的特性 一一 缓存，来支持这样的特性。现在，将 data.js 这个文件视作是本地数据库的初始化数据，要做的第一件事就是将这些初始化数据「装进」缓存中，以形成数据库的初始化数据。

应用程序的生命周期。在什么时候将初始化数据装载到缓存中是一个需要考虑的向题。考虑一下，初始化的行为在整个应用程序生命周期里只应该发生一次，所以最好的时机是在小程序启动时来装载初始化数据。应用程序启动时是一个 MINA 框架行为，如果想掌握这个时刻，并做一些我们想做的事儿，就需要框架通知我们：嗨，现在是应用程序启动的时候，你要做什么事儿，就在这个函数里做吧。想想之前页面的生命周期，每一个重要的结点，MINA 框架都会给页面一个通知，比如 onLoad、onShow、onReady 等。同样，整个应用程序也有自己的生命周期。

还是类比一下页面的生命周期。在页面的 JS 文件中，我们使用 Page (object）来注册页面，并在 object 中指定页面的生命周期函数等。同样，可以在 app.js 文件中使用 App (object）来注册小程序，并在 object 中指定小程序的生命周期函数等。Object 参数有以下几个：1）onLaunch 监听小程序初始化，当小程序初始化完成时，会触发 onLaunch（全局只触发一次）。2）onShow 监听小程序显示，当小程序启动，或从后台进入前台显示，会触发 onShow。3）onHide 监听小程序隐藏，当小程序从前台进入后台，会触发 onHide。4）onError 错误监听函数，当小程序发生脚本错误，或者 API 调用失败时，会触发 onError 并带上错误信息。

当然，除了以上几个 MINA 框架给予的特定函数，开发者还可以添加任意函数或数据到 Object 参数中，用「this」可以访问这些函数和数据。这里特别对 onShow 和 onHide 做一个说明。onHide 会在小程序从前台进入后台时触发，比如在 iPhone 中通过按下「Home」键，将微信隐藏时触发 onHide；而 onShow 不仅仅在小程序启动时会触发，还会在小程序从后台到前台时触发，相当于是 onHide 的反向动作。可以在开发工具中模拟应用程序的「进入后台」和「从后台显示」这两个动作，从而触发 onShow 和 onHide。开发工具提供了一个「后台」按钮，点击后应用程序将模拟进入后台的效果，再点击次将从后台返回到前台，如图 5-2 所示。

使用 Storages 缓存初始化本地数据库。上ー小节中我们分析了，最好的初始化数据库的时机是在应用程序启动时，在 app.js 中加入以下代码：

```
//app.js
var dataObj = require("data/data.js")

App({
  onLaunch: function () {

    // 缓存初始化本地数据库
    wx.setStorage({
      key: 'postList',
      data: dataObj.postList,
      success: function(res){
        // success
      },
      fail: function(){
        // fail
      },
      complete: function(){
        //complete
      }
    })

})
```

在上面的代码中，首先通过 require 加载 data.js 文件作为初始化数据。在应用程序生命周期函数 onLaunch 里，使用 wx.setStorage 方法将初始化数据存入到小程序的缓存中。什么是缓存？缓存让小程序具备了本地存储数据的能力，它具有以下几个特点：

1）只要用户不主动清除缓存，则缓存一直存在。2）缓存以 key: value 键值对的形式存在，很类似于服务器流行的 memcache 或者 redist 缓存型数据库。3）小程序提供了一系列 API 用来操作缓存，包括：存储、读取、移除、清除全部和获取缓存信息。每种操作同时都具有同步和异步两个方法。具体 API 请参考官方文档。4）请注意移除和清除的区别。删除某一个 key 的缓存，请使用 wx.removeStorage 方法；而如果想清除所有的缓存请使用 wx.clearStorage 方法。5）要注意，小程序的缓存永久存在，不存在过期时间这个概念。如果想清除缓存，则需要主动调用清除存的 API。6）小程序的本地缓存有容量上限，最大不允许超过 10 MB。

代码清单 5-12 中的 wx.setStorage (object）是一个异步方法，参数 object 包含 key, data 和 success、fail、complete 这 3 个通用方法（关于这 3 个通用方法，之前我们反复强调，几乎所有小程序的异步 API 方法中都包含这 3 个方法，后面的内容将不再列出这些方法，请开发者根据自己的需求来使用这些方法。Key 用来设置缓存的键，而 data 用来设置缓存的值，可以是 Javascript 对象或者字符串。运行以上代码并不会出现明显的效果，但我们可以在调试下的【Storage】面板里看看有什么变化，如图 5-3 和图 5-4 所示。

图 5-3 中的 postList 就是在代码中设置的 key: 'postList'，后面的 Array 数组就是设置的 data 对象，也就是要初始化的数据，对应的是 data.js 文件的 3 篇文章数据。点击展开 Array，如图 5-4 印证了这一点。「Storage」面板是査看缓存的重要功能，当你遇到与缓存相关的问题时，请一定要到这里来看一看。

是的，这就是我们搭建的一个简易本地数据库，它具有增、删、改的功能。当然，它也具备简单的查询功能，但并不如 MySQL 这类数据库的查询功能强大。注意，将本地缓存理解为一个简易数据库的思想非常重要，我们应当像在服务器编写数据库访问类一样，编写一组操作自己业务缓存的通用方法，而且最好将这些方法集中在一个「类」中。这样的做法将大大提高代码的可阅读性与可维护性。在实际项目中，本地缓存是非常重要的功能，可以极大地改善用户体验。

所有的缓存操作方法还有一个同步的版本，用同步的方法来改写一下代码清单 5-12；同步方法 wx.setStorageSync 是在异步方法名 wx.setStorage 后加了一个后缀「Sync」。不仅仅是 setStorage，小程序中几乎所有同步方法的方法名都是在异步方法名后增加了「Sync」。

同步方法的参数非常简单，它接收 2 个参数，例如 wx.setStorageSync(key, data)，同步方法没有 success、fail、complete 等回调方法。在本书的后续代码中如果没有特殊情况，通常都用同步方法。开发者可以根据自己的业务和环境选取异步方法。但要注意的是，选取异步方法会大大增加代码风险率和调试难度。如果没有必要（通常是处于性能和体验的考虑），建议优先考虑同步方法。

代码清单 5-12 和代码清单 5-13 分別用异步和同步的方法设置了缓存。但考虑一下上面的代码还有没有问题。上面的代码将在小程序每次启动时，都会执行一次 require 和一次 setstorage。但实际上，缓存如果不主动清除，它是一直存在的，因此完全没有必要每次启动小程序时都执行一次初始化数据库。仅当缓存不存在时，执行一次上述代码即可。下面我们对数据库进行修改，因为如果每次启动时都重新初始化缓存，那么对数据库的修改就会被初始化数据覆盖，这并不是我们想看到的结果。

修改上述代码如下：

```
    // 缓存初始化本地数据库
    var storageData = wx.getStorageSync("postList");
    if(!storageData){
      // 如果 postList 缓存不存在
      var dataObj = require("data/data.js")
      wx.clearStorageSync();
      wx.setStorageSync("postList", dataObj.postList);
    }

```

wx.getStorageSync(key) 这个方法可以获取指定 key 的緩存内容。如果指定 key 的缓存不存在则说明数据库还没有初始化。那么此时首先使用 wx.clearStorageSync() 清除所有的缓存数据，接着再重新读取并设置初始化数据。以上代码优化了初始化缓存数据库的方案。只有当缓存数据库不存在时，才通过 require 加载 data.js 文件，并初始化数据库。这样可以避免每次启动应用程序都重复初始化数据库。

虽然通常来说，require 都是放在代码文件的顶部，但我们也可以在需要的时候才引用它。代码清单 5-14 中演示了这种用法。本地缓存数据库，我们就初步建立完成了，后续内容我们还会持续完善这个数据库。

缓存的强制清理及注意事项。除了使用 wx.clearStorageSync() 代码清除缓存外，在模拟器中还可以通过开发工具左侧的「缓存」工具进行缓存清理。缓存工具点击后会弹出 4 个选项，其中「清除数据存储」就是清除 Storage 的功能。但要特别注意，真机上没有类似于开发工具这样的强制清理缓存的按钮。微信自帯的缓存清理并不是用来清除小程序缓存的，这点要特别注意。

笔者在实际开发过程中遇到很多缓存引起的问题，其中大多数是因为更新了初始化数据后，却忘记在手机上清除缓存，以至于没办法更新真机上的初始化数据。建议的解決方案是，在开发过程中，临时在页面里增加一个按钮，点击按钮执行 wx.clearStorageSync()，强制清理缓存。这样重启应用程序后，由于本机没有缓存，所以会重新加载初始化数据。本书将在后面编写 setting 设置页面时，增加一个清理缓存的选项。

在处理缓存相关问题时，开发者要保持头脑清醒，否则有时候一个小小的缓存没更新的问题，将浪费开发者大量的时间。一个典型的案例是，你更改了初始化数据里的文章图片路径，但在真机上运行时，由于缓存存在，就不会重新加载新的初始化数据。这将导致你的新图片一直无法显示。另外一种思路是，在开发阶段，不要做代码清单 5-14 中是否有缓存的判断，每次应用程序重启都强制更新一次初始化数据，从而保证数据一直是最新状态。

2『不做判断是否存在缓存，每次都重载，这也是一个解决方案，具体要看应用场景。去实现设置页面里的清楚缓存功能。（2020-03-07）』

### 5.9 编写缓存数据库操作类

我们来构建一个访问缓存数据库的访问「类」。在 Javascript 编程的世界里似乎「类」这个概念一直都不是那么流行，相当一部分原因在于 Javascript 的面向对象和我们在大学和工作后所理解的诸如 Java、C# 这种经典的面向对象语言有很多的不同，这是由于 Javascript 历史原因造成的。但 Javascript 里并不是没有面向对象，只不过它是用原型链的方式来实现对象的继承机制。

ES6 的出现让 Javascript 这个语言重新焕发了新生，module、lambda、class 等特性的支持，让 Javascript 更加现代化。考虑到本书主要内容是讲解小程序，如果全部使用 ES6，必然会全面使用面向对象的思想来构建整个项目，这会给部分不熟悉 ES6 的开发者造成一定的困扰。所以 Orange Can 项目的编写并没有全面使用 ES6，但 ES6 的重要性是不言而喻的，Orange Can 将尝试对于某些模块使用 ES6 来编写。不使用 ES6 并不代表我们没有办法编写面向对象的代码，我们将尝试用 prototype 和 ES6 的 class 分别来构建缓存数据库的操作类。在项目根目录下新建 db 文件夹，并在该文件夹下新建 DBPost.js 文件，并在文件中写入以下代码：

```
var DBPost = function() {
  // 所有文章的本地缓存存储键值
  this.storageKeyName = 'postList';
}

DBPost.prototype = {
  // 得到全部文章信息
  getAllPostData:function() {
    var res = wx.getStorageSync(this.storageKeyName);
    if(!res){
      res = require('../data/data.js').postList;
      this.execSetStorageSync(res);
    }
    return res;
  },

  // 本地缓存，保存/更新
  execSetStorageSync:function(data){
    wx.getStorageSync(this.storageKeyName, data);
  },
};

module.exports = {
  DBPost:DBPost
};
```

上述代码首先定义了ー个 DBPost 构造函数。在构造函数中，我们将 post 数据在缓存数据库中的 key，postList，赋值给构造函数的 this 变量。注意，这个 postList 必须同 app.js 中我们初始化数据库时设置的文章数据的 key 相同，否则无法读取数据。

随后，我们在构造函数的原型链上添加一个对象，这个对象的所有属性和方法都会被构造函数的实例继承。比如，我们在这个对象中增加了一个 getAllPostData 方法，这个方法将可以获取缓存数据库中所有的文章数据。在 getAllPostData 中，我们做了一个判断，如果缓存不存在将重新加载 data.js 数据文件，并存入到缓存数据库中。最后，还是使用 module.exports 将 DBPost 输出。

2『在构造函数的原型链上添加一个对象，这个对象的所有属性和方法都会被构造函数的实例继承。这句话带来的触动很大，做一张金句卡片。』

当然这里最好的写法还是使用 ES6 的 Class 和 Module 来编写。使用构造函数和 prototype 原型链构建对象，总是会让那些熟悉 Java、C# 等现代经典面向对象的开发者觉得很奇怪。ES6 的 Class 优化了 Javascript 的对象构建方式，让对象看起来更加符合现代的面向对象写法。但是，ES6 大多特性只是一种语法糖，在本质上 Javascript 的运行和解析机制并没有被改变。所以理解 Javascript 的构造函数与原型链 prototype 依然非常重要。

### 5.10 使用缓存数据库操作类

现在，我们尝试在 post.js 中使用上ー小节中定义的数据库操作类，将 post.js 代码更改一下：

```
var DBPost = require('../../db/DBPost.js').DBPost;

  onLoad: function () {
    var dbPost = new DBPost();
    this.setData({
      postList: dbPost.getAllPostData()
    });
```

需特别注意的是，这里没有直接使用 require 加载 data.js 文件，因为 data.js 现在只是初始化数据，它已经在 app.js 中被装载到缓存数据库中。所以，我们现在 require 的是 DB 操作类所在的模块文件，通过这个类来操作文章数据。

代码第一行同样使用 require 加载 DBPost.js 文件，并读取 DBPOST。那么，如果要使用 DBpost，必须先使用操作符「new」将 DBPost 实例化。实例化 DBPost 后，就可以调用该对象的 getAllPostData 方法，从而读取所有文章的缓存数据并绑定到 postList 中。保存后，程序可以正常地运行。

### 5.11 使用 ES6 改写缓存操作类

我们用 ES6 的新特性 Class、Module 来改写缓存操作类。

```
class DBPost {
  constructor(url) {
    this.storageKeyName = 'postList';
  }

  // 得到全部文章信息
  getAllPostData() {
    var res = wx.getStorageSync(this.storageKeyName);
    if(!res){
      res = require('../data/data.js').postList;
      this.execSetStorageSync(res);
    }
    return res;
  }

  // 本地缓存，保存/更新
  execSetStorageSync(data) {
    wx.getStorageSync(this.storageKeyName, data);
  }

};

export {DBPost}
```

1『注意，函数名与后面的花括号之间是有空格的，比如 execSetStorageSync(data) 与后面的花括号。』

以上代码使用 ES6 的 Class 改写了缓存数据库操作类。可以看到，同 prototype 的实现方式相比，ES6 的写法更加符合现代语言的类的标准定义习惯。注意 Class 中定义的两个函数，它们是不需要 function 关键字的。同时，方法之间不要加「,」，否则会报错。最后 export 输出语法也非常简洁，如 export {Dbpost}。接着，我们再看如何使用 ES6 版本的 DBPost。

```
import {DBPost} from '../../db/DBPost.js';
```

注意，这里不再使用 require 来加载 DBPost.js 这个文件，而是使用 ES6 导入模块的关键字 Import 将 DBPost 导入进来。这种写法的可读性比 require 要高得多。通过以上两种不同的写法，可以清晰地看到 ES6 提供的 Class 模板让 Javascript 的面向对象编程变得更加的清晰，更符合现代面向对象写法。但 Class 仅仅是一个语法糖，不使用 ES6 一样可以实现面向对象的编写方法。建议开发者使用 Class 来编写对象，小程序本身在编译时会集成 babel 这个插件，将 ES6 转成 ES5。我们将选用 ES6 实现的这个版本作为 Orange Can 的项目代码，当然如果你不熟悉 ES6，也可以使用 prototype 这种编写方式。

### 5.12 完善文章数据

在这一章的末尾，我们将完善文章数据，顺便看一下如何更新缓存中的初始化数据。目前，我们仅有 3 篇文章的数据，现在再增加两篇文章的数据。在 data.js。文件中再增加两篇文章数据，代码如下：

理论上，当增加了两篇文章数据后，不需要增加任何代码，再次刷新项目后，文章列表页面应该立刻出现这两篇文章的数据。但实际上并不是这样，保存后 post 页面还是只有 3 篇文章的数据。原因很简单，因为缓存已经存在了，如果更改了初始化数据又不清除缓存，那么缓存是不会被更新的。点击开发工具左侧的「缓存」按钮，随后在弹出的菜单中点击「清除数据缓存」，然后再编译项目，发现文章列表里已经有 5 篇文章了。

1『又见清理缓存的重要性。』

### 5.13 完整的 data.js 数据

在这个章节的末尾，我们给出 data.js 文件的所有数据内容，包括已经用到的和没有用到的。以上是完整的 data.js 数据文件。有部分数据目前我们还没有用到，比如 music 数据、文章 id 号、文字详情数据、点赞、评论等。但在后面的章节中，我们将使用以上的诸多数据。开发者可自行修改文字、图片、音乐内容，但需要保持数据结构不变。再次提醒开发者，更新 data.js 文件后，需要主动在开发工具中清除数据缓存。
