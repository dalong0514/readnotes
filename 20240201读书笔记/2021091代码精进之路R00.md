## 记忆时间

## 卡片

### 0101. 主题卡 ——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡 —— 实体类和辅助类

信息源自「0101命名」

类是面向对象中最重要的概念之一，是一组数据和操作的封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。

2『实体类和辅助类，做一张属于卡片。（2021-10-13）』—— 已完成

实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如 Customer、Bank 和 Employee 等。

辅助类是辅佐实体类一起完成业务逻辑的，其命名要能够通过后缀来体现功能。例如，用来为 Customer 做控制路由的控制类 CustomerController、提供 Customer 服务的服务类 CustomerService、获取数据存储的仓储类 CustomerRepository。

对于辅助类，尽量不要用 Helper、Util 之类的后缀，因为其含义太过笼统，容易破坏 SRP（单一职责原则）。比如对于处理 CSV，可以这样写：

```java
CSVHelper.parse(String)

CSVHelper.create(int[])
```

但是我更建议将 CSVHelper 拆开：

```java
CSVParser.parse(String)

CSVBuilder.create(int[])
```

### 0202. 术语卡 —— 计算机里的函数

信息源自「0301函数」

在计算机编程中，函数的作用和数学中的定义类似。函数是一组代码的集合，是程序中最小的功能模块，一次函数调用包括接收参数输入、数据处理、返回结果。同一个函数可以被一个或多个函数调用任意多次。

2『这里有关函数的定义，做一张术语卡片。（2021-10-14）』

实际上，在软件体系中，关于函数有 3 个概念：子程序（Subroutine）、函数（Function）和方法（Method）。在不同的历史阶段，不同的编程语言对「函数」的解释和称呼会有所不同。其中，子程序是比较老的概念，现在基本已经不再用这个概念了；函数是最通用的叫法，特别是随着函数式编程、FaaS（Function as a Service）等概念的兴起，函数被提及得越来越多；方法则是面向对象语言中对函数的叫法。

在英语中，Function 一般代表函数式语言中的函数，而 Method 代表面向对象语言中的函数。但是在中文技术书籍中，将 Method 翻译成「方法」和「函数」的都有，我觉得两种译法都可以。在本书中，「函数」和「方法」都会被用到，在面向对象的语境下大多使用「方法」，其他场景会尽量使用「函数」。

### 0203. 术语卡 ——

### 0301. 人名卡 ——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡 ——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 数据信息卡 ——

### 0601. 任意卡 —— 开闭原则和里氏代换原则是设计目标，单一职责、接口隔离、依赖倒置原则是设计方法

信息源自「0401设计原则」

SOLID 最早由 Robert C. Martin 在 2000 年的论文「Design Principles and Design Patterns」中引入。在 2004 年前后，Michael Feathers 提醒 Martin 可以调整一下这些原则的顺序，那么它们的首字母的缩写就可以排列成 SOLID。这个新名字的确促进了 SOLID 思想的传播，再一次证明了命名的重要性。

SOLID 原则之间并不是相互孤立的，彼此间存在着一定关联，一个原则可以是另一个原则的加强或基础；违反其中的某一个原则，可能同时违反了其他原则。其中，开闭原则和里氏代换原则是设计目标；单一职责原则、接口分隔原则和依赖倒置原则是设计方法。

2『开闭原则和里氏代换原则是设计目标，单一职责、接口隔离、依赖倒置原则是设计方法。做一张任意卡片。（2021-11-06）』—— 已完成

### 0602. 任意卡 —— 泛化即继承

信息源自「0601模型」

泛化（Generalization）关系也称为继承关系，用于描述父类与子类之间的关系。父类称为基类或超类，子类称为派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。在代码实现时，我们使用面向对象的继承机制来实现泛化关系，例如，在 Java 语言中使用 extends 关键字。

1『原来之前在其他地方看到的泛化就是继承的意思，搞得这么「专业」，误人啊。泛化即继承，做一张任意卡片。（2021-11-06）』—— 已完成

举例说明，Student 类和 Teacher 类都是 Person 类的子类，Student 类和 Teacher 类继承了 Person 类的属性和方法，Person 类的属性包含姓名（name）和年龄（age），每一个 Student 和 Teacher 也都具有这两个属性。另外，Student 类增加了属性学号（studentNo），Teacher 类增加了属性教师编号（teacherNo），如图 6-13 所示。

## 内容提要

这是一本为专业程序员而写的书，写好代码、追求卓越和工匠精神是每个程序员都应该具备的优秀品质。

本书共有 13 章内容，主要分为技艺部分、思想部分和实践部分。技艺部分详细介绍了编程技巧和方法论，并配以详尽的代码案例，有助于读者提高编写代码的能力，优化代码质量。思想部分主要包括抽象能力、分治思想，以及程序员应该具备的素养等内容。实践部分主要介绍了常见的应用架构模式，以及 COLA 架构的设计原理。

本书的目标读者是专业程序员，书中有关命名、函数、抽象和建模等内容是具有普适性的。无论你是否使用 Java 语言编程，也不管你从事的是业务应用开发、前端开发，还是底层技术开发工作，都可以阅读和使用本书。

## 序一

软件研发是技术也是艺术，不仅要有一行行的代码，还要有主题思想、想象力、宏观架构…… 程序员在成为一个架构师梦想的指引下，不断地学习语言特性、编程模型和各种思想方法，并在一次次的系统重构中成长。可以说，程序员的快乐和骄傲很大程度上来自于那些具有美感的代码。

软件的发展如此迅猛，作为程序员，我们经常会面对着没有前人经验的「无人区」。过去的软件大多数是对现实世界的模拟，还有参照物供我们去归纳总结抽象。但随着 PC 互联网和移动互联网的发展，软件已经演进为一个与现实连接的虚拟世界，成为了社会的基础设施。在这个全新的领域，我们只有不断地突破思想的边界，善于打破旧观念，敢于探索未知，才能有所贡献。

刚认识建飞的时候，他对代码质量的追求和对优雅架构的探索精神打动了我。几年下来，我看到他在这个领域中逐渐形成自己的认知体系、做事方法和评价标准，并沉淀出了在很多业务系统中得到了有效应用的 COLA 系统框架，也在如何做技术 Leader 方面形成了自己的思路，带领团队拿到了良好的业务结果。

这本书是建飞的阶段性思考总结，相信读者能从这本书中看到他对软件研发的热情和独到见解。我也希望建飞能够不断地探索总结，给我们带来更多的惊喜！

阿里巴巴技术副总裁

玄 难

2019 年 6 月

## 序二

写软件的人有一大爱好，就是聚在一起，相互调侃自家的代码。「我司祖传代码，五代单传，无注释，如无字天书……」「我司代码相当的浪，想重构吧，害怕一不小心大水冲了龙王庙……」

软件人员还有一个爱好，就是崇拜「银弹」。

前两年，银弹是敏捷、Scrum，搞得轰轰烈烈，但是实践下来，往往变成了管理者要求软件团队更快和更频繁出产品的工具：两星期一迭代，三个月出产品。架构设计往边靠，先出个 MVP，再迭代，将来再重构…… 有更重要的需求了？没关系，这里加个 if/else，那里复制一下代码就可以实现了。当敏捷变成了一种管理工具后，代码架构更加脆弱，用一个「摇摇欲坠」的架构去支撑不断变化的业务需求，要「敏捷」，只能 996 了。

近几年的银弹是微服务，但是微服务需要更强的业务建模能力和技术管理能力，否则实现和维护微服务系统只能是难上加难。

有时候，我很悲观地思考，变得「臭不可闻」是不是每个系统不可避免的命运？如果不是，靠什么才能避免代码的腐化呢？

我隐隐约约地觉得一个很好的架构可能是解决问题的办法。因为我在写代码前，如果没有业务压力，我可以优哉游哉地想个几天，等动手写代码时，头脑中的分治联合早已清楚，洋洋洒洒，如有神助；可是如果业务复杂繁忙，需要多个团队合作开发，就很难保证架构在演化过程中保持清晰健壮，也很难保证团队不走捷径、不做「变通」，更难以自动自觉地写出干净的代码为己任，而不会为了完成任务去堆砌代码。

可惜，我并没有深入且系统地思考解决方案。但是，本书的作者想了，更可贵的是，他做出来了。这本书从最底层的技术细节开始讲起，从命名、代码规范、设计模式，到技术人员的素养、技术 Leader 的修养，再到 COLA 架构和如何使用 COLA 架构快速开发系统。整本书的风格如我喜欢的代码一般，清晰、简洁、有力。

我尤其喜欢的是第 11 章「技术 Leader 的修养」。技术高手在任何公司都很重要，但是以我所观察到的情况，很多高手都是「救火队长」，哪里有火就扑向哪里，成为大家顶礼膜拜的「救火英雄」；或者有些所谓的高手只在纸上做架构，指点江山。我认为，真正的技术 Leader 是能够创建并且演进架构，在架构层面上帮助大家比较容易地写出好代码的人；是能够创建良好的技术氛围，以写好代码为荣，以写坏代码为耻，促使大家不停学习的人。张建飞分享了他的团队中一些很有意义的做法，使我深受启发。

好代码才是真正的银弹！COLA 架构能够在架构层面上帮助程序员写出好代码、研读源代码，它是作者及其团队多年来孜孜不倦地践行工匠精神打磨出的系统产物。对于读者，我的建议是一边研读源代码，一边反复阅读本书，并进一步阅读书中推荐的其他书籍。我相信，不管你是刚入行的新人，还是工作多年、经验丰富的人，抑或是技术管理人员，都能从本书中收获良多。

2013 年的「搞笑诺贝尔奖」中提到屎壳郎在迷路时能够利用银河导航。即使我们的工作是在维护「屎山」（Shit Mountain），也请不要忘记时时仰望星空……

Micro Focus 架构师

陈萍

2019 年 7 月

## 前言

我有一个梦想，我写的代码，可以像诗歌一样优美。

我有一个梦想，我做的设计，能恰到好处，既不过度，也无不足。

这种带有一点洁癖的完美主义就像一把达摩克利斯之剑，时刻提醒我不能将就、不能妥协。

完美主义的代价使我在很长时间持续地迷茫和焦虑，甚至一度感到失望和怀疑。在软件的世界里，到底有没有优雅的代码和整洁的架构呢？

每每看到「剪不断、理还乱」的代码，我都会感到懊恼和羞愧。懊恼的是，不知道如何能有效地治理混乱、控制复杂度；羞愧的是，我真的无能为力吗？

一边是无止境的业务需求，一边是补丁加补丁的业务代码，开发人员被夹在中间，像一只困兽，向左走，还是向右走？方向在哪里？我倍感困惑。就像 Robert C. Martin 说的：「不管你们有多敬业，加多少班，在面对烂系统时，你仍然会寸步难行，因为你大部分的精力不是在应对开发需求，而是在应对混乱。」

的确，软件是具有天然的复杂性的，而且不可能彻底地消除这种复杂性。不甘于向复杂度屈服的我们，花了很多时间研究复杂性的根源，随着对复杂性理解的不断深入，我们发现造成软件复杂性的主要因素如下。

1、软件的本质复杂性。《人月神话》的作者 Frederick P. Brooks. Jr 曾说：「软件的复杂性是一个基本特征，而不是偶然如此。」问题域有其复杂性，而软件在实现过程中又有很大的灵活性和抽象性，导致软件具有天然的复杂性。

2、缺少技艺。「写代码」作为一种技能，入门并不是很难。但是要像高手那样优雅地「写好代码」并不是一件容易的事，需要持续地学习和实践。

3、糟糕的技术氛围。在一个技术团队中，如果技术 Leader 只在乎分配给员工的任务有没有按时实现，从来不关心代码的质量好坏，又怎能指望团队写出「干净的代码」？

4、教条和妥协。我们可能不得已在不恰当的场景使用了不恰当的解决方案，造成了不必要的复杂性。我们向自己妥协、向产品经理妥协、向工期妥协、向技术债妥协，总有很多借口把设计糟糕、混乱丑陋的代码发布上线。

念念不忘，必有回响；不忘初心，方得始终。经过不懈的努力，我们的坚持和努力终于在 2018 年有了一些阶段性的成果，我们找到了一些切实可行的控制复杂度的办法，并沉淀了整洁面向对象分层架构（Clean Object-oriented and Layered Architecture ，COLA）。

COLA[1] 的诞生给了我们很大的鼓舞和希望，就像是在茫茫大海上漂流，终于看到了彼岸的灯塔。

在 COLA 日趋成熟之际，我迫不及待地想要将这些发现和应用整理分享出来。在探索复杂度治理的相关工作和研究中，我不止一次地感叹如果能更早地了解这些知识、掌握这些方法该有多好，这样就能避免很多不必要的焦虑，少做有缺陷的设计，少写丑陋的代码了。相信你在看完本书后也会有同样的感受，因为我相信对代码的极致追求是每个技术人员的基本动力和诉求。我们都知道「写出好代码」是比「写出代码」要难得多的要求，一个程序员的「美德」就在于他是否能为后人留下一段看得懂、可维护性好的代码。

写好代码的技艺不是一蹴而就的，它是一个系统化的工程，不是看几本书、写几年代码就能轻松习得的，而需要我们对自己的思维习惯、学习方法和工程实践进行彻底的反省和重构。本书记录了一个普通码农如何通过认知升级、知识重构、持续学习，继而转向工匠的过程。作为一个技术人，我有义务将这个过程分享出来，以期给同样在路上的你带来一些启发，缩短你「从码农到工匠」的探索路径。

由于认知水平有限，本书的很多观点可能只是一家之言，因此我更希望读者带着批判的眼光来看这本书，取其精华，并对有疑问的地方提出质疑和见解。

灵活性和没有银弹（Silver Bullet），也是软件行业的有趣之处。在这个行业里，一个问题会有很多种解法，即使是最简单的函数也至少可以写出 10 种不同的代码来实现。因此，知识储备、判断力和思辨力是软件行业给我们提出的更高要求，任何不区分上下文和情景的教条都有可能在实施过程中遭遇惨败。我真诚地期待读者对书中的内容进行批评和指正，如果你对本书或者 COLA 架构有任何想法和意见，都可以通过下面的微信公众号来联系我。

软件设计不仅是「技术」（Technique），更是一门「技艺」（Craftsmanship）。要想控制复杂度，防止系统腐化，我们不能只满足做一个搬砖的「码农」，而是要坚持自己的技术梦想和技术信仰，怀有一颗「匠人」之心，保持专注、持续学习，每天进步一点点。唯有如此，我们才有可能「从码农走向工匠」！

## 本书的结构

本书共分为三大部分：技艺部分、思想部分和实践部分。

技艺部分（第 1-7 章）

这部分详细介绍了一些实用的编程技巧和方法论，并配以详尽的代码案例。掌握这些方法论可以有效地提高我们的编程素养，培养更好的编程习惯，写出更好的程序。

第 1 章，命名。好的命名可以极大地提升代码可读性和可理解性，本章主要介绍命名的重要性、命名要注意什么，以及我们如何对不同的软件构建（Artifact）进行命名。

第 2 章，规范。在 Google 的代码审查（Code Review）实践中，代码是否符合规范（Norms）是最重要的检查项。在本章中，我们将了解必需的规范、如何制定规范，以及如何贯彻实施规范。

第 3 章，函数。有时即使你不采用任何面向对象（Object Oriented，OO）技术，只把函数写好，代码也会呈现完全不一样的风貌。本章介绍许多写函数的技巧和方法，非常实用。

第 4 章，设计原则。本章介绍了很多前人总结的优秀设计原则，包括最著名的 SOLID，它为我们提供了非常好的 OO 设计指导原则，比如扩展性的终极目标是满足 OCP。我个人特别推崇 DIP，因为它是架构设计的重要指导原则。

第 5 章，设计模式。好的设计模式能够使代码具有恰到好处的灵活性和优雅性，工程师之间的沟通也会变得简单。本章没有详细介绍 GoF 中的全部 24 种模式，只重点介绍几个日常使用频率高、实用性强的设计模式。

第 6 章，模型。软件工程就是一个对现实世界的问题进行分析、抽象、建模，然后转换成计算机可以理解的语言，解释执行，实现特定业务逻辑的过程。本章主要介绍了什么是模型、软件工程中常见的建模方法论，以及如何运用这些模型为软件服务。

第 7 章，DDD 的精髓。领域建模是面向对象技术的精髓，本章的主要思想都来自于领域驱动设计（Domain Driven Design，DDD），但是并没有教条地照搬，而是结合实践对 DDD 进行了改良、萃取和优化。

思想部分（第 8-11 章）

思想是比技艺更高层次的能力要求，如果说技艺是「术」，那么思想就是「道」，领悟这些道理，对我们的职业发展会大有裨益。

第 8 章，抽象。抽象能力是工程师需要的核心能力之一。本章介绍了什么是抽象、抽象的层次性、如何进行抽象，以及如何培养结构化思维和抽象思维。

第 9 章，分治。分治思想的伟大之处在于，我们可以将一个很复杂的问题域分解成多个相对独立的子问题，再各个击破。分治思想在软件领域可谓是无处不在。

第 10 章，技术人的素养。做一个优秀的工程师不容易，然而还是有一些特质是值得我们学习的。本章主要介绍了技术人应该具备的一些素养，以及如何培养这些素养。

第 11 章，技术 Leader 的修养。一个优秀的工程师不一定是一个好的技术 Leader，一个技术 Leader 在很大程度上决定了团队的技术味道和技术追求。在本章中，我会介绍自己在技术管理上的一些心得。

实践部分（第 12、13 章）

「Talk is cheap, show me the code」，一本没有实战的技术书是难以服众的。如果说思想是务虚的最高境界，那么实践就是务实的最低要求。

第 12 章，COLA 架构。本章主要介绍了什么是架构，重点介绍 COLA 架构及其背后的设计理念和设计原理。

第 13 章，工匠平台。本章通过 COLA 架构在工匠平台实际业务场景中的落地，介绍如何使用 COLA 来搭建一个完整的应用架构，以及如何通过领域建模来实现业务逻辑。

## 本书特色

本书的特色之处在于「虚实结合」—— 既重视思想，又兼顾实践。

所谓思想，是我们分析和解决问题所需要的底层能力。我利用大量篇幅介绍了抽象、批判思维、辩证思维，以及程序员的素养等。思想是我们构建技术大厦的底层基石，是我们必须要掌握的底层能力，它超越了软件行业的范畴，是一种哲学和世界观。

实践即 COLA 架构。这不仅是一本技术书，也是开源框架 COLA 的技术指导手册。到目前为止，我还没有看到比 COLA 更轻量、更简洁、可直接应用到生产系统中的应用框架。看完本书，相信你会对 COLA，以及如何应用 COLA 进行应用架构和复杂性治理有一个全面的了解。

## 本书面向的读者

本书的目标读者是专业程序员。无论你使用哪种编程语言、从事哪个岗位的工作，写好代码、追求卓越和工匠精神是每个程序员都应该具备的优秀品质。

本书最适合的读者是具有一定经验、从事以 Java 语言为主的业务应用开发人员，主要有以下两个原因。

首先，书中所有的示例和讨论都是基于 Java 语言编写的。熟悉 Java 语言和面向对象技术，能够更好地理解本书内容，尤其是第 5 章和第 6 章，以及思想部分的内容。

其次，COLA 是面向业务应用的框架，第 13 章的实战也是一个基于 COLA 和 Spring Boot 的业务项目，因此更适用于具有一定工作经验、从事业务开发的读者。

最后，我想特别对以下不同类型的读者说几句话。

新程序员：如果你是在校生或初入职场的新人，在追求技术宽度的同时，请一定要养成「写好代码」的习惯。充分利用这本书，写好代码，能让你站在一个更高的起点上。

资深程序员：职场的资深人士能够选择本书，说明你和我一样，还怀有一颗「不安分」的心。「种一棵树最好的时间是十年前，其次是现在」，在追求卓越的路上，我们都没有迟到，现在上路还不晚。更何况，我们多年来一直在坚持写代码，这本身就是一种胜利！

架构师：熟悉我的人都知道，我不赞成在业务团队设置专门的架构岗位，因为我认为架构是一种能力，而不是职位。如果恰巧，你就在这样的岗位上，那么请一定不要画完架构图就算完成工作，要深入代码细节中去，这样才能发现设计中存在的问题，赢得程序员的尊重。如果你对技艺部分已经比较熟悉，建议重点阅读思想部分和实践部分。

技术团队管理者：管理者的一个很重要的使命就是帮助团队成长，包括制定规范和技术传承。倘若你和我一样，不仅仅把自己定位为一个「管理者」，那么请重点阅读第 11 章。

[1] COLA 的开源地址是 [alibaba/COLA: Clean Object-oriented & Layered Architecture](https://github.com/alibaba/COLA)。

## 资源与支持

本书由异步社区出品，[异步社区-致力于优质 IT 知识的出版和分享](https://www.epubit.com/)，为您提供相关资源和后续服务。

配套资源：本书源代码请到前言中提到的 GitHub 开源地址中获取。

提交勘误：

作者和编辑尽最大努力来确保书中内容的准确性，但难免会存在疏漏。欢迎您将发现的问题反馈给我们，帮助我们提升图书的质量。

当您发现错误时，请登录异步社区，按书名搜索，进入本书页面，点击「提交勘误」，输入勘误信息，单击「提交」按钮即可。本书的作者和编辑会对您提交的勘误进行审核，确认并接受后，您将获赠异步社区的 100 积分。积分可用于在异步社区兑换优惠券、样书或奖品。

与我们联系：

我们的联系邮箱是 contact@epubit.com.cn。如果您对本书有任何疑问或建议，请您发邮件给我们，并请在邮件标题中注明本书书名，以便我们更高效地做出反馈。

如果您有兴趣出版图书、录制教学视频，或者参与图书翻译、技术审校等工作，可以发邮件给我们；有意出版图书的作者也可以到异步社区在线提交投稿（直接访问 www.epubit.com/selfpublish/submission 即可）。

如果您所在的学校、培训机构或企业，想批量购买本书或异步社区出版的其他图书，也可以发邮件给我们。

如果您在网上发现有针对异步社区出品图书的各种形式的盗版行为，包括对图书全部或部分内容的非授权传播，请您将怀疑有侵权行为的链接发邮件给我们。您的这一举动是对作者权益的保护，也是我们持续为您提供有价值的内容的动力之源。

关于异步社区和异步图书：

「 异步社区」是人民邮电出版社旗下 IT 专业图书社区，致力于出版精品 IT 技术图书和相关学习产品，为作译者提供优质出版服务。异步社区创办于 2015 年 8 月，提供大量精品 IT 技术图书和电子书，以及高品质技术文章和视频课程。更多详情请访问异步社区官网 https://www.epubit.com。

「 异步图书」是由异步社区编辑团队策划出版的精品 IT 专业图书的品牌，依托于人民邮电出版社近 30 年的计算机图书出版积累和专业编辑团队，相关图书在封面上印有异步图书的 LOGO。异步图书的出版领域包括软件开发、大数据、AI、测试、前端、网络技术等。
