## 记忆时间

## 第三部分 大写的计算 

计算机科学的真义 [145] 是在自然界中无处不在的大写的计算。

—— 朗顿（Chris Langton），引自勒温（Roger Lewin）的 《复杂性：混沌边缘的生命》 （Complexity：Life at the Edge of Chaos）

1001 元胞自动机、生命和宇宙

1101 粒子计算

1201 生命系统中的信息处理

1301 如何进行类比

1401 计算机模型

## 1001. 元胞自动机、生命和宇宙

### 10.1 自然界中的计算

《科学》杂志不久前出版了一篇文章，[146] 题为《社会性昆虫行为的计算》（Getting the Behavior of Social Insects to Compute），文中介绍了一些昆虫学家的工作，他们将蚂蚁群体的行为等同于「计算机算法」，每只蚂蚁都执行简单的程序，使得整个种群作为一个整体执行复杂的计算，比如在决定何时将巢穴搬往何地的问题上形成一致。

如果有一只蚂蚁来领导和决策，很容易就能在计算机上编出程序来进行计算。其他蚂蚁只需按照领导者的决策来做就行了。然而，在前面我们已经看到，在蚂蚁群体中没有领导者；蚁群「计算机」由数百万只自主的蚂蚁组成，每只蚂蚁都只是根据与一小部分蚂蚁的交互来进行决策和行动。这种计算与具有 CPU 和内存的普通电脑进行的计算差别很大。

与此类似，1994 年三位杰出的大脑科学家也写了一篇文章，「大脑是计算机吗？」[147] 他们认为，「如果我们同意接受更宽泛的计算概念，答案就一定是是。」同蚁群一样，大脑的计算方式 —— 数以亿计的神经元并行工作，而无须中央控制 —— 也与现代的数字计算机的运作方式完全不同。

在前两章我们探讨了计算机中的生命和进化。在这一部分，我们来看看相对的思想，以及计算在自然界中的广泛存在。自然系统的「计算」指的是什么呢？大致上说，计算是复杂系统为了成功适应环境而对信息的处理。但是这样的说法还能更精确些吗？信息在哪里？复杂系统又是如何处理信息的？ 

为了让这类问题更易于研究，科学家们通常会将问题理想化 —— 也就是尽可能简化，但仍然保留问题的主要特征。鉴于此，许多人都用元胞自动机这种理想化的复杂系统模型来研究自然界中的计算。

### 10.2 元胞自动机

在第 4 章曾讲过，图灵机将「明确程序」—— 也就是计算 —— 的概念进行了形式化。计算就是图灵机根据机器的规则集将带子上的初始输入转换成停机时带子上的输出。这个抽象的机器就是后来所有数字计算机的设计原型。由于冯·诺依曼对计算机设计作出的贡献，现在的计算机架构被称为「冯·诺依曼体系结构」。

冯·诺依曼体系结构包括存储数据和程序指令的随机存取存储器（RAM）、从存储器存取指令和数据并执行指令处理数据的中央处理单元（CPU）。你可能知道，虽然程序员们编程时使用的是高级语言，存储在计算机中的指令和数据却是 0/1 组成的串。执行指令就是将这种 0/1 码译成基本的逻辑操作让 CPU 执行。只需要几种基本的逻辑操作就能实现所有计算，现代 CPU 每秒能执行数亿次这样的逻辑操作。

元胞自动机是理想化的复杂系统，结构完全不同于计算机。想象一块板子上排列着许多灯泡（图 10.1），每个灯泡与四周以及斜对角的灯泡连在一起。在图中只画了其中一个灯泡的连接线，不过姑且想象所有灯泡都有连接线。

图 10.1 排列的灯泡，每个都与四周以及对角的灯泡相连，图中画了一个灯泡的连线作为示范。灯泡的状态可以是亮和灭。假设边沿是回绕连在一起，也就是认为最左边的与最右边的灯泡相邻，最下面的与最上面的灯泡相邻，等等 

图 10.2 中（左边的盒子），有些灯泡已经点亮（为了简洁，我没有画灯泡的连线）。先设定好灯泡的开关状态，然后各个灯泡开始不断定时「更新状态」—— 选择开或关，所有灯泡都同步变化。你可以将这个灯泡阵看做萤火虫发光的模型，每只萤火虫都根据周围萤火虫的闪灭来调整自己是亮还是灭；也可以看做神经元的激发模型，各个神经元受周围神经元的状态激发或抑制；或者就当做抽象艺术也行，如果你愿意的话。

图 10.2 左：灯泡阵列的初始状态，没有画灯泡之间的连线。右：变化一次之后的状态，规则是「采用邻域占多数的状态」

灯泡每一步如何「决定」是开还是关呢？它们都遵循一些规则，根据邻域内灯泡的状态 —— 也就是相邻的 8 个灯泡和它自己的状态 —— 来决定下一步的状态（是开还是关）。

例如，规则可以是这样：「如果邻域内的灯泡（包括自己）点亮的超过一半，就点亮（如果本来就是亮的，则不变），否则就熄灭（如果本来就是灭的，则不变）。」也就是说，邻域中 9 个灯泡，如果有 5 个或 5 个以上是亮的，中间的灯泡下一步就是亮的。我们来看看灯泡阵列下一步会怎么变。

图 10.1 的文字中说了，为了让每个灯泡都有 8 个邻居，阵列的四边是回绕相连的。可以想象成上边和下边合到一起，左边和右边合到一起，形成一个面包圈形状。这样每个灯泡就都有 8 个邻居。现在再来看上面给出的规则。图 10.2 是初始设置和变化一次后的状态。也可以使用更复杂的规则，例如，「如果邻域中点亮的灯泡不少于 2 个，不多于 7 个，就点亮，否则就熄灭」，这样阵列的变化就会不一样。或者这样，「如果刚好 1 个灯泡是灭的，或者 4 个是亮的，就点亮，否则就熄灭」。可能的规则很多。

到底有多少种可能的规则呢？说「很多」还太保守了。答案是「2 的 512 次幂」，（2^512） [148] 这个数字很大，比宇宙中的原子数量还大许多倍。（注释中有答案的推导过程。） 这个灯泡阵列其实就是一个元胞自动机。元胞自动机是由元胞组成的网格，每个元胞都根据邻域的状态来选择开或关。（广义上，元胞的状态可以随便定多少种，但是这里我们只讨论开 / 关状态。）所有的元胞遵循同样的规则，也称为元胞的更新规则，规则根据各元胞邻域的当前状态决定元胞的下一步状态。

为什么说这么简单的系统会是复杂系统的理想化模型呢？同自然界的复杂系统一样，元胞自动机也是由大量简单个体（元胞）组成，不存在中央控制，每个个体都只与少量其他个体交互。而且元胞自动机也能表现出非常复杂的行为，它们的行为很难甚至不可能通过其更新规则来预测。

同其他许多精彩的思想一样，元胞自动机也是由冯·诺依曼发明的，他在 20 世纪 40 年代受他的一位同事 —— 数学家乌拉姆 —— 的启发提出了这个思想。（为了与冯·诺依曼体系结构相区别，元胞自动机经常被称为非冯·诺依曼体系结构，这是计算机科学的一大笑话。）第 8 章说过，冯·诺依曼想要将自我复制机器的逻辑形式化，而他用来研究这个问题的工具就是元胞自动机。简单地说，他设计了一种元胞自动机规则，能完美复制任意元胞自动机的初始形态，他的规则中元胞不止两种状态，而是 29 种。

冯·诺依曼还证明他的元胞自动机等价于通用图灵机（参见第 4 章）。元胞的更新规则扮演了图灵机读写头的规则的角色，而元胞阵列的状态则相当于图灵机的带子 —— 也就是说，它可以编码通用图灵机运行的程序和数据。元胞一步一步的更新相当于通用图灵机一步一步的迭代。能力等价于通用图灵机的系统（也就是说，通用图灵机能做的，它也能做）被称为通用计算机，或者说能进行通用计算。

### 10.3 生命游戏

冯·诺依曼的元胞自动机规则相当复杂。1970 年，数学家康威（John Conway）发现了一种简单得多的两状态通用图灵机，也能进行通用计算。他称之为「生命游戏」。[149] 我不知道为什么叫做「游戏」，只知道「生命」来自于康威对其规则的解释。将状态为开的元胞看做活的，状态为关的元胞看做死的。康威用四种生命过程来定义规则：1）出生，死元胞的相邻元胞中如果刚好有 3 个是活的，下一步就变成活的；2）存活，活元胞的相邻元胞有 2-3 个是活的，下一步就能继续存活；3）过于稀疏，活元胞的相邻活元胞如果少于 2 个就会死去；4）过度拥挤，活元胞的相邻活元胞如果多于 3 个就会死去。

康威当时是想寻找一个能产生类似生命的元胞自动机。出人意料的是，生命游戏的行为丰富而有趣，以至于现在出现了一个爱好者团体，他们的主要兴趣就是发现能产生有趣行为的初始设置。图 10.3 就是其中一个有趣的行为，被称为滑翔机 。这里我们不再用灯泡，就用黑格子表示开（活），用白格子表示关（死）。图 10.3 中可以看到有一个滑翔机向东南方向移动。当然，元胞并没有动，它们都是固定的。移动的是由活状态元胞形成的一个不消散的形状。因为元胞自动机的边界是回绕相连的，所以滑翔机能一直移动。爱好者们还发现了其他复杂的形状，例如太空船，它类似于滑翔机，而且更有趣；滑翔机发射器，它会不断射出新的滑翔机。康威证明，通过用变化的开 / 关状态模拟读写头在带子上的读写，就能让生命游戏模拟图灵机。

图 10.3 生命游戏中滑翔机的一个循环变化。滑翔机形状每 4 步向东南方向移动一格

康威还给出了生命游戏模拟通用计算机的证明框架 [150] （后来由其他人细化）。[151] 将程序和输入数据编码为开关状态初始设置，生命游戏运行后产生的图样表示程序的输出。康威在证明中组合使用滑翔机发射器、滑翔机等结构来实现与、或、非等逻辑运算。人们早已发现，能用各种可能来组合这些逻辑操作的机器就能进行通用计算。康威的证明表明，原则上，逻辑运算的所有可能组合都能在生命游戏中实现。

像生命游戏这么简单的元胞自动机在原则上能运行标准计算机运行的程序，这真是让人吃惊。不过，实际上，稍微复杂一点的计算就需要大量逻辑运算，并以各种方式相互作用，因此要设计出能实现复杂计算的初始设置基本不太可能。即使设计得出来，计算也会慢得让人无法忍受，更不要说用这种并行的非冯·诺依曼结构的元胞自动机来模拟传统冯·诺依曼结构计算机需要耗费的大量资源。因此没有人用生命游戏（或其他「通用」元胞自动机）来进行真实计算或是模拟自然系统。我们只是想利用元胞自动机的并行特征以及它产生复杂图形的能力。下面先来看看元胞自动机能够产生的图形种类。

### 10.4 四类元胞机

20 世纪 80 年代初，普林斯顿高等研究院的物理学家沃尔夫勒姆对元胞机着了迷。沃尔夫勒姆（图 10.4）是传奇般的天才人物。他 1959 年生于伦敦，15 岁就发表了他的第一篇物理学论文。两年后，在牛津大学一年级的暑假，大部分人这时候都会去打工挣钱，或是背着背包搭顺风车周游欧洲，沃尔夫勒姆却写了一篇关于「量子色动力学」的论文，这篇论文被诺贝尔奖获得者物理学家盖尔曼注意到，他邀请沃尔夫勒姆加入他在加州理工的研究小组。两年后，沃尔夫勒姆获得了理论物理博士学位，而这时他才 20 岁（大部分人大学毕业后至少需要 5 年才能获得博士学位）。他留在加州理工任教，此后不久又获得了第一届麦克阿瑟天才奖。两年后，他受邀加入普林斯顿高等研究院。真是让人叹为观止。他有了名气，又有资金支持，可以想干什么就干什么，他决定研究元胞自动机动力学。

图 10.4 沃尔夫勒姆（照片由沃尔夫勒姆研究公司提供，WolframResearch，Inc.） 

根据理论物理学的惯例，沃尔夫勒姆从元胞自动机最简单的形式来研究其行为，他用的是一维两状态的元胞自动机，每个元胞仅与两个相邻元胞相连（图 10.5 a）。沃尔夫勒姆称之为「初等兀胞自动机」（elementary cellular automata）。他认为，如果这种看上去极为简单的系统也理解不了，就更不可能理解更复杂的（例如，两维或多状态的）元胞自动机。

图 10.5 描绘了一个初等元胞自动机的规则。图 10.5（a）是元胞格子 —— 一排元胞，每个都与两侧相邻的元胞相连。这里仍然是用方格表示元胞 —— 黑表示开，白表示关。两头的格子回绕连在一起，形成一个环。图 10.5（b）是元胞遵循的规则：3 个相邻元胞总共有 8 种可能状态组合，对于每种状态组合都给出了中间元胞的更新状态。例如，当 3 个元胞都是关状态时，中间元胞下一步就是关状态。同样，当 3 个元胞的状态为关一关一开时，中间元胞下一步就会变成开状态。这里规则指的是整个状态组合和更新状态的表，而不仅仅是表中的一行。图 10.5（c）展示了这个元胞自动机的时空图。最顶上一行是一维元胞机的初始状态设置。下面跟着的依次是每一步更新后的状态。这种图被称为时空图，因为它表现了元胞自动机的立体构型随时间的变化。

图 10.5（a）一维元胞自动机，两端回绕形成一个环；（b）初等元胞自动机的一种规则（规则 110），表示 3 个元胞的状态组合以及对应的中间元胞下一步的状态！（c）时空图，显示了元胞自动机的 4 步变化

3 个元胞有 8 种可能的状态组合（见图 10.5 b），而每种可能的状态组合又有两种可能的元胞更新状态，因此初等元胞自动机总共有 256（2^8）种可能的规则。20 世纪 80 年代时，计算机的性能已经足以让沃尔夫勒姆对这些规则逐个进行研究，设定各种初始状态，然后观察它们的变化。沃尔夫勒姆给初等元胞自动机的规则都编了号，编号方法见图 10.6。他将开状态记为「1」，关状态记为「0」，根据更新状态将规则记为 0/1 串，最前面一位对应 3 个元胞都为开时的更新状态，最后一位则对应 3 个元胞都为关时的更新状态。这样图 10.5 中的规则就记为 01101110。然后沃尔夫勒姆将这个 0/1 串当做二进制数。01101110 作为二进制数等于十进制数 110。因此这个规则就叫做「规则 110」。如果更新状态是 00011110，则为「规则 30」。（注释中介绍了如何将二进制数转换为十进制数。） [152]

图 10.6 沃尔夫勒姆使用的初等元胞自动机命名系统 

沃尔夫勒姆和他的同事开发了一种专门的计算机语言 —— Matliematica —— 用来简化元胞自动机的模拟。沃尔夫勒姆用 Matliematica 编程运行元胞自动机，并绘制它们的时空图。例如，图 10.7 和图 10.8 与图 10.5 类似，只是规模大些。图 10.7 中有 200 个元胞，初始状态随机设置，应用的更新规则是 110，逐行往下更新了 200 时间步。图 10.8 应用的则是规则 30，也是从随机初始状态开始。

图 10.7 规则 110 的时空图。这个一维元胞自动机有 200 个元胞，图中是从随机初始状态开始，200 步的变化情况 

看着图 10.7 和图 10.8，也许你会理解为什么沃尔夫勒姆会对初等元胞自动机这么着迷。这种极为简单的元胞自动机规则究竟是如何产生出如此复杂的图样的呢？ 对沃尔夫勒姆来说，简单的规则涌现出如此的复杂性，这简直就是神迹。他后来说，「规则 30 自动机是我在科学中所遇到的最让人惊异的事物…… [153] 我花了几年时间来理解它的重要性。最后，我意识到这幅图包含了所有科学长久以来的一个谜团的线索：自然界的复杂性到底从何而来。」沃尔夫勒姆对规则 30 印象非常深刻，[154] 以至于他用其来构造伪随机数发生器，并申请了专利。

图 10.8 规则 30 的时空图，从随机初始状态开始运行

沃尔夫勒姆对全部 256 种初等元胞自动机进行了彻底研究，从各种不同的初始状态开始，观察它们的变化。他让元胞自动机运行较长一段时间，直至元胞自动机的变化稳定下来。他发现最后都进入了 4 种类型的变化情况： 

类型 1 ：不管初始状态如何，最后几乎都停止在不变的最终图样。规则；就是一个例子，不管初始状态如何，所有元胞很快就都变成了关状态，不再变化。

类型 2 ：不管初始状态如何，最后要么停止在不变的图样，要么在几个图样之间循环。具体的最终图样依赖于初始状态。

类型 3 ：大部分初始状态会产生看似随机的行为，虽然也会出现三角形等规则结构。规则 30（图 10.8）就属于这一类。

类型 4 ：最有趣的类型。沃尔夫勒姆这样描述：「类型 4 是有序与随机的混合： [155] 局部结构相当简单，但是这些结构会移动，并以非常复杂的方式相互作用。」规则 110（图 10.7）就属于这一类。

沃尔夫勒姆猜想，由于图样和相互作用的复杂性，类型 4 的所有规则都能进行通用计算。不过很难证明某个具体的元胞自动机、图灵机或其他机器是通用的。图灵证明的只是存在通用图灵机，冯·诺依曼也只是证明自复制自动机同时也是通用计算机。后来有几位科学家证明了简单的元胞自动机（比如生命游戏）是通用的。20 世纪 90 年代，沃尔夫勒姆的一位研究助手库克（Matthew Cook）最终证明了规则 110 的确是通用的 [156] ，这也许是目前已知的最简单的通用计算机。

### 10.5 沃尔夫勒姆的「新科学」

1998 年，库克在圣塔菲研究所的一次会议上作报告，我第一次知道了他的结果。我当时的反应同我的大多数同事差不多，「太酷了！太巧妙了！不过没有什么实际或科学意义。」和生命游戏一样，规则 110 也是极为简单的确定性系统产生出无法预测的复杂行为的例子。但在实际中很难设置一个初始状态来产生出所希望的复杂计算。而且规则 110 会比生命游戏更慢。

沃尔夫勒姆对这个结果的看法完全不同。在 2002 年出版的《一种新科学》（A New Kind of Science）中，沃尔夫勒姆将规则 110 的通用性视为「新的自然定律」[157] —— 他提出的计算等价性原理（Principle of Computational Equivalence）—— 的有力证据。

沃尔夫勒姆提出的这个原理包括 4 部分： 

1、思考自然界中的过程的正确方法是将它们视为计算 。

2、像规则 110 这样极为简单的规则（或「程序」）都能进行通用计算，这表明通用计算的能力在自然界中广泛存在。

3、通用计算是自然界中计算的复杂性的上限。也就是说，自然系统或过程不可能产生出「不可计算」的行为。

4、自然界中各种过程实现的计算在复杂程度上都几乎等价。

明白了没有？我必须承认，很难解释清楚这个原理的意思，沃尔夫勒姆这本 1200 页的鸿篇巨著，一个主要目的就是阐释这个原理，并说明它如何适用于各个科学领域。我通读了这本书，但还是没有完全明白沃尔夫勒姆的意思。不过我还是尽力解释一下。

沃尔夫勒姆说的「自然界中的过程就是计算」指的是类似于图 10.7 和图 10.8 中的某种东西。在任意给定时刻，元胞自动机都在通过将其规则应用于其当前状态来处理信息。沃尔夫勒姆认为，自然系统正是以这样的方式运作 —— 它们包含信息，并根据简单规则处理这些信息。在《一种新科学》中，沃尔夫勒姆探讨了量子力学、进化和发育生物学、经济等领域，他想说明这些领域都能描述为使用简单规则进行的计算。本质上，他的「新科学」指的是这样的思想，宇宙和其中的万事万物都能用这种简单的程序进行解释。这就是大写的计算，非常大。因此，根据沃尔夫勒姆的观点，既然规则 110 这样极度简单的规则都能支持通用计算，那大部分自然系统 —— 基本上应该都比规则 110 复杂 —— 也就能支持通用计算。

而且沃尔夫勒姆相信，给定正确的输入，没有比通用计算机所能进行的计算更复杂的计算。因此这就是自然界中所有可能计算的复杂性的上限。第 4 章曾说过，图灵证明了通用计算机原则上能计算一切「可计算」的东西。但是一些计算要比其他的更简单。虽然都能在同样的计算机上运行，「计算 1+1」的程序肯定没有模拟地球气候的程序复杂，对吧？但沃尔夫勒姆的原理却说，实际进行的所有计算的「复杂程度」本质上都是等价的。这到底是什么意思呢？沃尔夫勒姆的理论还没有被广泛接受。这里我将给出我自己的意见。

对于前两点，我认为沃尔夫勒姆提出的简单的计算机模型和实验能解释科学中许多过程的观点是正确的，这本书中的例子也证明了这一点。在第 12 章我还会讲到，我认为可以用信息处理解释许多自然系统的行为。我也发现许多这样的系统似乎的确能支持通用计算，虽然这一点的科学意义目前还不得而知。

至于第 3 点，目前也无法知道是否自然界中存在比通用计算机更强大的过程（能计算「不可计算的」东西）。现在已经证明，如果能建造出真正的非数字计算机（能计算具有无穷位小数的数字），你就能用其来解决停机问题 [158] —— 我们在第 4 章看到的图灵不可计算问题。一些人，包括沃尔夫勒姆，不相信自然界真的存在无穷小数 —— 也就是说，他们认为大自然本质上是数字的。两边都没有真正令人信服的证据。

第 4 点对我来说没有意义。我认为很有可能我的大脑支持通用计算（至少在我有限的记忆容量允许的范围内），而线虫的脑也（基本上）是通用的，但我不认为我们进行的计算在复杂程度上是等价的。沃尔夫勒姆走得更远，他认为存在一个简单的类似元胞自动机的规则可以作为「宇宙的终极确定性模型」[159] ，这个原初元胞自动机的计算是存在的万事万物的源头。

这个规则有多长呢？沃尔夫勒姆说，「我猜其实相当短。」[160] 但是到底多长呢？「我不知道。也许三四行 Mathematica 程序。」小写的计算。

《新科学》在 2002 年出版后引起了轰动 —— 很快就位居亚马逊网站的畅销书榜首，并在之后很久都留在畅销书榜中。沃尔夫勒姆为了这本书的出版成立了沃尔夫勒姆媒体公司（Wolfram Media），书出版后这家公司进行了大规模的宣传活动。对这本书的看法分成两个极端：一些读者认为这本书棒极了，是革命性的；另一些人认为这本书盲目自大，缺乏实质和原创性。例如，批评者指出物理学家祖斯（Konrad Zuse）和弗瑞德金（Edward Fredkin）早在 20 世纪 60 年代就提出了宇宙是元胞自动机的理论 [161]。不管怎样，我们这些元胞自动机的爱好者都认为，《新科学》至少很好地宣传了元胞自动机。

### 1101. 粒子计算 [162]

1989 年我偶然读到物理学家帕卡德（Norman Packard）的一篇文章，[163] 写的是用遗传算法设计元胞自动机规则。我一下就被吸引住了，想自己也试试。当时因为繁忙，无暇顾及（我在写博士论文），但这个想法一直留在我的脑海里。几年后，论文完成了，我也在圣塔菲研究所找到了职位，终于可以有时间深入研究这个问题了。有个叫赫拉贝尔（Peter Hraber）的本科生当时在研究所逗留，想找点事情做，我就把他招进来协助我研究这个课题。很快一个叫达斯（Rajarshi Das）的研究生也加入我们，他当时在独立研究类似的课题。

类似于帕卡德的思想，我们想用遗传算法演化出能执行所谓的「多数分类」（majority classification）[164] 任务的元胞自动机规则。这个任务很简单：元胞自动机要能区分初始状态中是「开」状态还是「关」状态占多数。如果是开状态占多数，最后所有元胞就应当都变成开状态。

同样，如果是关状态占多数，最后所有元胞就应当都变成关状态。（如果初始状态中开状态和关状态的数量一样多，就没有答案，但是可以让元胞的数量为奇数来避免这种可能。）多数分类任务有点类似于选举，是在大家都只知道最近邻居政治观点的情况下预测两个候选人谁会赢。多数分类问题对冯·诺依曼结构的计算机而言是小菜一碟。CPU 只需要分别对初始状态中的开状态和关状态进行计数，同时在内存中记录计数值就可以了。计数结束后，从内存中读取数值进行比较，然后根据结果将元胞状态都设成开或关 。冯·诺依曼结构的计算机可以轻松实现这个工作，因为它有随机存取存储器可以存储初始状态和中间值，还有中央处理器可以计数，进行最后的比较，以及将状态重设。

而元胞自动机则没有 CPU 和内存可以用来计数。它只有一个一个的元胞，每个元胞除了自己的状态就只知道相邻元胞的状态。这种情形其实也是对许多实际系统的理想化。例如，在大脑中，神经元只与其他少数神经元有连接，而神经元必须决定是否激发，以及以何种强度激发，使得大量神经元的整体激发模式能表示特定的感知输入。类似的，第 12 章我们还会看到，蚂蚁必须根据与其他少量蚂蚁的交互来决定做什么事情，让蚁群整体能够受益。因此，基本上很难设计出让所有元胞能协同决策的元胞自动机。赫拉贝尔和我想知道遗传算法是不是能解决这个设计问题。

借鉴帕卡德的工作，我们使用一维元胞自动机，每个元胞与相邻的 6 个元胞相连，这样元胞的邻域中就有 7 个元胞（包括自己）。你可以先想一下如何给元胞自动机设计规则，让它能进行多数分类。一个合理的想法是：「元胞应当变成邻域中当前占多数的状态。」这就好像根据你自己和邻居的多数意见来预测哪个候选人会当选。然而，这个「局部多数投票」元胞自动机并不能完成任务，图 11.1 说明了这一点。初始状态中黑色元胞占多数，然后根据局部多数投票规则运行了 200 步。可以看到元胞自动机很快变成黑白区域相间，然后就不再变化。黑白区域的边界两边的元胞邻域分别是黑白占多数。最后的状态组合中既有黑色元胞也有白色元胞，没有得到想要的结果。其中的问题是，根据这个规则，区域之间无法相互交流信息，因此它们无法得知自己是否是多数。

这个规则的设计并不是那么显而易见，因此依照第 9 章的做法，我们用遗传算法来试一下是不是能产生出有用的规则。在遗传算法中元胞自动机规则被编码成 0/1 序列。每一位对应一种可能的邻域状态组合（图 11.2）。遗传算法的初始群体为随机产生的元胞自动机规则。为了计算规则的适应度，算法用各种初始状态组合进行测试。算法的适应度为产生出的最终状态正确的比例 —— 正确指的是如果初始开状态占多数，元胞就都为开 ，初始关状态占多数，元胞就都为关（图 11.3）。我们将遗传算法运行了许多代，最终算法设计出了一些表现得相当好的规则。

图 11.1「局部多数投票」元胞自动机的时空图，初始状态为黑色占多数（图片引自米歇尔、克鲁奇菲尔德和达斯的文章《演化执行计算的元胞自动机：最近的研究综述》，收录在《第一届进化计算及其应用国际会议文集》，俄罗斯科学院，1996 年） 

我们通过机器人罗比已经看到，遗传算法演化得出的结果往往无法在其「基因组」层面进行理解。我们在这里演化出的用于多数分类的元胞自动机也是一样。下面是遗传算法演化出的表现最好的基因组之一：

```
00000101000001100001010110000111000001110000010000010101010101110110010001110111000001010000000101111101111111111011011101111111 
```

第 1 位是邻域全为 0 时中间元胞的更新状态，第 2 位是邻域为 0000001 时中间元胞的更新状态，依次往后。由于邻域状态有 128 种可能，因此基因组有 128 位。但光看这些数位是看不出这个规则如何运作，也无法知道为何它进行多数分类时适应度很高。

图 11.2 元胞自动机编码为遗传算法个体的方法图示。128 种可能的邻域状态组合按固定顺序排列。各邻域状态组合对应的中心元胞更新状态编码为 0（关）和 1（开）。遗传算法中每个个体有 128 位，以固定顺序编码更新状态

图 11.4 给出了这个规则在两种不同初始状态下的行为：分别为 a）黑色元胞占多数，b）白色元胞占多数。可以看到在两种情形下最终行为都是正确的 —— a）变成了全黑，b）变成了全白。

在得到最终状态组合的过程中，元胞之间似乎在协同处理信息，以达到正确的最终状态。在这个过程中的图样很有意思，它们到底意味着什么呢？ 我们花了很多时间盯着图 11.4 这样的图看，想知道到底发生了什么。幸运的是，伯克利的物理学家克鲁奇菲尔德碰巧访问了圣塔菲研究所，并对此产生了兴趣。他和他的同事正好发展了合适的概念能帮助我们理解这些图样是如何完成计算的。

图 11.4 中有三种类型的图样：全黑、全白以及类似于棋盘格的黑白交替（图 11.4 分辨率较低，所以看上去像灰色）。正是这种棋盘格图样传递了局部区域黑白元胞密度的信息。

图 11.3 为了计算适应度，用各种随机初始状态对规则进行测试。适应度为规则在运行一定步数后产生出正确答案的比例 同遗传算法为机器人罗比演化的策略一样，这个元胞自动机的策略也相当聪明。图 11.5 是我对图 11.4（a）作的标记。大部分为黑色和大部分为白色的区域很快就变成了全黑和全白。注意当黑色区域在左边而白色区域在右边时，中间的分界线总是垂直的。

但如果白色区域在左边而黑色区域在右边，则会形成由黑白元胞相间组成的棋盘格图样三角形。如果把元胞自动机的两头回绕连在一起，就能看到三角形的环绕效果。棋盘格区域的 A 边和 B 边以同样的速度扩展（即向两边覆盖同样的宽度）。A 线向西南延伸，直到碰到垂直界线。B 线则刚好避开了从另一边与这条垂直界线相撞。这表明 A 线的延伸长度要短一些，也就是说，A 线左边的白色区域要小于 B 线右边的黑色区域。碰撞后，A 线消失了，而黑色区域则得以继续扩展。在三角形底部的角上，B 线和 C 线消失了，全部元胞格子都变成了黑色，从而得到了正确的状态组合。

图 11.4 演化出的表现最好的元胞自动机规则之一执行多数分类任务时的时空行为。在图（a）中，初始状态中黑色元胞占多数，元胞自动机迭代运行后全部变成了黑色。在图（b）中，初始状态中白色元胞占多数，元胞自动机迭代运行后全部变成了白色（图片引自米歇尔、克鲁奇菲尔德和达斯的文章《演化执行计算的元胞自动机：最近的研究综述》，收录在《第一届进化计算及其应用国际会议文集》，俄罗斯科学院，1996 年） 

如果我们将这些图样当做是进行计算，那么垂直界线和棋盘格区域就可以视为信号。这些信号通过元胞的局部互动而产生和传播。信号使得元胞自动机能作为一个整体判断相邻的大片黑白区域哪个更大，截去较小的区域，并使较大的区域得以扩展。这些信号就是图 11.1 中的局部多数投票元胞自动机与图 11.5 中的元胞自动机的主要区别。前面提到，前者的黑色和白色区域之间没有信息沟通，因而也无法得知两者谁占多数。而对于后者，棋盘格和垂直边界产生的信号则可以进行这样的信息传递，通过信号之间的相互作用对传递的信息进行处理，从而得出答案。

图 11.5 标记了重要特征后的图 11.4（a） 克鲁奇菲尔德之前发明了一种方法 165 可以研究动力系统行为中的「信息处理结构」，他建议我们用这种方法来分析遗传算法演化出的元胞自动机。克鲁奇菲尔德的思想是区域之间的界线（例如图 11.5 中的 A、B、C 线以及垂直界线）携带有信息，而界线发生碰撞就是对信息进行处理。图 11.6 对图 11.5 的时空图进行了重绘，将黑色、白色和棋盘格区域都去掉，只留下界线，这样更容易看清楚一些。这张图有点像以前物理实验用的气泡室中的基本粒子轨迹。因此克鲁奇菲尔德就把这些界线称为「粒子」。

图 11.6 对时空图 11.4（a）进行重绘，将单一的图样去掉，只留下区域之间的界线（粒子）（图片引自米歇尔、克鲁奇菲尔德和达斯的文章《演化执行计算的元胞自动机：最近的研究综述》，收录在《第一届进化计算及其应用国际会议文集》，俄罗斯科学院，1996 年）

物理粒子通常习惯用希腊字母表示，这里也照样。这个元胞自动机能产生 6 种不同类型的粒子：γ（伽马）、μ（缪）、η（艾塔）、δ（德尔塔）、β（贝塔）、α（阿尔法，一种寿命很短的粒子，衰变成 γ 和 μ）。每种粒子分别对应一种界线 —— 例如，η 与黑色和棋盘格区域之间的界线相对应。粒子碰撞有 5 种，其中 3 种（β+γ、μ+β、和 η+δ）会产生出新粒子，而另外两种（η+μ 和 γ+δ）则会「湮灭」，两个粒子都消失。

将元胞自动机的行为用粒子进行描述能帮助我们理解其如何编码信息和进行计算。例如，α 和 β 粒子编码了关于初始状态的不同类型的信息。α 粒子衰变成 γ 和 μ。γ 粒子携带了白色区域边界的信息；类似的，μ 粒子则携带了黑色区域边界的信息。当 γ 抢在 μ 之前与 β 碰撞，β 和 γ 所携带的信息就结合到了一起，从而可以得知，最初由这几条界线划分的大块白色区域要小于大块黑色区域。这个新的信息被编码在新产生的粒子 η 中，它的任务就是追上粒子 μ，并与其一起湮灭。

这种分析方法也可以被应用于其他几种演化出来的执行多数分类等任务的元胞自动机。这使得我们能预测特定元胞自动机的适应度等特征（而不用去运行元胞自动机本身，只需要分析其「粒子」描述就可以了）。另外我们也能理解为何某个元胞自动机的适应度会较高，以及如何描述各种元胞自动机在执行计算时所犯的错误。

粒子描述让我们看到了仅仅观察元胞自动机规则或是其时空图变化看不到的东西：它们让我们能从信息处理的角度来解释元胞自动机是如何执行计算的。粒子是我们强加给元胞自动机的描述，而不是在元胞自动机中确实发生的事情，遗传算法也没有用它们来演化元胞自动机。然而不知怎的遗传算法却演化出了行为可以用粒子信息处理解释的规则。事实上粒子以及它们之间的相互作用可以作为一种语言，用来解释以一维元胞自动机为背景的分布式计算。沃尔夫勒姆曾提出《元胞自动机理论的二十个问题》 [166] ，其中最后一个问题是：「对元胞自动机的信息处理能不能给出高层次的描述？」他想要的可能就是类似于这种语言的东西。

这些都是最近的工作，还需要继续深入研究。我相信，用这种方法理解计算，虽然不符合正统，却对没有中央控制，分布在简单个体中的计算会有用。例如，关于感知信号的高级信息在大脑中如何编码和处理目前仍然是个谜。也许可以用某种类似于粒子的语言对其进行解释，也有可能是类似于波的计算，因为大脑是三维的，神经元在一起形成携带信息的波运动，并通过波的相互作用处理信息。大脑计算当然与一维元胞自动机不在一个层面上。不过，有一种自然系统却可以用非常类似于粒子的语言解释：植物的气孔网络。所有有叶植物的叶子表面都布满了气孔 —— 根据光线和湿度开合的微小孔隙。气孔打开时可以让二氧化碳进来，用于光合作用。但是气孔打开也会导致植物体内的水分蒸发。

犹他州立大学（Utah State University）的植物学家莫特（Keith Mott）、物理学家皮克（David Peak）和他们的同事长期观察叶子气孔的开合模式 [167] ，他们认为气孔组成了一个有点类似于二维元胞自动机的网络。他们还发现气孔开合的时间模式很像二维形式的粒子相互作用。他们猜测植物通过气孔进行分布式计算 —— 通过优化气孔的开合让二氧化碳的获取和水分流失达到最佳平衡 —— 这种计算也许也能用粒子语言进行解释。

## 1201. 生命系统中的信息处理 [168] 

自从西拉德发现信息能将热力学第二定律从麦克斯韦妖的威胁下拯救出来之后，信息和计算就日渐成为科学的宠儿。在许多人看来，信息具有本体地位，同质量和能量一样，被当做实在的第三种基本成分。在生物学中尤其如此，将生命系统描述成信息处理网络已成为潮流。信息处理一词随处可见，以至于你可能会认为它的意义已没有疑义，也许就是基于香农对信息的形式化定义。然而，同其他复杂系统科学的核心概念一样，信息处理的概念也很不清晰；一旦脱离了图灵机和冯·诺依曼结构计算机的精确形式化背景，就经常很难厘清信息处理或计算的概念。上一章介绍的工作就是在元胞自动机的背景下针对这个问题的尝试。

这一章的目的是探讨生命系统中的信息处理或计算。我将描述三种不同的自然系统，免疫系统、蚁群和细胞代谢 —— 在其中信息处理似乎都扮演了关键的角色 —— 并尽力阐明信息和计算在它们中所扮演的角色。最后我将尝试弄清在此类分散系统中信息处理的共性。

### 12.1 什么是信息处理

我先引用一下自己在第 10 章的一段话：「自然系统的计算指的是什么呢？大致上说，计算是复杂系统为了成功适应环境而对信息进行的处理。但是这样的说法还能更精确些吗？信息在哪里？复杂系统又是如何处理信息的？」

这些问题似乎很显然，但如果深究一下，我们很快就会陷入复杂系统科学最深的泥沼之中。当我们说一个系统在处理信息或计算（从现在开始，我会不加区分地使用这两个词），我们就面临着以下问题 [169]：

1、「信息」在这个系统中扮演了什么角色？ 

2、信息又是如何传递和处理的？ 

3、这些信息是如何获得意义的？又是对谁有意义？（有些人会不同意计算需要某种类型的意义，不过我会先坚持己见，认为它需要。） 

### 12.2 传统计算机中的信息处理

在第 4 章我们已经知道，20 世纪 30 年代图灵用图灵机对输入的处理步骤定义了计算的概念。图灵的定义是传统冯·诺依曼结构计算机的设计基础。对于这些计算机，关于信息的问题很容易回答。我们可以说信息就是带子上的符号和读写头的可能状态。信息的处理则是通过读写头在带子上的读写和状态变化实现的。这一切都是根据规则进行的，程序就是由规则组成的。

对于传统计算机的程序，我们（至少）可以从两个层面来看：机器码层面和编程语言层面。在机器码层面上，程序是由具体的让机器一步一步执行的低级指令组成（例如，「将内存中地址 n 的数据移到 CPU 的寄存器 j」，「对 CPU 寄存器 j 和 i 中的数据执行或逻辑运算，将结果存入内存中地址，处」，等等）。

而在编程语言层面上，程序是由 BASIC 或 JAVA 这样的高级语言的指令组成，让人更容易理解（例如，「将某个变量乘以 2，并将结果赋给另一个变量」，等等）。一个高级语言指令通常要用几个低级指令来实现，不同的计算机类型可能有不同的实现。因此高级语言程序可以以不同的方式实现为机器码；高级语言是对信息处理更抽象的描述。

图灵机输入和输出的信息的意义来自于人们（程序员或使用者）的解读。中间步骤产生的信息的意义也来自人们对高级语言命令步骤的解读（或设计）。高级语言描述让我们能容易理解在机器码或硬件层面上对于人来说很抽象的计算。

### 12.3 元胞自动机中的信息处理

对于元胞自动机等非冯·诺依曼结构的计算机来说，答案就不是那么显而易见了。例如我们在上一章用遗传算法演化出来执行多数分类任务的元胞自动机就是这样。与传统计算机作个类比，我们可以说元胞自动机的信息就是元胞格子在每一步的状态组合。输入就是初始状态组合，输出则是最终的状态组合，在每个中间步的信息则根据元胞自动机规则在元胞邻域内进行传递和处理。意义来自人们对所执行的任务的认识以及对从输入到输出的映射的解读（例如，「元胞最终都变成了白色；这意味着初始状态组合中白色元胞占多数」）。

在这个层面上描述信息处理就类似于在「机器码层面」进行描述，并不能帮助人们理解计算是如何完成的。同冯·诺依曼结构计算的情形一样，在这里我们也需要一种高级语言来理解中间步骤的计算，对元胞自动机底层的具体细节进行抽象。

上一章我提出，粒子以及粒子的相互作用可以用来描述元胞自动机的信息处理，类似于高级语言。信息通过粒子的运动来传递，粒子的碰撞则是对信息进行处理。这样，信息处理的中间步骤就通过人们对粒子行为的解释获得了意义。冯·诺依曼结构的计算之所以容易描述，一个原因就是，编程语言层面和机器码层面可以毫无歧义地相互转化，因为计算机的设计让这种转化可以很容易做到。计算机科学提供了自动编译和反编译的工具，让我们可以理解具体的程序是如何处理信息的。

而元胞自动机则不存在这样的编译和反编译工具，至少目前还没有，也没有实用和通用的设计「程序」的高级语言。用粒子来帮助理解元胞自动机高级信息处理结构的思想也是最近才出现，还远没有形成此类系统的计算理论体系。理解元胞自动机信息处理的困难在实际生命系统中也同样存在。「自然系统的计算指的是什么？」对于这个问题目前仍然知之甚少，在科学家、工程师和哲学家之间存在着广泛的争议。

然而它对于复杂系统科学又是极为重要的问题，因为对生命系统中信息处理的高层次描述不仅能让我们从更高的视角理解具体系统的运作，也能让我们超越系统繁杂的细节，抽象出一般性原理。实质上，这种描述就是为生物学提供一种「高级语言」。这一章余下部分将力图用具体的例子来阐明这种思想。

### 12.4 免疫系统

在第 1 章曾讲到过免疫系统。现在我们来更深入地了解一下，为了保护身体免受病毒、细菌、寄生虫等病原体的侵害，免疫系统 [170] 是如何处理信息的。我们知道，免疫系统是由数以亿计的各种细胞和分子组成，它们在身体里循环，通过各种信号相互影响。在免疫系统各种类型的细胞中，我关注的是淋巴细胞（白细胞的一种，见图 12.1）。

淋巴细胞是在骨髓中产生的。有两种淋巴细胞很重要，释放抗体攻击病毒和细菌的 B 细胞，以及杀死入侵者同时还调节其他细胞反应的 T 细胞。身体中所有细胞表面都有称为受体的分子。顾名思义，这些分子是细胞接收信息的途径。信息表现为能与受体分子结合的外界分子。受体能否与某个分子结合取决于它们的分子结构是否能充分匹配。一个淋巴细胞表面覆盖的受体是一样的，可以与特定的某一类分子形状匹配。如果恰好遇到了形状相匹配的病原体分子（称为「抗原」），淋巴细胞的受体就会与其相结合，淋巴细胞就「识别」出了抗原，这是消灭病原体的第一步。结合可强可弱，依赖于分子与受体的匹配程度。图 12.2 描绘了这个过程。

图 12.1 人类淋巴细胞，表面覆盖着受体，可以与遇到的特定形状的分子相结合

图 12.2 淋巴细胞（图中为 B 细胞）受体与抗原结合的示意图

免疫系统面临的主要问题是，它不知道什么病原体将会入侵身体，因此它也就不可能「预先设计」出一组淋巴细胞，让它们的受体与入侵病原体的分子形状刚好能紧密结合。而且可能的病原体种类是个天文数字，因此免疫系统永远也不可能在同一时间产生出那么多淋巴细胞以应对每一种可能。虽然身体每天会产生数以百万计不同的淋巴细胞，身体可能遇到的病原体却还要多得多。

我们来看看免疫系统是如何解决这个问题的。为了能「覆盖到」各种各样可能的病原体外形，身体内会同时存在许多种类型的淋巴细胞。免疫系统利用随机性，让淋巴细胞能识别的形状范围互不相同。当淋巴细胞产生时，通过淋巴细胞 DNA 复杂的随机重组过程，新的受体会被创造出来。由于淋巴细胞群体不断更新（每天会产生上千万新的淋巴细胞），身体也就不断产生具有新的受体形状的淋巴细胞。对于任何进入体内的病原体，身体很快就产生出能与病原体的标记分子（也就是抗原）相结合的淋巴细胞，虽然结合可能不是很紧密。

一旦发生了结合事件，免疫系统就得搞清楚这是不是真正的威胁。病原体当然是有害的，一旦它们进入身体，就会开始大量复制。不过发动免疫系统攻击会导致发炎等对身体有害的症状，攻击太强烈甚至有可能致命。免疫系统作为一个整体必须确定威胁是否足够严重，值得承担让免疫反应伤害身体的风险。

免疫系统只有在强结合事件足够多之后才会进入高速运转模式。B 细胞和 T 细胞这两种类型的淋巴细胞协同工作，判断攻击是否有必要。一旦 B 细胞表面强结合受体的数量超过了某个阈值，与此同时 B 细胞从有类似受体的 T 细胞那里收到了「发动」信号，B 细胞就会被激活，表明它现在感觉到了身体受到威胁（图 12.3）。一旦激活，B 细胞就会向血液中释放抗体分子。这些抗体与抗原结合，使它们失效，并对它们进行标记，好让其他免疫细胞摧毁它们。

图 12.3 通过与抗原结合和接收 T 细胞的「发动」信号激活 B 细胞的示意图。信号刺激 B 细胞产生和释放抗体（y 形分子） 

激活的 B 细胞被输送到淋巴结，在那里迅速分裂，产生出大量后代，复制时由于变异，许多后代的受体形状都改变了。然后这些后代会与淋巴结俘获的抗原进行测试。不能结合的细胞很快就会死去。存活下来的后代被释放到血液中，其中一些会遇到抗原并与其结合，有时候会比它们的母细胞结合得更紧密。这些激活的 B 细胞同样又被输送到淋巴结，在那里产生出自己的后代。这也就是为什么当你病了的时候淋巴结会肿大，因为它在大量产生淋巴细胞。这个循环不断进行，与抗原匹配得越好的 B 细胞产生的后代也越多。简而言之，这就是一个自然选择过程，B 细胞群体进化出能与目标抗原紧密结合的受体形状，从而使得通过选择「设计」出来攻击特定抗原的抗体武器库不断扩大。这个侦测和摧毁过程一般需要数天或数周时间才能将目标病原体从身体中清除干净。

这种策略起码存在两个潜在问题。首先，免疫系统如何防止淋巴细胞错误攻击身体自身的细胞？其次，免疫系统在对身体的伤害作用太大时如何停止或调整攻击？ 

免疫学家们还没有完全弄清这些问题，现在这些问题都还是活跃的研究领域。有人认为避免攻击自身的一个主要机制是所谓的负选择（negative selection）。当淋巴细胞产生出来时，它们不会被立即释放到血液中去，它们会在骨髓和胸腺中进行测试，与身体自身的分子进行接触。与「自身」分子紧密结合的淋巴细胞可能会被杀死或对基因进行「编辑」以改变受体。也就是说免疫系统只使用不会攻击自身的淋巴细胞。这个机制经常会失效，有时候会产生出糖尿病或类风湿性关节炎这类自身免疫性疾病。

另一个防止自身免疫攻击的主要机制可能是调节性 T 细胞（regulatory Tcells）的作用。调节性 T 细胞是 T 细胞的一个特殊亚种。目前还不清楚调节性 T 细胞是如何工作的，只知道它们通过某种化学机制抑制其他 T 细胞的活动。

还有一种可能的机制是 B 细胞之间对一种有限资源的竞争 [171] —— 一种称为 B 细胞刺激因子（BAFF）的特殊化学物质，B 细胞需要它才能存活。在负选择过程中漏网并且仍然与自身分子紧密结合的 B 细胞，由于总是与自身分子结合在一起，因此比其他 B 细胞需要更多的 BAFF。对这种有限资源的竞争导致结合自身分子的 B 细胞死亡的可能性增加。虽然免疫系统攻击外来病原体，它也还是有义务在攻击的毒性和尽可能防止伤害身体之间进行平衡。免疫系统使用了一系列机制来实现这种平衡（目前对这些机制还知之甚少）。其中许多机制都依赖于一组信号分子，被称为细胞因子 （cytokines）。对身体的伤害会导致细胞因子的分泌，细胞因子会抑制活跃的淋巴细胞。可能伤害越严重，细胞因子的浓度就越高，活跃的细胞也就越有可能遇到它们，从而被关闭，达到调节免疫系统的目的，而不用对整个免疫系统进行抑制。

### 12.5 蚁群

第 1 章曾说过，蚁群与大脑很相似。都可以看做由相对简单的个体（神经元、蚂蚁）组成的网络，并且涌现出宏观尺度上的信息处理行为。有两个例子表现出蚁群的这种行为，一是以最佳和适应性的方法搜寻食物的能力，以及适应性地根据蚁群整体的需要分配蚂蚁执行各种工作。这两种行为都是在没有中央控制的情况下完成的，所使用的机制与前面描述的免疫系统惊人的相似。大部分蚂蚁种类的食物搜索大致是这样进行的 [172] 。蚁群中搜寻食物的蚂蚁随机朝一个方向搜索，如果遇到食物，就返回蚁穴，沿途留下作为信号的化学物质 —— 信息素 （pheromones）。当其他蚂蚁发现了信息素，就有可能会沿着信息素的轨迹前进。信息素的浓度越高，蚂蚁就越有可能跟着信息素走。如果蚂蚁找到了那堆食物，就会返回巢穴，将信息素的轨迹增强。如果信息素的轨迹得不到增强，就会消失。通过这种方式，蚂蚁一起创造和沟通关于食物位置和质量的各种信息，并且这种信息还会适应环境的变化。

存在的轨迹和强度很好地表达了搜索蚁协同发现的食物情报（图 12.4）。蚁群的任务分配也是以分散方式进行的。生态学家戈登（Deborah Gordon）曾研究过红色收割蚁（Red Harvester ants）的任务分配 [173] 。蚁群中的工蚁分为四个工种：搜寻食物、维护蚁穴、巡逻和垃圾处理。执行各种任务的工蚁数量能随着环境变化。戈登发现，如果蚁穴被稍微搅乱，维护蚁穴的工蚁数量会增加。如果附近的食物源很多，质量很好，搜寻食物的工蚁数量就会增加。单只蚂蚁可以根据蚁穴环境的变化作出适应性响应，决定采取哪种工作，无需另外的蚂蚁来指挥，每只蚂蚁也仅与其他少数蚂蚁交互，它们是如何做到的呢？

图 12.4 蚁迹（Flagstaffotos 版权所有，经许可重印） 

答案可能是蚂蚁根据它们周围的环境以及它所遇到的执行各种任务的蚂蚁比例来决定自己干什么。比如，一只闲逛的蚂蚁 —— 目前什么也没有做 —— 在蚁穴附近遇到了杂物，它执行蚁穴维护工作的概率就会增加。另外，如果它发现很多维护蚁穴的工蚁在进进出出，也会增加执行蚁穴维护工作的概率；因为这种活动的增加表明有重要的蚁穴维护工作在进行。类似的，维护蚁穴的工蚁如果遇到了很多搜寻食物的蚂蚁带着种子返回蚁穴，就会增加它转向搜寻食物工作的概率；因为种子搬运信号的增加表明发现了高质量的食物源，需要进行采集。

显然，通过用触须与其他蚂蚁交流，侦测与各项工作有关的特殊化学物质，蚂蚁就能知道其他蚂蚁在做什么。类似的这种利用信息素与其他个体直接交互的机制可能也是其他种类蚂蚁和社会昆虫集体行为的基础，例如第 1 章中看到的蚂蚁用身体搭桥和构建庇护所 [174] ，这些行为的许多方面还有待进一步研究。

### 12.6 生物代谢

代谢是指一系列化学过程，生物消耗从食物、空气或阳光中获取的能量，维持生命所需的所有功能。这些化学过程大部分发生在细胞内部，通过称为代谢途径的化学反应链进行。在生物体内的每个细胞中，营养分子通过反应产生能量，细胞组分也通过代谢途径产生。

这些组分内部的维持和修复以及外部的功能和细胞间通讯。数以百万的分子不断在细胞质中随机运动，分子不断相互碰撞，偶尔（微秒级尺度）酶会碰到形状匹配的分子，从而加速由酶控制的化学反应。这样逐级反应逐渐形成大分子。淋巴细胞通过释放细胞因子影响免疫系统，蚂蚁通过释放信息素影响收集食物的行为，同样，代谢途径上的化学反应也会不断改变特定途径的速度和获得的原材料。代射途径一般是复杂的化学反应序列，受自我调节反馈控制。

例如，糖酵解（glycolysis）是所有生命中都存在的代谢途径 —— 它通过多步反应将葡萄糖转化为丙酮酸（pryrnvate），丙酮酸又通过称为柠檬酸循环的代谢途径产生许多物质，其中包括 ATP（三磷腺苷），ATP 是细胞能量的主要来源。这种代谢途径的数量数以百计，有些独立，有些相互依赖。代谢途径生成新的分子，开启其他代谢途径，并调节自身或其他代谢途径。

与前面描述的免疫系统和蚁群的调节机制类似，代谢调节机制也是基于反馈。糖酵解就是这样的例子。糖酵解的一个主要作用是为制造 ATP 提供必需的化学原料，如果细胞中 ATP 的量很多，就会减缓糖酵解的速度，从而降低 ATP 的产生速度。反过来，如果细胞缺乏 ATP，糖酵解的速度就会加快。代谢途径的速度一般都受途径产生的化学物质调节。

### 12.7 这些系统中的信息处理

现在我们来尝试回答这一章开始时提出的关于信息处理的问题：1）「信息」在这些系统中扮演了什么角色？ 2）信息是如何被传递和处理的？ 3）信息是如何获得意义的？又是对谁有意义？ 

#### 12.7.1 信息扮演了什么角色

在元胞自动机的例子中，当我说到信息处理时，我指的不是细胞、蚂蚁或酶这样的单个个体的行为，而是一大群这种个体的集体行为。根据这个框架，信息不像在传统计算机中那样，位于系统中的某个具体位置。在这里它表现为系统组分的动态模式和统计结果。在免疫系统中，淋巴细胞的空间分布和时间动力学可以解释为体内病原体数量变化信息的动态表示。类似的，细胞因子浓度的空间分布和动态可以解释为免疫系统杀死病原体和避免伤害身体的宏观尺度信息。对于蚁群，食物源的信息则动态地表示为蚂蚁在不同蚁迹上的统计分布。

蚁群的整体状态表示为执行各种任务的蚂蚁的动态分布。至于细胞代谢，当前状态以及细胞需求的信息则不断通过各种分子的浓度和动态变化反映出来。

#### 12.7.2 信息是如何被传递和处理的

1、通过采样实现通讯。

将信息编码为基本组分的统计和变化模式的一个后果是，没有哪个个体组分能感知或传达系统状态的「宏观画面」。信息必须通过空间和时间采样来传递。在免疫系统中，淋巴细胞通过受体接受抗原和免疫系统其他细胞释放的细胞因子来对环境采样。淋巴细胞采样这些分子信号的空间和时间分布，进而被激活或是休眠。其他细胞反过来又会对激活的淋巴细胞的浓度和类型进行采样，并受其影响，将对抗病原体的细胞吸引到身体的特定区域。对于蚁群，单只蚂蚁则是通过感受器对信息素信号进行采样。它们根据对环境中信息素浓度特征的采样决定移动方向。

前面讲过，单只蚂蚁也会用基于浓度的采样信息 —— 遇到的其他蚂蚁 —— 来决定是否进行某项工作。在细胞代谢中，通过酶与特定分子结合，酶对分子浓度的时空变化进行采样，进而又反馈到代谢途径。

2、行为的随机成分。

由于获得的信息具有统计性，系统组分的行为就必然是随机的（至少「不可预测」）。前面描述的三个系统本质上都利用了随机性和或然性 [175] 。每个淋巴细胞的受体形状都有随机生成成分，从而能采样许多可能的形状。淋巴细胞随血流分布，因此体内淋巴细胞的空间分布也有随机成分，从而可以采样抗原的多种可能空间特征。淋巴细胞激活的具体阈值、实际的分裂速度以及后代的变异都具有随机性。类似的，蚂蚁搜寻食物的活动也具有随机成分，蚂蚁对信息素的侦测以及是否受其轨迹吸引也是随机的。蚂蚁改变工种也是以随机的方式。

生物化学家齐夫（Edward Ziff）和科学史学家罗森菲尔德（Israel Rosenfield）这样描述随机性的作用：「最终蚂蚁会建立通往食物源路径的详细地图 [176] 。观察者可能会认为蚂蚁的食物分布地图是由某位智能设计者提供的。通往食物源的路径看上去就像是精心画出来的，但实际上却是一系列随机搜索的产物。」

细胞代谢依赖于分子的随机扩散和分子相遇的概率，随着系统的变化，相对浓度会发生变化，从而概率也会跟着变化。为了让数量相对较少的简单个体（蚂蚁、细胞、分子）能探测相比起来要大得多的可能范围，这种内在的随机性和或然性似乎是必需的，尤其是通过探测获得的信息本质上是统计性的，而且对于将要遇到的事物也没有什么先验知识。

但是随机性必须与确定性达成平衡：复杂适应系统的自我调节不断调整各项事务的概率 —— 个体应该向哪里移动，它们应当采取什么行动，以及如何探测庞大空间中的具体路径。

3、微粒化探测。

复杂生物系统绝大多数都有微粒化结构，它们由大量相对比较简单的个体组成，个体以高度并行的方式协同工作。这种结构有几个可能的好处，稳健、效率高、可以演化。还有一个额外的好处就是微粒化并行系统能进行侯世达所说的「并行级差扫描 」（parallel terraced scan）[177]。他指的是对许多可能性和路径同时进行探测，某项探测所能获得的资源依赖于其当时的成效。搜索是并行的，许多可能性被同时探测，但是存在「级差」，意思是并不是所有可能都以同样的速度和深度进行探测。利用获得的信息不断调整探测，从而有所侧重。

例如，免疫系统需要随时确定，在病原体可能形状的庞大空间中，哪部分区域需要用淋巴细胞进行探测。体内每个淋巴细胞都可以看做形状空间的微小探测器。探测器的形状范围越成功（与抗原结合得越紧密），获得的探测资源也就越多，即后代淋巴细胞越多，形状范围不成功的（结合不紧密的淋巴细胞）则得不到那么多资源。不过，在处理获得的信息的同时，免疫系统也在不断产生新的淋巴细胞，用来探测全新的形状范围。这样系统在应对当前状况的同时，也不会忽略新的可能性。与此类似，蚂蚁搜寻食物时也使用并行级差扫描策略：开始时许多蚂蚁随机寻找食物。一旦在某个方向发现了食物，就会分派更多的系统资源（蚂蚁），通过前面描述的反馈机制，进一步探测这个方向。路径得到的探测资源不断通过其相对绩效 —— 所发现食物的数量和质量 —— 进行动态调整。但是，由于蚂蚁数量很多，再加上具有随机性，绩效不好的路径也会继续探测，当然分派的资源会少得多。谁知道呢，说不定就能发现更好的食物源。

在细胞代谢机制中，微粒化探测是由代谢途径实现的，每条途径执行特定的任务。代谢途径的反应速度受其本身和其他途径的反馈影响。反馈通过分子浓度变化的形式体现，从而使得各途径的相对速度可以不断根据细胞的当前需求进行调整。此外，系统微粒化的特性不仅使其能探测各种不同的路径，同时也使得系统能够连续地调整探测路径，因为采取的动作都相对较小。而如果更加粗粒化，就很有可能在没有绩效的探测路径上浪费时间。因此，探测的微粒化特性使得系统能根据其获得的信息连贯地对探测进行调整。不仅如此，微粒化系统天生具有冗余度，因此即使有个体组分不能可靠工作，获取的信息也只是统计性的，系统还是能正常运转。冗余度使得对信息有许多独立的采样，而且只有大量组分采取同样的微粒化行动时才会产生效果。

4、分散探测与集中行动之间的互动。

在三个例子中，根据系统的需要，随机分散探测与集中行动之间不断进行互动。在免疫系统中，分散探测是通过带有各种受体、尝试匹配可能抗原的淋巴细胞群体的不断变化进行。集中行动则是让成功匹配的淋巴细胞产生后代，集中应对特定形状的抗原。蚂蚁搜寻食物时是由蚂蚁随机移动、四处寻找食物来进行分散探测，在集中行动中则是蚂蚁循着信息素轨迹活动。在细胞代谢中，作为分散行动的分子随机探测则与由化学浓度和基因调节控制的集中激活或抑制结合在一起。

对于所有的适应性系统，在两种探测模式中保持适当的平衡都是关键 [178] 。而最优的平衡点随时间不断变化。开始时所知的信息很少，探测基本是随机分散的。随着信息增多并产生影响，探测逐渐变得具有确定性，集中于对系统的感知进行响应。简而言之，系统既要探测信息，又要对信息加以利用，不断调整适应。在分散探测和集中行动之间进行平衡可能是适应性和智能系统的共性。例如霍兰德就曾用这种平衡解释遗传算法的工作原理。

5、信息是如何获得意义的。

信息如何获得意义（有些人称为目的性），这是哲学的一个永恒话题。对于哲学家们的看法我无从置评，但是要想理解生命系统中的信息处理过程，我们必须面对这个问题。在我看来，意义与生存和自然选择密切相关。如果事件影响到某个生物的生存或繁衍能力，那么事件对生物就具有某种意义。总之，事件的意义是如何应对事件的依据。事件对生物免疫系统的意义是其对生物适应度的影响。（我在这里非正式地使用适应度一词。）这些事件对免疫系统有意义是因为它们告诉免疫系统该如何应对，以提高生物的适应度 —— 对于蚁群、细胞以及其他生物的信息处理系统也是一样。聚焦于适应度是我理解意义的概念，并将其应用到生物信息处理系统的一条途径。

但是在前面描述的复杂系统中，并不存在中央控制或领导者，那么是谁或是什么在觉察当前情势的意义 [179] ，然后据此做出适当的反应呢？这个问题实际上问的就是什么构成了生命系统的意识或自我意识。对我来说，这个问题是复杂系统研究和整个科学最深的谜团。这个谜团是许多科学和哲学书的主题，但是至今还没有让人完全满意的答案。

将生命系统视为在进行计算的观点有个有趣的副产品：它激发了计算机学家编写程序模仿这类系统来完成真实任务。例如免疫系统的信息处理思想引出了所谓的人工免疫系统 [180]：保护计算机免受病毒和各种入侵者攻击的适应性程序。类似的，蚁群启发了所谓的「蚁群算法」[181]，模拟蚂蚁释放信息素和转换工作的原理来解决移动电话路由优化和货运调度优化等困难问题。下一章我还将介绍我与我的博士导师合作研究的人工智能程序，这个工作是受包括细胞代谢在内的全部三个系统的启发。