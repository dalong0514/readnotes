## 记忆时间

## 目录

0101 C# 和 .NET Core 简介

0201 C# 语言基础

## 0101. C# 和 .NET Core 简介

C# 是一种通用的、类型安全（type-safe）的面向对象编程语言。其目标是提高程序员的生产力，为此，需要在简单性、表达性和性能之间进行权衡。C# 语言的首席架构师 Anders Hejlsberg 随该语言的第一个版本一直走到了今天（他也是 Turbo Pascal 的发明者和 Delphi 的架构师）。C# 语言和平台无关，且可以与多种特定平台下的框架协同工作。

### 1.1 面向对象

C# 实现了丰富的面向对象范式，包括封装、继承和多态。封装意味着在对象周围创建一个边界，将其外部（公有）行为与内部（私有）实现细节隔离。C# 面向对象特性包括：

1、统一的类型系统。

C# 中的基础构件是一种称为类型的数据与函数的封装单元。C# 拥有统一的类型系统，其中的所有类型都共享一个公共的基类型。这意味着所有类型，不论它们是表示业务对象还是表示数字这样的基元类型，都共享相同的基本功能。例如，任何类型的实例都可以通过调用 ToString 方法将自身转换为一个字符串。

2、类与接口。

在传统面向对象范式中，唯一的类型就是类。然而 C# 还有其他几种类型，其中之一是接口。接口与类相似，但它无法持有数据。这意味着它仅可用于定义行为（而非状态）。这样接口不但可以实现多重继承，还可以将标准与实现隔离。

3、属性、方法和事件。

在纯粹的面向对象范式中，所有的函数都是方法。而在 C# 中，方法只是函数成员之一，除此之外还有属性、事件及其他的形式。属性是封装了一部分对象状态的函数成员，例如按钮的颜色或者标签的文本。事件则是简化对象状态变化处理的函数成员。

虽然 C# 首先是一种面向对象的语言，但它也借鉴了函数式编程的范式。例如：1）可以将函数作为值看待。C# 使用委托（delegate）将函数作为值传递给其他函数或者从其他函数中返回。2）C# 支持纯函数模式。函数式编程的核心是避免使用值可以变化的变量，或称为声明式模式。C# 拥有支持该模式的若干关键功能，包括支持可以捕获变量的匿名函数（Lambda 表达式），通过查询表达式（query expression）执行列表式或响应式编程；它还可以使用只读字段（read-only field）和属性创建不可变的类型。

### 1.2 类型安全性

C# 是一种类型安全的语言。这意味着类型的实例只能通过它们定义的协议进行交互，从而保证了每种类型的内部一致性。例如，C# 不允许将字符串类型作为整数类型进行处理。

更具体地说，C# 支持静态类型化（static typing），即在编译时会执行安全性检查。此外，在运行时也会同样执行类型安全性检查。

静态类型化能够在程序运行之前排除大量的错误。它将大量的运行时单元测试转移到编译器中，确保程序中所有类型之间都是相互适配的，使大型程序更易于管理、更具预测性并更加健壮。而且静态类型化可以借助一些工具（例如 Visual Studio 的 IntelliSense）来提供更好的编程辅助，它能够知晓某个特定变量的类型，自然也知道该变量上能够调用的方法；同时这些工具还可以明确程序中的变量、类型或方法的所有使用位置，以实现可靠的重构。

C# 允许部分代码通过 dynamic 关键字来动态定义指定类型。然而，C# 在大多数情况下仍然是一门静态类型化语言。

C# 还是一门强类型语言（strongly typed language），因为它的类型规则非常严格（不论是静态还是运行时均是如此）。例如，不能用浮点类型的参数来调用接受整数类型参数的函数，除非先将这个浮点数转换为整数。这可以防止编码错误。

### 1.3 内存管理

C# 依靠运行时来实现自动内存管理。公共语言运行时的垃圾回收器会作为程序的一部分运行，并负责回收那些不再被引用的对象所占用的内存，程序员无须显式释放对象的内存，从而避免诸如 C++ 等语言中错误使用指针而造成的问题。

C# 并未抛弃指针，只是在大多数编程任务中是不需要使用指针的。对于性能优先的热点和互操作性，仍然可以在标记为 unsafe 的程序块内使用指针并进行显式内存分配。

### 1.4 平台支持

曾几何时，C# 几乎只用于编写运行在 Windows 平台上的代码。但是后来，Microsoft 和一些公司均针对其他平台进行了研发：

1、.NET Core 框架可以在 Linux、macOS 以及 Windows 操作系统上开发网络应用程序。

2、Xamarin 可用于开发支持 iOS 和 Android 平台的移动应用程序。

3、Blazor 将 C# 编译为可在浏览器上运行的 Web 程序集。

在 Windows 平台上：

1、.NET Core 3 可用于开发运行在 Windows 7 到 Windows 10 操作系统上的富客户端应用程序和网络应用程序。

2、Universal Windows Platform（UWP）支持 Windows 10 桌面系统以及相关设备（如 Xbox、Surface Hub 以及 Hololens）的应用开发。

### 1.5 C# 和公共语言运行时

C# 的执行依赖公共语言运行时（Common Language Runtime，CLR），它提供了必需的运行时服务，例如自动化内存管理与异常处理（其中「公共」指其他托管程序设计语言，如 F#、Visual Basic 和托管 C++，也能够共享该运行时）。

C# 也是一种托管语言，因为它也会将源代码编译为托管代码，托管代码以中间语言（Intermediate Language，IL）的形式表示。CLR 通常会在执行前将 IL 转换为机器（例如 x86 或 x64）原生代码，称为即时（Just-In-Time，JIT）编译。除此之外，还可以使用提前编译（ahead-of-time compilation）技术来改善拥有大量程序集或在资源有限的设备上运行的程序的启动速度（包括那些使用 Xamarin 开发的应用，以达到 iOS 应用商店标准。）

托管代码的容器称为程序集（assembly）。它们不仅包含 IL，还包含称为元数据（metadata）的类型信息。元数据的引入使程序集不需要额外的文件就可以引用其他程序集中的类型。

Microsoft 的 ildasm 工具可用于反编译或查看程序集的内容。而其他工具，例如 ILSpy 与 JetBrains 的 dotPeek 则可以将 IL 代码进一步反编译为 C#。IL 的层次相比原生机器代码要高得多，因此反编译器可以高质量地重建 C# 代码。

程序也可以通过反射（reflection）查询其元数据，甚至在运行时生成新的 IL（Reflection.Emit）。

### 1.6 框架与基础类库

CLR 并非独立发行，而是作为框架的一部分与一系列标准程序集一道发行的。在开发应用程序时，应当选定一个特定的目标框架，这也意味着该应用程序依赖该框架提供的功能。目标框架的选择也决定了应用程序支持的平台。

如图 1-1 所示，框架由三个部分构成。基础类库（Base Class Library，BCL）位于 CLR 之上，为应用程序提供实用的功能（如集合、XML/JSON、输入输出 [I/O]、网络功能、序列化和并行编程）。位于 BCL 之上的是应用程序框架层。它提供了特定用户接口范式的 API（例如，ASP.NET Core 针对网络应用程序开发，而 Windows Presentation Foundation [WPF] 则针对富客户端应用程序开发）。命令行应用程序则不需要应用程序层的支持。

图 1-1：框架的架构

当 C# 在 2000 年首次发布时，应用该语言的框架仅有 Microsoft .NET Framework。而现在已有四个主要框架可供选择：

1、.NET Core。

.NET Core 是一个现代开源框架。它既用于开发能够在 Windows、Linux 和 macOS 操作系统上运行的命令行应用程序与网络应用程序，也可以开发运行于 Windows 7 到 Windows 10 操作系统之上的富客户端应用程序（需要.NET Core 3 及以上版本的支持）。你可以在一个系统上同时安装多个版本的.NET Core 框架，并且可以通过创建自包含的应用程序来省去安装.NET Core 的麻烦。

2、UWP。

用于编写运行在 Windows 10 桌面系统以及其他设备（Xbox、Surface Hub 和 Hololens）上的沉浸式触摸优先的应用程序。UWP 应用运行在沙盒之内，并可通过 Windows Store 发行。Windows 10 操作系统中已经预装了 UWP。

3、Mono + Xamarin。

开源框架，用于编写运行于 iOS 和 Android 操作系统的移动应用程序。

4、.NET Framework（已被 .NET Core 3 取代）。

用于编写运行于 Windows 桌面系统和服务器系统的网络应用程序与富客户端应用程序。虽然 Microsoft 会继续支持和维护当前的 4.8 版本以保证现有应用程序的执行，但该框架目前已没有后续的发布计划。Windows 操作系统上预装了 .NET Framework。.NET Framework 支持 C# 7.3 及之前的版本。

1『NET Framework 只支持 C# 7.3 及之前的版本，做一张信息数据卡片。（2022-03-27）』—— 已完成

虽然上述框架支持的系统不同，使用场景不同，但它们均发布了相似的 CLR 和 BCL。

我们可以充分利用这种相似性来编写可以跨框架运行的类库，请参见 5.1 节。

本书着眼于 C# 和 CLR 以及 BCL 提供的核心功能，如图 1-2 所示。虽然主要关注 .NET Core 3，但也会涉及部分和 BCL 提供了相似功能的用于 UWP 应用程序的 Windows Runtime 的类型。

### 1.7 遗留框架和小众框架

以下的框架仍然可以在旧有的平台上运行：

1、用于 Windows 8/8.1 的 Windows Runtime（现被 UWP 取代）。

2、用于游戏开发的 Microsoft XNA（现被 UWP 取代）。

3、.NET Core 1.x 和 2.x 版本（仅用于网络应用程序和命令行应用程序开发）。

同样值得一提的是以下的小众框架：

1、.NET Micro Framework 是在资源非常受限的嵌入式设备（大小在 1MB 以内）上运行 .NET 代码的框架。

2、Mono（Xamarin 也是基于该框架的）同样拥有在 Linux、macOS 和 Windows 上开发跨平台「窗体应用程序」的应用程序层，不过该应用程序层并未支持所有的特性（Avalonia 是另一个进行跨平台用户界面开发的框架。它是一个基于.NET Core 与.NET Framework 的类似 WPF 的类库）。

图 1-2：本书涉及内容（标记为灰色的应用程序框架则不在本书讨论的范围之内）

除此之外，还可以在 SQL Server 上执行托管代码。SQL Server 的 CLR 集成环境支持在 SQL 中调用 C# 开发的自定义函数、存储过程以及聚合函数。它虽然使用.NET Framework，但是其沙盒是由特殊的 CLR 宿主提供的，以保护 SQL Server 进程无恙。

### 1.8 Windows Runtime

C# 还支持和 Windows Runtime（WinRT）的互操作。WinRT 是：

1、支持 Windows 8 及以上版本操作系统的语言无关的面向对象执行接口。

2、植入 Windows 8 及以上版本操作系统的库，该类库与上述接口兼容。

「WinRT」这个词汇容易令人误解。这是因为它曾经有两个含义：

1、UWP 的前身，即 Windows 8/8.1 商店应用（有时称为 Metro 或者 Modern 应用）的开发平台。

2、Microsoft 在 2011 年发布的基于精简指令集（RISC）的平板电脑操作系统（该系统已经被废弃）。

所谓执行接口（execution interface）是一个调用（潜在地）由其他语言编写的代码的协议。Microsoft Windows 曾以低层次的 C 语言函数调用形式提供了原生的执行接口，组成了 Win32 API。

WinRT 则更加丰富。从局部看，它是一个支持.NET、C++ 和 JavaScript 的增强版本的 COM（组件对象模型）。和 Win32 不同，它是面向对象的，并拥有相对丰富的类型系统。这意味着从 C# 中引用 WinRT 库就像是引用.NET 库一样，你甚至不会意识到你正在使用 WinRT。

Windows 10 的 WinRT 库是 UWP 的关键组成部分（UWP 依托于 WinRT 和.NET Core 库）。如果目标平台是标准.NET Core 平台，则引用 Windows 10 的 WinRT 库是可选的。但是当需要访问 Windows 10 特有的并未被.NET Core 涵盖的功能时，WinRT 库就非常有用了。

Windows 10 的 WinRT 库支持 UWP 用户界面，可开发沉浸式触摸优先的应用。它还支持移动设备相关的功能，例如传感器、文本消息等（Windows 8、Windows 8.1 以及 Windows 10 的新功能是通过 WinRT 而非 Win32 开放的）。WinRT 库还提供了文件 I/O 定制功能使其能够在 UWP 沙盒中顺畅运行。

WinRT 和普通 COM 的区别是 WinRT 的程序库支持多种语言，包括 C#、VB、C++ 和 JavaScript，因此每一种语言（几乎）都将 WinRT 类型视为自己的专属类型。例如，WinRT 会根据目标语言的要求调整大小写规则，甚至还会重新对一些函数与接口进行映射。WinRT 程序集还在.winmd 文件中包含了丰富的元数据，而其格式与.NET 文件相同，不需要特殊处理就可以无缝对接。事实上，除了命名空间存在区别之外，开发者甚至不知道使用的是 WinRT 而非.NET 类型。此外，WinRT 类型遵循 COM 风格限制，并对继承和泛型提供了有限的支持。

C# 不仅可以使用 WinRT 库，还可以创建新的库（并在 JavaScript 应用程序中调用）。

### 1.9 C# 简史

下面将倒序介绍 C# 各个版本的新特性以方便熟悉旧版本语言的读者。

#### 1.9.1 C# 8.0 新特性

C# 8.0 随 Visual Studio 2019 发布。

#### 1.9.2 C# 7.x 新特性

C# 7 随 Visual Studio 2017 发布。

C# 7.3 在先前的功能上做了微小的改进。例如，使用相等以及不等运算符对元组进行比较，改进了重载解析，并可以在自动属性对应的字段上附加特性。

#### 1.9.3 C# 6.0 新特性

C# 6.0 随 Visual Studio 2015 发布。随之一起发布的有崭新的完全使用 C# 实现的、代号为「Roslyn」的编译器。新的编译器将一整条编译流水线通过程序库进行开放，从而实现对任意源代码的分析（见第 27 章）。编译器本身是开源的，其源代码可以从 GitHub（http://github.com/dotnet/roslyn）上获得。

此外，C# 6.0 为了改善代码的清晰性引入了一系列小而精的改进。

null 条件（「Elvis」）运算符（请参见 2.10 节）可以避免在调用方法或访问类型的成员之前显式地编写判断 null 的语句。在以下示例中，result 的计算结果为 null 而不会抛出 NullReferenceException：

#### 1.9.4 C# 5.0 新特性

C# 5.0 最大的新特性是通过两个关键字 async 和 await 支持异步功能。异步功能支持异步延续（asynchronous continuation），从而简化响应式和线程安全的富客户端应用程序的编写。它还有利于编写高并发和高效的 I/O 密集型应用程序，无须为每一个操作绑定一个线程资源。

第 14 章将详细介绍异步功能。

#### 1.9.5 C# 4.0 新特性

C# 4.0 引入了四个主要功能增强：

动态绑定（第 4 章和第 20 章）将绑定过程（解析类型与成员的过程）从编译时推迟到运行时。这种方法适用于一些需要避免使用复杂反射代码的场合。动态绑定还适用于实现动态语言以及 COM 组件的互操作。

可选参数（见第 2 章）允许函数指定参数的默认值，这样调用者就可以省略一些参数，而命名参数则允许函数的调用者按名字而非位置指定参数。

类型变化规则在 C# 4.0 中进行了一定程度的放宽（见第 3 章和第 4 章），因此泛型接口和泛型委托类型参数可以标记为协变（covariant）或逆变（contravariant），从而支持更加自然的类型转换。

COM 互操作性（见第 25 章）在 C# 4.0 中进行了三个方面的改进。第一，参数可以通过引用传递，并无须使用 ref

关键字（特别适合与可选参数一同使用）。第二，包含 COM 互操作类型的程序集可以链接而无须引用。链接的互操作类型支持类型等价转换，无须使用主互操作程序集（primary interop assembly），并且解决了版本控制和部署的难题。第三，链接的互操作类型中的函数若返回 COM 变体类型，则会映射为 dynamic 而不是 object，因此无须进行强制类型转换。

#### 1.9.6 C# 3.0 新特性

C# 3.0 增加的特性主要集中在语言集成查询（Language-Integrated Query，LINQ）上。LINQ 令 C# 程序可以直接编写查询并以静态方式检查其正确性。它可以查询本地集合（如列表或 XML 文档），也可以查询远程数据源（如数据库）。C# 3.0 中和 LINQ 相关的新特性还包括隐式类型局部变量、匿名类型、对象初始化器、Lambda 表达式、扩展方法、查询表达式和表达式树。

隐式类型局部变量（var 关键字，见第 2 章）允许在声明语句中省略变量类型，然后由编译器推断其类型。这样可以简化代码并支持匿名类型（见第 4 章）。匿名类型是一些即时创建的类，它们常用于生成 LINQ 查询的最终输出结果。数组也可以隐式类型化（见第 2 章）。

对象初始化器（见第 3 章）允许在调用构造器之后以内联的方式设置属性，从而简化对象的构造过程。对象初始化器既支持命名类型也支持匿名类型。

Lambda 表达式（见第 4 章）是由编译器即时创建的微型函数，适用于创建「流畅的」LINQ 查询（见第 8 章）。

扩展方法（见第 4 章）可以在不修改类型定义的情况下使用新的方法扩展现有类型，使静态方法变得像实例方法一样。LINQ 表达式的查询运算符就是使用扩展方法实现的。

查询表达式（见第 8 章）提供了编写 LINQ 查询的更高级语法，大大简化了具有多个序列或范围变量的 LINQ 查询的编写过程。

表达式树（见第 8 章）是赋值给一种特殊类型 `Expression<TDelegate>` 的 Lambda 表达式的微型代码文档对象模型（Document Object Model，DOM）。表达式树使 LINQ 查询能够远程执行（例如在数据库服务器上），因为它们可以在运行时进行转换和翻译（例如变成 SQL 语句）。

C# 3.0 还添加了自动属性和分部方法。

自动属性（见第 3 章）对在 get/set 中对私有字段直接读写的属性进行了简化，并将字段的读写逻辑交给编译器自动生成。分部方法（partial method）（见第 3 章）可以令自动生成的分部类（partial class）自定义需要手动实现的钩子函数，而该函数可以在未被使用的情况下「消失」。

#### 1.9.7 C# 2.0 新特性

C# 2 提供的新特性包括泛型（见第 3 章）、可空值类型（见第 4 章）、迭代器（见第 4 章）以及匿名方法（Lambda 表达式的前身）。这些新特性为 C# 3 引入 LINQ 铺平了道路。

C# 2 还添加了分部类、静态类以及许多细节功能，例如对命名空间别名限定符、友元程序集和定长缓冲区的支持。

泛型需要在运行时仍然能够确保类型的正确性，因此需要引入新的 CLR（CLR 2.0）才能实现泛型。

## 0201. C# 语言基础

本章将介绍 C# 语言的一些基础知识。

本章和接下来的两章中的所有程序和代码片段都可以作为交互式示例在 LINQPad 中运行。阅读本书时使用这些示例可以加快你的学习进度。在 LINQPad 中编辑、执行这些示例可以立即看到结果，无须在 Visual Studio 中建立项目和解决方案。

若要在 LINQPad 中下载这些示例，请单击 Samples 选项卡，然后单击「Download more samples」。

### 2.1 第一个 C# 程序

以下程序计算 12 乘以 30，并将结果 360 打印到屏幕上。双斜线「//」表示其后的内容是注释：

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleAppNetFramework
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int x = 12 * 30;
            Console.WriteLine(x);
        }
    }
}
```

该程序的核心是以下两个语句：

```cs
int x = 12 * 30;
Console.WriteLine (x);
```

在 C# 中，语句按顺序执行，每条语句都以分号（或者代码块，详见本章后续内容）结尾。第一条语句计算表达式 12*30 的值，并把结果存储到一个局部变量 x 中，该变量是一个整数类型。第二条语句调用 Console 类的 WriteLine 方法，将变量 x 的值输出到屏幕上的文本窗口中。

方法完成由一系列语句（称为语句块）指定的行为。语句块由一对大括号及其中的零条或者多条语句组成。以下示例定义了一个名为 Main 的方法：

```cs
static void Main()
{  ... }
```

编写高层函数来调用低层函数可令程序得到简化。下面来重构该程序，使用一个可重用的方法来计算某个整数乘以 12：

```cs
namespace ConsoleAppNetFramework
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(FeetToInches(30));
            Console.WriteLine(FeetToInches(100));
        }

        static int FeetToInches(int feet)
        {
            int inches = feet * 12;
            return inches;
        }
    }
}
```

方法可以通过参数来接收调用者输入的数据，并通过指定的返回类型向调用者返回输出数据。上述代码中定义了一个 FeetToInches 方法，该方法有一个用于输入英尺的参数和一个用于输出英寸的返回类型：

```cs
static int FeetToInches (int feet) 
{...}
```

示例中的字面量 30 和 100 是传递给 FeetToInches 方法的实际参数。而 Main 方法后的括号是空的，因为没有任何参数。其返回类型是 void，说明它不向调用者返回任何值：

C# 将 Main 方法作为程序执行的默认入口点。Main 方法也可以返回整数值（而非 void），从而将其返回给程序的执行环境（非 0 返回值往往代表一个错误）。Main 方法还可以接受一个字符串数组作为参数（数组中包含了传递给可执行程序的任何实际参数）。例如：

```cs
static int Main (string[] args) {...}
```

数组（例如 string []）是固定数量的某种特定类型元素的集合。数组由元素类型和它后面的方括号指定。相关内容将在 2.7 节介绍。

Main 方法可以在异步编程中声明为 async 并返回 Task 或 `Task<int>` 对象，详情请参见第 14 章。

方法是 C# 中诸多种类的函数之一。另一种函数是我们用来执行乘法运算的「`*`」运算符。其他的函数种类还包括构造器、属性、事件、索引器和终结器。

本例将两个方法组合到一个类中。类由函数成员和数据成员组成，并形成面向对象的构件块。Console 类将处理命令行输入 / 输出（I/O）功能的成员（例如 WriteLine 方法）聚集在一起。Test 类则由 Main 方法和 FeetToInches 两个方法组成。类也是一种类型，将在 2.3 节中介绍。

程序的最外层将类型组织到了命名空间中。为了使 System 命名空间在应用程序中生效，并能够使用 Console 类，需要使用 using 指令。应将所有的类定义在 TestPrograms 命名空间中，例如：

```cs
using System;

namespace TestPrograms 
{ 
class Test
{...} 

class Test2
{...}}
```

.NET Core 库由若干嵌套的命名空间组织而成。例如，以下命名空间中包含处理文本的类型：

```cs
using System.Text;
```

使用 using 指令仅仅是为了方便，也可以使用命名空间加类型名称（例如 System.Text.StringBuilder）这种完整限定名称来引用类型。

#### 2.1.1 编译

C# 编译器将一系列.cs 扩展名的源代码文件编译成程序集（assembly）。程序集是.NET 中的最小打包和部署单元。程序集可以是一个应用程序或者是一个库。普通的控制台程序或 Windows 应用程序包含一个 Main

方法（即入口点），而库则没有。库可以被应用程序或其他的库调用（或引用）。.NET Core 就是由一系列程序集（及其运行时环境）组成的。

和.NET Framework 不同，.NET Core 程序集并没有.exe 后缀。.NET Core 应用程序构建后生成的.exe 文件只是一个和平台相关的、负责启动应用程序的.dll 程序集的原生加载器。

.NET Core 还支持创建自包含部署。它包含加载器、程序集以及.NET Core 框架本身，而这些内容均包含在一个.exe 文件中。

dotnet 工具（Windows 下则为 dotnet.exe）是一个用于管理.NET 源代码和二进制文件的命令行工具。该工具像集成开发环境（例如 Visual Studio 和 Visual Studio Code）那样，既可用于构建程序，也可用于启动程序。

dotnet 工具可通过安装.NET Core SDK 或安装 Visual Studio 获得。其默认安装位置在 Windows 操作系统上位于 % ProgramFiles%\dotnet，在 Ubuntu Linux 上位于 /usr/bin/dotnet。

dotnet 工具在编译应用程序时需要一个工程文件及一个或者多个 C# 代码文件。以下命令将创建一个控制台应用程序的基本结构：

```
dotnet new Console -n MyFirstProgram
```

上述命令将创建名为 MyFirstProgram 的子目录，并在其中创建名为 MyFirstProgram.csproj 的工程文件以及包含 Main 方法的 Program.cs 代码文件。其中 Main 方法将在控制台输出「Hello，World」。

在 MyFirstProgram 目录执行以下命令将构建并运行上述应用程序：

```
dotnet run MyFirstProgram
```

如果仅仅希望构建应用程序，但不运行，则可以执行以下代码：

```
dotnet build MyFirstProgram.csproj
```

构建生成的程序集将保存在 bin\debug

子目录下。

我们将在第 18 章详细介绍程序集。

### 2.2 语法

C# 的语法基于 C 和 C++ 语法。本节将使用下面的程序介绍 C# 的语法元素：

```cs
using System;

class Test 
{ 
static void Main() {  int x = 12 * 30;  Console.WriteLine (x); }
}
```

#### 2.2.1 标识符和关键字

标识符是程序员为类、方法、变量等选择的名字。下面按顺序列出了上述示例中的标识符：

```cs
System  Test  Main  x  Console  WriteLine
```

标识符必须是一个完整的词，它由以字母和下划线开头的 Unicode 字符构成。C# 标识符是区分大小写的。通常约定参数、局部变量以及私有字段应该以小写字母开头（例如 myVariable），而其他类型的标识符则应该以大写字母开头（例如 MyMethod）。

关键字是对编译器有特殊意义的名字。以下是示例中用到的关键字：

```cs
using  class  static  void  int
```

大部分关键字是保留的，这意味着它们不能用作标识符。以下列出了 C# 中的所有关键字：

避免冲突

如果希望用保留的关键字作为标识符，需在关键字前面加上 @ 前缀。例如：

```cs
class class {...}   // Illegal

class @class {...}   // Legal
```

@ 并不是标识符的一部分，所以 @myVariable 和 myVariable 是一样的。

@ 前缀在调用使用其他拥有不同关键字的 .NET 语言编写的库时非常有用。

上下文关键字

一些关键字是上下文相关的，它们有时不用添加 @ 前缀就可以用作标识符。它们是：

使用上下文关键字作为标识符时，应避免与上下文中的关键字混淆。

#### 2.2.2 字面量、标点与运算符

字面量在语法上是指嵌入程序中的原始数据片段。上述示例中用到的字面量有 12 和 30。

标点有助于划分程序结构。以下是示例中用到的标点：

```cs
{  }  ;
```

大括号可将多条语句组合成一个语句块。

分号用于结束一条语句（但语句块并不需要使用分号）。这意味着语句也可以放在多行中：

```cs
Console.WriteLine
    (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);
```

运算符用于改变和结合表达式。大多数 C# 运算符都以符号表示，例如乘法运算符 `*`。我们将在本章后续内容中详细介绍运算符。上述示例中出现的运算符有：

```cs
. ()  *  =
```

点号（.）表示某个对象的成员（或者数字字面量的小数点）。括号在声明或调用方法时使用；空括号在方法没有参数时使用（本章后续还会介绍括号的其他用途）。等号用于赋值操作（双等号 == 用于相等比较，请参见本章后续内容）。

#### 2.2.3 注释

C# 提供了两种不同形式的源代码文档：单行注释和多行注释。单行注释由双斜线开始，到本行结束为止。例如：

```cs
int x = 3;  // Comment about assigning 3 to x
```

多行注释由 `/*` 开始，到 `*/` 结束。例如：

```cs
int x = 3;  /
* This is a comment that
spans two lines */
```

注释也可以嵌入 XML 文档标签中，我们将在 4.19 节中介绍。

### 2.3 类型基础

类型是值的蓝图。以下示例使用了两个 int 类型的字面量 12 和 30，并声明了一个 int 类型的变量 x：


```cs
static void Main()
{ 
    int x = 12 * 30;
    Console.WriteLine(x);
}
```

变量表示一个存储位置，其中的值可能会不断变化。与之对应，常量总是表示同一个值（后面会详细介绍）：

```cs
const int y = 360;
```

C# 中的所有值都是某一种类型的实例。值或者变量所包含的可能取值均由其类型决定。

#### 2.3.1 预定义类型示例

预定义类型是指那些由编译器特别支持的类型。int 就是一种预定义类型，它代表一系列能够存储在 32 位内存中的整数，其范围为 `-2^31～2^31-1`，并且它是该范围内数字字面量的默认类型。我们能够对 int 类型的实例执行算术运算等功能：

```cs
int x = 12 * 30;
```

C# 中的另一个预定义类型是 string。string 类型表示字符序列，例如「.NET」或者「http://oreilly.com」。我们可以通过以下方式调用函数来操作字符串：

```cs
string message = "Hello world";

string upperMessage = message.T

oUpper();Console.WriteLine (upperMessage

);        // HELLO WORLDint x = 2015;message = message + x.ToString(

);Console.WriteLine (message);

// Hello world2015
```

预定义类型 bool 只有两种值：true和 false。bool 类型通常与 if 语句一起控制条件分支执行流程。例如：

```cs
bool simpleVar = false;
if (simpleVar) 
    Console.WriteLine ("This will not print");
int x = 5000;
bool lessThanAMile = x < 5280;
if (lessThanAMile) 
    Console.WriteLine ("This will print");
```

在 C# 中，预定义类型（也称为内置类型）拥有相应的 C# 关键字。在 .NET Core 的 System 命名空间下也包含很多不是预定义类型的重要类型（例如 DateTime）。

#### 2.3.2 自定义类型示例

我们能使用简单函数来构造复杂函数，同样也可以使用基元类型来构建复杂类型。以下示例定义了一个名为 UnitConverter 的自定义类型。这个类将作为单位转换的蓝图：

```cs
using System;

public class UnitConverter
{
    // Field 
    int ratio;  
    // Constructor 
    public UnitConverter(int unitRatio) 
    {
        ratio = unitRatio;
    }
    // Method
    public int Convert(int unit)
    {
        return unit * ratio;
    } 
 }
class Test
{ 
    static void Main()
    {
        UnitConverter feetToInchesConverter = new UnitConverter(12); 
        UnitConverter milesToFeetConverter = new UnitConverter(5280); 
        Console.WriteLine(feetToInchesConverter.Convert(30)); 
        Console.WriteLine (feetToInchesConverter.Convert(100));
        Console.WriteLine (feetToInchesConverter.Convert(milesToFeetConverter.Convert(1)));   
    }
}
```

类型的成员类型包含数据成员和函数成员。UnitConverter 的数据成员是 ratio 字段，函数成员是 Convert 方法和 UnitConverter 的构造器。

预定义类型和自定义类型

C# 的优点之一是其中的预定义类型和自定义类型非常相近。预定义 int 类型是整数的蓝图。它保存 32 位的数据，提供像 ToString 这种函数成员来使用这些数据。类似地，我们自定义的 UnitConverter 类型也是单位转换的蓝图。它保存比率数据，并提供函数成员来使用这些数据。

构造器和实例化

将类型实例化即可创建数据。预定义类型可以简单地通过字面量进行实例化，例如 12 或 "Hello World"。而自定义类型则需要使用 new 运算符来创建实例。以下语句创建并声明了一个 UnitConverter 类型的实例：

```cs
UnitConverter feetToInchesConverter = new UnitConverter (12);
```

使用 new 运算符后会立刻实例化一个对象，调用对象的构造器进行初始化。构造器的定义类似于方法，不同的是方法名和返回类型简化为所属的类型名称：

```cs
public class UnitConverter
{ 
... 
public UnitConverter (int unitRatio) { ratio = unitRatio; }
...
}
```

实例与静态成员

由类型的实例操作的数据成员和函数成员称为实例成员。UnitConverter 的 Convert 方法和 int 的 ToString 方法就是实例成员的例子。在默认情况下，成员就是指实例成员。

那些不是由类型的实例操作，而是由类型本身操作的数据成员和函数成员必须标记为 static。Test.Main 和 Console.WriteLine 就是静态方法。事实上，Console 类是一个静态类，它的所有成员都是静态的。Console 类型无法实例化，因此控制台将在整个应用程序内共享使用。

我们来对比实例成员和静态成员。在下面的代码中，实例字段 Name 属于特定的 Panda 实例，而 Population 则属于所有 Pand实例：

```cs
public class Panda 
{
    // Instance field 
    public string Name; 
    // Static field
    public static int Population;
    // Constructor
    public Panda (string n) 
    {
        // Assign the instance field 
        Name = n;
        // Increment the static Population field
        Population = Population + 1;
    }
}
```

下面的代码创建了两个 Panda 实例，先打印它们的名字，再打印总数：

```cs
using System;

class Test 
{
    static void Main() 
    {
    Panda p1 = new Panda ("Pan Dee");
    Panda p2 = new Panda ("Pan Dah");
    Console.WriteLine (p1.Name); 
    Console.WriteLine (p2.Name);
    Console.WriteLine (Panda.Population);
    }
}
```

1『上面的例子里，Panda.Population，无论是静态属性还是静态方法，都可以直接用类名 Panda 来调用，无需实例化一个对象。（2022-04-03）』

如果试图求 p1.Population 或者 Panda.Name 的值，则会生成一个编译时错误。

public 关键字

public 关键字将成员公开给其他类。在上述示例中，如果 Panda 类中的 Name 字段没有标记为公有（public）的，那么它就是私有的，且 Test 类就不能访问它。将成员标记为 public 就是类型的通信手段：「这就是我想让其他类型看到的，而其他的都是我私有的实现细节。」在面向对象的术语中，类的公有成员封装了私有成员。

#### 2.3.3 转换

C# 可以转换兼容类型的实例。转换始终会根据一个已经存在的值创建一个新的值。转换可以是隐式的也可以是显式的：隐式转换自动发生而显式转换需要强制转换。在下面的示例中，我们把一个 int 隐式地转换为 long 类型（其存储位数是 int 的两倍），并将一个 int 显式地转换为一个 short 类型（其存储位数是 int 的一半）：

```cs
int x = 12345;    // int is a 32-bit integer

long y = x;     // Implicit conversion to 64-bit 

integershort z = (short)x; // Explicit conversion to 16-bit integer
```

隐式转换只有在以下条件都满足时才能进行：

1、编译器能确保转换总能成功。

2、没有信息在转换过程中丢失。

相对地，只要满足下列条件之一就需要显式转换：

1、编译器不能保证转换总是成功。

2、信息在转换过程中有可能丢失。

如果编译器可以确定某个转换一定会失败，那么这两种转换都无法执行。包含泛型的转换在特定情况下也会失败，请参见 3.9.11 节。

以上的数值转换是 C# 中内置的。C# 还支持引用转换、装箱转换（见第 3 章）与自定义转换（见 4.16 节）。对于自定义转换，编译器并没有强制要求上述规则，因此没有良好设计的类型有可能在转换时出现意想不到的效果。

#### 2.3.4 值类型与引用类型

所有的 C# 类型可以分为以下几类：1）值类型。2）引用类型。3）泛型参数。4）指针类型。

本节将介绍值类型和引用类型。泛型参数将在 3.9 节介绍，指针类型将在 4.17 节中介绍。

值类型。包含大多数的内置类型（具体包括所有数值类型、char 类型和 bool 类型）以及自定义的 struct 类型和 enum 类型。

引用类型。包含所有的类、数组、委托和接口类型（这其中包括了预定义的 string 类型）。

值类型和引用类型最根本的不同在于它们在内存中的处理方式。

值类型

值类型的变量或常量的内容仅仅是一个值。例如，内置的值类型 int 的内容是 32 位的数据。

可以通过 struct 关键字定义自定义值类型（参见图 2-1）：

```cs
public struct Point { public int X; public int Y; }
```

或采用更简短的形式：

```cs
public struct Point { public int X, Y; }
```

图 2-1：内存中的值类型实例

值类型实例的赋值总是会进行实例复制。例如：

```cs
static void Main() 
{ 
    Point p1 = new Point();
    p1.X = 7;
    Point p2 = p1;
    Console.WriteLine (p1.X); 
    Console.WriteLine (p2.X);
    p1.X = 9;
    Console.WriteLine (p1.X); 
    Console.WriteLine (p2.X);
}
```

图 2-2 中展示了 p1 和 p2 拥有不同的存储空间。

图 2-2：赋值操作复制了值类型的实例

引用类型

引用类型比值类型复杂，它由两部分组成：对象和对象引用。引用类型变量或常量中的内容是一个含值对象的引用。以下示例重写了前面例子中的 Point 类型，令其成为一个类而非 struct （参见图 2-3）：

```cs
public class Point { public int X, Y; }
```

图 2-3：内存中的引用类型实例

给引用类型变量赋值只会复制引用，而不会复制对象实例。这允许不同的变量指向同一个对象，而值类型通常不会出现这种情况。如果 Point 是一个类，那么若重复之前的示例，则对 p1 的操作就会影响 p2：

```cs
static void Main() 
{ 
    Point p1 = new Point();
    p1.X = 7;
    
    Point p2 = p1;
    
    Console.WriteLine (p1.X); 
    Console.WriteLine (p2.X);
    
    p1.X = 9;
    
    Console.WriteLine (p1.X); 
    Console.WriteLine (p2.X);
}
```

图 2-4 展示了 p1 和 p2 是指向同一对象的两个不同引用。

图 2-4：赋值操作复制了引用

null

引用可以用字面量 null 来赋值，表示它并不指向任何对象：

```cs
class Point {...} 
...

Point p = null; 
// True
Console.WriteLine (p == null);

// The following line generates a runtime error 
// (a NullReferenceException is thrown): 
Console.WriteLine (p.X);
```

C# 8 引入了一个新的特性来避免意外发生 NullReferenceException 错误。更多详细信息请参见 4.8 节。

相对地，值类型通常不能为 null：

```cs
struct Point {...} 
...

// Compile-time error 
Point p = null; 
// Compile-time error
int x = null;

```

C# 中也有一种可令值类型为 null 的结构，称为可空（nullable）值类型（请参见 4.7 节）

存储开销

值类型实例占用的内存大小就是存储其字段所需的内存。例如，Point 需要占用 8 字节的内存：

```cs
struct Point 
{
    int x; // 4 bytes
    int y; // 4 bytes 
}
```

从技术上说，CLR 用整数倍字段的大小（最大到 8 字节）来分配内存地址。因此，下面定义的对象实际上会占用 16 字节的内存（第一个字段的 7 个字节被「浪费了」）：

```cs
struct A { byte b; long l; }
```

这种行为可以通过指定 StructLayout 属性来重写（请参见 25.6 节）。

引用类型要求为引用和对象单独分配存储空间。对象除占用和字段一样的字节数外，还需要额外的管理空间开销。管理开销的精确值本质上属于 .NET 运行时实现的细节，但最少也需要 8 个字节来存储该对象的类型的键以及一些临时信息（如线程锁的状态及是否可以被垃圾回收器固定等）。根据 .NET 运行时是工作在 32 位还是 64 位平台上，每一个对象的引用都需要额外的 4 或 8 个字节的存储空间。

#### 2.3.5 预定义类型分类

C# 中的预定义类型有：

值类型：

数值

有符号整数（sbyte、short、int、long）

无符号整数（byte、ushort、uint、ulong）

实数（float、double、decimal）

逻辑值（bool）

字符（char）

引用类型：

字符串（string）

对象（object）

C# 的预定义类型又称为 .NET Core 类型，位于 System 命名空间。因而以下两个语句仅在拼写上有所不同：

```cs
int i = 5;

System.Int 32 i = 5;
```

在 CLR 中，除了 decimal 之外的一系列预定义值类型属于基元类型。之所以称为基元类型，是因为它们在编译过的代码中有直接的指令支持，而这种指令通常翻译为底层处理器直接支持的指令。例如：

```cs
// Underlying hexadecimal representation 
// 0x7 
int i = 7;
// 0x1 
bool b = true;
// 0x41 
char c = 'A';
// uses IEEE floating-point encoding
float f = 0.5f;
```

System.IntPtr 和 System.UIntPtr 类型也是基元类型（参见第 25 章）。

### 2.4 数值类型

表 2-1 中列出了 C# 中所有的预定义数值类型。

表 2-1：C# 中的预定义数值类型

在整数类型中，int 和 long 是最基本的类型，C# 和运行时都对其有良好的支持。其他的整数类型通常用于实现互操作性或存储空间使用效率要求更高的情况。

在实数类型中，float 和 double 称为浮点类型，并通常用于科学和图形计算。decimal 类型通常用于金融计算这种十进制下的高精度算术运算。

#### 2.4.1 数值字面量

整数类型字面量

可以使用十进制或者十六进制表示，十六进制使用 0x 作为前缀。例如：

```cs
int x = 127;

long y = 0x7F;
```

从 C# 7 开始，可以在数值字面量的任意位置加入下划线以方便阅读：

```cs
int million = 1_000_000;
```

C# 7 及后续版本还可以用 0b 前缀使用二进制表示数值：

```cs
var b = 0b1010_1011_1100_1101_1110_1111;
```

实数字面量

可以用小数或指数表示，例如：

```cs
double d = 1.5;

double million = 1E06;
```

数值字面量类型推断

默认情况下，编译器将数值字面量推断为 double 类型或是整数类型：

如果字面量包含小数点或者指数符号（E），那么它是 double。否则，字面量的类型就是下列能匹配这个字面量的第一个类型：int、uint、long 和 ulong。

例如：

```cs
Console.WriteLine ( 1.0.GetType()); 
Console.WriteLine ( 1E06.GetType()); 
Console.WriteLine ( 1.GetType()); 
Console.WriteLine ( 0xF0000000.GetType());
Console.WriteLine (0x100000000.GetType());
```

数值后缀

数值后缀显式地定义了字面量的类型。后缀可以是小写或大写字母：

一般 U 和 L 后缀很少使用，因为 uint、long 和 ulong 总是可以推断出来或者从 int 类型隐式地转换过来：

```cs
long i = 5;   // Implicit lossless conversion from int literal to long
```

从技术上讲，后缀 D 是多余的，因为所有带小数点的字面量都会推断为 double 类型，可以直接在数值字面量后加上小数点：

```cs
double x = 4.0;
```

后缀 F 和 M 最有用，并应该在指定 float 或 decimal 字面量时使用。如果没有后缀 F，下面的语句将不能编译，因为 4.5 会被认定为 double，而 double 是无法隐式地转换为 float 的：

```cs
float f = 4.5F;
```

同样的规则也适用于 decimal 字面量：

```cs
decimal d = -1.23M;   // Will not compile without the M suffix.
```

我们将在下一节详细介绍数值转换的语义。

#### 2.4.2 数值转换

整数类型到整数类型的转换

整数类型转换在目标类型能够表示源类型的所有可能值时是隐式转换，否则需要显式转换。例如：

```cs
int x = 12345;    // int is a 32-bit integer

long y = x;     // Implicit conversion to

64-bit integral typeshort z = (short)x; // Explicit conversion to

16-bit integral type
```

浮点类型到浮点类型的转换

double 能表示所有可能的 float 值，因此 float 能隐式地转换为 double。反之，则必须是显式转换。

浮点类型和整数类型的转换

所有整数类型都可以隐式地转换为浮点数类型：

```cs
int i = 1;

float f = i;
```

反之，则必须是显式转换：

```cs
int i2 = (int)f;
```

将浮点数转换为整数时，小数点后的数值将被截去而不会舍入。静态类 System.Convert 提供了在不同值类型之间转换的舍入方法（见第 6 章）。

将大的整数类型隐式地转换为浮点类型会保留数值部分，但是有时会丢失精度。这是因为浮点类型虽然拥有比整数类型更大的数值，但是有时其精度却比整数类型要小。以下代码用一个更大的数重复上述示例展示了这种精度丢失的情况：

```cs
int i1 = 100000001;

float f = i1;

int i2 = (int)f;

// Magnitude preserved, precision lost // 100000000
```

decimal 类型转换

所有的整数类型都能隐式地转换为 decimal 类型，因为 decimal 可以表示所有可能的 C# 整数类型值。其他所有的数值类型转换为 decimal 或从 decimal 类型进行转换都必须是显式的转换，因为这些转换要么数值可能超越边界，要么可能发生精度损失。

#### 2.4.3 算术运算符

算术运算符（+、-、*、/、%）可应用于除 8 位和 16 位整数类型之外的所有数值类型：

```
+  Addition

-  Subtract

ion*  Multipli

cation/  Division

%  Remainder after division
```

#### 2.4.4 自增和自减运算符

自增和自减运算符（++、--）分别给数值类型加 1 或者减 1。具体要将其放在变量之前还是之后，则取决于需要得到变量在自增 / 自减之前的值还是之后的值。例如：

```cs
int x = 0, y = 0;

Console.WriteLine (x++); 
Console.WriteLine (++y);

// Outputs 0; x is now 1 
// Outputs 1; y is now 1
```

#### 2.4.5 特殊整数类型运算

整数类型指 int、uint、long、ulong、short、ushort、byte 和 sbyte。

整数除法

整数类型的除法运算总是会截断余数（向 0 舍入）。用一个值为 0 的变量作除数将产生运行时错误（DivideByZeroException）：

```cs
int a = 2 / 3;

int b = 0;

int c = 5 / b;

// 0

// throws DivideByZeroException
```

用字面量或常量 0 作除数将产生编译时错误。

整数溢出

在运行时执行整数类型的算术运算可能会造成溢出。默认情况下，溢出会默默地发生而不会抛出任何异常，且其溢出行为是「周而复始」的，就像是运算发生在更大的整数类型上，而将超出部分的进位丢弃后继续运算一样。例如，减小最小的整数值将产生最大的整数值：

```cs
int a = int.MinValue; 
a--; 
Console.WriteLine (a == int.MaxValue); // True
```

整数运算溢出检查运算符

checked 运算符的作用是：在运行时当整数类型表达式或语句超过相应类型的算术限制时不再默默地溢出，而是抛出 OverflowException。checked运算符可在有 ++、--、+、-（一元运算符和二元运算符）、*、/ 和整数类型间显式转换运算符的表达式中起作用。溢出检查会带来微小的性能损失。

checked 运算符对 double 和 float 类型没有作用（它们会溢出为特殊的「无限」值，这会在后面介绍），对 decimal 类型也没有作用（这种类型总是会进行溢出检查）。

checked 运算符既可以包裹表达式，也能够包裹语句块，例如：

```cs
int a = 1000000;
int b = 1000000;
int c = checked (a * b);

// Checks just the expression.
// Checks all expressions 
// in statement block.

checked 
{ 
...
c = a * b;
...
}
```

在编译时打开 checked 开关（在 Visual Studio 中，可以在「Advanced Build Settings」中设置）将使程序在默认情况下对所有表达式都进行算术溢出检查。如果你只想禁用指定表达式或语句的溢出检查，可以用 unchecked 运算符来实现。例如，下面的代码即使在编译时打开了 checked 开关也不会抛出异常：

```cs
int x = int.MaxValue;
int y = unchecked (x + 1); 
unchecked { int z = x + 1; }
```

常量表达式的溢出检查

无论是否打开了 checked 工程选项，编译时的表达式计算总会检查溢出，除非应用了 unchecked 运算符。

```cs
int x = int.MaxValue + 1;        // Compile-time error

int y = unchecked (int.MaxValue + 1);  // No errors
```

位运算符

C# 支持以下的位运算符：

#### 2.4.6 8 位和 16 位整数类型

8 位和 16 位整数类型指 byte、sbyte、short、ushort。这些类型自己并不具备算术运算符，所以 C# 隐式地将它们转换为所需的更大一些的类型。当试图把运算结果赋给一个小的整数类型时会产生编译时错误：

```cs
short x = 1, y = 1;

short z = x + y;

// Compile-time error
```

在以上示例中，x 和 y 会隐式地转换成 int 以便进行加法运算。因此运算结果也是 int，它不能隐式地转换回 short（因为这可能会造成数据丢失）。必须使用显式转换才能令其通过编译：

```cs
short z = (short) (x + y);  // OK
```

#### 2.4.7 特殊的 float

和 double 值不同于整数类型，浮点类型包含某些特定运算需要特殊对待的值。这些特殊的值是 NaN（Not a Number，非数字）、+∞、-∞和 - 0。float 和 double 类型包含表示 NaN、+∞、-∞值的常量，其他的常量还有 MaxValue、MinValue 以及 Epsilon。例如：

```cs
Console.WriteLine (double.NegativeInfinity);  // -Infinity
```

double 和 float 类型的特殊值的常量表如下：

非零值除以零的结果是无穷大：

```cs
Console.WriteLine ( 1.0 / 0.0);         // Infinity

Console.WriteLine (−1.0 / 0.0);         // -Infinity

Console.WriteLine ( 1.0 / −0.0);         // -Infinity

Console.WriteLine (−1.0 / −0.0);         // Infinity
```

零除以零或无穷大减去无穷大的结果是 NaN：

```cs
Console.WriteLine ( 0.0 / 0.0);         // NaN

Console.WriteLine ((1.0 / 0.0) − (1.0 / 0.0));  // NaN
```

使用相等比较运算符（==）时，一个 NaN 值永远也不等于其他的值，甚至不等于其他的 NaN 值：

```cs
Console.WriteLine (0.0 / 0.0 == double.NaN);  // False
```

必须使用 float.IsNaN 或 double.IsNaN 方法来判断一个值是否为 NaN：

```cs
Console.WriteLine (double.IsNaN (0.0 / 0.0));  // True
```

但使用 object.Equals 方法时，两个 NaN 值却是相等的：

```cs
Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));  // True
```

NaN 在表示特殊值时很有用。在 Windows Presentation Foundation（WPF）中，double.NaN 表示值为「自动」（Automatic）。另一种表示方法是使用可空值类型（见第 4 章）；还可以使用一个包含数值类型和一个额外字段的自定义结构体（见第 3 章）。

2『 NaN 的使用场景，做一张任意卡片。（2022-04-05）』—— 已完成

float 和 double

遵循 IEEE 754 格式类型规范，几乎所有的处理器都原生支持此规范。如需此类型行为的详细信息，可参考 IEEE 官方网站（http://www.ieee.org/）。

#### 2.4.8 double

和 decimal 的对比

double 类型常用于科学计算（例如计算空间坐标）。decimal 类型常用于金融计算以及计算那些「人为」的而非真实世界度量的结果。以下是这两种类型的不同之处：

#### 2.4.9 实数的舍入误差

float 和 double

都是基于 2 来表示数值的。因此只有基于 2 表示的数值才能够精确表示。事实上，这意味着大多数有小数部分的字面量（它们都基于 10）将无法精确表示。例如：

```cs
float tenth = 0.1f;            // Not quite 0.1

float one  = 1f;Console.WriteLine (one - tenth * 10f);  // -1.490116E-08
```

这就是为什么 float 和 double 不适合金融运算。相反，decimal 基于 10，它能够精确表示基于 10 的数值（也包括它的因数，基于 2 和基于 5 的数值）。因为实数的字面量都是基于 10 的，所以 decimal 能够精确表示像 0.1 这样的数。然而，double 和 decimal 都不能精确表示那些基于 10 的循环小数：

```cs
decimal m = 1M / 6M;        // 0.1666666666666666666666666667M

double d = 1.0 / 6.0;       // 0.16666666666666666
```

这将会导致积累性的舍入误差：

```cs
decimal notQuiteWholeM = m+m+m+m+m+m; // 1.0000000000000000000000000002M

double notQuiteWholeD = d+d+d+d+d+d; // 0.99999999999999989
```

这也将影响相等和比较操作：

```cs
Console.WriteLine (notQuiteWholeM == 1M);  // False

Console.WriteLine (notQuiteWholeD < 1.0);  // True
```

### 2.5 布尔类型和运算符

C# 中的 bool（System.Boolean 的别名）类型是能赋值为 true 和 false 字面量的逻辑值。

尽管布尔类型的值仅需要 1 位的存储空间，但是运行时却使用了 1 字节内存空间。这是因为字节是运行时和处理器能够有效使用的最小单位。为避免在使用数组时的空间浪费，.NET 在 System.Collections 命令空间下提供了 BitArray 类，其中的每一个布尔值仅占用一位。

#### 2.5.1 布尔类型转换

bool 类型不能转换为数值类型，反之亦然。

#### 2.5.2 相等和比较运算符

== 和 != 用于判断任意类型的相等与不等，并总是返回一个 bool 值。值类型通常有很简单的相等定义：

```cs
int x = 1;

int y = 2;

int z = 1;

Console.WriteLine (x == y); 
Console.WriteLine (x == z);

// False 
// True
```

对于引用类型，默认情况下相等是基于引用的，而不是基于底层对象的实际值（更多内容请参见第 6 章）：

```cs
public class Dude 
{
public string Name;
public Dude (string n) { Name = n; } 
} 
...

Dude d1 = new Dude ("John");
Dude d2 = new Dude ("John");
Console.WriteLine (d1 == d2);
Dude d3 = d1;
Console.WriteLine (d1 == d3);

// False

// True
```

相等和比较运算符 ==、!=、<、>、>= 和 <= 可用于所有的数值类型，但是用于实数时要特别注意（请参见 2.4.9 节）。比较运算符也可以用于枚举（enum）类型的成员，它比较的是表示枚举成员的整数值，将在 3.7 节中介绍。

相等和比较运算符将在 4.16 节、6.11 节和 6.12 节中详细介绍。

#### 2.5.3 条件运算符

&& 和 || 运算符用于判断「与」和「或」条件。它们常常与代表「非」的！

运算符一起使用。在下面的例子中，UseUmbrella 方法在下雨或阳光充足（伞可以保护我们不会经受日晒雨淋），以及无风（因为伞在有风的时候不起作用）的时候返回 true：

```cs
static bool UseUmbrella (bool rainy, bool sunny, bool windy)
{ 
    return !windy && (rainy || sunny);
}
```

&& 和 || 运算符会在可能的情况下执行短路计算。在上面的例子中，如果刮风，(rainy || sunny) 将不会计算。短路计算在某些表达式中是非常必要的，它可以允许像下面这样的表达式运行而不会抛出 NullReferenceException：

```cs
if (sb != null && sb.Length > 0) ...
```

& 和 | 运算符也可用于判断「与」和「或」条件：

```cs
return !windy & (rainy | sunny);
```

不同之处是 & 和 | 运算符不支持短路计算，因此它们很少用于替代条件运算符。

与在 C 和 C++ 中不同，C# 中的 & 和 | 运算符在用于布尔表达式时执行布尔比较（非短路计算），仅在用于数值运算时才执行位运算。

（三元）条件运算符

三元条件运算符（由于它是唯一一个使用三个操作数的运算符，因此也称为三元运算符）使用 q ? a : b 的形式。它在 q 为真时计算 a，否则计算 b 。例如：

```cs
static int Max (int a, int b)
{
    return (a > b) ? a : b;
}
```

条件运算符在 LINQ 语句中尤其有用（见第 8 章）。

### 2.6 字符串和字符

C# 的 char（System.Char 的别名）类型表示一个 Unicode 字符并占用两个字节（UTF-16）。char 字面量应位于两个单引号之间：

```cs
char c = 'A';    // Simple character
```

转义序列指那些不能用字面量表示或解释的字符。转义序列由反斜线后跟一个表示特殊含义的字符组成，例如：

```cs
char newLine = '\n';

char backSlash = '\\';
```

表 2-2 中列出了转义序列字符。

表 2-2：转义序列字符

\u（或 \x）转义字符通过 4 位十六进制代码来指定任意 Unicode 字符：

```cs
char copyrightSymbol = '\u00A9';

char omegaSymbol = '\u03A9';

char newLine = '\u000A';
```

#### 2.6.1 char 转换

从 char 类型到数值类型的隐式转换只在这个数值类型可以容纳无符号 short 类型时有效。其他的数值类型则需要显式转换。

#### 2.6.2 字符串类型

C# 中的字符串类型（System.String 类型的别名，将在第 6 章详细介绍）表示不可变（创建之后即无法更改）的 Unicode 字符序列。字符串字面量应位于两个双引号（"）之间：

```cs
string a = "Heat";
```

string 类型是引用类型而不是值类型，但是它的相等运算符却遵守值类型的语义。

```cs
string a = "test";

string b = "test";

Console.Write (a == b); // True
```

对 char 字面量有效的转义字符在字符串中同样有效：

```cs
string a = "Here's a tab:\t";
```

这意味着当需要一个反斜线时，需要写两次才可以：

```cs
string a1 = "\\\\server\\fileshare\\helloworld.cs";
```

为避免这种情况，C# 引入了原意字符串字面量。原意字符串字面量要加 @ 前缀，它不支持转义字符。下面的原意字符串和之前的字符串是一样的。

```cs
string a2 = @"\\server\fileshare\helloworld.cs";
```

原意字符串可以贯穿多行：

```cs
string escaped = "First Line\r\nSecond Line"; 
string verbatim = @"First Line Second Line";

// True if your text editor uses CR-LF line separators: 
Console.WriteLine (escaped == verbatim);
```

原意字符串中需要用两个双引号来表示一个双引号字符：

```cs
string xml = @"<customer id=""123""></customer>";
```

2『原意字符，做一张术语卡片。（2022-04-07）』—— 已完成




字符串连接

`+` 运算符可连接两个字符串：

```cs
string s = "a" + "b";
```

如果操作数之一是非字符串值，则会调用其 ToString 方法：

```cs
string s = "a" + 5; // a5
```

重复使用 + 运算符来构建字符串效率较低。更高效的解决方案是使用 System.Text.StringBuilder 类型（将在第 6 章介绍）。

字符串插值

以 `$` 字符为前缀的字符串称为插值字符串。插值字符串可以在大括号内包含表达式：

```cs
int x = 4;

Console.Write ($"A square has {x} sides");
// Prints: A square has 4 sides
```

大括号内可以是任意类型的有效 C# 表达式。C# 会调用其 ToString 方法或等价方法将表达式转换为字符串。若要更改表达式的格式，可以使用冒号和一个格式字符串（将在 6.1.2 节中对其详细介绍）：

```cs
string s = $"255 in hex is {byte.MaxValue:X2}";     // X2 = 2-digit hexadecimal
// Evaluates to "255 in hex is FF"
```

插值字符串只能在单行内声明，除非使用原意字符串运算符。

```cs
int x = 2;

// Note that $ must appear before @ prior to C# 8: 
string s = $@"this spans { x} lines";
```

若要在插值字符串中表示大括号字符，只需书写两个大括号字符即可。

字符串比较

string 类型不支持使用「<」和「>」进行比较。必须使用字符串的 CompareTo 方法进行比较，这部分内容将在第 6 章介绍。

### 2.7 数组

数组是固定数量的特定类型的变量（称为元素）集合。为了实现高效访问，数组中的元素总是存储在连续的内存块中。

C# 中的数组用元素类型后加方括号的方式表示：

```cs
char[] vowels = new char[5];  // Declare an array of 5 characters
```

方括号也可用于通过索引检索数组，即通过位置访问特定的元素：

```cs
vowels[0] = 'a';

vowels[1] = 'e';

vowels[2] = 'i';

vowels[3] = 'o';

vowels[4] = 'u';

Console.WriteLin

e (vowels[1]);  // e
```

因为数组索引从 0 开始，所以上面的语句打印「e」。可以使用 for 循环语句来遍历数组中的每一个元素。下面的例子中的 for 循环将把整数变量 i 从 0 到 4 进行循环：

```cs
for (int i = 0; i < vowels.Length; i++)
    Console.Write (vowels[i]);  // aeiou
```

数组的 Length 属性返回数组中的元素数目。一旦数组创建完毕，它的长度将不能更改。System.Collection 命名空间和子命名空间提供了可变长度数组和字典等高级数据结构。

数组初始化表达式可以让你一次性声明并填充数组：

```cs
char[] vowels = new char[] {'a','e','i','o','u'};
```

或者简写为：

```cs
char[] vowels = {'a','e','i','o','u'};
```

所有的数组都继承自 System.Array 类，它为所有的数组提供通用服务。这些成员包括与数组类型无关的获取和设定数组元素的方法，将在 7.3 节介绍。

#### 2.7.1 默认数组元素初始化

创建数组时其元素总会用默认值初始化。类型的默认值是按位取 0 的内存表示的值。例如，若定义一个整数数组，由于 int 是值类型，因此该操作会在连续的内存块中分配 1 000 个整数。每一个元素的默认值都是 0：

```cs
int[] a = new int[1000];
Console.Write (a[123]);

// 0
```

值类型和引用类型的区别

数组元素的类型是值类型还是引用类型对其性能有重要的影响。若元素类型是值类型，每个元素的值将作为数组的一部分进行分配，例如：

```cs
public struct Point { public int X, Y; } 
...

Point[] a = new Point[1000];
int x = a[500].X;
// 0
```

若 Point 是类，创建数组则仅仅分配 1 000 个空引用：

```cs
public class Point { public int X, Y; } 
...

Point[] a = new Point[1000];
int x = a[500].X;
// Runtime error, NullReferenceException
```

为避免这个错误，必须在实例化数组之后显式实例化 1 000 个 Point 实例：

```cs
Point[] a = new Point[1000];

for (int i = 0; i < a.Length; i++) // Iterate i from 0 to 999
    a[i] = new Point();

// Set array element i with new point
```

不论元素是何种类型，数组本身总是引用类型对象。例如，下面的语句是合法的：

```cs
int[] a = null;
```

#### 2.7.2 索引和范围（C# 8）

C# 8 引入了索引和范围的概念以简化对数组元素或部分数组的操作。

索引和范围可以和 CLR 类型 `Span<T>` 与 `ReadOnlySpan<T>` 配合使用（请参见 5.4.16 节）。

自定义类型也可以通过定义类型为 Index 或 Range 的索引器来使用索引和范围（请参见 3.1.9 节）。

索引

索引使用 `^` 运算符从数组的末尾来引用数组元素。`^1` 代表最后一个元素而 `^2` 代表倒数第二个元素，依此类推（`^0` 等于数组的长度，因此 `vowels [^0]` 将会产生错误）。

```cs
char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement = vowels [^1]; 
char secondToLast = vowels [^2];
// 'u' 
// 'o'
```

类型实现了索引的功能，因此也可以使用如下方式来引用数组元素：

```cs
Index first = 0; Index last = ^1; 
char firstElement = vowels [first]; 
char lastElement = vowels [last];

// 'a' // 'u'
```

范围

范围使用 `..` 运算符得到数组的一个「切片」：

```cs
char[] firstTwo = vowels [..2];
char[] lastThree = vowels [2..];
// 'a', 'e' 
// 'i', 'o', 'u'
char[] middleOne = vowels [2..3]; // 'i'
```

注意，范围中的第二个数字是开区间的。因此 `..2` 表示返回 vowels [2] 之前的元素。

在范围中也可以使用 `^` 符号。例如，以下语句返回数组中的最后两个字符：

```cs
char[] lastTwo = vowels [^2..];   // 'o', 'u'
```

C# 的 Range 类型实现了范围的功能，因此可以用如下方式来操作范围：

```cs
Range firstTwoRange = 0..2;

char[] firstTwo = vowels [firstTwoRange]; // 'a', 'e'
```

#### 2.7.3 多维数组

多维数组分为两种类型：矩形数组和锯齿形数组。矩形数组代表 n 维的内存块，而锯齿形数组则是数组的数组。

矩形数组

矩形数组声明时使用逗号分隔每个维度。下面的语句声明了一个矩形二维数组，它的维度是 3×3：

```cs
int[,] matrix = new int[3,3];
```

数组的 GetLength 方法返回给定维度的长度（从 0 开始）：

```cs
for (int i = 0; i < matrix.GetLength(0); i++) 
    for (int j = 0; j < matrix.GetLength(1); j++)
        matrix[i,j] = i * 3 + j;
```

矩形数组可以显式地以具体值来初始化。以下示例创建了一个和上例一样的数组：

```xs
int[,] matrix = new int[,]
{ 
    {0,1,2}, {3,4,5}, {6,7,8}
};
```

锯齿形数组

锯齿形数组在声明时用一对方括号表示一个维度。以下例子声明了一个最外层维度是 3 的二维锯齿形数组：

```cs
int[][] matrix = new int[3][];
```

有趣的是，这里是 new int [3][] 而非 new int [][3]。Eric Lippert 有一篇精彩的文章（http://albahari.com/jagged）详细解释了这个问题。

不同于矩形数组，锯齿形数组内层维度在声明时并未指定，每个内层数组都可以是任意长度。每一个内层数组都隐式初始化为 null 而不是一个空数组，因此都需要手动创建：

```cs
for (int i = 0; i < matrix.Length; i++)
{
    // Create inner array
    matrix[i] = new int[3];
    for (int j = 0; j < matrix[i].Length; j++)
        matrix[i][j] = i * 3 + j;
}
```

锯齿形数组也可以用具体值进行初始化。以下例子创建了一个和前面例子类似的数组，并在最后额外追加了一个元素：

```cs
int[][] matrix = new int[][]
{ 
    new int[] {0,1,2}, 
    new int[] {3,4,5}, 
    new int[] {6,7,8,9}
};
```


#### 2.7.4 简化数组初始化表达式

有两种方式可以简化数组初始化表达式。第一种是省略 new 运算符和类型限制条件：

```cs
char[] vowels = {'a','e','i','o','u'};

int[,] rectangularMatrix ={ {0,1,2}, {3,4,5}, {6,7,8}};

int[][] jaggedMatrix ={ new int[] {0,1,2}, new int[] {3,4,5}, new int[] {6,7,8,9}};
```

第二种是使用 var 关键字，使编译器隐式确定局部变量类型：

```cs
var i = 3;
var s = "sausage";

// Therefore:
// i is implicitly of type int // s is implicitly of type string

// rectMatrix is implicitly of type int[,]
var rectMatrix = new int[,] {
{0,1,2},
{3,4,5},
{6,7,8} };

// jaggedMat is implicitly of type int[][]
var jaggedMat = new int[][] {
new int[] {0,1,2},
new int[] {3,4,5},
new int[] {6,7,8,9} };
```

数组类型可以进一步应用隐式类型转换规则：可以直接在 new 关键字之后忽略类型限定符，而由编译器推断数组类型：

```cs
var vowels = new[] {'a','e','i','o','u'};  // Compiler infers char[]
```

为了使上述机制工作，数组中的所有元素必须能够隐式转换为一种类型（至少有一个元素是目标类型，而且最终只有一种最佳类型），例如：

```cs
var x = new[] {1,10000000000};  // all convertible to long
```

#### 2.7.5 边界检查

运行时会为所有数组的索引操作进行边界检查。如果用了无效的索引，就会抛出 IndexOutOfRangeException。

```cs
int[] arr = new int[3];
// IndexOutOfRangeException thrown
arr[3] = 1;
```

数组边界检查对类型安全和调试简化都是非常必要的。

通常，边界检查的性能开销很小，且即时（Just-In-Time，JIT）编译器也会对其进行优化。例如，在进入循环之前预先确保所有的索引操作的安全性，从而避免每次循环中都进行检查。另外 C# 还提供了 unsafe 代码来显式绕过边界检查（参见 4.17 节）。

### 2.8 变量和参数

变量表示存储着可变值的存储位置。变量可以是局部变量、参数（value、ref、out 或 in），字段（实例或静态）以及数组元素。

#### 2.8.1 栈和堆

栈和堆是存储变量的地方。它们分别具有不同的生命周期语义。

栈

栈是存储局部变量和参数的内存块。从逻辑上讲，栈会在函数进入和退出时增加或减少。考虑下面的方法（为了避免干扰，这里省略了输入参数检查）：

```cs
static int Factorial (int x) 
{
    if (x == 0) return 1;
    return x * Factorial (x-1);
}
```

这个方法是递归的，即它调用其自身。每一次进入这个方法的时候，就在栈上分配一个新的 int，而每一次离开这个方法，就会释放一个 int。

堆

堆是保存对象（例如引用类型的实例）的内存块。新创建的对象会分配在堆上并返回其引用。程序执行过程中，堆就被新创建的对象不断填充。运行时的垃圾回收器会定期从堆上释放对象，因此应用程序才不会内存不足。只要对象没有被「存活」的对象引用，它就可以被释放。

以下例子中，首先创建了一个 StringBuilder 对象并将其引用赋值给 ref1 变量，之后在其中写入内容。StringBuilder 对象在后续没有使用的情况下可立即被垃圾回收器释放。

之后，创建另一个 StringBuilder 对象赋值给 ref2，再将引用复制给 ref3。虽然 ref2 之后便不再使用，但是由于 ref3 保持着同一个 StringBuilder 对象的引用，因此在 ref3 使用完毕之前它不会被垃圾回收器回收。

```cs
using System; 
using System.Text;

class Test 
{
    static void Main() 
    { 
        StringBuilder ref1 = new StringBuilder ("object1"); 
        Console.WriteLine (ref1); // The StringBuilder referenced by ref1 is now eligible for GC.
            
        StringBuilder ref2 = new StringBuilder ("object2"); 
        StringBuilder ref3 = ref2; // The StringBuilder referenced by ref2 is NOT yet eligible for GC.
            
        Console.WriteLine (ref3);
        // object2
    }

}
```

值类型的实例（和对象的引用）就存储在变量声明的地方。如果声明为类的字段或数组的元素，则该实例会存储在堆上。

C# 中无法像 C++ 那样显式删除对象。未引用的对象最终将被垃圾回收器回收。

静态字段也会存储在堆上。与分配在堆上的对象（可以被垃圾回收）不同，这些变量一直存活直至应用程序域结束。

#### 2.8.2 明确赋值

C# 强制执行明确赋值策略。在实践中，这意味着在 unsafe 上下文之外无法访问未初始化的内存。明确赋值有三种含义：

1、局部变量在读取之前必须赋值。

2、调用方法时必须提供函数的实际参数（除非标记为可选参数，参见 2.8.4 节）。

3、运行时将自动初始化其他变量（例如字段和数组元素）。

例如，以下示例将产生编译时错误：

```cs
static void Main() 
{
    int x;
    Console.WriteLine (x); 
}
```

字段和数组元素会自动初始化为其类型的默认值。以下代码输出 0，因为数组元素会隐式赋为默认值：

```cs
static void Main() 
{
    int[] ints = new int[2];
    Console.WriteLine (ints[0]);
    // 0
}
```

以下代码输出 0，因为字段会隐式赋值为默认值：

```cs
class Test 
{
    static int x;
    static void Main() 
    { 
        Console.WriteLine (x); 
    } 
}
```

#### 2.8.3 默认值

所有类型的实例都有默认值。预定义类型的默认值是按位取 0 的内存表示的值：

default 关键字可用于获取任意类型的默认值：

```cs
Console.WriteLine (default (decimal));  // 0
```

从 C# 7.1 开始，在可以进行类型推定的情况下无须指定类型信息：

```cs
decimal d = default;
```

自定义值类型（例如 struct）的默认值等同于每一个字段都取其默认值。

#### 2.8.4 参数

方法可以有一连串的参数。在调用方法时必须为这些参数提供实际值。在下面的例子中，Foo 方法仅有一个类型为 int 的参数 p：

```cs
static void Foo (int p) 
{
    p = p + 1;
    Console.WriteLine (p);
    // Increment p by 1 
    // Write p to screen
}

static void Main() { Foo (8); }
```

使用 ref、in 和 out 修饰符可以控制参数的传递方式：

按值传递参数

默认情况下，C# 中的参数默认按值传递，这是最常用的方式。这意味着在将参数值传递给方法时将创建一份参数值的副本：

```cs
class Test 
{
    static void Foo (int p) 
    {
        p = p + 1;
        Console.WriteLine (p);
        // Increment p by 1 
        // Write p to screen
    }
    
    static void Main() 
    {
        int x = 8;
        Foo (x); Console.WriteLine (x);
        // Make a copy of x 
        // x will still be 8
    }
}
```

为 p 赋一个新的值并不会改变 x 的内容，因为 p 和 x 分别存储在不同的内存位置。

按值传递引用类型参数复制的是引用而非对象本身。下例中，Foo 方法中的 String-Builder 对象和 Main 方法中实例化的是同一个对象，但是它们的引用是不同的。换句话说，变量 sb 和 fooSB 是引用同一个 StringBuilder 对象的不同变量：

```cs
class Test 
{
    static void Foo (StringBuilder fooSB) 
    {
        fooSB.Append ("test");
        fooSB = null; 
    }
    
    static void Main() 
    {
        StringBuilder sb = new StringBuilder();
        Foo (sb);
        Console.WriteLine (sb.ToString()); // test 
    }
}
```

由于 fooSB 是引用的一份副本，因此将它赋值为 null 并不会把 sb 也赋值为 null（然而，如果在声明和调用 fooSB 时使用 ref 修饰符，则 sb 会变成 null）。

```cs
class Test 
{
    static void Foo (StringBuilder fooSB) 
    {
        fooSB.Append ("test");
        fooSB = null; 
    }
    
    static void Main() 
    {
        StringBuilder sb = new StringBuilder();
        Foo (sb);
        Console.WriteLine (sb.ToString()); // test 
    }
}
```

ref 修饰符

在 C# 中，若按引用传递参数则应使用 ref 参数修饰符。在下面的例子中，p 和 x 指向同一块内存位置：

```cs
class Test 
{

    static void Foo (ref int p) 
    {
        p = p + 1;
        Console.WriteLine (p);
        // Increment p by 1 // Write p to screen
    }
    
    static void Main() 
    {
        int x = 8;
        Foo (ref x); 
        Console.WriteLine (x);
        // Ask Foo to deal directly with x 
        // x is now 9
    }

}
```

现在给 p 赋新值将改变 x 的值。注意，ref 修饰符在声明和调用时都是必需的，这样就清楚地表明了程序将如何执行。

ref 修饰符对于实现「交换」方法是必要的（3.9 节将介绍如何编写适用于所有类型的「交换」方法）：

```cs
class Test 
{

    static void Swap (ref string a, ref string b) 
    { 
        string temp = a;
        a = b;
        b = temp;
    }
    
    static void Main() 
    {
        string x = "Penn";
        string y = "Teller";
        Swap (ref x, ref y); 
        Console.WriteLine (x); 
        Console.WriteLine (y);
        // Teller 
        // Penn
    }

}
```

无论参数是引用类型还是值类型，都可以按引用传递或按值传递。

out 修饰符

out 参数和 ref 参数类似，但在以下几点上不同：

1、无须在传入函数之前进行赋值。

2、必须在函数结束之前赋值。

out 修饰符通常用于获得方法的多个返回值，例如：

```cs
class Test {

    static void Split (string name, out string firstNames, out string lastName) 
    {
        int i = name.LastIndexOf (' ');
        firstNames = name.Substring (0, i);
        lastName = name.Substring (i + 1);
    }
    
    static void Main() 
    { 
        string a, b; 
        Split ("Stevie Ray Vaughan", out a, out b); 
        Console.WriteLine (a); 
        Console.WriteLine (b); 
    }
    // Stevie Ray // Vaughan

}
```

与 ref 参数一样，out 参数按引用传递。

out 变量及丢弃变量

从 C# 7 开始，允许在调用含有 out 参数的方法时直接声明变量。因此可以将前面例子中的 Main 方法简化为：

```cs
static void Main() 
{
    Split ("Stevie Ray Vaughan", out string a, out string b);
    Console.WriteLine (a); // Stevie Ray
    Console.WriteLine (b); // Vaughan 
}
```

当调用含有多个 out 参数的方法时，若并不关注所有参数的值，那么可以使用下划线来「丢弃」那些不感兴趣的参数：

```cs
// Discard the 2nd param
Split ("Stevie Ray Vaughan", out string a, out _); 
Console.WriteLine (a);
```

此时，编译器会将下划线认定为一个特殊的符号，称为丢弃符号。一次调用可以包括多个丢弃符号。假设 SomeBigMethod 定义了 7 个 out 参数，除第 4 个之外其他的全部被丢弃：

```cs
SomeBigMethod (out _, out _, out _, out int x, out _, out _, out _);
```

出于向后兼容性的考虑，如果在作用域内已经有一个名为 [_] 的变量，这个语言特性就失效了。

```cs
string _; 
Split ("Stevie Ray Vaughan", out string a, out _); 
Console.WriteLine (_); // Vaughan
```

按引用传递的含义

按引用传递参数是为现存变量的存储位置起一个别名而不是创建一个新的存储位置。下面的例子中，变量 x 和 y 代表相同的实例：

```cs
class Test 
{ 

    static int x;
    static void Main() 
    { 
        Foo (out x); }
        static void Foo (out int y) { Console.WriteLine (x);
        y = 1;
        Console.WriteLine (x);
        // x is 0 // Mutate y // x is 1
    }

}
```

in 修饰符

in 参数和 ref 参数相似，但前者的参数值无法在方法内更改（如果更改则会产生一个编译时错误）。这个修饰符非常适用于向方法传递大型值类型对象，因为此时编译器不仅可以避免在参数传递时对参数进行拷贝操作而造成开销，还可以保护参数的原始值不被修改。

in 修饰符是重载的一个重要部分：

```cs
void Foo ( SomeBigStruct a) { ... } 
void Foo (in SomeBigStruct a) { ... }
```

若希望调用第二个重载方法，则调用者必须使用 in 修饰符。

```cs
SomeBigStruct x = ...; 
Foo (x); // Calls the first overload 
Foo (in x); // Calls the second overload
```

当调用不会造成歧义时：

```cs
void Bar (in SomeBigStruct a) { ... }
```

则 in 修饰符是可选的：

```cs
Bar (x);   // OK (calls the 'in' overload)
Bar (in x); // OK (calls the 'in' overload)
```

需要说明的是为了使上述示例有实际意义，我们将 SomeBigStruct 定义为 struct 类型（请参见 3.4 节）。

params 修饰符

params 参数修饰符只能修饰方法的最后一个参数，它能够使方法接受任意数量的指定类型参数。参数类型必须声明为数组，例如：

```cs
class Test 
{

    static int Sum (params int[] ints) 
    {
        int sum = 0;
        for (int i = 0; i < ints.Length; i++)
        sum += ints[i];
        // Increase sum by ints[i]
        return sum;
    } 
    
    static void Main() { Console.WriteLine (total); }
    int total = Sum (1, 2, 3, 4);
    // 10

}
```

也可以将普通的数组提供给 params 参数，因此 Main 方法的第一行从语义上等价于：

```cs
int total = Sum (new int[] { 1, 2, 3, 4 } );
```

可选参数

方法、构造器和索引器（见第 3 章）中都可以声明可选参数。只要在参数声明中提供默认值，这个参数就是可选参数：

```cs
void Foo (int x = 23) { Console.WriteLine (x); }
```

可选参数在调用方法时可以省略：

```cs
Foo();   // 23
```

默认参数 23 实际上传递给了可选参数 x，编译器在调用端将值 23 传递到编译好的代码中。上例中调用 Foo 的代码语义上等价于：

```cs
Foo (23);
```

这是由于编译器总是用默认值代替可选参数而造成的。

若 public 方法对其他程序集可见，则在添加可选参数时双方均需重新编译，就像参数是必须提供的一样。

可选参数的默认值必须由常量表达式或者无参数的值类型构造器指定，可选参数不能标记为 ref 或者 out。

必填参数必须在可选参数方法声明和调用之前出现（params 参数例外，它总是最后出现）。下面的例子将 1 显式传递给参数 x，而将默认值 0 传递给参数 y：

```cs
void Foo (int x = 0, int y = 0) { Console.WriteLine (x + ", " + y); }
// 1, 0
void Test(){ Foo(1);}
```

相反，如需传递默认值给 x 而传递显式值给 y，则必须联合使用命名参数与可选参数。

命名参数

除了用位置确定参数外，还可以用名称来确定参数：

```cs
void Foo (int x, int y) 
{ 
    Console.WriteLine (x + ", " + y); 
}

void Test() { Foo (x:1, y:2); }
```

命名参数能够以任意顺序出现。下面两种调用 Foo 的方式在语义上是一样的：

```cs
Foo (x:1, y:2);

Foo (y:2, x:1);
```

上述写法的不同之处是参数表达式将按调用端参数出现的顺序计算。通常，这种不同只出现在非独立的拥有副作用的表达式中。例如下面的代码将输出 0,1：

```cs
int a = 0;

Foo (y: ++a, x: --a); // ++a is evaluated first
```

当然，在实践中应当避免这种代码。

命名参数和可选参数可以混合使用：

```cs
Foo (1, y:2);
```

然而这里有一个限制：除非参数均出现在正确的位置，否则按位置传递的参数必须出现在命名参数之前。因此可以按照如下方式调用 Foo 方法：

```cs
Foo (x:1, 2);     // OK. Arguments in the declared positions
```

但无法进行如下的调用：

```cs
Foo (y:2, 1);     // Compile-time error. y isn't in the first position
```

命名参数在和可选参数混合使用时特别有效。例如，考虑下面的方法：

```cs
void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }
```

我们可以用以下方式在调用它的时候仅提供 d 的值：

```cs
Bar (d:3);
```

这个特性在调用 COM API 时非常有用，将在第 25 章中详细讨论。


#### 2.8.5 引用局部变量

C# 7 添加了一个令人费解的特性：即定义一个用于引用数组中某一个元素或对象中某一个字段的局部变量：

```cs
int[] numbers = { 0, 1, 2, 3, 4 };

ref int numRef = ref numbers [2];
```

在这个例子中，numRef 是 numbers [2] 的引用。当更改 numRef 的值时，也相应更改了数组中的元素值：

```cs
numRef *= 10;

Console.Write

Line (numRef);    // 20Console.Write

Line (numbers [2]);  // 20
```

引用局部变量的目标只能是数组的元素、对象字段或者局部变量；而不能是属性（见第 3 章）。引用局部变量适用于在特定的场景下进行小范围优化，并通常和引用返回值合并使用。

#### 2.8.6 引用返回值

第 24 章将讨论 `Span<T>` 和 `ReadOnlySpan<T>` 类型。这两种类型使用引用返回值特性实现了非常高效的索引器。除此场景之外，引用返回值鲜有使用。可以将其理解为一个微观性能改进。

从方法中返回的引用局部变量，称为引用返回值（ref return）：

```cs
static string x = "Old Value";
static ref string GetX() => ref x;
static void Main() 
{ 
    ref string xRef = ref GetX();
    // This method returns a ref
    // Assign result to a ref local
    xRef = "New Value";
    Console.WriteLine (x);
    // New Value
}
```

如果在调用端忽略 ref 修饰符，则该调用将会返回一个普通的值：

```cs
string localX = GetX(); // Legal: localX is an ordinary non-ref variable.
```

定义属性或者索引器时也可以使用引用返回值：

```cs
static ref string Prop => ref x;
```

注意，这些属性即使不定义 set 访问器也是隐式可写的：

```cs
Prop = "New Value";
```

为了避免修改，可使用 ref readonly：

```cs
static ref readonly string Prop => ref x;
```

ref readonly 修饰符在保持了返回引用所带来的性能提升之余还阻止了修改操作。当然，由于 x 是字符串类型（引用类型），因此这种更改在本例中的影响微乎其微。不论字符串有多长，唯一改进的地方是避免了一次 32 位或者 64 位引用的复制。如果使用自定义值类型（请参见 3.4 节），则在将结构体标记为 readonly 的情况下（否则编译器将执行一次防御性质的拷贝）才会切实地改善性能。

试图在返回类型为引用返回值的属性或者索引器中定义 set 访问器是非法的。

#### 2.8.7 var：隐式类型局部变量

我们通常会一次性完成变量的声明和初始化。如果编译器能够从初始化表达式中推断出变量的类型，就能够使用 var 关键字（C# 3.0 引入）来代替类型声明，例如：

```cs
var x = "hello";
var y = new System.Text.StringBuilder(); 
var z = (float)Math.PI;
```

它们完全等价于：

```cs
string x = "hello";
System.Text.StringBuilder y = new System.Text.StringBuilder();
float z = (float)Math.PI;
```

因为是完全等价的，所以隐式类型变量仍是静态类型的。例如，下面的代码将产生编译时错误：

```cs
var x = 5;
// Compile-time error; x is of type int
x = "hello";
```

注意，当无法直接从变量声明语句中看出变量类型的时候，var 关键字将降低代码的可读性。例如：

```cs
Random r = new Random();

var x = r.Next();
```

变量 x 的类型是什么呢？

4.10 节将介绍必须使用 var 的场景。

### 2.9 表达式和运算符

表达式本质上是值。最简单的表达式是常量和变量。表达式能够用运算符进行转换和组合。运算符用一个或多个输入操作数来输出一个新的表达式。

以下是一个常量表达式的例子：

12

可以使用 `*` 运算符来组合两个操作数（字面量表达式 12 和 30）：

```cs
12 * 30
```

由于操作数本身可以是表达式，所以可以创造出更复杂的表达式。例如，(12 * 30) 是下面表达式中的操作数。

```cs
1 + (12 * 30)
```

C# 中的运算符分为一元运算符、二元运算符和三元运算符，这取决于它们使用的操作数数量（1、2 或 3）。二元运算符总是使用中缀表示法，即运算符在两个操作数之间。

#### 2.9.1 基础表达式

基础表达式由 C# 语言内置的基础运算符表达式组成，例如：

```cs
Math.Log (1)
```

该表达式由两个基础表达式构成，第一个表达式执行成员查找（用 `.` 运算符），而第二个表达式执行方法调用（用 `()` 运算符）。

#### 2.9.2 空表达式

空表达式是没有值的表达式，例如：

```cs
Console.WriteLine (1)
```

因为空表达式没有值，所以不能作为操作数来创建更复杂的表达式：

```cs
1 + Console.WriteLine (1)   // Compile-time error
```

#### 2.9.3 赋值表达式

赋值表达式用 = 运算符将另一个表达式的值赋值给变量，例如：

```cs
x = x * 5
```

赋值表达式不是一个空表达式，它的值即是被赋予的值。因此赋值表达式可以和其他表达式组合。下面的例子中，表达式将 2 赋给 x 并将 10 赋给 y：

```cs
y = 5 * (x = 2)
```

这种类型的表达式也可以用于初始化多个值：

复合赋值运算符是由其他运算符组合而成的简化运算符（这条规则的例外是第 4 章中介绍的事件，它的 += 和 -= 运算符会特殊对待并映射至事件的 add 和 remove 访问器上。）：

```cs
x *= 2  // equivalent to x = x * 2

x <<= 1  // equivalent to x = x <<1
```

#### 2.9.4 运算符优先级和结合性

当表达式包含多个运算符时，运算符的优先级和结合性决定了计算的顺序。优先级高的运算符先于优先级低的运算符执行。如果运算符的优先级相同，那么运算符的结合性决定计算的顺序。

优先级

对于以下表达式：

```cs
1 + 2 * 3
```

由于 `*` 的优先级高于 + ，因此它将按下面的方式计算：

```cs
1 + (2 * 3)
```

左结合运算符

二元运算符（除了赋值运算符、Lambda 运算符、null 合并运算符）是左结合运算符。换句话说，它们是从左往右计算的。例如，下面的表达式：

```cs
8 / 4 / 2
```

由于左结合性将按如下方式计算：

```cs
( 8 / 4 ) / 2  // 1
```

插入括号可以改变实际的计算顺序：

```cs
8 / ( 4 / 2 )  // 4
```

右结合运算符

赋值运算符、Lambda 运算符、null 合并运算符和条件运算符是右结合的。换句话说，它们是从右往左计算的。右结合性允许多重赋值，例如：

```cs
x = y = 3;
```

首先将 3 赋值给 y，之后再将表达式的结果 (3) 赋值给 x。

#### 2.9.5 运算符表

表 2-3 按照优先级列出了 C# 的运算符。同一类别的运算符优先级相同。4.16 节将介绍用户可重载的运算符。

表 2-3：C# 的运算符（按照优先级顺序分类）

表 2-3：C# 的运算符（按照优先级顺序分类）（续）

表 2-3：C# 的运算符（按照优先级顺序分类）（续）

### 2.10 null 运算符

C# 提供了三个简化 null 处理的运算符：null 合并运算符、null 合并赋值运算符和 null 条件运算符。

#### 2.10.1 null 合并运算符

null 合并运算符写作 ??=。它的意思是「如果左侧操作数不是 null，则结果为操作数，否则结果为另一个值。」例如：

```cs
string s1 = null;

string s2 = s1 ?? "nothing";  // s2 evaluates to "nothing"
```

如果左侧的表达式不是 null，则右侧的表达式将不会进行计算。null 合并运算符同样适用于可空值类型（请参见 4.7 节）。

#### 2.10.2 null 合并赋值运算符（C# 8）

null 合并赋值运算符写作 ??=。它的含义是「如果左侧操作数为 null，则将右侧的操作数赋值给左侧的操作数。」例如：

```cs
string s1 = null;
s1 ??= "something";
Console.WriteLine (s1);

s1 ??= "everything";
Console.WriteLine (s1);
// something
// something
```

该运算符可以将如下的模式：

```cs
if (myVariable == null) myVariable = someDefault;
```

简化为

```cs
myVariable ??= someDefault;
```

2.10.3 null 条件运算符 

`?.` 运算符称为 null 条件运算符或者 Elvis 运算符（从 Elvis 表情符号而来）。该运算符可以像标准的「.」运算符那样访问成员或调用方法。当运算符的左侧为 null 的时候，该表达式的运算结果也是 null，而不会抛出 NullReferenceException 异常。

```cs
System.Text.StringBuilder sb = null;
string s = sb?.ToString(); // No error; s instead evaluates to null
```

上述代码的最后一行等价于：

```cs
string s = (sb == null ? null : sb.ToString());
```

当遇到 null 时，Elvis 运算符将直接略过表达式的其余部分。在下例中，即使 ToString () 和 ToUpper () 方法使用的是标准的「.」运算符，s 的值仍然为 null。

```cs
System.Text.StringBuilder sb = null;
string s = sb?.ToString().ToUpper();  // s evaluates to null without error
```

仅当直接的左侧运算数有可能为 null 的时候才有必要重复使用 Elvis 运算符。因此下述表达式在 x 和 y 都为 null 时依然是健壮的：

```cs
x?.y?.z
```

它等价于（唯一的不同在于 x.y 仅执行了一次）：

```cs
x == null ? null
    : (x.y == null ? null : x.y.z)
```

需要指出，最终的表达式必须能够处理 null，因此以下的范例是非法的：

```cs
System.Text.StringBuilder sb = null;
int length = sb?.ToString().Length;  // Illegal : int cannot be null
```

我们可以使用可空值类型（请参见 4.7 节）来修正这个问题。如果你已经对可空值类型有所了解，请参见如下范例代码：

```cs
int?length = sb?.ToString().Length;  // OK: int? can be null
```

也可以使用 null 条件运算符调用返回值为 void 的方法：

```cs
someObject?.SomeVoidMethod();
```

如果 someObject 为 null，则表达式将「不执行指令」而不会抛出 NullReferenceException 异常。

null 条件运算符可以和第 3 章介绍的常用类型成员（包括方法、字段、属性和索引器）一起使用。而且它也可以和 null 合并运算符配合使用。

```cs
System.Text.StringBuilder sb = null;
string s = sb?.ToString() ??"nothing";  // s evaluates to "nothing"
```

### 2.11 语句

函数是由语句构成的，语句按照出现的字面顺序执行。语句块则是在大括号（{}）中的一系列语句。

#### 2.11.1 声明语句

声明语句可以声明新的变量，并可以用表达式初始化变量。声明语句以分号结束。可以用逗号分隔的列表声明多个同类型的变量：

```cs
string someWord = "rosebud";
int someNumber = 42;
bool rich = true, famous = false;
```

常量的声明和变量声明类似，但是它的值无法在声明之后改变，并且变量初始化必须和声明同时进行（请参见 3.1.2 节）：

```cs
const double c = 2.99792458E08;

c += 10;

// Compile-time error
```

局部变量

局部变量和局部常量的作用范围在当前的语句块中。在当前语句块或者嵌套的语句块中声明另一个同名的局部变量是不行的：

```cs
static void Main() 
{
    int x; 
    {
        int y;
        int x; 
    } 
    {
        int y; 
    } 
    Console.Write (y);
    // Error - x already defined
    // OK - y not in scope
    // Error - y is out of scope
}
```

变量的作用范围是它所在的整个代码块（前向和后向都包含）。由于在变量或常量声明之前引用它是不合法的，因此将示例中的 x 初始化移到方法的末尾会得到相同的错误，这个奇怪的规则和 C++ 是不同的。

#### 2.11.2 表达式语句

表达式语句既是表达式也是合法的语句。表达式语句必须改变状态或者执行某些可能改变状态的调用。状态改变本质上指改变一个变量的值。可能的表达式语句有：

1、赋值表达式（包括自增和自减表达式）。

2、方法调用表达式（有返回值的和没有返回值的）。

3、对象实例化表达式。

例如：

```cs
// Declare variables with declaration statements: 
string s; 
int x, y; 
System.Text.StringBuilder sb;

// Expression statements

x = 1 + 2;

x++; 
y = Math.Max (x, 5); 
Console.WriteLine (y); 
sb = new StringBuilder(); 
new StringBuilder();

// Assignment expression 
// Increment expression 
// Assignment expression 
// Method call expression 
// Assignment expression 
// Object instantiation expression
```

当调用有返回值的构造器或方法时，并不一定要使用它的返回值。因此，除非构造器或方法改变了某些状态，否则以下这些语句完全没有用处：

```cs
new StringBuilder();   // Legal, but useless

new string ('c', 3);   // Legal, but useless

x.Equals (y);      // Legal, but useless
```

#### 2.11.3 选择语句

C# 使用以下几种机制来有条件地控制程序的执行流：

选择语句（if、switch）

条件语句（?:）

循环语句（while、do-while、for 和 foreach）

本节介绍两种最简单的结构：if 语句和 switch 语句。

if 语句

if 语句在 bool 表达式为真时执行其中的语句。例如：

```cs
if (5 < 2 * 3)
    Console.WriteLine ("true");    // true
```

if 中的语句可以是代码块：

```cs
if (5 < 2 * 3) 
{ 
    Console.WriteLine ("true");
    Console.WriteLine ("Let's move on!");
}
```

else 子句

if 语句之后可以紧跟 else 子句：

```cs
if (2 + 2 == 5)
    Console.WriteLine ("Does not compute"); 
else 
    Console.WriteLine ("False"); // False
```

在 else 子句中，可以嵌套另一个 if 语句：

```cs
if (2 + 2 == 5)
    Console.WriteLine ("Does not compute"); 
else
if (2 + 2 == 4)
    Console.WriteLine ("Computes");  // Computes
```

用大括号改变执行流

else 子句总是与它之前的语句块中紧邻的未配对的 if 语句结合：

上述代码在语义上等价于：

可以通过改变大括号的位置来改变执行流：

大括号可以明确表明结构，这能提高嵌套 if 语句的可读性（虽然编译器并不需要）。需要特别指出的是下面的模式：

```cs
static void TellMeWhatICanDo (int age) 
{
if (age >= 35)
    Console.WriteLine ("You can be president!"); 
else if (age >= 21) 
    Console.WriteLine ("You can drink!"); 
else if (age >= 18) 
    Console.WriteLine ("You can vote!"); 
else 
    Console.WriteLine ("You can wait!");
}
```

这里，我们参照其他语言的 elseif 结构（以及 C# 本身的 #elif 预处理指令）来安排 if 和 else 语句。Visual Studio 自动识别这个模式并保持代码缩进。从语义上讲，紧跟着每一个 if 语句的 else 语句在功能上都是嵌套在 else 子句之中的。

switch 语句

switch 语句可以根据变量可能的取值来转移程序的执行。switch 语句有比嵌套 if 语句更加简洁的代码，因为 switch 语句只要求表达式计算一次：

```cs
static void ShowCard (int cardNumber) 
{
    switch (cardNumber) 
    { 
        case 13:
            Console.WriteLine ("King"); 
            break; 
        case 12:
            Console.WriteLine ("Queen"); 
            break; 
        case 11:
            Console.WriteLine ("Jack"); 
            break; 
        case -1:
            goto case 12; 
        default:
            Console.WriteLine (cardNumber); 
            break;
            // Joker is -1 
            // In this game joker counts as queen 
            // Executes for any other cardNumber
    }
}
```

这个例子演示了最一般的情形，即针对常量的 switch。当指定常量时，只能指定内置的整数类型、bool、char、enum 类型以及 string 类型。

每一个 case 子句结束时必须使用某种跳转指令显式指定下一个执行点（除非代码本身就是一个无限循环）。这些跳转指令有：

break（跳转到 switch 语句的最后）

goto case x（跳转到另外一个 case 子句）

goto default（跳转到 default子句）

其他的跳转语句，例如 return、throw、continue 或者 goto label

当多个值要执行相同的代码时，可以按照顺序列出共同的 case 条件：

```cs
switch (cardNumber) 
{
    case 13: 
    case 12: 
    case 11:
        Console.WriteLine ("Face card");
        break; 
    default:
        Console.WriteLine ("Plain card");
        break;
}
```

语句的这种特性可以写出比多个 if-else 更加简洁的代码。

按类型 switch

按照类型进行 switch 是带有模式的 switch 语句的一种特殊的使用情况。C# 7 和 C# 8 引入了一系列普遍适用的模式，有关模式的完整讨论请参见 4.12 节。

C# 7 开始支持按类型 switch：

```cs
static void Main() 
{
    TellMeTheType (12);
    TellMeTheType ("hello");
    TellMeTheType (true); 
}

static void TellMeTheType (object x) 
{
    // object allows any type.
    switch (x) 
    { 
        case int i:
            Console.WriteLine ("It's an int!"); 
            Console.WriteLine ($"The square of {i} is {i * i}"); 
            break; 
        case string s:
            Console.WriteLine ("It's a string"); 
            Console.WriteLine ($"The length of {s} is {s.Length}"); 
            break; 
        default:
            Console.WriteLine ("I don't know what x is"); 
            break;
    }
}
```

类型允许其变量为任何类型，这部分内容将在 3.2 节和 3.3 节详细讨论。

每一个 case 子句都指定了一种需要匹配的类型和一个变量（模式变量），如果类型匹配成功就对变量赋值。和常量不同，子句对可用的类型并没有进行任何限制。

when 关键字可用于对 case 进行预测，例如：

```cs
switch (x) 
{ 
    case bool b when b == true:
        // Fires only when b is true
        Console.WriteLine ("True!"); 
        break; 
    case bool b:
        Console.WriteLine ("False!"); 
        break; 
}
```

case 子句的顺序会影响类型的选择（这和选择常量的情况有些不同）。如果交换 case 的顺序，则上述示例可以得到完全不同的结果（事实上，上述程序甚至无法编译，因为编译器发现第二个 case 子句是永远不会执行的）。但 default 子句是一个例外，不论它出现在什么地方都会在最后才执行。

如果希望按照类型进行 switch，但对其值却并不关心，这种情况下可以使用变量「丢弃」（_）：

```cs
case DateTime _:
    Console.WriteLine ("It's a DateTime");
```

堆叠多个 case 子句也是没有问题的。下面的例子中，Console.WriteLine 会在任何浮点类型的值大于 1 000 时执行：

```cs
switch (x) 
{ 
    case float f when f > 1000:
    case double d when d > 1000:
    case decimal m when m > 1000:
        Console.WriteLine ("We can refer to x here but not f or d or m"); 
        break; 
}
```

上述例子中，编译器仅允许在 when 子句中使用模式变量 f、d 和 m。当调用 Console.WriteLine 时，它并不清楚到底三个模式变量中的哪一个会被赋值，因而编译器会将它们放在作用域之外。

除此以外，还可以混合使用常量选择和模式选择，甚至可以选择 null 值：

```cs
case null:
    Console.WriteLine ("Nothing here");
    break;
```

switch 表达式（C# 8）

C# 8 支持在表达式中使用 switch。以下示例展示了其使用方法，其中假定变量 cardNumber 是 int 类型：

```cs
string cardName = cardNumber switch 
{
    13 => "King",
    12 => "Queen",
    11 => "Jack",
    _ => "Pip card"  // equivalent to 'default'
};
```

注意，switch 是在变量名称后出现的，且其中的 case 子句相应地变为了以逗号结尾的表达式而不再是语句。switch 表达式相比 switch 语句更加紧凑，且可以用于 LINQ 查询（请参见第 8 章）。

如果在 switch 表达式中忽略默认表达式（_）同时其他条件匹配失败，则会抛出一个异常。

switch 表达式也支持多变量的选择（元组模式）：

```cs
int cardNumber = 12;
string suit = "spades";

string cardName = (cardNumber, suit) switch 
{
    (13, "spades") => "King of spades",
    (13, "clubs") => "King of clubs",
    ... 
};
```

switch 表达式和各种模式（详情请参见 4.12 节）组合可以获得更多的选择效果。

#### 2.11.4 迭代语句

C# 中可以使用 while、do-while、for 和 foreach 语句重复执行一系列语句。

while 和 do-while 循环

while 循环在其 bool 表达式为 true 的情况下重复执行循环体中的代码。这个表达式在循环体执行之前进行检测。例如：

```cs
int i = 0;
while (i < 3) 
{ 
    Console.WriteLine (i);
    i++;
}
```

do-while 循环在功能上不同于 while 循环的地方是它在语句块执行之后才检查表达式的值（保证语句块至少执行过一次）。以下将上述例子用 do-while 循环进行了重写：

```cs
int i = 0;
do 
{
    Console.WriteLine (i); 
    i++;
} 
while (i < 3);
```

for 循环

for 循环类似一个有特殊子句（用于初始化和迭代循环变量）的 while 循环。for 循环有以下三个子句：

```cs
for (initialization-clause; condition-clause; iteration-clause) 
    statement-or-statement-block
```

每一个子句的作用如下：

初始化子句：在循环之前执行，初始化一个或多个迭代变量。

条件子句：它是一个 bool 表达式，当其为 true 时，将执行循环体。

迭代子句：在每次语句块迭代之后执行，通常用于更新迭代变量。

例如，下面的例子将打印 0 到 2 的数字：

```cs
for (int i = 0; i < 3; i++)
    Console.WriteLine (i);
```

下面的代码将打印前 10 个斐波那契数（每一个数都是前面两个数的和）：

```cs
for (int i = 0, prevFib = 1, curFib = 1; i < 10; i++)
{ 
    Console.WriteLine (prevFib); 
    int newFib = prevFib + curFib; 
    prevFib = curFib; 
    curFib = newFib;
}
```

for 语句的这三个部分都可以省略，因而可以通过下面的代码来实现无限循环（也可以用 while (true) 来代替）：

```cs
for (;;)
    Console.WriteLine ("interrupt me");
```

foreach 循环

foreach 语句遍历可枚举对象的每一个元素。大多数 C# 和 .NET Core 中表示集合或元素列表的类型都是可枚举的。例如，数组和字符串都是可枚举的。以下示例从头到尾枚举了字符串中的每一个字符：

```cs
foreach (char c in "beer")  // c is the iteration variable
    Console.WriteLine (c)  ;OUTPUT:beer
```

第 4.6 节将详细介绍可枚举对象。

#### 2.11.5 跳转语句

C# 的跳转语句有 break、continue、goto、return 和 throw。

跳转语句仍然遵守 try 语句的可靠性规则（参见 4.5 节）。这意味着：

到 try 语句块之外的跳转总是在达到目标之前执行 try 语句的 finally 语句块。

跳转语句不能从 finally 语句块内跳到块外（除非使用 throw）。

break 语句

break 语句用于结束迭代或 switch 语句的执行：

```cs
int x = 0;
while (true) 
{
    if (x++ > 5) 
        break;
    // break from the loop
} 
// execution continues here after break 
...
```

continue 语句

continue 语句放弃循环体中其后的语句，继续下一轮迭代。例如，以下的循环跳过了偶数：

```cs
for (int i = 0; i < 10; i++)
{
    if ((i % 2) == 0)
        continue;
    // If i is even, 
    // continue with next iteration
    Console.Write (i + " ");
}
```

goto 语句

goto 语句将执行点转移到语句块中的指定标签处。格式如下：

```cs
goto statement-label;
```

或用于 switch 语句内：

```cs
goto case case-constant;  // (Only works with constants, not patterns)
```

标签语句仅仅是代码块中的占位符，位于语句之前，用冒号后缀表示。下面的代码模拟 for 循环来遍历从 1 到 5 的数字：

```cs
int i = 1;

startLoop: if (i <= 5) 
{
    Console.Write (i + " ");
    i++;
    goto startLoop; 
}
```

goto case case-constant 会将执行点转移到 switch 语句块中的另一个条件上（参见本章 2.11.3 节）。

return 语句

return 语句用于退出方法。如果这个方法有返回值，则必须返回方法指定返回类型的表达式。

return 语句能够出现在方法的任意位置（除 finally 块中），且可以出现超过一次。

throw 语句

throw 语句抛出异常来表示有错误发生（参见 4.5 节）：

```cs
if (w == null) 
    throw new ArgumentNullException (...);
```

#### 2.11.6 其他语句

using 语句用一种优雅的语法在 finally 块中调用实现了 IDisposable 接口对象的 Dispose 方法（请参见 4.5 节和 12.1 节）。

C# 重载了 using 关键字，使它在不同上下文中有不同的含义。特别注意 using 指令和 using 语句是不同的。

lock 语句是调用 Mintor 类的 Enter 和 Exit 方法的简化写法（请参见第 14 章和第 23 章）。

### 2.12 命名空间

命名空间是一系列类型名称的领域。通常情况下，类型组织在分层的命名空间里，既避免了命名冲突又更容易查找。例如，处理公钥加密的 RSA 类型就定义在如下的命名空间下：

```cs
System.Security.Cryptography
```

命名空间组成了类型名的基本部分。下面代码调用了 RSA 类型的 Create 方法：

```cs
System.Security.Cryptography.RSA rsa = 
    System.Security.Cryptography.RSA.Create();
```

命名空间是独立于程序集的。程序集是像 .exe 或者 .dll 一样的部署单元（参见第 18 章）。命名空间并不影响成员的可见性（public、internal、private 等）。

namespace 关键字为其中的类型定义了命名空间。例如：

```cs
namespace Outer.Middle.Inner 
{
    class Class1 {}
    class Class2 {} 
}
```

命名空间中的「.」表明了嵌套命名空间的层次结构。下面的代码在语义上和上一个例子是等价的：

```cs
namespace Outer 
{
    namespace Middle 
    { 
        namespace Inner 
        { 
            class Class1 {} 
            class Class2 {} 
        } 
    }
}
```

类型可以用完全限定名称（也就是包含从外到内的所有命名空间的名称）来指定。例如，上述例子中，可以使用 Outer.Middle.Inner.Class1 来指代 Class1。

如果类型没有在任何命名空间中定义，则它存在于全局命名空间。全局命名空间也包含了顶层命名空间，就像前面例子中的 Outer 命名空间。

#### 2.12.1 using

指令 using 指令用于导入命名空间。这是避免使用完全限定名称来指代某种类型的快捷方法。以下例子导入了前一个例子的 Outer.Middle.Inner 命名空间：

```cs
using Outer.Middle.Inner;

class Test 
{ 
    static void Main() 
    { 
        Class1 c; // Don't need fully qualified name 
    } 
}
```

在不同命名空间中定义相同类型名称是合法的（通常也是可取的）。不过，这种做法通常出现在开发者不会同时导入两个命名空间时使用。TextBox 类就是一个典型的例子，这个名称在 System.Windows.Controls（WPF）和 System.Windows.Forms.Controls（Windows Forms）命名空间中都有定义。

#### 2.12.2 using static 指令

我们不仅可以导入命名空间，还可以使用 using static 指令导入特定的类型。这样就可以使用类型静态成员而无须指定类型的名称了。下面的例子中，在不指定类型的情况下调用了 Console 类的静态方法 WriteLine：

```cs
using static System.Console;

class Test 
{
     static void Main() 
     { 
        WriteLine("Hello"); 
     }
}
```

using static 指令将导入类型的全部可访问静态成员，包括字段、属性以及嵌套类型（参见第 3 章）。同时，该指令也支持导入枚举类型的成员。因此，如果导入了以下的枚举类型：

```cs
using static System.Windows.Visibility;
```

就可以直接使用 Hidden 而非 Visibility.Hidden：

```cs
var textBox = new TextBox { Visibility = Hidden};  // XAML-style
```

C# 编译器还没有聪明到可以基于上下文来推断出正确的类型，因此在导入多个静态类型导致歧义时会发生编译错误。

#### 2.12.3 命名空间中的规则

名称范围

外层命名空间中声明的名称能够直接在内层命名空间中使用。以下示例中的 Class1 在 Inner 中不需要限定名称：

```cs
namespace Outer 
{ 
    class Class1 {} 
    namespace Inner 
    { 
        class Class2 : Class1 {}
    } 
}
```

使用命名空间分层结构中不同分支中的类型需要使用部分限定名称。在下面的例子中，SalesReport 类继承 Common.ReportBase：

```cs
namespace MyTradingCompany 
{
    namespace Common 
    { 
        class ReportBase {}
    } 
    
    namespace ManagementReporting 
    { 
        class SalesReport : Common.ReportBase {}
    }
}
```

名称隐藏

如果相同类型名称同时出现在内层和外层命名空间中，则内层名称优先。如果要使用外层命名空间中的类型，必须使用它的完全限定名称：

所有的类型名在编译时都会转换为完全限定名称。中间语言（IL）代码不包含非限定名称和部分限定名称。

重复的命名空间

只要命名空间内的类型名称不冲突就可以重复声明同一个命名空间：

```cs
namespace Outer.Middle.Inner 
{
    class Class1 {} 
} 

namespace Outer.Middle.Inner 
{
    class Class2 {} 
}
```

上述例子也可以分为两个不同的源文件，并将每一个类都编译到不同的程序集中。

源文件 1：

```cs
namespace Outer.Middle.Inner 
{
    class Class1 {} 
} 
```

源文件 2：

```cs
namespace Outer.Middle.Inner 
{
    class Class2 {} 
}
```

嵌套的 using 指令

可以在命名空间中嵌套 using 指令，这样可以控制 using 指令在命名空间声明中的作用范围。在以下例子中，Class1 在一个命名空间中可见，但是在另一个命名空间中不可见：

```cs
namespace N1 
{
    class Class1 {} 
} 

namespace N2 
{
    using N1;
    class Class2 : Class1 {} 
} 

namespace N2 
{
    class Class3 : Class1 {} 
}
```

#### 2.12.4 类型和命名空间别名

导入命名空间可能导致类型名称的冲突，因此可以只导入需要的特定类型而不是整个命名空间，并给它们创建别名。例如：

```cs
using PropertyInfo2 = System.Reflection.PropertyInfo;
class Program { PropertyInfo2 p; }
```

下面的代码为整个命名空间创建了别名：

```cs
using R = System.Reflection;
class Program { R.PropertyInfo p; }
```

#### 2.12.5 高级命名空间特性

外部别名

使用外部别名就可以引用两个完全限定名称相同的类型（例如，命名空间和类型名称都相同）。这种特殊情况只在两种类型来自不同的程序集时才会出现。请考虑下面的例子：

程序库 1，编译为 Widgets1.dll：

```cs
namespace Widgets
{ 
    public class Widget {}
}
```

程序库 2，编译为 Widgets2.dll：

```cs
namespace Widgets 
{ 
    public class Widget {} 
}
```

当应用程序同时引用 Widgets1.dll 和 Widgets2.dll 时：

```cs
using Widgets; 

class Test 
{
    static void Main()
    {
        Widget w = new Widget();
    } 
}
```

以上程序是无法编译的，因为 Widget 类型是有二义性的。外部别名则可以消除应用程序中的二义性。首先需要更改应用程序的 .csproj 工程文件，为每一个引用赋予唯一的别名：

```cs
<ItemGroup> 
    <Reference Include="Widgets1">
        <Aliases>W1</Aliases> 
    </Reference> 
        <Aliases>W2</Aliases> 
    </Reference> 
</ItemGroup>
```

接下来就可以使用 extern alias 指令使用这些别名了：

```cs
extern alias W1; 
extern alias W2;

class Test 
{ 
    static void Main() 
    { 
    W1.Widgets.Widget w1 = new W1.Widgets.Widget(); 
    W2.Widgets.Widget w2 = new W2.Widgets.Widget(); 
    } 
}
```

命名空间别名限定符 之前提到，内层命名空间中的名称「隐藏」外层命名空间中的名称。但是，有时即使使用类型的完全限定名也无法解决冲突。请考虑下面的例子：

```cs
namespace N 
{ 
    class A 
    { 
        static void Main() => new A.B(); 
        public class B {} 
    } 
}

namespace A 
{ 
    class B {} 
}
```

Main 方法可以实例化嵌套类 B 或命名空间 A 中的类 B。编译器总是给当前命名空间中的标识符以更高的优先级；在这种情况下，将会实例化嵌套类 B。

要解决这样的冲突，可以使用如下的方式限定命名空间中的名称：

1、全局命名空间，即所有命名空间的根命名空间（由上下文关键字 global 指定）。

2、一系列的外部别名。

「::」用于限定命名空间别名。下面的例子使用了全局命名空间（这通常出现在自动生成的代码中，以避免名称冲突）：

```cs
namespace N 
{
    class A 
    { 
        static void Main() 
        { 
            System.Console.WriteLine (new A.B()); 
            System.Console.WriteLine (new global::A.B()); 
        }
        public class B {}
    }
}

namespace A 
{ 
    class B {} 
}
```

以下例子使用了别名限定符（「外部别名」一节中例子的修改版本）：

```cs
extern alias W1; 
extern alias W2;

class Test 
{ 
    static void Main() 
    { 
        W1::Widgets.Widget w1 = new W1::Widgets.Widget(); 
        W2::Widgets.Widget w2 = new W2::Widgets.Widget(); 
    } 
}
```