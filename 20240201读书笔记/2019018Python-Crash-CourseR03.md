## 记忆时间

## 目录

1501生成数据

如何用 matplotlib 来作图；如何实现产生随机数；如何使用 pygal 来创建直方图（矢量图）。

1601 下载数据

csv 和 json 文件的概念，以及如何使用它们；加深学习使用 pygal 库。

1701 使用 API

如何自动采集数据并对其可视化处理（学会使用 requests 包的基本操作）。

1801 Django 入门

创立虚拟环境；安装 Django；在 Django 里创建项目；为这个项目创建数据库；查看核实该项目是否在正常运行。

## 1501. 生成数据

在本章中，你学习了：如何生成数据集以及如何对其进行可视化；如何使用 matplotlib 创建简单的图表，以及如何使用散点图来探索随机漫步过程；如何使用 Pygal 来创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。

使用代码生成数据集是一种有趣而强大的方式，可用于模拟和探索现实世界的各种情形。完成后面的数据可视化项目时，请注意可使用代码模拟哪些情形。请研究新闻媒体中的可视化，看看其中是否有图表是以你在这些项目中学到的类似方式生成的。

数据可视化指的是通过可视化表示来探索数据，它与数据挖掘紧密相关，而数据挖掘指的是使用代码来探索数据集的规律和关联。数据集可以是用一行代码就能表示的小型数字列表，也可以是数以吉字节的数据。

1『数据挖掘是用代码来探索数据集的规律和关联；数据可视化是用可视化来探索数据集的规律和关联。』

漂亮地呈现数据关乎的并非仅仅是漂亮的图片。以引人注目的简洁方式呈现数据，让观看者能够明白其含义，发现数据集中原本未意识到的规律和意义。

所幸即便没有超级计算机，也能够可视化复杂的数据。鉴于 Python 的高效性，使用它在笔记本电脑上就能快速地探索由数百万个数据点组成的数据集。数据点并非必须是数字，利用本书前半部分介绍的基本知识，也可以对非数字数据进行分析。

在基因研究、天气研究、政治经济分析等众多领域，大家都使用 Python 来完成数据密集型工作。数据科学家使用 Python 编写了一系列令人印象深刻的可视化和分析工具，其中很多也可供你使用。最流行的工具之一是 matplotlib，它是一个数学绘图库，我们将使用它来制作简单的图表，如折线图和散点图。然后，我们将基于随机漫步概念生成一个更有趣的数据集 —— 根据一系列随机决策生成的图表。

我们还将使用 Pygal 包，它专注于生成适合在数字设备上显示的图表。通过使用 Pygal，可在用户与图表交互时突出元素以及调整其大小，还可轻松地调整整个图表的尺寸，使其适合在微型智能手表或巨型显示器上显示。我们将使用 Pygal 以各种方式探索掷骰子的结果。

1『

WARNING: The scripts f2py, f2py3 and f2py3.7 are installed in '/Users/Daglas/Library/Python/3.7/bin' which is not on PATH.

Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.

』

安装必要的包后，对安装进行测试。为此，首先使用命令 python 或 python3 启动一个终端会话，再尝试导入 matplotlib：

    import matplotlib

如果没有出现任何错误消息，就说明你的系统安装了 matplotlib。

要查看使用 matplotlib 可制作的各种图表，请访问 http://matplotlib.org/ 的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。

3『[Matplotlib: Python plotting — Matplotlib 3.1.1 documentation](https://matplotlib.org/)』

下面来使用 matplotlib 绘制一个简单的折线图，再对其进行定制，以实现信息更丰富的数据可视化。我们将使用平方数序列 1、4、9、16 和 25 来绘制这个图表。只需向 matplotlib 提供如下数字，matplotlib 就能完成其他的工作。我们首先导入了模块 pyplot，并给它指定了别名 plt，以免反复输入 pyplot。在线示例大都这样做，因此这里也这样做。模块 pyplot 包含很多用于生成图表的函数。我们创建了一个列表，在其中存储了前述平方数，再将这个列表传递给函数 plot()，这个函数尝试根据这些数字绘制出有意义的图形。plt.show() 打开 matplotlib 查看器，并显示绘制的图形，如图 15-1 所示。查看器让你能够缩放和导航图形。

图 15-1 所示的图形表明数字是越来越大的，但标签文字太小，线条太细。所幸 matplotlib 让你能够调整可视化的各个方面。参数 linewidth （见 ❶）决定了 plot() 绘制的线条的粗细。函数 title() （见 ❷）给图表指定标题。在上述代码中，出现了多次的参数 fontsize 指定了图表中文字的大小。函数 xlabel() 和 ylabel() 让你能够为每条轴设置标题（见 ❸）；而函数 tick_params() 设置刻度的样式（见 ❹），其中指定的实参将影响 x 轴和 y 轴上的刻度（axes='both' ），并将刻度标记的字号设置为 14（labelsize=14 ）。最终的图表阅读起来容易得多了，如图 15-2 所示：标签文字更大，线条也更粗。

图形更容易阅读后，我们发现没有正确地绘制数据：折线图的终点指出 4.0 的平方为 25！下面来修复这个问题。当你向 plot() 提供一系列数字时，它假设第一个数据点对应的 x 坐标值为 0，但我们的第一个点对应的 x 值为 1。为改变这种默认行为，我们可以给 plot() 同时提供输入值和输出值。现在 plot() 将正确地绘制数据，因为我们同时提供了输入值和输出值，它无需对输出值的生成方式作出假设。最终的图形是正确的，如图 15-3 所示。

有时候，需要绘制散点图并设置各个数据点的样式。例如，你可能想以一种颜色显示较小的值，而用另一种颜色显示较大的值。绘制大型数据集时，你还可以对每个点都设置同样的样式，再使用不同的样式选项重新绘制某些点，以突出它们。要绘制单个点，可使用函数 scatter()，并向它传递一对 x 和 y 坐标，它将在指定位置绘制一个点。

下面来设置输出的样式，使其更有趣：添加标题，给轴加上标签，并确保所有文本都大到能够看清。在 ❶ 处，我们调用了 scatter()，并使用实参 s 设置了绘制图形时使用的点的尺寸。如果此时运行 scatter_squares.py，将在图表中央看到一个点，如图 15-4 所示。

要绘制一系列的点，可向 scatter() 传递两个分别包含 x 值和 y 值的列表，如下所示。列表 x_values 包含要计算其平方值的数字，而列表 y_values 包含前述每个数字的平方值。将这些列表传递给 scatter() 时，matplotlib 依次从每个列表中读取一个值来绘制一个点。要绘制的点的坐标分别为 (1, 1)、(2, 4)、(3, 9)、(4, 16) 和 (5, 25)，最终的结果如图 15-5 所示。

手工计算列表要包含的值可能效率低下，需要绘制的点很多时尤其如此。可以不必手工计算包含点坐标的列表，而让 Python 循环来替我们完成这种计算。下面是绘制 1000 个点的代码。我们首先创建了一个包含 x 值的列表，其中包含数字 1-1000（见 ❶）。接下来是一个生成 y 值的列表解析，它遍历 x 值（for x in x_values ），计算其平方值（x**2 ），并将结果存储到列表 y_values 中。然后，将输入列表和输出列表传递给 scatter() （见 ❷）。由于这个数据集较大，我们将点设置得较小，并使用函数 axis() 指定了每个坐标轴的取值范围（见 ❸）。函数 axis() 要求提供四个值：x 和 y 坐标轴的最小值和最大值。在这里，我们将 x 坐标轴的取值范围设置为 0-1100，并将 y 坐标轴的取值范围设置为 0-1 100 000。结果如图 15-6 所示。

matplotlib 允许你给散点图中的各个点指定颜色。默认为蓝色点和黑色轮廓，在散点图包含的数据点不多时效果很好。但绘制很多点时，黑色轮廓可能会粘连在一起。要删除数据点的轮廓，可在调用 scatter()  时传递实参 edgecolor='none'。将相应调用修改为上述代码后，如果再运行 scatter_squares.py，在图表中看到的将是蓝色实心点。

要修改数据点的颜色，可向 scatter() 传递参数 c，并将其设置为要使用的颜色的名称，如下所示。你还可以使用 RGB 颜色模式自定义颜色。要指定自定义颜色，可传递参数 c，并将其设置为一个元组，其中包含三个 0-1 之间的小数值，它们分别表示红色、绿色和蓝色分量。例如，下面的代码行创建一个由淡蓝色点组成的散点图。值越接近 0，指定的颜色越深，值越接近 1，指定的颜色越浅。

颜色映射 （colormap）是一系列颜色，它们从起始颜色渐变到结束颜色。在可视化中，颜色映射用于突出数据的规律，例如，你可能用较浅的颜色来显示较小的值，并使用较深的颜色来显示较大的值。模块 pyplot 内置了一组颜色映射。要使用这些颜色映射，你需要告诉 pyplot 该如何设置数据集中每个点的颜色。下面演示了如何根据每个点的 y 值来设置其颜色。我们将参数 c 设置成了一个 y 值列表，并使用参数 cmap 告诉 pyplot 使用哪个颜色映射。这些代码将 y 值较小的点显示为浅蓝色，并将 y 值较大的点显示为深蓝色，生成的图形如图 15-7 所示。注意：要了解 pyplot 中所有的颜色映射，请访问 http://matplotlib.org/，单击 Examples，向下滚动到 Color Examples，再单击 colormaps_reference。

要让程序自动将图表保存到文件中，可将对 plt.show() 的调用替换为对 plt.savefig() 的调用。第一个实参指定要以什么样的文件名保存图表，这个文件将存储到 scatter_squares.py 所在的目录中；第二个实参指定将图表多余的空白区域裁剪掉。如果要保留图表周围多余的空白区域，可省略这个实参。

在本节中，我们将使用 Python 来生成随机漫步数据，再使用 matplotlib 以引人瞩目的方式将这些数据呈现出来。随机漫步是这样行走得到的路径：每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。你可以这样认为，随机漫步就是蚂蚁在晕头转向的情况下，每次都沿随机的方向前行所经过的路径。

在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上移动。水滴中的分子运动是随机的，因此花粉在水面上的运动路径犹如随机漫步。我们稍后将编写的代码模拟了现实世界的很多情形。

为模拟随机漫步，我们将创建一个名为 RandomWalk 的类，它随机地选择前进方向。这个类需要三个属性，其中一个是存储随机漫步次数的变量，其他两个是列表，分别存储随机漫步经过的每个点的 x 和 y 坐标。RandomWalk 类只包含两个方法：\_\_init\_\_() 和 fill\_walk()，其中后者计算随机漫步经过的所有点。下面先来看看 \_\_init\_\_()，如下所示。为做出随机决策，我们将所有可能的选择都存储在一个列表中，并在每次做决策时都使用 choice() 来决定使用哪种选择（见 ❶）。接下来，我们将随机漫步包含的默认点数设置为 5000，这大到足以生成有趣的模式，同时又足够小，可确保能够快速地模拟随机漫步（见 ❷）。然后，在 ❸ 处，我们创建了两个用于存储 x 和 y 值的列表，并让每次漫步都从点 (0, 0) 出发。

我们将使用 fill_walk() 来生成漫步包含的点，并决定每次漫步的方向，如下所示。请将这个方法添加到 random_walk.py 中。在 ❶ 处，我们建立了一个循环，这个循环不断运行，直到漫步包含所需数量的点。这个方法的主要部分告诉 Python 如何模拟四种漫步决定：向右走还是向左走？沿指定的方向走多远？向上走还是向下走？沿选定的方向走多远？

我们使用 choice([1, -1]) 给 x_direction 选择一个值，结果要么是表示向右走的 1，要么是表示向左走的 -1（见 ❷）。接下来，choice ([0, 1, 2, 3, 4]) 随机地选择一个 0~4 之间的整数，告诉 Python 沿指定的方向走多远（x_distance ）。（通过包含 0，我们不仅能够沿两个轴移动，还能够沿 y 轴移动。）

在 ❸ 和 ❹ 处，我们将移动方向乘以移动距离，以确定沿 x 和 y 轴移动的距离。如果 x_step 为正，将向右移动，为负将向左移动，而为零将垂直移动；如果 y_step 为正，就意味着向上移动，为负意味着向下移动，而为零意味着水平移动。如果 x_step 和 y_step 都为零，则意味着原地踏步，我们拒绝这样的情况，接着执行下一次循环（见 ❺）。为获取漫步中下一个点的 x 值，我们将 x_step 与 x_values 中的最后一个值相加（见 ❻），对于 y 值也做相同的处理。获得下一个点的 x 值和 y 值后，我们将它们分别附加到列表 x_values 和 y_values 的末尾。

下面的代码将随机漫步的所有点都绘制出来。我们首先导入了模块 pyplot 和 RandomWalk 类，然后创建了一个 RandomWalk 实例，并将其存储到 rw 中（见 ❶），再调用 fill_walk()。在 ❷ 处，我们将随机漫步包含的 x 和 y 值传递给 scatter()，并选择了合适的点尺寸。图 15-8 显示了包含 5000 个点的随机漫步图（本节的示意图未包含 matplotlib 查看器部分，但你运行 rw_visual.py 时，依然会看到）。

每次随机漫步都不同，因此探索可能生成的各种模式很有趣。要在不多次运行程序的情况下使用前面的代码模拟多次随机漫步，一种办法是将这些代码放在一个while 循环中，如下所示。这些代码模拟一次随机漫步，在 matplotlib 查看器中显示结果，再在不关闭查看器的情况下暂停。如果你关闭查看器，程序将询问你是否要再模拟一次随机漫步。如果你输入 y，可模拟多次随机漫步：这些随机漫步都在起点附近进行，大多沿特定方向偏离起点，漫步点分布不均匀等。要结束程序，请输入 n。

1『这里的这个 while 语句，提供了一个实现控制 matplotlib 查看器的实现办法。』

在本节中，我们将定制图表，以突出每次漫步的重要特征，并让分散注意力的元素不那么显眼。为此，我们确定要突出的元素，如漫步的起点、终点和经过的路径。接下来确定要使其不那么显眼的元素，如刻度标记和标签。最终的结果是简单的可视化表示，清楚地指出了每次漫步经过的路径。

我们将使用颜色映射来指出漫步中各点的先后顺序，并删除每个点的黑色轮廓，让它们的颜色更明显。为根据漫步中各点的先后顺序进行着色，我们传递参数 c，并将其设置为一个列表，其中包含各点的先后顺序。由于这些点是按顺序绘制的，因此给参数 c 指定的列表只需包含数字 1-5000，如下所示。在 ❶ 处，我们使用了 range() 生成了一个数字列表，其中包含的数字个数与漫步包含的点数相同。接下来，我们将这个列表存储在 point_numbers 中，以便后面使用它来设置每个漫步点的颜色。我们将参数 c 设置为 point_numbers，指定使用颜色映射 Blues，并传递实参 edgecolor=none 以删除每个点周围的轮廓。最终的随机漫步图从浅蓝色渐变为深蓝色，如图 15-9 所示。

1『这里面涉及到方法希望以后有机会可以弄明白。』

除了给随机漫步的各个点着色，以指出它们的先后顺序外，如果还能呈现随机漫步的起点和终点就更好了。为此，可在绘制随机漫步图后重新绘制起点和终点。我们让起点和终点变得更大，并显示为不同的颜色，以突出它们，如下所示。为突出起点，我们使用绿色绘制点 (0, 0)，并使其比其他点大（s=100 ）。为突出终点，我们在漫步包含的最后一个 x 和 y 值处绘制一个点，将其颜色设置为红色，并将尺寸设置为100。请务必将这些代码放在调用 plt.show() 的代码前面，确保在其他点的上面绘制起点和终点。如果你现在运行这些代码，将能准确地知道每次随机漫步的起点和终点（如果起点和终点不明显，请调整它们的颜色和大小，直到明显为止）。

下面来隐藏这个图表中的坐标轴，以免我们注意的是坐标轴而不是随机漫步路径。要隐藏坐标轴，可使用如下代码。为修改坐标轴，使用了函数 plt.axes() （见 ❶）来将每条坐标轴的可见性都设置为 False。随着你越来越多地进行数据可视化，经常会看到这种串接方法的方式。如果你现在运行 rw_visual.py，将看到一系列图形，但看不到坐标轴。

下面来增加点数，以提供更多的数据。为此，我们在创建 RandomWalk 实例时增大 num_points 的值，并在绘图时调整每个点的大小，如下所示。这个示例模拟了一次包含 50 000 个点的随机漫步（以模拟现实情况），并将每个点的大小都设置为 1。最终的随机漫步图更纤细，犹如云朵，如图 15-10 所示。正如你看到的，我们使用简单的散点图制作出了一件艺术品！

图表适合屏幕大小时，更能有效地将数据中的规律呈现出来。为让绘图窗口更适合屏幕大小，可像下面这样调整 matplotlib 输出的尺寸。函数 figure() 用于指定图表的宽度、高度、分辨率和背景色。你需要给形参 figsize 指定一个元组，向 matplotlib 指出绘图窗口的尺寸，单位为英寸。

Python 假定屏幕分辨率为 80 像素/英寸，如果上述代码指定的图表尺寸不合适，可根据需要调整其中的数字。如果你知道自己的系统的分辨率，可使用形参 dpi 向 figure() 传递该分辨率，以有效地利用可用的屏幕空间，如下所示：

	plt.figure(dpi=128, figsize=(10, 6))

在本节中，我们将使用 Python 可视化包 Pygal 来生成可缩放的矢量图形文件。对于需要在尺寸不同的屏幕上显示的图表，这很有用，因为它们将自动缩放，以适合观看者的屏幕。如果你打算以在线方式使用图表，请考虑使用 Pygal 来生成它们，这样它们在任何设备上显示时都会很美观。

在这个项目中，我们将对掷骰子的结果进行分析。掷 6 面的常规骰子时，可能出现的结果为 1-6 点，且出现每种结果的可能性相同。然而，如果同时掷两个骰子，某些点数出现的可能性将比其他点数大。为确定哪些点数出现的可能性最大，我们将生成一个表示掷骰子结果的数据集，并根据结果绘制出一个图形。

在数学领域，常常利用掷骰子来解释各种数据分析，但它在赌场和其他博弈场景中也得到了实际应用，在游戏《大富翁》以及众多角色扮演游戏中亦如此。

要了解使用 Pygal 可创建什么样的图表，请查看图表类型画廊：访问 http://www.pygal.org/，单击 Documentation，再单击 Chart types。每个示例都包含源代码，让你知道这些图表是如何生成的。

3『[Pygal — pygal 2.0.0 documentation](http://www.pygal.org/en/stable/)』

1『创建 Die 类时总是报错：unindent does not match any outer indentation level。怎么也找不出来 die.py 里哪错了，最后重新敲了一遍代码就解决了。』

下面的类模拟掷一个骰子。方法 \_\_init\_\_() 接受一个可选参数。创建这个类的实例时，如果没有指定任何实参，面数默认为 6；如果指定了实参，这个值将用于设置骰子的面数（见 ❶）。骰子是根据面数命名的，6 面的骰子名为 D6，8 面的骰子名为 D8，以此类推。方法 roll() 使用函数 randint() 来返回一个 1 和面数之间的随机数（见 ❷）。这个函数可能返回起始值 1、终止值 num_sides 或这两个值之间的任何整数。

使用这个类来创建图表前，先来掷 D6 骰子，将结果打印出来，并检查结果是否合理。在 ❶ 处，我们创建了一个 Die 实例，其面数为默认值 6。在 ❷ 处，我们掷骰子 100 次，并将每次的结果都存储在列表 results 中。下面是一个示例结果集。通过快速扫描这些结果可知，Die 类看起来没有问题。我们见到了值 1 和 6，这表明返回了最大和最小的可能值；我们没有见到 0 或 7，这表明结果都在正确的范围内。我们还看到了 1-6 的所有数字，这表明所有可能的结果都出现了。

为分析掷一个 D6 骰子的结果，我们计算每个点数出现的次数。由于我们将使用 Pygal 来进行分析，而不是将结果打印出来，因此可以将模拟掷骰子的次数增加到 1000（见 ❶）。为分析结果，我们创建了空列表 frequencies，用于存储每种点数出现的次数。在 ❷ 处，我们遍历可能的点数（这里为 1-6），计算每种点数在 results 中出现了多少次（见 ❸），并将这个值附加到列表 frequencies 的末尾（见 ❹）。接下来，我们在可视化之前将这个列表打印出来。结果看起来是合理的：我们看到了 6 个值 —— 掷 D6 骰子时可能出现的每个点数对应一个；我们还发现，没有任何点数出现的频率比其他点数高很多。下面来可视化这些结果。

有了频率列表后，我们就可以绘制一个表示结果的直方图。直方图 是一种条形图，指出了各种结果出现的频率。创建这种直方图的代码如下。为创建条形图，我们创建了一个 pygal.Bar() 实例，并将其存储在 hist 中（见 ❶）。接下来，我们设置 hist 的属性 title （用于标示直方图的字符串），将掷 D6 骰子的可能结果用作 x 轴的标签（见 ❷），并给每个轴都添加了标题。在 ❸ 处，我们使用 add() 将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表，其中包含将出现在图表中的值）。最后，我们将这个图表渲染为一个 SVG 文件，这种文件的扩展名必须为 .svg。要查看生成的直方图，最简单的方式是使用 Web 浏览器。为此，在任何 Web 浏览器中新建一个标签页，再在其中打开文件 die_visual.svg（它位于 die_visual.py 所在的文件夹中）。

注意，Pygal 让这个图表具有交互性：如果你将鼠标指向该图表中的任何条形，将看到与之相关联的数据。在同一个图表中绘制多个数据集时，这项功能显得特别有用。

同时掷两个骰子时，得到的点数更多，结果分布情况也不同。下面来修改前面的代码，创建两个 D6 骰子，以模拟同时掷两个骰子的情况。每次掷两个骰子时，我们都将两个骰子的点数相加，并将结果存储在 results 中。请复制 die_visual.py 并将其保存为 dice_visual.py，再做如下修改。

创建两个 Die 实例后，我们掷骰子多次，并计算每次的总点数（见 ❶）。可能出现的最大点数 12 为两个骰子的最大可能点数之和，我们将这个值存储在了 max_result 中（见 ❷）。可能出现的最小总点数 2 为两个骰子的最小可能点数之和。分析结果时，我们计算 2 到 max_result 的各种点数出现的次数（见 ❸）。我们原本可以使用 range(2, 13)，但这只适用于两个 D6 骰子。模拟现实世界的情形时，最好编写可轻松地模拟各种情形的代码。前面的代码让我们能够模拟掷任何两个骰子的情形，而不管这些骰子有多少面。创建图表时，我们修改了标题、x 轴标签和数据系列（见 ❹）。（如果列表 x_labels 比这里所示的长得多，那么编写一个循环来自动生成它将更合适。）

运行这些代码后，在浏览器中刷新显示图表的标签页，你将看到如图 15-12 所示的图表。这个图表显示了掷两个 D6 骰子时得到的大致结果。正如你看到的，总点数为 2 或 12 的可能性最小，而总点数为 7 的可能性最大，这是因为在 6 种情况下得到的总点数都为 7。这 6 种情况如下：1 和 6、2 和 5、3 和 4、4 和 3、5 和 2、6 和 1。

下面来创建一个 6 面骰子和一个 10 面骰子，看看同时掷这两个骰子 50 000 次的结果如何。为创建 D10 骰子，我们在创建第二个 Die 实例时传递了实参 10 （见 ❶）。我们还修改了第一个循环，以模拟掷骰子 50 000 次而不是 1000 次。可能出现的最小总点数依然是 2，但现在可能出现的最大总点数为 16，因此我们相应地调整了标题、x 轴标签和数据系列标签（见 ❷）。图 15-13 显示了最终的图表。可能性最大的点数不是一个，而是 5 个，这是因为导致出现最小点数和最大点数的组合都只有一种（1 和 1 以及 6 和 10），但面数较小的骰子限制了得到中间点数的组合数：得到总点数 7、8、9、10 和 11 的组合数都是 6 种。因此，这些总点数是最常见的结果，它们出现的可能性相同。

## 1601. 下载数据

在本章中，你学习了：如何使用网上的数据集；如何处理 CSV 和 JSON 文件，以及如何提取你感兴趣的数据；如何使用 matplotlib 来处理以往的天气数据，包括如何使用模块 datetime，以及如何在同一个图表中绘制多个数据系列；如何使用 Pygal 绘制呈现各国数据的世界地图，以及如何设置 Pygal 地图和图表的样式。

有了使用 CSV 和 JSON 文件的经验后，你将能够处理几乎任何要分析的数据。大多数在线数据集都可以以这两种格式中的一种或两种下载。学习使用这两种格式为学习使用其他格式的数据做好了准备。

在本章中，你将从网上下载数据，并对这些数据进行可视化。网上的数据多得难以置信，且大多未经过仔细检查。如果能够对这些数据进行分析，你就能发现别人没有发现的规律和关联。

我们将访问并可视化以两种常见格式存储的数据：CSV 和 JSON。我们将使用 Python 模块 csv 来处理以 CSV（逗号分隔的值）格式存储的天气数据，找出两个不同地区在一段时间内的最高温度和最低温度。然后，我们将使用 matplotlib 根据下载的数据创建一个图表，展示两个不同地区的气温变化：阿拉斯加锡特卡和加利福尼亚死亡谷。在本章的后面，我们将使用模块 json 来访问以 JSON 格式存储的人口数据，并使用 Pygal 绘制一幅按国别划分的人口地图。

阅读本章后，你将能够处理各种类型和格式的数据集，并对如何创建复杂的图表有更深入的认识。要处理各种真实世界的数据集，必须能够访问并可视化各种类型和格式的在线数据。

要在文本文件中存储数据，最简单的方式是将数据作为一系列以逗号分隔的值 （CSV）写入文件。这样的文件称为 CSV 文件。例如，下面是一行 CSV 格式的天气数据：

	2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195

这是阿拉斯加锡特卡 2014 年 1 月 5 日的天气数据，其中包含当天的最高气温和最低气温，还有众多其他数据。CSV 文件对人来说阅读起来比较麻烦，但程序可轻松地提取并处理其中的值，这有助于加快数据分析过程。

导入模块 csv 后，我们将要使用的文件的名称存储在 filename 中。接下来，我们打开这个文件，并将结果文件对象存储在 f 中（见❶）。然后，我们调用 csv.reader()，并将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的阅读器（reader ）对象（见❷）。我们将这个阅读器对象存储在 reader 中。

模块 csv 包含函数 next()，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。在前面的代码中，我们只调用了 next() 一次，因此得到的是文件的第一行，其中包含文件头（见❸）。我们将返回的数据存储在 header_row 中。正如你看到的，header_row 包含与天气相关的文件头，指出了每行都包含哪些数据：

reader 处理文件中以逗号分隔的第一行数据，并将每项数据都作为一个元素存储在列表中。文件头 AKDT 表示阿拉斯加时间（Alaska Daylight Time），其位置表明每行的第一个值都是日期或时间。文件头 Max TemperatureF 指出每行的第二个值都是当天的最高华氏温度。可通过阅读其他的文件头来确定文件包含的信息类型。

注意：文件头的格式并非总是一致的，空格和单位可能出现在奇怪的地方。这在原始数据文件中很常见，但不会带来任何问题。

读取该数据时，获得的是一个字符串，因为我们需要想办法将字符串 '2014-7-1' 转换为一个表示相应日期的对象。为创建一个表示 2014 年 7 月 1 日的对象，可使用模块 datetime 中的方法 strptime()。我们在终端会话中看看 strptime() 的工作原理：

我们首先导入了模块 datetime 中的 datetime 类，然后调用方法 strptime()，并将包含所需日期的字符串作为第一个实参。第二个实参告诉 Python 如何设置日期的格式。在这个示例中，'%Y-' 让 Python 将字符串中第一个连字符前面的部分视为四位的年份；'%m-' 让 Python 将第二个连字符前面的部分视为表示月份的数字；而 '%d' 让 Python 将字符串的最后一部分视为月份中的一天（1~31）。方法 strptime() 可接受各种实参，并根据它们来决定如何解读日期。表 16-1 列出了其中一些这样的实参。

	dates, highs = [], []

1『原来同时创建 2 个空列表还能这么操作的。』

我们创建了两个空列表，用于存储从文件中提取的日期和最高气温（见❶）。然后，我们将包含日期信息的数据（row[0] ）转换为 datetime 对象（见❷），并将其附加到列表 dates 末尾。在 ❸ 处，我们将日期和最高气温值传递给 plot()。在 ❹ 处，我们调用了 fig.autofmt_xdate() 来绘制斜的日期标签，以免它们彼此重叠。图 16-2 显示了改进后的图表。

添加两个数据系列后，我们就可以了解每天的气温范围了。下面来给这个图表做最后的修饰，通过着色来呈现每天的气温范围。为此，我们将使用方法 fill_between()，它接受一个 x 值系列和两个 y 值系列，并填充两个 y 值系列之间的空间：

❶处的实参 alpha 指定颜色的透明度。Alpha 值为 0 表示完全透明，1（默认设置）表示完全不透明。通过将 alpha 设置为 0.5，可让红色和蓝色折线的颜色看起来更浅。

在 ❷ 处，我们向 fill_between() 传递了一个 x 值系列：列表 dates，还传递了两个 y 值系列：highs 和 lows。实参 facecolor 指定了填充区域的颜色，我们还将 alpha 设置成了较小的值 0.1，让填充区域将两个数据系列连接起来的同时不分散观察者的注意力。图 16-5 显示了最高气温和最低气温之间的区域被填充的图表。

我们应该能够使用有关任何地方的天气数据来运行 highs_lows.py 中的代码，但有些气象站会偶尔出现故障，未能收集部分或全部其应该收集的数据。缺失数据可能会引发异常，如果不妥善地处理，还可能导致程序崩溃。

其中好像没有记录 2014 年 2 月 16 日的数据，表示最高温度的字符串为空。为解决这种问题，我们在从 CSV 文件中读取值时执行错误检查代码，对分析数据集时可能出现的异常进行处理，如下所示：

对于每一行，我们都尝试从中提取日期、最高气温和最低气温（见❶）。只要缺失其中一项数据，Python 就会引发 ValueError 异常，而我们可这样处理：打印一条错误消息，指出缺失数据的日期（见❷）。打印错误消息后，循环将接着处理下一行。如果获取特定日期的所有数据时没有发生错误，将运行 else 代码块，并将数据附加到相应列表的末尾（见❸）。鉴于我们绘图时使用的是有关另一个地方的信息，我们修改了标题，在图表中指出了这个地方（见❹）。

使用的很多数据集都可能缺失数据、数据格式不正确或数据本身不正确。对于这样的情形，可使用本书前半部分介绍的工具来处理。在这里，我们使用了一个 try-except-else 代码块来处理数据缺失的问题。在有些情况下，需要使用 continue  来跳过一些数据，或者使用 remove() 或 del 将已提取的数据删除。可采用任何管用的方法，只要能进行精确而有意义的可视化就好。

Open Knowledge Foundation（http://data.okfn.org/ ）提供了大量可以免费使用的数据集，这些数据就来自其中一个数据集。

1『书里的那些 --snip-- 是指省略的意思。』

原始数据的格式常常不统一，因此经常会出现错误。导致上述错误的原因是，Python 不能直接将包含小数点的字符串 '1127437398.85751' 转换为整数（这个小数值可能是人口数据缺失时通过插值得到的）。为消除这种错误，我们先将字符串转换为浮点数，再将浮点数转换为整数：

函数 float() 将字符串转换为小数，而函数 int() 丢弃小数部分，返回一个整数。现在，我们可以打印 2010 年的完整人口数据，不会导致错误了：

每个字符串都成功地转换成了浮点数，再转换为整数。以数字格式存储人口数量值后，就可以使用它们来制作世界人口地图了。

制作地图前，还需要解决数据存在的最后一个问题。Pygal 中的地图制作工具要求数据为特定的格式：用国别码表示国家，以及用数字表示人口数量。处理地理政治数据时，经常需要用到几个标准化国别码集。population_data.json 中包含的是三个字母的国别码，但 Pygal 使用两个字母的国别码。我们需要想办法根据国家名获取两个字母的国别码。

Pygal 使用的国别码存储在模块 i18n （internationalization 的缩写）中。字典 COUNTRIES 包含的键和值分别为两个字母的国别码和国家名。要查看这些国别码，可从模块 i18n 中导入这个字典，并打印其键和值：

导致显示错误消息的原因有两个。首先，并非所有人口数量对应的都是国家，有些人口数量对应的是地区（阿拉伯世界）和经济类群（所有收入水平）。其次，有些统计数据使用了不同的完整国家名（如 Yemen, Rep.，而不是 Yemen）。当前，我们将忽略导致错误的数据，看看根据成功恢复了的数据制作出的地图是什么样的。

有了国别码后，制作世界地图易如反掌。Pygal 提供了图表类型 Worldmap，可帮助你制作呈现各国数据的世界地图。为演示如何使用 Worldmap，我们来创建一个突出北美、中美和南美的简单地图：

有几个国家没有相关的数据，我们将其显示为黑色，但对于大多数国家，都根据其人口数量进行了着色。本章后面将处理数据缺失的问题，这里先来修改着色，以更准确地反映各国的人口数量。在当前的地图中，很多国家都是浅色的，只有两个国家是深色的。对大多数国家而言，颜色深浅的差别不足以反映其人口数量的差别。为修复这种问题，我们将根据人口数量将国家分组，再分别给每个组着色。

印度和中国的人口比其他国家多得多，但在当前的地图中，它们的颜色与其他国家差别较小。中国和印度的人口都超过了 10 亿，接下来人口最多的国家是美国，但只有大约 3 亿。下面不将所有国家都作为一个编组，而是根据人口数量分成三组 —— 少于 1000 万的、介于 1000 万和 10 亿之间的以及超过 10 亿的：

为将国家分组，我们创建了三个空字典（见❶）。接下来，遍历 cc_populations，检查每个国家的人口数量（见❷）。if-elif-else 代码块将每个「国别码-人口数量」对加入到合适的字典（cc_pops_1 、cc_pops_2 或cc_pops_3 ）中。

在 ❸ 处，我们打印这些字典的长度，以获悉每个分组的规模。绘制地图时，我们将全部三个分组都添加到 Worldmap 中（见❹）。如果你现在运行这个程序，首先看到的将是每个分组的规模：

在这个地图中，根据人口将国家分组虽然很有效，但默认的颜色设置很难看。例如，在这里，Pygal 选择了鲜艳的粉色和绿色基色。下面使用 Pygal 样式设置指令来调整颜色。我们也让 Pygal 使用一种基色，但将指定该基色，并让三个分组的颜色差别更大：

Pygal 样式存储在模块 style 中，我们从这个模块中导入了样式 RotateStyle （见❶）。创建这个类的实例时，需要提供一个实参 —— 十六进制的 RGB 颜色（见❷）；Pygal 将根据指定的颜色为每组选择颜色。十六进制格式的 RGB 颜色是一个以井号（#）打头的字符串，后面跟着 6 个字符，其中前两个字符表示红色分量，接下来的两个表示绿色分量，最后两个表示蓝色分量。每个分量的取值范围为 00 （没有相应的颜色）~FF （包含最多的相应颜色）。如果你在线搜索 hex color chooser（十六进制颜色选择器 ），可找到让你能够尝试选择不同的颜色并显示其 RGB 值的工具。这里使用的颜色值（#336699）混合了少量的红色（33）、多一些的绿色（66）和更多一些的蓝色（99），它为 RotateStyle 提供了一种淡蓝色基色。

3『[Color Picker online | hex Color Picker | html Color Picker](https://imagecolorpicker.com/)』

Pygal 通常默认使用较暗的颜色主题。为方便印刷，我使用 LightColorizedStyle 加亮了地图的颜色。这个类修改整个图表的主题，包括背景色、标签以及各个国家的颜色。要使用这个样式，先导入它：

3『[Welcome - Home - DataHub - Frictionless Data](https://datahub.io/)』

16-6 选择你感兴趣的数据：免费的 JSON 格式数据非常丰富，许多著名的国际组织都在积极分享有价值的数据。例如 OpenKnowledgeInternational (https://okfn.org/）上就有许多有趣的 JSON 数据。你也可以用本节的方法获取它们，开启自己的分析项目。

[Home | Open Knowledge Foundation](https://okfn.org/)

16-8 尝试 Python 数据科学工具：虽然 Python 标准库对数据分析的支持相对有限，但是 Python 具有非常完善的数据科学生态系统，有许多易学易用、高效便捷的第三方开源数据分析工具。除了前面介绍的 matplotlik，还有科学计算工具包 [NumPy — NumPy](https://numpy.org/)、[SciPy.org — SciPy.org](https://www.scipy.org/)、快速数据分析工具 [Python Data Analysis Library — pandas: Python Data Analysis Library](https://pandas.pydata.org/)、机器学习工具 [scikit-learn: machine learning in Python — scikit-learn 0.22 documentation](https://scikit-learn.org/stable/) 以及让深度学习开发更简单的 [Home - Keras Documentation](https://keras.io/)，它支持 Tensorflow、CNTK 和 Theano）。如果感兴趣，可以用 Pandas 直接读取 JSON 文件数据，并进行格式转换、数据聚合、时间序列分析，结合 Scikit-learn 可以对收盘价进行回归分析与预测。

我们首先导入了模块 json，以便能够正确地加载文件中的数据，然后，我们将数据存储在 pop_data 中（见❶）。函数 json.load() 将数据转换为 Python 能够处理的格式，这里是一个列表。在 ❷ 处，我们遍历 pop_data 中的每个元素。每个元素都是一个字典，包含四个「键-值」对，我们将每个字典依次存储在 pop_dict 中。

## 1701. 使用 API

在本章中，你学习了：如何使用 API 来编写独立的程序，它们自动采集所需的数据并对其进行可视化；使用 GitHub API 来探索 GitHub 上星级最高的 Python 项目，还大致地了解了 Hacker News API；如何使用 requests 包来自动执行 GitHub API 调用，以及如何处理调用的结果。我们还简要地介绍了一些 Pygal 设置，使用它们可进一步定制生成的图表的外观。

在本章中，你将学习如何编写一个独立的程序，并对其获取的数据进行可视化。这个程序将使用 Web 应用编程接口 （API）自动请求网站的特定信息而不是整个网页，再对这些信息进行可视化。由于这样编写的程序始终使用最新的数据来生成可视化，因此即便数据瞬息万变，它呈现的信息也都是最新的。

Web API 是网站的一部分，用于与使用非常具体的 URL 请求特定信息的程序交互。这种请求称为 API 调用。请求的数据将以易于处理的格式（如 JSON 或 CSV）返回。依赖于外部数据源的大多数应用程序都依赖于 API 调用，如集成社交媒体网站的应用程序。

本章的可视化将基于来自 GitHub 的信息，这是一个让程序员能够协作开发项目的网站。我们将使用 GitHub 的 API 来请求有关该网站中 Python 项目的信息，然后使用 Pygal 生成交互式可视化，以呈现这些项目的受欢迎程度。

GitHub 的 API 让你能够通过 API 调用来请求各种信息。要知道 API 调用是什么样的，请在浏览器的地址栏中输入如下地址并按回车键：

	https://api.github.com/search/repositories?q=language:python&sort=stars

这个调用返回 GitHub 当前托管了多少个 Python 项目，还有有关最受欢迎的 Python 仓库的信息。下面来仔细研究这个调用。第一部分（https://api.github.com/ ）将请求发送到 GitHub 网站中响应 API 调用的部分；接下来的一部分（search/repositories ）让 API 搜索 GitHub 上的所有仓库。

repositories 后面的问号指出我们要传递一个实参。q 表示查询，而等号让我们能够开始指定查询（q= ）。通过使用 language:python，我们指出只想获取主要语言为 Python 的仓库的信息。最后一部分（&sort=stars ）指定将项目按其获得的星级进行排序。

从第二行输出可知，编写本书时，GitHub 总共有 713 062 个 Python 项目。"incomplete_results" 的值为 false，据此我们知道请求是成功的（它并非不完整的）。倘若 GitHub 无法全面处理该 API，它返回的这个值将为 true。接下来的列表中显示了返回的 "items"，其中包含 GitHub 上最受欢迎的 Python 项目的详细信息。requests 包让 Python 程序能够轻松地向网站请求信息以及检查返回的响应。

在 ❶ 处，我们导入了模块 requests。在 ❷ 处，我们存储 API 调用的 URL，然后使用 requests 来执行调用（见❸）。我们调用 get() 并将 URL 传递给它，再将响应对象存储在变量 r 中。响应对象包含一个名为 status_code 的属性，它让我们知道请求是否成功了（状态码 200 表示请求成功）。在 ❹ 处，我们打印 status_code，核实调用是否成功了。这个 API 返回 JSON 格式的信息，因此我们使用方法 json() 将这些信息转换为一个 Python 字典（见❺）。我们将转换得到的字典存储在 response_dict 中。像这样简单的调用应该会返回完整的结果集，因此完全可以忽略与 'incomplete_results' 相关联的值。但执行更复杂的 API 调用时，程序应检查这个值。

1『r = requests.get(url)；response_dict = r.json() 可以直接把请求返回的 json 格式的信息转化为 python 字典对象。』

在这里，我们打印了表示第一个仓库的字典中与很多键相关联的值。在 ❶ 处，我们打印了项目的名称。项目所有者是用一个字典表示的，因此在 ❷ 处，我们使用键 owner 来访问表示所有者的字典，再使用键 key 来获取所有者的登录名。在 ❸ 处，我们打印项目获得了多少个星的评级，以及项目在 GitHub 仓库的 URL。接下来，我们显示项目的创建时间（见❹）和最后一次更新的时间（见❺）。最后，我们打印仓库的描述。输出类似于下面这样：

对这些数据进行可视化时，我们需要涵盖多个仓库。下面就来编写一个循环，打印 API 调用返回的每个仓库的特定信息，以便能够在可视化中包含所有这些信息：

    print('\nName: ', repo_dict['name'])

1『想要实现在恰当的地方空行，试试用上面的语句，踩过坑的。如果把 \n 拿到 name 字符串外面来的话，会比自己想要的结果多一个空格出来。』

我们关心的信息是搜索 API 的速率限制（见❶）。从 ❷ 处可知，极限为每分钟 10 个请求，而在当前这一分钟内，我们还可执行 8 个请求（见❸）。reset 值指的是配额将重置的 Unix 时间或新纪元时间 （1970 年 1 月 1 日午夜后多少秒）（见❹）。用完配额后，你将收到一条简单的响应，由此知道已到达 API 极限。到达极限后，你必须等待配额重置。

注意：很多 API 都要求你注册获得 API 密钥后才能执行 API 调用。编写本书时，GitHub 没有这样的要求，但获得 API 密钥后，配额将高得多。

1『注意，函数括号里面传递实参时的赋值号 = 是没有空格的。』

我们首先导入了 pygal 以及要应用于图表的 Pygal 样式。接下来，打印 API 调用响应的状态以及找到的仓库总数，以便获悉 API 调用是否出现了问题。我们不再打印返回的有关项目的信息，因为将通过可视化来呈现这些信息。

在 ❶ 处，我们创建了两个空列表，用于存储将包含在图表中的信息。我们需要每个项目的名称，用于给条形加上标签，我们还需要知道项目获得了多少个星，用于确定条形的高度。在循环中，我们将项目的名称和获得的星数附加到这些列表的末尾 ❷。

接下来，我们使用 LightenStyle 类（别名 LS ）定义了一种样式，并将其基色设置为深蓝色（见❸）。我们还传递了实参 base_style，以使用 LightColorizedStyle 类（别名 LCS ）。然后，我们使用 Bar() 创建一个简单的条形图，并向它传递了 my_style （见❹）。我们还传递了另外两个样式实参：让标签绕 x 轴旋转 45 度（x_label_rotation=45 ），并隐藏了图例（show_legend=False ），因为我们只在图表中绘制一个数据系列。接下来，我们给图表指定了标题，并将属性 x_labels 设置为列表 names。

由于我们不需要给这个数据系列添加标签，因此在 ❺ 处添加数据时，将标签设置成了空字符串。生成的图表如图 17-1 所示。从中可知，前几个项目的受欢迎程度比其他项目高得多，但所有这些项目在 Python 生态系统中都很重要。

在 ❶ 处，我们创建了一个Pygal类 Config 的实例，并将其命名为 my_config。通过修改 my_config 的属性，可定制图表的外观。在 ❷ 处，我们设置了两个属性 —— x_label_rotation 和 show_legend，它们原来是在创建 Bar 实例时以关键字实参的方式传递的。

在 ❸ 处，我们设置了图表标题、副标签和主标签的字体大小。在这个图表中，副标签是 x 轴上的项目名以及 y 轴上的大部分数字。主标签是 y 轴上为 5000 整数倍的刻度；这些标签应更大，以与副标签区分开来。在 ❹ 处，我们使用 truncate_label 将较长的项目名缩短为 15 个字符（如果你将鼠标指向屏幕上被截短的项目名，将显示完整的项目名）。接下来，我们将 show_y_guides 设置为 False，以隐藏图表中的水平线（见❺）。最后，在 ❻ 处设置了自定义宽度，让图表更充分地利用浏览器中的可用空间。

在 ❼ 处创建Bar 实例时，我们将 my_config 作为第一个实参，从而通过一个实参传递了所有的配置设置。我们可以通过 my_config 做任意数量的样式和配置修改，而 ❼ 处的代码行将保持不变。图 17-2 显示了重新设置样式后的图表。

在 Pygal 中，将鼠标指向条形将显示它表示的信息，这通常称为工具提示。在这个示例中，当前显示的是项目获得了多少个星。下面来创建一个自定义工具提示，以同时显示项目的描述。

来看一个简单的示例，它可视化前三个项目，并给每个项目对应的条形都指定自定义标签。为此，我们向 add() 传递一个字典列表，而不是值列表：

Pygal 还允许你将图表中的每个条形用作网站的链接。为此，只需添加一行代码，在为每个项目创建的字典中，添加一个键为 'xlink' 的「键-值」对。Pygal 根据与键 'xlink' 相关联的 URL 将每个条形都转换为活跃的链接。单击图表中的任何条形时，都将在浏览器中打开一个新的标签页，并在其中显示相应项目的 GitHub 页面。至此，你对 API 获取的数据进行了可视化，它是交互性的，包含丰富的信息！

为探索如何使用其他网站的 API 调用，我们来看看 [Hacker News](https://news.ycombinator.com/)。在 Hacker News 网站，用户分享编程和技术方面的文章，并就这些文章展开积极的讨论。Hacker News 的 API 让你能够访问有关该网站所有文章和评论的信息，且不要求你通过注册获得密钥。

这个字典包含很多键，如 'url' （见❶）和 'title' （见❷）。与键 'descendants' 相关联的值是文章被评论的次数（见❸）。与键 'kids' 相关联的值包含对文章所做的所有评论的 ID（见❹）。每个评论自己也可能有 kid，因此文章的后代（descendant）数量可能比其 kid 数量多。

下面来执行一个 API 调用，返回 Hacker News 上当前热门文章的 ID，再查看每篇排名靠前的文章：

首先，我们执行了一个 API 调用，并打印了响应的状态（见❶）。这个 API 调用返回一个列表，其中包含 Hacker News 上当前最热门的 500 篇文章的 ID。接下来，我们将响应文本转换为一个 Python 列表（见❷），并将其存储在 submission_ids 中。我们将使用这些 ID 来创建一系列字典，其中每个字典都存储了一篇文章的信息。

在 ❸ 处，我们创建了一个名为 submission_dicts 的空列表，用于存储前面所说的字典。接下来，我们遍历前 30 篇文章的 ID。对于每篇文章，我们都执行一个 API 调用，其中的 URL 包含 submission_id 的当前值（见❹）。我们打印每次请求的状态，以便知道请求是否成功了。

在 ❺ 处，我们为当前处理的文章创建一个字典，并在其中存储文章的标题以及到其讨论页面的链接。在 ❻ 处，我们在这个字典中存储了评论数。如果文章还没有评论，响应字典中将没有键 'descendants'。不确定某个键是否包含在字典中时，可使用方法 dict.get()，它在指定的键存在时返回与之相关联的值，并在指定的键不存在时返回你指定的值（这里是 0）。最后，我们将 submission_dict 附加到 submission_dicts 末尾。

Hacker News 上的文章是根据总体得分排名的，而总体得分取决于很多因素，其中包含被推荐的次数、评论数以及发表的时间。我们要根据评论数对字典列表 submission_dicts 进行排序，为此，使用了模块 operator 中的函数 itemgetter() （见❼）。我们向这个函数传递了键 'comments'，因此它将从这个列表的每个字典中提取与键 'comments' 相关联的值。这样，函数 sorted() 将根据这种值对列表进行排序。我们将列表按降序排列，即评论最多的文章位于最前面。

对列表排序后，我们遍历这个列表（见❽），对于每篇热门文章，都打印其三项信息：标题、到讨论页面的链接以及文章现有的评论数：

使用任何 API 来访问和分析信息时，流程都与此类似。有了这些数据后，你就可以进行可视化，指出最近哪些文章引发了最激烈的讨论。

## 1801. Django 入门

在本章中，你首先学习了如何使用 Django 框架来创建 Web 应用程序。你制定了简要的项目规范，在虚拟环境中安装了 Django，创建了一个项目，并核实该项目已正确地创建。你学习了如何创建应用程序，以及如何定义表示应用程序数据的模型。你学习了数据库，以及在你修改模型后，Django 可为你迁移数据库提供什么样的帮助。你学习了如何创建可访问管理网站的超级用户，并使用管理网站输入了一些初始数据。

你还探索了 Django shell，它让你能够在终端会话中处理项目的数据。你学习了如何定义 URL、创建视图函数以及编写为网站创建网页的模板。最后，你使用了模板继承，它可简化各个模板的结构，并使得修改网站更容易。

在第 19 章，我们将创建对用户友好而直观的网页，让用户无需通过管理网站就能添加新的主题和条目，以及编辑既有的条目。我们还将添加一个用户注册系统，让用户能够创建账户和自己的学习笔记。让任意数量的用户都能与之交互，是 Web 应用程序的核心所在。

当今的网站实际上都是富应用程序（rich application），就像成熟的桌面应用程序一样。Python 提供了一组开发 Web 应用程序的卓越工具。在本章中，你将学习如何使用 [The Web framework for perfectionists with deadlines | Django](https://www.djangoproject.com/) 来开发一个名为「学习笔记」（Learning Log）的项目，这是一个在线日志系统，让你能够记录所学习的有关特定主题的知识。

我们将为这个项目制定规范，然后为应用程序使用的数据定义模型。我们将使用 Django 的管理系统来输入一些初始数据，再学习编写视图和模板，让 Django 能够为我们的网站创建网页。

Django 是一个 Web 框架  ——  一套用于帮助开发交互式网站的工具。Django 能够响应网页请求，还能让你更轻松地读写数据库、管理用户等。在第 19 章和第 20 章，我们将改进「学习笔记」项目，再将其部署到活动的服务器，让你和你的朋友能够使用它。

完整的规范详细说明了项目的目标，阐述了项目的功能，并讨论了项目的外观和用户界面。与任何良好的项目规划和商业计划书一样，规范应突出重点，帮助避免项目偏离轨道。这里不会制定完整的项目规划，而只列出一些明确的目标，以突出开发的重点。我们制定的规范如下：

我们要编写一个名为「学习笔记」的 Web 应用程序，让用户能够记录感兴趣的主题，并在学习每个主题的过程中添加日志条目。「学习笔记」的主页对这个网站进行描述，并邀请用户注册或登录。用户登录后，就可创建新主题、添加新条目以及阅读既有的条目。

学习新的主题时，记录学到的知识可帮助跟踪和复习这些知识。优秀的应用程序让这个记录过程简单易行。

为项目新建一个目录，将其命名为 learning_log，再在终端中切换到这个目录，并创建一个虚拟环境。如果你使用的是 Python 3，可使用如下命令来创建虚拟环境：

	learning_log$ python3 -m venv ll_env

这里运行了模块 venv，并使用它来创建一个名为 ll_env 的虚拟环境。

注意：如果你的系统安装了多个 Python 版本，需要指定 virtualenv 使用的版本。例如，命令 virtualenv ll_env --python=python3 创建一个使用 Python 3 的虚拟环境。

建立虚拟环境后，需要使用下面的命令激活它：

```
learning_log$ source ll_env/bin/activate

❶ (ll_env)learning_log$
```

这个命令运行 ll_env/bin 中的脚本 activate。环境处于活动状态时，环境名将包含在括号内，如 ❶ 处所示。在这种情况下，你可以在环境中安装包，并使用已安装的包。你在 ll_env 中安装的包仅在该环境处于活动状态时才可用。

要停止使用虚拟环境，可执行命令 deactivate ：

创建并激活虚拟环境后，就可安装 Django 了：

	pip3 install Django

由于我们是在虚拟环境中工作，因此在所有的系统中，安装 Django 的命令都相同：不需要指定标志 --user，也无需使用 python -m pip install package_name 这样较长的命令。别忘了，Django 仅在虚拟环境处于活动状态时才可用。

❶ 处的命令让 Django 新建一个名为 learning_log 的项目。这个命令末尾的句点让新项目使用合适的目录结构，这样开发完成后可轻松地将应用程序部署到服务器。

注意：千万别忘了这个句点，否则部署应用程序时将遭遇一些配置问题。如果忘记了这个句点，就将创建的文件和文件夹删除（ll_env 除外），再重新运行这个命令。

在 ❸ 处，运行了命令 ls （在Windows系统上应为 dir ），结果表明 Django 新建了一个名为 learning_log 的目录。它还创建了一个名为 manage.py 的文件，这是一个简单的程序，它接受命令并将其交给 Django 的相关部分去运行。我们将使用这些命令来管理诸如使用数据库和运行服务器等任务。

目录 learning_log 包含 4 个文件（见❸），其中最重要的是 settings.py、urls.py 和 wsgi.py。文件 settings.py 指定 Django 如何与你的系统交互以及如何管理项目。在开发项目的过程中，我们将修改其中一些设置，并添加一些设置。文件 urls.py 告诉 Django 应创建哪些网页来响应浏览器请求。文件 wsgi.py 帮助 Django 提供它创建的文件，这个文件名是 web server gateway interface（Web 服务器网关接口 ）的首字母缩写。

Django 将大部分与项目相关的信息都存储在数据库中，因此我们需要创建一个供 Django 使用的数据库。为给项目「学习笔记」创建数据库，请在处于活动虚拟环境中的情况下执行下面的命令：

	(ll_env)learning_log$ python3 manage.py migrate

我们将修改数据库称为迁移数据库。首次执行命令 migrate 时，将让 Django 确保数据库与项目的当前状态匹配。在使用 SQLite（后面将更详细地介绍）的新项目中首次执行这个命令时，Django 将新建一个数据库。在 ❶ 处，Django 指出它将创建必要的数据库表，用于存储我们将在这个项目（Synchronize unmigrated apps，同步未迁移的应用程序 ）中使用的信息，再确保数据库结构与当前代码（Apply all migrations，应用所有的迁移 ）匹配。

在 ❷ 处，我们运行了命令 ls，其输出表明 Django 又创建了一个文件 —— db.sqlite3。SQLite 是一种使用单个文件的数据库，是编写简单应用程序的理想选择，因为它让你不用太关注数据库管理的问题。

下面来核实 Django 是否正确地创建了项目。执行命令：

	(ll_env)learning_log$ python manage.py runserver

Django 启动一个服务器，让你能够查看系统中的项目，了解它们的工作情况。当你在浏览器中输入 URL 以请求网页时，该 Django 服务器将进行响应：生成合适的网页，并将其发送给浏览器。

在 ❶ 处，Django 通过检查确认正确地创建了项目；在 ❷ 处，它指出了使用的 Django 版本以及当前使用的设置文件的名称；在 ❸ 处，它指出了项目的 URL。URL http://127.0.0.1:8000/ 表明项目将在你的计算机（即 localhost）的端口 8000 上侦听请求。localhost 是一种只处理当前系统发出的请求，而不允许其他任何人查看你正在开发的网页的服务器。

现在打开一款Web浏览器，并输入 URL：http://localhost:8000/；如果这不管用，请输入 http://127.0.0.1:8000/。你将看到类似于图 18-1 所示的页面，这个页面是 Django 创建的，让你知道到目前为止一切正常。现在暂时不要关闭这个服务器。若要关闭这个服务器，按 Ctrl + C 即可。

Django 项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。我们暂时只创建一个应用程序，它将完成项目的大部分工作。在第 19 章，我们将再添加一个管理用户账户的应用程序。

当前，在前面打开的终端窗口中应该还运行着 runserver。请再打开一个终端窗口（或标签页），并切换到 manage.py 所在的目录。激活该虚拟环境，再执行命令 startapp ：

	(ll_env)learning_log$ python manage.py startapp learning_logs

1『这个命令前记得一定要把虚拟环境激活。』

命令 startapp appname 让 Django 建立创建应用程序所需的基础设施。如果现在查看项目目录，将看到其中新增了一个文件夹 learning_logs（见❶）。打开这个文件夹，看看 Django 都创建了什么（见❷）。其中最重要的文件是 models.py、admin.py 和 views.py。我们将使用 models.py 来定义我们要在应用程序中管理的数据。admin.py 和 views.py 将在稍后介绍。

我们来想想涉及的数据。每位用户都需要在学习笔记中创建很多主题。用户输入的每个条目都与特定主题相关联，这些条目将以文本的方式显示。我们还需要存储每个条目的时间戳，以便能够告诉用户各个条目都是什么时候创建的。

打开文件 models.py，看看它当前包含哪些内容：

这为我们导入了模块 models，还让我们创建自己的模型。模型告诉 Django 如何处理应用程序中存储的数据。在代码层面，模型就是一个类，就像前面讨论的每个类一样，包含属性和方法。下面是表示用户将要存储的主题的模型：

我们创建了一个名为 Topic 的类，它继承了 Model  —— Django 中一个定义了模型基本功能的类。Topic 类只有两个属性：text 和 date_added。

属性 text 是一个 CharField —— 由字符或文本组成的数据（见❶）。需要存储少量的文本，如名称、标题或城市时，可使用 CharField。定义 CharField 属性时，必须告诉 Django 该在数据库中预留多少空间。在这里，我们将 max_length 设置成了 200（即 200 个字符），这对存储大多数主题名来说足够了。

属性 date_added 是一个 DateTimeField  —— 记录日期和时间的数据（见❷）。我们传递了实参 auto_add_now=True，每当用户创建新主题时，这都让 Django 将这个属性自动设置成当前日期和时间。

1『DateTimeField 是 django.db.models 的一个属性。开始码的时候把 DateTimeField 误打成了 DataTimeField，找了很久才发现这个错误。』

注意：要获悉可在模型中使用的各种字段，请参阅 Django Model Field Reference（Django 模型字段参考），其网址为 [Model field reference | Django documentation | Django](https://docs.djangoproject.com/en/1.8/ref/models/fields/)。就当前而言，你无需全面了解其中的所有内容，但自己开发应用程序时，这些内容会提供极大的帮助。

我们需要告诉 Django，默认应使用哪个属性来显示有关主题的信息。Django 调用方法 `__str__()` 来显示模型的简单表示。在这里，我们编写了方法 `__str__()`，它返回存储在属性 text 中的字符串（见❸）。

注意：如果你使用的是 Python 2.7，应调用方法 `__unicode__()`，而不是 `__str__()`，但其中的代码相同。

要使用模型，必须让 Django 将应用程序包含到项目中。为此，打开 settings.py（它位于目录 learning_log/learning_log中），你将看到一个这样的片段，即告诉 Django 哪些应用程序安装在项目中：

这是一个元组，告诉 Django 项目是由哪些应用程序组成的。请将 INSTALLED_APPS 修改成下面这样，将前面的应用程序添加到这个元组中：

1『我的文件里 INSTALLED_APPS 是个列表，而非元组。』

通过将应用程序编组，在项目不断增大，包含更多的应用程序时，有助于对应用程序进行跟踪。这里新建了一个名为 My apps 的片段，当前它只包含应用程序 learning_logs。

接下来，需要让 Django 修改数据库，使其能够存储与模型 Topic 相关的信息。为此，在终端窗口中执行下面的命令：

	(ll_env)learning_log$ python manage.py makemigrations learning_logs

命令 makemigrations 让 Django 确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据。输出表明 Django 创建了一个名为 0001_initial.py 的迁移文件，这个文件将在数据库中为模型 Topic 创建一个表。

下面来应用这种迁移，让 Django 替我们修改数据库：

	(ll_env)learning_log$ python manage.py migrate

这个命令的大部分输出都与我们首次执行命令 migrate 的输出相同。我们需要检查的是 ❶ 处的输出行，在这里，Django 确认为 learning_logs 应用迁移时一切正常（OK ）。

每当需要修改「学习笔记」管理的数据时，都采取如下三个步骤：修改 models.py；对 learning_logs 调用 makemigrations ；让 Django 迁移项目。

为应用程序定义模型时，Django 提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。在本节中，我们将建立管理网站，并通过它使用模型 Topic 来添加一些主题。

Django 允许你创建具备所有权限的用户  ——  超级用户。权限决定了用户可执行的操作。最严格的权限设置只允许用户阅读网站的公开信息；注册了的用户通常可阅读自己的私有数据，还可查看一些只有会员才能查看的信息。为有效地管理 Web 应用程序，网站所有者通常需要访问网站存储的所有信息。优秀的管理员会小心对待用户的敏感信息，因为用户对其访问的应用程序有极大的信任。

为在 Django 中创建超级用户，请执行下面的命令并按提示做：

你执行命令 createsuperuser 时，Django 提示你输入超级用户的用户名（见❶）。这里我们输入的是 ll_admin，但你可以输入任何用户名，比如电子邮件地址，也可让这个字段为空（见❷）。你需要输入密码两次（见❸）。

注意：可能会对网站管理员隐藏有些敏感信息。例如，Django 并不存储你输入的密码，而存储从该密码派生出来的一个字符串  ——  散列值。每当你输入密码时，Django 都计算其散列值，并将结果与存储的散列值进行比较。如果这两个散列值相同，就通过了身份验证。通过存储散列值，即便黑客获得了网站数据库的访问权，也只能获取其中存储的散列值，而无法获得密码。在网站配置正确的情况下，几乎无法根据散列值推导出原始密码。

Django 自动在管理网站中添加了一些模型，如 User 和 Group，但对于我们创建的模型，必须手工进行注册。我们创建应用程序 learning_logs 时，Django 在 models.py 所在的目录中创建了一个名为 admin.py 的文件：

这些代码导入我们要注册的模型 Topic （见❶），再使用 admin.site.register () （见❷）让 Django 通过管理网站管理我们的模型。

现在，使用超级用户账户访问管理网站：访问 http://localhost:8000/admin/，并输入你刚创建的超级用户的用户名和密码，你将看到类似于图 18-2 所示的屏幕。这个网页让你能够添加和修改用户和用户组，还可以管理与刚才定义的模型 Topic 相关的数据。

向管理网站注册 Topic 后，我们来添加第一个主题。为此，单击 Topics 进入主题网页，它几乎是空的，这是因为我们还没有添加任何主题。单击 Add，你将看到一个用于添加新主题的表单。在第一个方框中输入 Chess，再单击 Save，这将返回到主题管理页面，其中包含刚创建的主题。

下面再创建一个主题，以便有更多的数据可供使用。再次单击 Add，并创建另一个主题 Rock Climbing。当你单击 Save 时，将重新回到主题管理页面，其中包含主题 Chess 和 Rock Climbing。

要记录学到的国际象棋和攀岩知识，需要为用户可在学习笔记中添加的条目定义模型。每个条目都与特定主题相关联，这种关系被称为多对一关系，即多个条目可关联到同一个主题。

像 Topic 一样，Entry 也继承了 Django 基类 Model （见❶）。第一个属性 topic 是一个 ForeignKey 实例（见❷）。外键是一个数据库术语，它引用了数据库中的另一条记录；这些代码将每个条目关联到特定的主题。每个主题创建时，都给它分配了一个键（或 ID）。需要在两项数据之间建立联系时，Django 使用与每项信息相关联的键。稍后我们将根据这些联系获取与特定主题相关联的所有条目。

接下来是属性 text，它是一个 TextField 实例（见❸）。这种字段不需要长度限制，因为我们不想限制条目的长度。属性 date_added 让我们能够按创建顺序呈现条目，并在每个条目旁边放置时间戳。

在 ❹ 处，我们在 Entry 类中嵌套了 Meta 类。Meta 存储用于管理模型的额外信息，在这里，它让我们能够设置一个特殊属性，让 Django 在需要时使用 Entries 来表示多个条目。如果没有这个类，Django 将使用 Entrys 来表示多个条目。最后，方法 \_\_str\_\_() 告诉 Django，呈现条目时应显示哪些信息。由于条目包含的文本可能很长，我们让 Django 只显示 text 的前 50 个字符（见❺）。我们还添加了一个省略号，指出显示的并非整个条目。

由于我们添加了一个新模型，因此需要再次迁移数据库。你将慢慢地对这个过程了如指掌：修改 models.py，执行命令 python manage.py makemigrations app_name，再执行命令 python manage.py migrate。

1『

总是报错：TypeError: \_\_init\_\_() missing 1 required positional argument: 'on_delete'

改代码：

	topic = models.ForeignKey(Topic, on_delete=models.CASCADE)

[Django在根据models生成数据库表时报 \_\_init\_\_() missing 1 required positional argument: 'on_delete' - phyger - 博客园](https://www.cnblogs.com/phyger/p/8035253.html)

原因：在 django2.0 后，定义外键和一对一关系的时候需要加 on_delete 选项，此参数为了避免两个表里的数据不一致问题，不然会报错。

举例说明：

	user=models.OneToOneField(User)

	owner=models.ForeignKey(UserProfile)

需要改成：

	user=models.OneToOneField(User,on_delete=models.CASCADE) 

在老版本这个参数（models.CASCADE）是默认值，五个可选择的值：

CASCADE：此值设置，是级联删除。

PROTECT：此值设置，是会报完整性错误。

SET_NULL：此值设置，会把外键设置为null，前提是允许为null。

SET_DEFAULT：此值设置，会把设置为外键的默认值。

SET()：此值设置，会调用外面的值，可以是一个函数。

一般情况下使用CASCADE就可以了。

』

生成了一个新的迁移文件  —— 0002_entry.py，它告诉 Django 如何修改数据库，使其能够存储与模型 Entry 相关的信息（见❶）。执行命令 migrate，我们发现 Django 应用了这种迁移且一切顺利（见❷）。

我们还需要注册模型 Entry。为此，需要将 admin.py 修改成类似于下面这样：

当你单击 Save 时，将返回到主条目管理页面。在这里，你将发现使用 text [:50] 作为条目的字符串表示的好处：管理界面中，只显示了条目的开头部分而不是其所有文本，这使得管理多个条目容易得多。

输入一些数据后，就可通过交互式终端会话以编程方式查看这些数据了。这种交互式环境称为 Django shell，是测试项目和排除其故障的理想之地。下面是一个交互式 shell 会话示例：

	(ll_env)learning_log$ python manage.py shell

在活动的虚拟环境中执行时，命令 python manage.py shell 启动一个 Python 解释器，可使用它来探索存储在项目数据库中的数据。在这里，我们导入了模块 learning_logs.models 中的模型 Topic （见❶），然后使用方法 Topic.objects.all () 来获取模型 Topic 的所有实例；它返回的是一个列表，称为查询集（queryset）。我们可以像遍历列表一样遍历查询集。下面演示了如何查看分配给每个主题对象的 ID：

我们将返回的查询集存储在 topics 中，然后打印每个主题的 id 属性和字符串表示。从输出可知，主题 Chess 的 ID 为 1，而 Rock Climbing 的 ID 为 2。知道对象的 ID 后，就可获取该对象并查看其任何属性。下面来看看主题 Chess 的属性 text 和 date_added 的值：

我们还可以查看与主题相关联的条目。前面我们给模型 Entry 定义了属性 topic，这是一个 ForeignKey，将条目与主题关联起来。利用这种关联，Django 能够获取与特定主题相关联的所有条目，如下所示：

为通过外键关系获取数据，可使用相关模型的小写名称、下划线和单词 set（见❶）。例如，假设你有模型 Pizza 和 Topping，而 Topping 通过一个外键关联到 Pizza ；如果你有一个名为 my_pizza 的对象，表示一张比萨，就可使用代码 my_pizza.topping_set.all () 来获取这张比萨的所有配料。

编写用户可请求的网页时，我们将使用这种语法。确认代码能获取所需的数据时，shell 很有帮助。如果代码在 shell 中的行为符合预期，那么它们在项目文件中也能正确地工作。如果代码引发了错误或获取的数据不符合预期，那么在简单的 shell 环境中排除故障要比在生成网页的文件中排除故障容易得多。我们不会太多地使用 shell，但应继续使用它来熟悉对存储在项目中的数据进行访问的 Django 语法。

注意：每次修改模型后，你都需要重启 shell，这样才能看到修改的效果。要退出 shell 会话，可按 Ctr + D；如果你使用的是 Windows 系统，应按 Ctr + Z，再按回车键。

使用 Django 创建网页的过程通常分三个阶段：定义 URL、编写视图和编写模板。首先，你必须定义 URL 模式。URL 模式描述了 URL 是如何设计的，让 Django 知道如何将浏览器请求与网站 URL 匹配，以确定返回哪个网页。每个 URL 都被映射到特定的视图  ——  视图函数获取并处理网页所需的数据。视图函数通常调用一个模板，后者生成浏览器能够理解的网页。为明白其中的工作原理，我们来创建学习笔记的主页。我们将定义该主页的 URL、编写其视图函数并创建一个简单的模板。

鉴于我们只是要确保「学习笔记」按要求的那样工作，我们将暂时让这个网页尽可能简单。Web 应用程序能够正常运行后，设置样式可使其更有趣，但中看不中用的应用程序毫无意义。就目前而言，主页只显示标题和简单的描述。

用户通过在浏览器中输入 URL 以及单击链接来请求网页，因此我们需要确定项目需要哪些 URL。主页的 URL 最重要，它是用户用来访问项目的基础 URL。当前，基础 URL（http://localhost:8000/）返回默认的 Django 网站，让我们知道正确地建立了项目。我们将修改这一点，将这个基础 URL 映射到「学习笔记」的主页。

打开项目主文件夹 learning_log 中的文件 urls.py，你将看到如下代码：

前两行导入了为项目和管理网站管理 URL 的函数和模块（见❶）。这个文件的主体定义了变量 urlpatterns （见❷）。在这个针对整个项目的 urls.py 文件中，变量 urlpatterns 包含项目中的应用程序的 URL。❸ 处的代码包含模块 admin.site.urls，该模块定义了可在管理网站中请求的所有 URL。我们需要包含 learning_logs 的 URL：

1『

被坑了，中文版里的代码是错的，在原书里找到源码如下：

```
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('learning_logs.urls'))
]
```
』

在 ❶ 处，我们添加了一行代码来包含模块 learning_logs.urls。这行代码包含实参 namespace，让我们能够将 learning_logs 的 URL 同项目中的其他 URL 区分开来，这在项目开始扩展时很有帮助。

默认的 urls.py 包含在文件夹 learning_log 中，现在我们需要在文件夹 learning_logs 中创建另一个 urls.py 文件：

为弄清楚当前位于哪个 urls.py 文件中，我们在这个文件开头添加了一个文档字符串（见❶）。接下来，我们导入了函数 url，因为我们需要使用它来将 URL 映射到视图（见❷）。我们还导入了模块 views （见❸），其中的句点让 Python 从当前的 urls.py 模块所在的文件夹中导入视图。在这个模块中，变量 urlpatterns 是一个列表，包含可在应用程序 learning_logs 中请求的网页（见❹）。

实际的 URL 模式是一个对函数 url () 的调用，这个函数接受三个实参（见❸）。第一个是一个正则表达式。Django 在 urlpatterns 中查找与请求的 URL 字符串匹配的正则表达式，因此正则表达式定义了 Django 可查找的模式。

我们来看看正则表达式：

	r'^$' 

其中的 r 让 Python 将接下来的字符串视为原始字符串，而引号告诉 Python 正则表达式始于和终于何处。脱字符（^ ）让 Python 查看字符串的开头，而美元符号让 Python 查看字符串的末尾。总体而言，这个正则表达式让 Python 查找开头和末尾之间没有任何东西的 URL。Python 忽略项目的基础 URL（http://localhost:8000/），因此这个正则表达式与基础 URL 匹配。其他 URL 都与这个正则表达式不匹配。如果请求的 URL 不与任何 URL 模式匹配，Django 将返回一个错误页面。

url () 的第二个实参（见❺）指定了要调用的视图函数。请求的 URL 与前述正则表达式匹配时，Django 将调用 views.index （这个视图函数将在下一节编写）。第三个实参将这个 URL 模式的名称指定为 index，让我们能够在代码的其他地方引用它。每当需要提供到这个主页的链接时，我们都将使用这个名称，而不编写 URL。

注意：正则表达式通常被称为 regex，几乎每种编程语言都使用它。它们的用途多得难以置信，但需要经过一定的练习才能熟悉。如果你不明白前面介绍的内容，也不用担心，你在完成这个项目的过程中，将会看到很多正则表达式。

视图函数接受请求中的信息，准备好生成网页所需的数据，再将这些数据发送给浏览器  ——  这通常是使用定义了网页是什么样的模板实现的。learning_logs 中的文件 views.py 是你执行命令 python manage.py startapp 时自动生成的，当前其内容如下：

URL 请求与我们刚才定义的模式匹配时，Django 将在文件 views.py 中查找函数 index ()，再将请求对象传递给这个视图函数。在这里，我们不需要处理任何数据，因此这个函数只包含调用 render () 的代码。这里向函数 render () 提供了两个实参：原始请求对象以及一个可用于创建网页的模板。下面来编写这个模板。

模板定义了网页的结构。模板指定了网页是什么样的，而每当网页被请求时，Django 将填入相关的数据。模板让你能够访问视图提供的任何数据。我们的主页视图没有提供任何数据，因此相应的模板非常简单。

在文件夹 learning_logs 中新建一个文件夹，并将其命名为 templates。在文件夹 templates 中，再新建一个文件夹，并将其命名为 learning_logs。这好像有点多余（我们在文件夹 learning_logs 中创建了文件夹 templates，又在这个文件夹中创建了文件夹 learning_logs），但建立了 Django 能够明确解读的结构，即便项目很大，包含很多应用程序亦如此。在最里面的文件夹 learning_logs 中，新建一个文件，并将其命名为 index.html，再在这个文件中编写如下代码：

制定创建网页的流程后，可以开始扩充「学习笔记」项目了。我们将创建两个显示数据的网页，其中一个列出所有的主题，另一个显示特定主题的所有条目。对于每个网页，我们都将指定 URL 模式，编写一个视图函数，并编写一个模板。但这样做之前，我们先创建一个父模板，项目中的其他模板都将继承它。

我们首先来创建一个名为 base.html 的模板，并将其存储在 index.html 所在的目录中。这个文件包含所有页面都有的元素；其他的模板都继承 base.html。当前，所有页面都包含的元素只有顶端的标题。我们将在每个页面中包含这个模板，因此我们将这个标题设置为到主页的链接：

这个文件的第一部分创建一个包含项目名的段落，该段落也是一个到主页的链接。为创建链接，我们使用了一个模板标签，它是用大括号和百分号（{% %} ）表示的。模板标签是一小段代码，生成要在网页中显示的信息。在这个实例中，模板标签 {% url 'learning_logs:index' %} 生成一个 URL，该 URL 与 learning_logs/urls.py 中定义的名为 index 的 URL 模式匹配（见❶）。在这个示例中，learning_logs 是一个命名空间，而 index 是该命名空间中一个名称独特的 URL 模式。

在简单的 HTML 页面中，链接是使用锚标签定义的：

<a href="link_url">link text</a>

让模板标签来生成 URL，可让链接保持最新容易得多。要修改项目中的 URL，只需修改 urls.py 中的 URL 模式，这样网页被请求时，Django 将自动插入修改后的 URL。在我们的项目中，每个网页都将继承 base.html，因此从现在开始，每个网页都包含到主页的链接。

在 ❶ 处，我们插入了一对块标签。这个块名为 content，是一个占位符，其中包含的信息将由子模板指定。子模板并非必须定义父模板中的每个块，因此在父模板中，可使用任意多个块来预留空间，而子模板可根据需要定义相应数量的块。

注意：在 Python 代码中，我们几乎总是缩进四个空格。相比于 Python 文件，模板文件的缩进层级更多，因此每个层级通常只缩进两个空格。

现在需要重新编写 index.html，使其继承 base.html，如下所示：

如果将这些代码与原来的 index.html 进行比较，可发现我们将标题 Learning Log 替换成了从父模板那里继承的代码（见❶）。子模板的第一行必须包含标签 {% extends %}，让 Django 知道它继承了哪个父模板。文件 base.html 位于文件夹 learning_logs 中，因此父模板路径中包含 learning_logs。这行代码导入模板 base.html 的所有内容，让 index.html 能够指定要在 content 块预留的空间中添加的内容。

在 ❷ 处，我们插入了一个名为 content 的 {% block %} 标签，以定义 content 块。不是从父模板继承的内容都包含在 content 块中，在这里是一个描述项目「学习笔记」的段落。在 ❸ 处，我们使用标签 {% endblock content %} 指出了内容定义的结束位置。

模板继承的优点开始显现出来了：在子模板中，只需包含当前网页特有的内容。这不仅简化了每个模板，还使得网站修改起来容易得多。要修改很多网页都包含的元素，只需在父模板中修改该元素，你所做的修改将传导到继承该父模板的每个页面。在包含数十乃至数百个网页的项目中，这种结构使得网站改进起来容易而且快捷得多。

注意：在大型项目中，通常有一个用于整个网站的父模板  —— base.html，且网站的每个主要部分都有一个父模板。每个部分的父模板都继承 base.html，而网站的每个网页都继承相应部分的父模板。这让你能够轻松地修改整个网站的外观、网站任何一部分的外观以及任何一个网页的外观。这种配置提供了一种效率极高的工作方式，让你乐意不断地去改进网站。

有了高效的网页创建方法，就能专注于另外两个网页了：显示全部主题的网页以及显示特定主题中条目的网页。所有主题页面显示用户创建的所有主题，它是第一个需要使用数据的网页。

首先，我们来定义显示所有主题的页面的 URL。通常，使用一个简单的 URL 片段来指出网页显示的信息；我们将使用单词 topics，因此 URL http://localhost:8000/topics/ 将返回显示所有主题的页面。下面演示了该如何修改 learning_logs/urls.py：

我们只是在用于主页 URL 的正则表达式中添加了 topics/ （见❶）。Django 检查请求的 URL 时，这个模式与这样的 URL 匹配：基础 URL 后面跟着 topics。可以在末尾包含斜杠，也可以省略它，但单词 topics 后面不能有任何东西，否则就与该模式不匹配。其 URL 与该模式匹配的请求都将交给 views.py 中的函数 topics () 进行处理。

函数 topics () 需要从数据库中获取一些数据，并将其发送给模板。我们需要在 views.py 中添加的代码如下：

我们首先导入了与所需数据相关联的模型（见❶）。函数 topics () 包含一个形参：Django 从服务器那里收到的 request 对象（见❷）。在 ❸ 处，我们查询数据库  ——  请求提供 Topic 对象，并按属性 date_added 对它们进行排序。我们将返回的查询集存储在 topics 中。

在 ❹ 处，我们定义了一个将要发送给模板的上下文。上下文是一个字典，其中的键是我们将在模板中用来访问数据的名称，而值是我们要发送给模板的数据。在这里，只有一个「键-值」对，它包含我们将在网页中显示的一组主题。创建使用数据的网页时，除对象 request 和模板的路径外，我们还将变量 context 传递给 render () （见❺）。

显示所有主题的页面的模板接受字典 context，以便能够使用 topics () 提供的数据。请创建一个文件，将其命名为 topics.html，并存储到 index.html 所在的目录中。下面演示了如何在这个模板中显示主题：

就像模板 index.html 一样，我们首先使用标签 {% extends %} 来继承 base.html，再开始定义 content 块。这个网页的主体是一个项目列表，其中列出了用户输入的主题。在标准 HTML 中，项目列表被称为无序列表，用标签 <ul></ul> 表示。包含所有主题的项目列表始于 ❶ 处。

在 ❷ 处，我们使用了一个相当于 for 循环的模板标签，它遍历字典 context 中的列表 topics。模板中使用的代码与 Python 代码存在一些重要差别：Python 使用缩进来指出哪些代码行是 for 循环的组成部分，而在模板中，每个 for 循环都必须使用 {% endfor %} 标签来显式地指出其结束位置。因此在模板中，循环类似于下面这样：

```
{% for item in list %}

  do something with each item

{% endfor %}
```

在循环中，我们要将每个主题转换为一个项目列表项。要在模板中打印变量，需要将变量名用双花括号括起来。每次循环时，❸ 处的代码 {{ topic }} 都被替换为 topic 的当前值。这些花括号不会出现在网页中，它们只是用于告诉 Django 我们使用了一个模板变量。HTML 标签 <li></li> 表示一个项目列表项，在标签对 <ul></ul> 内部，位于标签 <li> 和 </li> 之间的内容都是一个项目列表项。

在 ❹ 处，我们使用了模板标签 {% empty %}，它告诉 Django 在列表 topics 为空时该怎么办：这里是打印一条消息，告诉用户还没有添加任何主题。最后两行分别结束 for 循环（见❺）和项目列表（见❻）。

现在需要修改父模板，使其包含到显示所有主题的页面的链接：

我们在到主页的链接后面添加了一个连字符（见❶），然后添加了一个到显示所有主题的页面的链接  ——  使用的也是模板标签 url （见❷）。这一行让 Django 生成一个链接，它与 learning_logs/urls.py 中名为 topics 的 URL 模式匹配。现在如果你刷新浏览器中的主页，将看到链接 Topics。单击这个链接，将看到类似于图 18-4 所示的网页。

1『

报错：'learning_logs' is not a registered namespace

发现书中使用的 Django 版本为 1.11，而现在的版本是 3.0 的了。learning_log\urls.py 的一行代码：

	path('', include('learning_logs.urls')),

更改为：

	path('', include('learning_logs.urls', namespace='learning_logs')),

还是报错：Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

还需要在 learning_logs\urls.py 里增加一行代码：

	app_name = 'learning_logs'

』

接下来，我们需要创建一个专注于特定主题的页面  ——  显示该主题的名称及该主题的所有条目。同样，我们将定义一个新的 URL 模式，编写一个视图并创建一个模板。我们还将修改显示所有主题的网页，让每个项目列表项都是一个链接，单击它将显示相应主题的所有条目。

显示特定主题的页面的 URL 模式与前面的所有 URL 模式都稍有不同，因为它将使用主题的 id 属性来指出请求的是哪个主题。例如，如果用户要查看主题 Chess（其 id 为 1）的详细页面，URL 将为 http://localhost:8000/topics/1/。下面是与这个 URL 匹配的模式，它包含在 learning_logs/urls.py 中：

我们来详细研究这个 URL 模式中的正则表达式  —— r'^topics/(?P<topic_id>\d+)/$'。r 让 Django 将这个字符串视为原始字符串，并指出正则表达式包含在引号内。这个表达式的第二部分（/(?P<topic_id>\d+)/ ）与包含在两个斜杠内的整数匹配，并将这个整数存储在一个名为 topic_id 的实参中。这部分表达式两边的括号捕获 URL 中的值；?P<topic_id> 将匹配的值存储到 topic_id 中；而表达式 \d+ 与包含在两个斜杆内的任何数字都匹配，不管这个数字为多少位。

1『注意：?P 是大写的 P。』

发现 URL 与这个模式匹配时，Django 将调用视图函数 topic ()，并将存储在 topic_id 中的值作为实参传递给它。在这个函数中，我们将使用 topic_id 的值来获取相应的主题。

视图：函数 topic () 需要从数据库中获取指定的主题以及与之相关联的所有条目，如下所示：

这是第一个除 request 对象外还包含另一个形参的视图函数。这个函数接受正则表达式 (?P<topic_id>\d+) 捕获的值，并将其存储到 topic_id 中（见❶）。在 ❷ 处，我们使用 get () 来获取指定的主题，就像前面在 Django shell 中所做的那样。在 ❸ 处，我们获取与该主题相关联的条目，并将它们按 date_added 排序：date_added 前面的减号指定按降序排列，即先显示最近的条目。我们将主题和条目都存储在字典 context 中（见❹），再将这个字典发送给模板 topic.html（见❺）。

注意：❷ 处和 ❸ 处的代码被称为查询，因为它们向数据库查询特定的信息。在自己的项目中编写这样的查询时，先在 Django shell 中进行尝试大有裨益。相比于编写视图和模板，再在浏览器中检查结果，在 shell 中执行代码可更快地获得反馈。

模板：这个模板需要显示主题的名称和条目的内容；如果当前主题不包含任何条目，我们还需向用户指出这一点：

像这个项目的其他页面一样，这里也继承了 base.html。接下来，我们显示当前的主题（见❶），它存储在模板变量 {{topic}} 中。为什么可以使用变量 topic 呢？因为它包含在字典 context 中。接下来，我们开始定义一个显示每个条目的项目列表（见❷），并像前面显示所有主题一样遍历条目（见❸）。

每个项目列表项都将列出两项信息：条目的时间戳和完整的文本。为列出时间戳（见❹），我们显示属性 date_added 的值。在 Django 模板中，竖线（| ）表示模板过滤器  ——  对模板变量的值进行修改的函数。过滤器 date: 'M d, Y H:i' 以这样的格式显示时间戳：January 1, 2015 23:00。接下来的一行显示 text 的完整值，而不仅仅是 entry 的前 50 个字符。过滤器 linebreaks （见❺）将包含换行符的长条目转换为浏览器能够理解的格式，以免显示为一个不间断的文本块。在❻处，我们使用模板标签 {% empty %} 打印一条消息，告诉用户当前主题还没有条目。

在浏览器中查看显示特定主题的页面前，我们需要修改模板 topics.html，让每个主题都链接到相应的网页，如下所示：

我们使用模板标签 url 根据 learning_logs 中名为 topic 的 URL 模式来生成合适的链接。这个 URL 模式要求提供实参 topic_id，因此我们在模板标签 url 中添加了属性 topic.id。现在，主题列表中的每个主题都是一个链接，链接到显示相应主题的页面，如 http://localhost:8000/topics/1/。如果你刷新显示所有主题的页面，再单击其中的一个主题，将看到类似于图 18-5 所示的页面。

## 1901. 用户账户

在本章中，你学习了如何使用表单来让用户添加新主题、添加新条目和编辑既有条目。接下来，你学习了如何实现用户账户。你让老用户能够登录和注销，并学习了如何使用 Django 提供的表单 UserCreationForm 让用户能够创建新账户。建立简单的用户身份验证和注册系统后，你通过使用装饰器 @login_required 禁止未登录的用户访问特定页面。然后，你通过使用外键将数据关联到特定用户，还学习了如何执行要求指定默认数据的数据库迁移。最后，你学习了如何修改视图函数，让用户只能看到属于他的数据。你使用方法

filter () 来获取合适的数据，并学习了如何将请求的数据的所有者同当前登录的用户进行比较。该让哪些数据可随便访问，该对哪些数据进行保护呢？这可能并非总是那么显而易见，但通过不断地练习就能掌握这种技能。在本章中，我们就该如何保护用户数据所做的决策表明，与人合作开发项目是个不错的主意：有人对项目进行检查的话，更容易发现其薄弱环节。至此，我们创建了一个功能齐备的项目，它运行在本地计算机上。在本书的最后一章，我们将设置这个项目的样式，使其更漂亮；我们还将把它部署到一台服务器上，让任何人都可通过互联网注册并创建账户。

Web 应用程序的核心是让任何用户都能够注册账户并能够使用它，不管用户身处何方。在本章中，你将创建一些表单，让用户能够添加主题和条目，以及编辑既有的条目。你还将学习 Django 如何防范对基于表单的网页发起的常见攻击，这让你无需花太多时间考虑确保应用程序安全的问题。

然后，我们将实现一个用户身份验证系统。你将创建一个注册页面，供用户创建账户，并让有些页面只能供已登录的用户访问。接下来，我们将修改一些视图函数，使得用户只能看到自己的数据。你将学习如何确保用户数据的安全。