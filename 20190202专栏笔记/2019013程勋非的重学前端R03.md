# 2019013程勋非的重学前端R03

## 0301. 浏览器的实现和 API

### 1. 逻辑脉络

1、浏览器做的就是如何把一个 URL 转变成我们网页上所看见的内容：1）用协议向服务器请求页面；2）把请求回来的 HTML 文本经过解析构建成 DOM 树；3）计算 DOM 树上的 CSS 属性；4）根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；5）对位图进行合成（可选），这能极大增加后续绘制的速度；6）合成之后绘制到界面。

2、解析代码（通过状态机实现）和构建 DOM 树（通过栈实现）两个步骤。

### 2. 摘录及评论

### 0301浏览器1一个浏览器是如何工作的.md

我们一起学习了浏览器的第一步工作，也就是「浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面」的这一过程。在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注意的部分。最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。

我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在「给前端工程师了解浏览器」的水准，而不是详细到「给浏览器开发工程师实现浏览器」的水准。

实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。这个过程是这样的：1） 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；2）把请求回来的 HTML 代码经过解析，构建成 DOM 树；3）计算 DOM 树上的 CSS 属性；4）最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；5）一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；6）合成之后，再绘制到界面上。

我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。

HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。

```html
HTTP/1.1 301 Moved Permanently
Date: Fri, 25 Jan 2019 13:28:12 GMT
Content-Type: text/html
Content-Length: 182
Connection: keep-alive
Location: https://time.geekbang.org/
Strict-Transport-Security: max-age=15768000

<html>
<head><title>301 Moved Permanently</title></head>
<body bgcolor="white">
<center><h1>301 Moved Permanently</h1></center>
<hr><center>openresty</center>
</body>
</html>
```

这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的「方法」，请求的路径和请求的协议和版本；在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本；紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值；在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 HTML 代码。

我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义：

浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法；HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起；PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束；CONNECT 现在多用于 HTTPS 和 WebSocket；OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。

接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。

1xx：临时回应，表示客户端请继续。

2xx：请求成功。200：请求成功。

3xx: 表示请求的目标有变化，希望客户端进一步处理。301&302：永久性与临时性跳转；304：跟客户端缓存没有更新。

4xx：客户端请求错误。403：无权限；404：表示请求的页面不存在；418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议）

5xx：服务端请求错误。500：服务端错误；503：服务端暂时性错误，可以一会再试。

对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。

HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在就来了解一下它们。在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下：我们先来看看 Request Header。接下来看一下 Response Header。

这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完整的列表还是请你参考我给出的 rfc2616 标准。HTTP 请求的 body 主要用于提交表单场景。实际上，HTTP 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是：1）application/json；2）application/x-www-form-urlencoded；3）multipart/form-data；4）text/xml。

我们使用 HTML 的 form 标签提交产生的 HTML 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。

我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：[RFC 2818 - HTTP Over TLS](https://tools.ietf.org/html/rfc2818)。HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。

HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接：[RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP/2)](https://tools.ietf.org/html/rfc7540)。HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题；TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。

Note：其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。

### 黑板墙

现在工作中暂时只使用到 HTTPS。去年，看到一些公司已经开始着手更新 HTTP2，不少敬佩的前端高手做了分享。他们利用 HTTP2 服务端推送，以及 TCP 连接复用的特性，把 CSS 和 JS 文件分拆成更小的文件，分批下载。更小的文件意味着用户可以更快看到页面，以及性能的改善。与此同时，这种处理方式也对生产环境的工具链带来调整和改变。很有意思的变化。2019-02-09

HTT2 还有一个很重要的特性：使用二进制代理文本进行传输，极大提高了传输的效率。作者回复：嗯，这块没太细讲，我觉得大家了解即可，主要是服务端的工作。2019-02-23

### 0302浏览器2一个浏览器是如何工作的.md

继续探索了浏览器的工作原理，主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树。

前面讲了浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。今天主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的 Response 的 body，就要交给我们今天学习的内容去处理了。HTML 的结构不算太复杂，我们日常开发需要的 90% 的「词」（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。「<?」和「<%」什么的也是必须要支持好的，报了错也不能吭声。

	<p class="a">text text text</p>

如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了（它甚至可以嵌套）。那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是「<p」，所以「<p」就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）：1）<p「标签开始」的开始；2）class="a" 属性；3） >「标签开始」的结束；4）text text text 文本；5）\</p> 标签结束。

根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。比如，假设我们接受了一个字符「<」我们一下子就知道这不是一个文本节点啦。之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到「>」或者空格，这样就得到了一个完整的词（token）了。

实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟「当前状态」有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看：

当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考 HTML 官方文档，HTML 官方文档规定了 80 个状态（顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。这里我们为了理解原理，用这个简单的状态机就足够说明问题了。

1、状态机的初始状态，我们仅仅区分「<」和「非 <」：1）如果获得的是一个非 < 字符，那么可以认为进入了一个文本节点；2）如果获得的是一个 < 字符，那么进入一个标签状态。

2、不过当我们在标签状态时，则会面临着一些可能性。1）比如下一个字符是「!」，那么很可能是进入了注释节点或者 CDATA 节点。2）如果下一个字符是「/」，那么可以确定进入了一个结束标签。3）如果下一个字符是字母，那么可以确定进入了一个开始标签。4）如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑「?」「%」等内容。

我们可以看到，用状态机做词法分析，其实正是把每个词的「特征字符」逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。接下来就是代码实现的事情了，在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。）

为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：

```js

var data = function(c){
    if(c=="&") {
        return characterReferenceInData;
    }
    if(c=="<") {
        return tagOpen;
    }
    else if(c=="\0") {
        error();
        emitToken(c);
        return data;
    }
    else if(c==EOF) {
        emitToken(EOF);
        return data;
    }
    else {
        emitToken(c);
        return data;
    }
};
var tagOpenState = function tagOpenState(c){
    if(c=="/") {
        return endTagOpenState;
    }
    if(c.match(/[A-Z]/)) {
        token = new StartTagToken();
        token.name = c.toLowerCase();
        return tagNameState;
    }
    if(c.match(/[a-z]/)) {
        token = new StartTagToken();
        token.name = c;
        return tagNameState;
    }
    if(c=="?") {
        return bogusCommentState;
    }
    else {
        error();
        return dataState;
    }
};
//……
```

这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个「<」字符，来判断标签类型的状态。这里的状态机，每一个状态是一个函数，通过「if else」来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。这样，我们的状态迁移代码非常的简单：

```js
var state = data;
var char
while(char = getInput())
    state = state(char);
```

这段代码的关键一句是「state = state (char) 」，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。词法分析器接受字符的方式很简单，就像下面这样：

```js
function HTMLLexicalParser(){

    //状态函数们……
    function data() {
        // ……
    }

    function tagOpen() {
        // ……
    }
    // ……
    var state = data;
    this.receiveInput = function(char) {
        state = state(char);
    }
}
```

接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。

```js
function HTMLSyntaticalParser(){
    var stack = [new HTMLDocument];
    this.receiveInput = function(token) {
        //……
    }
    this.getOutput = function(){
        return stack[0];
    }
}
```

我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emitToken 来调用。在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象）：

```js
function Element(){
    this.childNodes = [];
}
function Text(value){
    this.value = value || "";
}
```

前面我们的词（token）中，以下两个是需要成对匹配的：1）tag start。2）tag end。根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点。

同样我们来看看直观的解析过程：  

```js
<html maaa=a >
    <head>
        <title>cool</title>
    </head>
    <body>
        <img src="a" />
    </body>
</html>
```

通过这个栈，我们可以构建 DOM 树：1）栈顶元素就是当前节点；2）遇到属性，就添加到当前节点；3）遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；4）遇到注释节点，作为当前节点的子节点；5）遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；6）遇到 tag end 就出栈一个节点（还可以检查是否匹配）。

我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。当我们的源代码完全遵循 XHTML（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。

今天的文章带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。

### 黑板墙

今天给你留的题目是：在语法和词法的代码，我已经给出了大体的结构，请你试着把内容补充完整吧。

[aimergenge/toy-html-parser: A simple html parser for play...](https://github.com/aimergenge/toy-html-parser)

