# 2019013程勋非的重学前端R01

## 记忆时间

## 卡片

### 0101. 反常识卡——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

#### 01. 常识

#### 02. 反常识

#### 03. 知识来源

比如提出者，如何演化成型的；书或专栏具体出现的地方。

#### 04. 例子

### 0201. 术语卡 —— 变量申明句法的解释

void 运算可以把任意一个表达式变成 undefined 值。任何变量在赋值前是 Undefined 类型、值为 undefined。所以申明变量的句法是 void 加上变量名，应为都是赋值前做的声明，相当于占了一个坑位在那，赋值的时候根据具体的值再更改为指定的类型。

### 0202. 术语卡 —— 装箱操作

运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。

### 0203. 术语卡 —— JavaScript 中的对象

实际上 JavaScript 对象的运行时是一个「属性的集合」，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下 "a" 是 key。{writable:true,value:1,configurable:true,enumerable:true} 是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。

### 0204. 术语卡 —— JavaScript 里函数是一种特殊的对象

关于对象的第二个和第三个特征「状态和行为」，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为「成员变量」和「成员函数」，Java 中则称它们为「属性」和「方法」。在 JavaScript 中，将状态和行为统一抽象为「属性」，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。

### 0205. 术语卡 —— 调用函数时使用的引用，决定了函数执行时刻的 this 值

我们对 this 的解释已经非常清晰了：调用函数时使用的引用，决定了函数执行时刻的 this 值。实际上从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。这个设计来自 JavaScript 早年，通过这样的方式，巧妙地模仿了 Java 的语法，但是仍然保持了纯粹的「无类」运行时设施。如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了。

关于 this，Kyle Simpson 有四条总结：1）由 new 调用？绑定到新创建的对象。2）由 call 或者 apply (或者 bind) 调用？绑定到指定的对象。3）由上下文对象调用？绑定到那个上下文对象。4）默认：在严格模式下绑定到 undefined，否则绑定到全局对象。例外：箭头函数不适用以上四条规则，它会继承外层函数调用的 this 绑定 (无论 this 绑定到什么)。

### 0301. 人名卡——

JavaScript 之父。

#### 01. 基本信息

用一句话描述你对这个大牛的印象。

#### 02. 贡献及著作

### 0401. 金句卡 —— 对象是一个属性的索引结构（一种数据结构）

## 总纲

### 1. 逻辑脉络

前端的学习分四大核心模块：JavaScript；HTML 和 CSS；浏览器 API；综合应用。任何编程语言要实现的过程：用规定的文法，去表达特定的语义，去操作运行时。运行时包含类型（数据结构）和执行过程（算法）。

### 2. 摘录及评论

2006 年那时候，谷歌刚刚基于 Ajax 发布的 Gmail 也没多久，虽然这项伟大的技术标志着 Web 1.0（静态网页）到 Web 2.0（动态网页）的迈进，但在国内依然少有人懂，如果当时谁可以对这项技术侃侃而谈，那简直就是大神的级别了。

2008 年，我加入了盛大做电子书，负责电子书的文本排版工作，这个工作是一个既写底层又写 JavaScript 的岗位，同时排版引擎也是浏览器的重要组成部分，也让我对浏览器的工作原理有了更深入的理解。在盛大后期，我加入了 WebOS 项目，负责前端框架，我开始基于移动的角度思考前端交互和框架，这份工作让我离前端又近了一步。回过来看，那几年，前端技术开始了它的大踏步发展，那一段时间，可以说是前端的 「白银时代」。最直观的表现之一就是前端逐步从后端分离了出来，它的代码也变得复杂了起来，还需要保存数据、处理数据、生成视图等等。

在手机淘宝，前端团队的各种基础设施也逐渐建立了起来，从最开始的多屏适配方案、基础库、工具链到页面搭建平台和性能体系，最后到客户端融合方案 Weex，我随着团队一起经历了业务发展、团队自身成长和行业变革。与此同时，在我加入阿里巴巴后的这段时间里，随着移动时代的到来，前端也开启了自己的 「黄金时代」，它的职责变得更加重要，有了独立的发布权限，技术也变得更加复杂。一些传统软件开发和互联网服务端的方法论逐步移植到前端开发中，并形成了前端自己的工程体系，诸如持续集成、前后端分离、线上监控……架构方面，前端架构的任务也从简单的解决兼容和风格问题，逐步过渡到提倡组件化和 UI 架构模式，最后形成了新一代的前端框架 React、Vue 和 Angular，他们也在竞争和互相学习中成长。

1『前端的青铜、白银和黄金时代。』

关于前端工程师成长，我认为需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。

前端知识分成了四个模块：1）JavaScript；2）CSS 和 HTML；3）浏览器实践；4）前端综合应用。前三个模块是前端的基础知识，是个人的前端能力提升，而模块四则是前端团队发展相关的内容，有助于你和团队的整体提高。

1）在 JavaScript 部分中，我主要会从文法和运行时的角度去讨论 JavaScript 语言。它们是互相关联的，而语义就是文法到运行时之间的桥梁；它们分别又是完备的，任何语言特性都离不开两者，所以从语法和运行时的角度，我们都可以了解完整的 JavaScript。2）CSS 和 HTML 部分，会侧重从语言和设计思想的角度来讲解，我们同样可以对两者的全貌建立一些认知。3）浏览器部分，包含了浏览器工作的原理和一些重要的 API，包括 BOM、DOM、CSSOM 和其他一些内容。了解了这些知识，你才能把 JavaScript 和 HTML、CSS 连接起来，用 JavaScript 来实现功能。4）前端综合应用部分，主要是我的一些工作经验，我会选择我在手淘和淘宝工作中的一些案例来辅助讲解。

前端是一个非常年轻的职业，但我仍然认为前端具有很多空间和机会，一些基础设施仍然简陋，前端的能力可以带来更多的业务场景，这些有待于我们去发掘。前端工程师也会面临技术发展问题带来的挑战。前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。我们就拿 JavaScript 标准来说，ES6 中引入的新特性超过了过去十年的总和，新特性带来的实践就更多了，仅仅是一个 Proxy 特性的引入，就支持了 VueJS 从 2.0 到 3.0 的内核原理完全升级。缺少系统教育 + 技术快速革新，在这样的大环境下，前端工程师保持自学能力就显得尤其重要了。

 0 基础入门的同学，你可以读几本经典的前端教材，比如《JavaScript 高级程序设计》《精通 CSS》等书籍，去阅读一些参考性质的网站也是不错的选项，比如 [MDN Web 文档](https://developer.mozilla.org/zh-CN/)。在这个专栏中，我希望传达的不仅仅是具体的知识点，还有体系架构和学习方法。我希望达到三个目标：1）带你摸索出适合自己的前端学习方法；2）帮助你建立起前端技术的知识架构；3）让你理解前端技术背后的核心思想。
 
 2『已下载书籍「2019105JavaScript高级程序设计3Ed」、「2019106精通CSS3Ed」。』

对于任何计算机语言来说，必定是 「用规定的文法，去表达特定语义，最终操作运行时的」 一个过程。这样，JavaScript 的任何知识都不会出现在这个范围之外，这是知识架构的完备性。我们再往下细分一个层级，就变成了这个样子：1）文法：词法、语法。2）语义。3）运行时：类型、执行过程。

1『任何编程语言要实现的过程：用规定的文法，去表达特定的语义，去操作运行时。运行时包含类型（数据结构）和执行过程（算法）。』

文法可以分成词法和语法，这来自编译原理的划分，同样是完备的。语义则跟语法具有一一对应关系，这里暂时不区分。对于运行时部分，这个划分保持了完备性，我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。

当我们再往下细分的时候，就会看到熟悉的概念了，词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等……比如在 JavaScript 标准中，有完整的文法定义，它是具有完备性的，所以我们可以根据它来完成，我们还可以根据语法去建立语义的知识架构。实际上，因为 JavaScript 有一份统一的标准，所以相对来说不太困难。

如果是浏览器中的 API，那就困难了，它们分布在 w3c 的各种标准当中，非常难找。但是我们要想找到一些具有完备性的线索，也不是没有办法。我喜欢的一个办法，就是用实际的代码去找：for in 遍历 window 的属性，再去找它的内容。 我想，学习的过程，实际上就是知识架构不断进化的过程，通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点。

1『构建知识体系的方法论。』

有一些知识，背后有一个很大的体系，例如，我们对比一下 CSS 里面的两个属性：opacity；display。虽然都是 「属性」，但是它们背后的知识量完全不同，opacity 是个非常单纯的数值，表达的意思也很清楚，而 display 的每一个取值背后都是一个不同的布局体系。我们要讲清楚 display，就必须关注正常流（Normal Flow）、关注弹性布局系统以及 grid 这些内容。

3『弹性布局，flex 之类的，学爬虫的时候得到一个概念，各个网页的布局大不相同，很难写一个通用的爬虫。「2020061Website_Scraping_with_R01」』

还有一些知识，涉及的概念本身经历了各种变迁，变得非常复杂和有争议性，比如 MVC，从 1979 年至今，概念变化非常大，MVC 的定义几乎已经成了一段公案，我曾经截取了 MVC 原始论文、MVP 原始论文、微软 MSDN、Apple 开发者文档，这些内容里面，MVC 画的图、箭头和解释都完全不同。这种时候，就是我们做一些考古工作的时候了。追本溯源，其实就是关注技术提出的背景，关注原始的论文或者文章，关注作者说的话。操作起来也非常简单：翻翻资料（一般 wiki 上就有）找找历史上的文章和人物，再顺藤摸瓜翻出来历史资料就可以了，如果翻出来的是历史人物（幸亏互联网的历史不算悠久），你也可以试着发封邮件问问。

这个过程，可以帮助我们理解一些看上去不合理的东西，有时候还可以收获一些趣闻，比如 JavaScript 之父 Brendan Eich 曾经在 Wikipedia 的讨论页上解释 JavaScript 最初想设计一个带有 prototype 的 scheme，结果受到管理层命令把它弄成像 Java 的样子（如果你再挖的深一点，甚至能找到他对某位 「尖头老板」 的吐槽）。根据这么一句话，我们再去看看 scheme，看看 Java，再看看一些别的基于原型的语言，我们就可以理解为什么 JavaScript 是现在这个样子了：函数是一等公民，却提供了 new this instanceof 等特性，甚至抄来了 Java 的 getYear 这样的 Bug。

1『认识中前端就是 html 负责骨架，css 负责外表和 js 负责行为。』

在开始列框架之前，我想先来谈谈我们的目标。实际上，我们在网上可以找到很多参考资料，比如 MDN 这样的参考手册，又比如一份语言标准，但是我们的课程既不是一本参考手册，也不是一份语言标准。参考手册希望做到便于查阅、便于理解和全面，语言标准的目标是严谨、无遗漏、无歧义。而我们的课程有什么不同呢？我认为，作为一个课程，有两个目标：一个是把无法通过查阅解决的原理和背景讲清楚，另一个是把不方便查阅和记忆的内容整理好。我会尽量避免像前面提到的两种文档一样逐条目罗列知识点和细节，当然，这不是在说两种文档没有价值，而是我们各有分工，参考手册和语言标准做的事情，我们没必要重复去做，即使做了也不一定能做得更好。

在这个课程里，我希望能和你一起打造一个前端知识的框架，再把知识点做个遍历，这其中，有原理和背景的部分，我去讲解知识的原理和背景。如果没有的话，我们就去讲整理和记忆这部分知识的方法，这样，即使你遇见无法一下子记住的知识，也可以很容易地查阅参考手册和标准来解决。

如果让我做一个划分，前端的知识在总体上分成基础部分和实践部分，基础部分包含了 JavaScript 语言（模块一）、CSS 和 HTML（模块二）以及浏览器的实现原理和 API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。学完这三个部分，你再结合基本的编程能力，就可以应对基本的前端开发工作了。实践部分（模块四）重点会介绍我在工作过程中遇到的问题和解决方案，希望这块内容能够帮助你和你的前端团队找到可能的发展方向和着力点。

在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。

类型部分中，对象比其它所有类型加起来都要更为复杂，所以我们会用较长的篇幅来讲解对象，包括它的一些历史和设计思路。执行过程我们则需要按照从大结构到小结构的角度讲解，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。我们从粗到细地了解执行过程。实例部分，对 JavaScript 来说类似基础库，JavaScipt 的内置对象多达 150 以上，考虑到我们即使逐次讲解也必定不如 MDN 更加细致全面，所以我们会从应用和机制的角度，挑选其中几个体系来讲解。

文法中的语法和语义基本是一一对应关系，在 JavaScript 标准中有一份语法定义表，它同样不适合一一讲解，我们会从 JavaScript 语法中特别的地方，以及与日常开发比较相关的地方来重点讲解，剩下的内容和词法部分，我们会带领大家做一些数据挖掘工作，从这份表格中找到一些和我们日常开发息息相关的内容。语义的大部分内容我们会在运行时的讲解中透出，同时它又跟语法有对应的关系，所以我们不再单独拿出来讲解。

在 HTML 的部分，我们会按照功能和语言来划分它的知识，HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类，并对它们分别进行讲解。我们都知道 HTML 的标签可以分为很多种，head 里面的我们称为元信息类标签，诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。还有一类是一些诸如 section、nav 的标签，它们在视觉表现上跟 div 并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。再有就是表单类的，比如 input、button。所以，基于这样的分类，我把标签分成下面几种。

1）文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；2）语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；3）链接：提供到文档内和文档外的链接；4）替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；5）表单：用于填写和提交信息的一类标签；6）表格：表头、表尾、单元格等表格的结构。

我们的重点会放在前四种标签上，表单和表格较少用到，而且基本以查阅型知识为主，这里就不拿出来讲解了。除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍 HTML 的语法和几个重要的语言机制：实体、命名空间。最后我们会介绍下 HTML 的补充标准：ARIA，它是 HTML 的扩展，在可访问性领域，它有至关重要的作用。

3『

[标记语言 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80)

标记语言是一种将文本（Text）以及文本相关的其他信息（包括例如文本的结构和表示信息等，这些信息通过标记来标识）结合起来，展现出关于文档结构和数据处理细节的计算机文字编码。当今广泛使用的标记语言是超文本置标语言（HyperText Markup Language，HTML）和可扩展置标语言（eXtensible Markup Language，XML）。标记语言广泛应用于网页和网络应用程序。标记最早用于出版业，是作者、编辑以及出版商之间用于描述出版作品的排版格式所使用的。标识（markup）这个词来源自传统出版业的「标记」一个手稿，也就是在原稿的边缘加注一些符号来指示打印上的要求。长久以来，这个工作都是由专门的人（markup men）以及校对人来进行，对原稿标志出使用什么样的字体，字体以及字号，然后再将原稿交给其它人进行手工的排版工作。

』

CSS 部分，按照惯例，我们也会从语言和功能两个角度去介绍。在语言部分，我们会从大到小介绍 CSS 的各种语法结构，比如 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。在布局类我们介绍两个最常用的布局：正常流和弹性布局。绘制类我们则会分成图形相关的和文字相关的绘制。最后我们会介绍动画和其它交互。

浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解 API 的基础。我们会从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。接着是 API 部分，我们会从 W3C 零散的标准中挑选几个大块的 API 来详细讲解，主要有：事件、DOM、CSSOM 几个部分，它们分别覆盖了交互、语义和可见效果，这是我们工作中用到的主要内容。其他的 API 怎么办呢，别着急，在最后，我会给出一份 Chrome 已经实现的 API 跟 W3C 标准的对应关系和它的生成过程，来覆盖其它部分。

最后一个模块是前端工程实践。我们在掌握了前面的基础知识之后，也就基本掌握了做一个前端工程师的底层能力。在这个模块中，我选择了性能、工具链、持续集成、搭建系统、架构与基础库这几个方向的前端工程实践案例。

首先我们会谈谈性能。对任何一个前端团队而言，性能是它价值的核心指标，从早年 「重构」 的实践开始，前端有通过性能证明自己价值的传统。但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。

下一个案例是工具链。这一部分，我将会探讨企业中工具链的建设思路。对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。

接下来还会给大家介绍前端的持续集成，持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如 daily build 就完全不适用前端，前端代码必须是线上实时可用的。这一部分内容将会针对前端的持续集成提出一些建设的思路。

接下来的案例是搭建系统，前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。这一部分内容我将会介绍什么是搭建系统，以及一些常见的搭建系统类型。

最后一个部分，会给大家介绍前端架构和基础库的知识。软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。这一部分文章我将会介绍前端架构工作的一些思路和切入点。上面的这些案例来自我在领导手淘前端团队时的经验，和我在阿里巴巴工作参与晋升面试时听到的案例，这些内容几乎是每一个年轻的前端团队成长过程中都会需要的基础设施。

基于这份知识框架图，我们的课程主要采用两种讲述形式：一种是重点讲解的课程，一种是知识图谱型的课程。重点讲解的课程我们会从技术的背景、原理和设计出发，把知识的内容呈现出来。这种形式适用于有体系和源流的知识，比较适合系统学习和理解，比如 JavaScript 中的对象、CSS 的排版。知识图谱型的课程则提供一些方法，用表格或者脑图的形式来整理知识的结构。这种形式适用于零散的知识，比较适合记住大概，用到时去查阅，比如 JavaScript 的词法、HTML 中的所有标签、以及浏览器中的 API 就十分适合这样的讲解方式。

### 黑板墙

粗鄙认为前端知识架构可以分为渲染层和网络层两方面，不论前端如何发展变化，比如 react，vue，ng，还是 flutter，小程序等等，本质上脱离不了这两方面，另外前端工程师在接触一个新语言或新框架，最难不是学习语言本身（官方文档可以解决），反而棘手的是如何去工程化（更好组织代码，打包工程）和去优化，这是做前端两年的感受。作者回复：渲染层和网络层这个分法听起来是有一定思考了，不过可以再想想，是不是还有别的层？另外就是，如何定义渲染层呢？

在 JavaScript 中，「类型」和「实例」就是数据结构，而「执行过程」就是算法。之前从来没有从这个角度看待过 JavaScript 语言，写代码的思路就不一样了。这是第一大收获。第二个收获是明确自己问题所处的分支。比如，JavaScript 大部分的问题都存在于「运行时」这个分支中。又比如，发现自己疲于奔命，总是 「感觉」 学不完的内容，其实是处于「持续集成」这个分支中。核对了一下自己已经掌握，和计划学习的前端知识，都能在这份知识框架中找到落脚点，再次体会到完备性的重要。

1『上面说的实例指的就是对象。』

前端自动化测试方面是都也可以讲解下，除了工具，最重要的是怎么造自动化测试用例，这个用例感觉比后端复杂，工作量也非常大，所以很多项目会放弃自动化测试。怎么才能做好自动化测试？作者回复：自动化测试，非一线大厂大型团队不建议搞，目前还没见过靠谱的方案。

在阅读这篇文章之前，我对于前端知识结构的划分是基于「语言」：前端 = HTML + CSS + JavaScript。每种语言下，又混杂了基础知识以及相关的工具。比如我之前认为的 JavaScript 包括：1）JavaScript 基础。2）Package Manager (NPM, Yarn)。3）Build tools (NPM Scripts, ESLint, Webpack...)。4）Frameworks (React, Vue.js, Angular)。5）Testing tools (Jest ...)。现在知道自己的认识有两个误区：1）这个知识架构没有完备性，这样划分，总有在这个结构之外的知识；2）学习的时候会疲于奔命，总想 「完整」 的学完所有的知识，却走了弯路。作者回复：我觉得你不妨思考下，如果我要讲 Package Manager、Build tools，你猜我会放到哪个部分？读者：package manager 和 build tools 属于工程化中的内容吧？大前端的一个必备前提，我认为就是工程化。可以模块化组织和管理，并提高模块重用性。

大家都觉得 HTML 容易，非常简单。就算不会，坐下来花一天时间看看 MDN 几乎都能写出来了。我们都知道写 HTML 要语义化，但是 HTML5 的语义我感觉非常复杂。有多少人能保证写出来的网页完完全全遵循了正确的语义？能达到屏幕阅读器理解的程度？我们想写语义正确的网页，但是也不想被语义复杂性所拖累。（本来读的也不是文科，div 一分钟能写出来的东西在语义上要纠结好久）程老师，我的问题是，作为一名前端工程师，平常工作的时候写 HTML 究竟要语义化到哪种程度呢？作者回复：这是个好问题，在语义化部分我有讲这个问题，很快你就能看到了。

## 0101. JavaScript1

### 1. 逻辑脉络

1、介绍了 JavaScript 运行时的类型系统，除了这七种基本语言类型，还有一些语言的实现者更关心的规范类型。程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。

2、JavaScript 对象的具体设计：具有高度动态性的属性集合。

3、「基于类」并非面向对象的唯一形态，基于原型也是一种形态，而且是一种非常优秀的抽象对象的形式。

4、介绍了一些不那么常规的对象，并且我还介绍了 JavaScript 中用对象来模拟函数和构造器的机制。这是一些不那么有规律、不那么优雅的知识，而 JavaScript 正是通过这些对象，提供了很多基础的能力。

### 2. 摘录及评论

### 0101JavaScript类型关于类型有哪些你不知道的细节.md

在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。除了这七种语言类型，还有一些语言的实现者更关心的规范类型。1）List 和 Record： 用于描述函数传参过程；2）Set：主要用于解释字符集等；3）Completion Record：用于描述异常、跳出等语句执行过程；4）Reference：用于描述对象属性访问、delete 等；5）Property Descriptor：用于描述对象的属性；6）Lexical Environment 和 Environment Record：用于描述变量和作用域；7）Data Block：用于描述二进制数据。有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。

JavaScript 类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题：1）为什么有的编程规范要求用 void 0 代替 undefined？2）字符串有最大长度吗？3）0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？4）ES6 新加入的 Symbol 是个什么东西？5）为什么给对象添加的方法能用在基本类型上？

我们的 JavaScript 模块会从运行时、文法和执行过程三个角度去剖析 JS 的知识体系，本篇我们就从运行时的角度去看 JavaScript 的类型系统。运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都具有运行时类型。

JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：Undefined；Null；Boolean；String；Number；Symbol；Object。其中 Symbol 类型是 ES6 中新加入的。

为什么有的编程规范要求用 void 0 代替 undefined？Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。

1『void 运算可以把任意一个表达式变成 undefined 值。任何变量在赋值前是 Undefined 类型、值为 undefined。所以申明变量的句法是 void 加上变量名，应为都是赋值前做的声明，相当于占了一个坑位在那，赋值的时候根据具体的值再更改为指定的类型。』

Undefined 跟 Null 有一定的表意差别，Null 表示的是：「定义了但是为空」。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。

Boolean 类型有两个值，true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。

我们来看看字符串是否有最大长度。String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。因为 String 的意义并非「字符串」，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。

Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。

3『编码的有关概念：对于英语我们一般不会遇到什么编码问题，因为一个英文字符在系统里占一个位置。对于中文的话，微软设置了一个编码 gbk，一个汉字在系统里占有 2 个位置，gbk 编码虽然节省空间，但只包含有常用字。对于那些生僻的字，就用 utf-8 编码，这个编码一个汉字是占有 3 个位置。摘自「2019004尹会生的零基础学Python/1501爬虫.md」』

JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了「性能和尽可能实现起来简单」。因为现实中很少用到 BMP 之外的字符。

Number 类型表示我们通常意义上的「数字」。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。JavaScript 中的 Number 类型有 18437736874454810627 (即 2^64-2^53+3) 个值。JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；Infinity，无穷大；-Infinity，负无穷大。

另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，「忘记检测除以 -0，而得到负无穷大」的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。同样根据浮点数的定义，非整数的 Number 类型无法用 \==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：

    console.log( 0.1 + 0.2 == 0.3);

这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：

    console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);

检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。

Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。我们创建 Symbol 的方式是使用全局的 Symbol 函数。我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：

    var mySymbol = Symbol("my symbol");

一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：

    var o = new Object

    o[Symbol.iterator] = function() {
        var v = 0
        return {
            next: function() {
                return { value: v++, done: v > 10 }
            }
        }        
    };

    for(var v of o) 
        console.log(v); // 0 1 2 3 ... 9

代码中我们定义了 iterator 之后，用 for (var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。这些标准中被称为「众所周知」的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。

Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。为什么给对象添加的方法能用在基本类型上？在 JavaScript 中，对象的定义是「属性的集合」。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。

提到对象，我们必须要提到一个概念：类。因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的「类」与类型混淆。事实上，JavaScript 中的「类」仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。JavaScript 中的几个基本类型，都在对象类型中有一个「亲戚」。它们是：Number；String；Boolean；Symbol。

1『JavaScript 中是无法自定义类型，因为类型就那么几种，一直强调的语言类型和规范类型。Number；String；Boolean；Symbol 这四个基本类型，在对象类型里都有与之匹配的亲戚。』

所以，我们必须认识到 3 与 new Number (3) 是完全不同的值，它们一个是 Number 类型，一个是对象类型。Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用。甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。

    Symbol.prototype.hello = () => console.log("hello");

    var a = Symbol("a");
    console.log(typeof a); //symbol，a 并非对象
    a.hello(); //hello，有效

所以我们文章开头的问题，答案就是。运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

1『上面的例子关键是运算符「.」操作，即装箱操作，a. 是在 a 这个 symbol 基本类型的基础上临时构造出一个 symbol 对象，因为之前在 symbol 对象原型上已经增加了 hello 方法，那么新构造的 symbol 对象自动继承了 symbol 对象里的 hello 方法。』

介绍一个现象：类型转换。因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。其中最为臭名昭著的是 JavaScript 中的「==」运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用「==」，而要求程序员进行显式地类型转换后，用 === 比较。其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：

1『弱类型语言的概念是什么？目前的理解就是动态语言，声明的时候不需要提前指定类型。（2020-03-12）』

在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。

字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：30；0b111；0o13；0xFF。此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：1e3；-1e-2。需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀「0x」，而且会忽略非数字字符，也不支持科学计数法。

在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。

在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。具体的算法，你可以去参考 JavaScript 的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。

每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。

1『运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。』

    var symbolObject = (function(){ return this; }).call(Symbol("a"));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true

我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：

装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：

    var symbolObject = Object(Symbol("a"));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true

在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。

    var symbolObject = Object(Symbol("a"));
    console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]

拆箱转换。在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。对象到 String 和 Number 的转换都遵循「先拆箱再转换」的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。

    var o = {
        valueOf : () => {console.log("valueOf"); return {}},
        toString : () => {console.log("toString"); return {}}
    }

    o * 2
    // valueOf
    // toString
    // TypeError

我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o\*2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o*2 换成 String (o)，那么你会看到调用顺序就变了。

```
var o = {
    valueOf : () => {console.log("valueOf"); return {}},
    toString : () => {console.log("toString"); return {}}
}

String(o)
// toString
// valueOf
// TypeError
```

ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。

    var o = {
        valueOf : () => {console.log("valueOf"); return {}},
        toString : () => {console.log("toString"); return {}}
    }

    o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}

    console.log(o + "")
    // toPrimitive
    // hello

事实上，「类型」在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。在表格中，多数项是对应的，但是请注意 object —— Null 和 function —— Object 是特例，我们理解类型的时候需要特别注意这个区别。从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。

### 黑板墙

我发现有很多同学都在纠结 undefined 问题，为什么不去读一下 mdn 呢（[undefined - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)）。前两段写的很明确了。undefined is a property of the global object; i.e., it is a variable in global scope. The initial value of undefined is the primitive value undefined. In modern browsers (JavaScript 1.8.5 / Firefox 4+), undefined is a non-configurable, non-writable property per the ECMAScript 5 specification. Even when this is not the case, avoid overriding it. 在 ES5 之前的时候，undefined 是可以被赋值的。在现代浏览器当中已经把 undefined 设置为一个 non-configurable, non-writable 属性的值了。

null 的类型是 object，这是由于历史原因造成的。1995 年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑 null，只把它当作 object 的一种特殊值。后来 null 独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null 返回 object 就没法改变了。

### 0102JavaScript对象面向对象还是基于对象.md

要想理解 JavaScript 对象，必须清空我们脑子里「基于类的面向对象」相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。

很多人在思考 JavaScript 对象时，会带着已有的「对象」观来看问题，最后的结果当然就是「剪不断理还乱」了。在后面的文章中，我会继续带你探索 JavaScript 对象的一些机制，看 JavaScript 如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。

与其它的语言相比，JavaScript 中的「对象」总是显得不那么合群。一些新人在学习 JavaScript 面向对象时，往往也会有疑惑：1）为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢；2）为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢？甚至，在一些争论中，有人强调：JavaScript 并非「面向对象的语言」，而是「基于对象的语言」。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答「如何定义面向对象和基于对象」这个问题。

实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。我们可以先看看 JavaScript 标准对基于对象的定义，这个定义的具体内容是：「语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合」。这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么。

1、什么是面向对象？我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解「对象」的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。中文的「对象」却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。

那么，我们先来看看在人类思维模式下，对象究竟是什么。对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字「3」（值）的概念。

在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：1）一个可以触摸或者可以看见的东西；2）人的智力可以理解的东西；3）可以指导思考或行动（进行想象或施加动作）的东西。

2『已下载原文书籍「2020099Object-oriented-analysis and-design-with-applications」。』

有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用「类」的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。这是我在前面说它不合群的原因之一。然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在「原型运行时」的基础上引入了 new、this 等语言特性，使之「看起来更像 Java」。

在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的「框架」，比如 PrototypeJS、Dojo。事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。不过，幸运的是，从运行时的角度看，可以不必受到这些「基于类的设施」的困扰，这是因为任何语言运行时类的概念都是被弱化的。首先我们来了解一下 JavaScript 是如何设计对象模型的。

2、JavaScript 对象的特征。在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。1）对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。2）对象有状态：对象具有状态，同一对象可能处于不同状态之下。3）对象具有行为：即对象的状态，可能因为它的行为产生变迁。

我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的，对象具有唯一标识的内存地址，所以具有唯一的标识。所以，JavaScript 程序员都知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false。

    var o1 = { a: 1 };
    var o2 = { a: 1 };
    console.log(o1 == o2); // false

关于对象的第二个和第三个特征「状态和行为」，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为「成员变量」和「成员函数」，Java 中则称它们为「属性」和「方法」。在 JavaScript 中，将状态和行为统一抽象为「属性」，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。

2『JavaScript 里函数是一种特殊的对象。做一张术语卡片。』

    var o = { 
        d: 1,
        f() {
            console.log(this.d);
        }    
    };

所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。在实现了对象基本特征的基础上，我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。

我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。

    var o = { a: 1 };
    o.b = 2;
    console.log(o.a, o.b); //1 2

为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。

3、JavaScript 对象的两类属性。对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。

先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。1）value：就是属性的值。2）writable：决定属性能否被赋值。3）enumerable：决定 for in 能否枚举该属性。4）configurable：决定该属性能否被删除或者改变特征值。在大多数情况下，我们只关心数据属性的值即可。

第二类属性是访问器（getter/setter）属性，它也有四个特征。1）getter：函数或 undefined，在取属性值时被调用。2）setter：函数或 undefined，在设置属性值时被调用。3）enumerable：决定 for in 能否枚举该属性。4）configurable：决定该属性能否被删除或者改变特征值。

访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：

    var o = { a: 1 };
    o.b = 2;
    //a和b皆为数据属性
    Object.getOwnPropertyDescriptor(o,"a") // {value: 1, writable: true, enumerable: true, configurable: true}
    Object.getOwnPropertyDescriptor(o,"b") // {value: 2, writable: true, enumerable: true, configurable: true}
    
我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：

    var o = { a: 1 };
    Object.defineProperty(o, "b", {value: 2, writable: false, enumerable: false, configurable: true});
    //a和b都是数据属性，但特征值变化了
    Object.getOwnPropertyDescriptor(o,"a"); // {value: 1, writable: true, enumerable: true, configurable: true}
    Object.getOwnPropertyDescriptor(o,"b"); // {value: 2, writable: false, enumerable: false, configurable: true}
    o.b = 3;
    console.log(o.b); // 2

这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：

    var o = { get a() { return 1 } };
    console.log(o.a); // 1

访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。这样，我们就理解了，实际上 JavaScript 对象的运行时是一个「属性的集合」，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下 "a" 是 key。{writable:true,value:1,configurable:true,enumerable:true} 是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。

1『对象是一个属性的索引结构，做一张金句卡片。』

讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。你甚至可以理解为什么会有「JavaScript 不是面向对象」这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript 中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。

JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。

### 黑板墙

关键点在于是否可以在运行时动态改变对象。结合文章通篇看下来，觉得 JS 的 OO 和他基于类的 OO 不同之处，在于 JS 可以在运行时修改对象，而 class based 的类只能预先全部定义好，我们并不能在运行时动态修改类。在我理解来说，条条大路通罗马，面向对象是罗马，class based 是一条路，prototype based 是另一条路。而且 Symbol 的出现，暴露出了许多内置接口，让 JS 又在这条路上走了更远一些。（以前上学背面向对象的三个特征，封装，继承，多态，现在看一下突然觉得很对。另外，好奇 Symbol 是怎么实现的。

```
var o = { get a() { return 1 } };
console.log(o.a); // 1
```

看到这段我就感到值了。我目前在用 layui 框架，根据 layui 文档的描述，只有执行 var form = layui.form; 这一句时才会下载 form.js 这个文件，我一直没能理解。这篇文章解除了我的疑惑，原来调用 getter 时可以不写括号 ()。

肯定有同学对这里有疑问，解释一下吧，这里边应用到了 ES6 的 getter, setter 属性，为啥 o.a，没写小括号呢？ 因为每次访问 get，函数返回为 1，作为一个 value 返回的，而非 Obj 中调用某个方法，所以才没写成 Obj.fun () 的方式，另外 老师下边有一句总结，很容易遗漏 ，每次访问，访问器属性，都会执行 get, set 方法。

getter setter 实际应用的例子有哪些？ vue 的数据，视图双向绑定算吗？作者回复: vue2.0 确实用到了这个。

我理解的，重学前端专栏的意义是，从语言使用者的角度，转到语言实现者的角度，来看待语言的发展，通过对比其他语言，来阐述 js 语言本身的特性。重学的意义在于，多数开发者是语言使用者，而没有从语言实现者的角度，对语言本身有思考。有一种「不识庐山真面目，只缘身在此山中」的感觉。简单说，就是大多数人就是用用，没有想过（或者没有能力）去了解语言本身的来龙去脉。

个人理解：面向对象就是万物皆为类，离开了类就活不了；比如 Java 里面，就算只写个 main 函数也要用 class 包裹起来。而基于对象说的是这门语言可以使用类和对象，但不使用类和对象也照样玩的转，比如 c++、php、js。作者回复：不是的，基于类的面相对象只是一个派系。

js 是一个具有动态性的面向对象的语言，ES2015 前主要以「prototype」面向对象编程，ES2015 问世后主要以「class」实现面向对象编程，我想 super 也是借鉴 Java 的，以后 js 可能还会有 interface，那就更灵活了。

### 0103JavaScript对象我们真的需要模拟类吗.md

在新的 ES 版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。

早期的 JavaScript 程序员一般都有过使用 JavaScript「模拟面向对象」的经历。在上一篇文章我们已经讲到，JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。那么，随着我们理解的思路继续深入，这些「模拟面向对象」，实际上做的事情就是「模拟基于类的面向对象」。

尽管我认为，「类」并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript 推出之时，管理层就要求它去模仿 Java。所以，JavaScript 创始人 Brendan Eich 在「原型运行时」的基础上引入了 new、this 等语言特性，使之「看起来语法更像 Java」，而 Java 正是基于类的面向对象的代表语言之一。但是 JavaScript 这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。

庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的「坑」，统一了社区的方案，这对语言的发展有着非常大的好处。实际上，我认为「基于类」并非面向对象的唯一形态，如果我们把视线从「类」移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。

1、什么是原型？原型是顺应人类自然思维的产物。中文中有个成语叫做「照猫画虎」，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。最为成功的流派是使用「类」的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。

「基于类」的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。与此相对，「基于原型」的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。基于原型的面向对象系统通过「复制」的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。

基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，「大猫」可能更为接近直观的感受一些。

我们的 JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。事实上，Brendan 更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的 scheme 语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是 Brendan 选择原型系统很重要的理由。

原型系统的「复制操作」有两种实现思路：1）一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；2）另一个是切实地复制对象，从此两个对象再无关联。历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。

2、JavaScript 的原型。如果我们抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括：1）如果所有对象都有私有字段 [[prototype]]，就是对象的原型；2）读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。

这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为：1）Object.create 根据指定的原型创建新对象，原型可以是 null；2）Object.getPrototypeOf 获得一个对象的原型；3）Object.setPrototypeOf 设置一个对象的原型。利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。

```
var cat = {
    say(){
        console.log("meow~");
    },
    jump(){
        console.log("jump");
    }
}

var tiger = Object.create(cat,  {
    say:{
        writable:true,
        configurable:true,
        enumerable:true,
        value:function(){
            console.log("roar!");
        }
    }
})

var anotherCat = Object.create(cat);
anotherCat.say();
var anotherTiger = Object.create(tiger);
anotherTiger.say();
```

这段代码创建了一个「猫」对象，又根据猫做了一些修改创建了虎，之后我们完全可以用 Object.create 来创建另外的猫和虎对象，我们可以通过「原始猫对象」和「原始虎对象」来控制所有猫和虎的行为。但是，在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，可以说非常别扭。考虑到 new 和 prototype 属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的 JavaScript 中的原型和类。

3、早期版本中的类与原型。在早期版本的 JavaScript 中，「类」的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。以下代码展示了所有具有内置 class 属性的对象：

```
    var o = new Object;
    var n = new Number;
    var s = new String;
    var b = new Boolean;
    var d = new Date;
    var arg = function(){ return arguments }();
    var r = new RegExp;
    var f = new Function;
    var arr = new Array;
    var e = new Error;
    console.log([o, n, s, b, d, arg, r, f, arr, e].map(v => Object.prototype.toString.call(v))); 
```

因此，在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：

```
    var o = { [Symbol.toStringTag]: "MyObject" }
    console.log(o + "");
```

这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。但是，考虑到 JavaScript 语法中跟 Java 相似的部分，我们对类的讨论不能用「new 运算是针对构造器对象，而不是类」来试图回避。所以，我们仍然要把 new 理解成 JavaScript 面向对象的一部分，下面我就来讲一下 new 操作具体做了哪些事情。

new 运算接受一个构造器和一组调用参数，实际上做了几件事：1）以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；2）将 this 和调用参数传给构造器，执行；3）如果构造器返回的是对象，则返回，否则返回第一步创建的对象。new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。下面代码展示了用构造器模拟类的两种方法：

```
function c1(){
    this.p1 = 1;
    this.p2 = function(){
        console.log(this.p1);
    }
} 
var o1 = new c1;
o1.p2();

function c2(){
}
c2.prototype.p1 = 1;
c2.prototype.p2 = function(){
    console.log(this.p1);
}

var o2 = new c2;
o2.p2();
```

第一种方法是直接在构造器中修改 this，给 this 添加属性。第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。

没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法（当时的 mozilla 提供了私有属性 \__proto\__，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 polyfill，见以下代码：

```
Object.create = function(prototype){
    var cls = function(){}
    cls.prototype = prototype;
    return new cls;
}
```

这段代码创建了一个空函数作为类，并把传入的原型挂在了它的 prototype，最后创建了一个它的实例，根据 new 的行为，这将产生一个以传入的第一个参数为原型的对象。这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以放到今天意义已经不大了。

4、ES6 中的类。好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。

1『定义定就用 class。』

ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。我们先看下类的基本写法：

```
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
}
```

在现有的类语法中，getter/setter 和 method 是兼容性最好的。我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。

```
class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }

  speak() {
    console.log(this.name + ' barks.');
  }
}

let d = new Dog('Mitzie');
d.speak(); // Mitzie barks.
```

以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。

### 黑板墙

不过感觉本篇在写的时候有一些地方讲的不够严谨：1）[[class]] 和 Symbol.toStringTag 实质上是控制的「the creation of the default string description of an object」，但举例中使用了一个 o.toString () 来讲述，感觉容易造成误解。2）在讲解 ES6 中的类时，文中指出「类中定义的方法和属性则会被写在原型对象之上」，事实上一般数据属性写在对象上，而访问器属性和方法才是写在原型对象之上的。3）class 和 extends 实质上是作为语法糖，统一了 JS 程序员对基于类的面向对象的模拟，但感觉文中讲的不是很清楚。

### 0104JavaScript对象你知道全部的对象分类吗.md

在前面的课程中，我已经讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。比如说，我们不论怎样编写代码，都没法绕开 Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的 length 属性。并且，在浏览器环境中，我们也无法单纯依靠 JavaScript 代码实现 div 对象，只能靠 document.createElement 来创建。这也说明了 JavaScript 的对象机制并非简单的属性集合 + 原型。我们日常工作中，接触到的主要 API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的 API 的一些特性。

1、JavaScript 中的对象分类。我们可以把对象分成几类。1）宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。2）内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。3）固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。4）原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。5）普通对象（Ordinary Objects）：由 {} 语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。下面我会为你一一讲解普通对象之外的对象类型。

2、宿主对象。首先我们来看看宿主对象。JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。JavaScript 标准中规定了全局对象属性，W3C 的各种标准中规定了 Window 对象的其它属性。宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 DOM 对象。宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。

3、内置对象·固有对象。我们在前面说过，固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。固有对象在任何 JavaScript 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的「类」其实就是固有对象的一种。ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过这个链接查看。但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部 JavaScript 固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。

3『[ECMAScript® 2018 Language Specification](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects)』

4、内置对象·原生对象。我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。（基本类型、基础功能和数据结构、错误类型、二进制操作、待类型的数组）

通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。这些构造器创建的对象多数使用了私有字段，例如：Error: [[ErrorData]]、Boolean: [[BooleanData]]、Number: [[NumberData]]、Date: [[DateValue]]、RegExp: [[RegExpMatcher]]、Symbol: [[SymbolData]]、Map: [[MapData]]。这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的「特权对象」。

5、用对象来模拟函数与构造器：函数对象与构造器对象。我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。

JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了「具有 [[call]] 私有字段的对象」，就可以被 JavaScript 函数调用语法支持。[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。

我们可以这样说，任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。

当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：

    console.log(new Date); // 1
    console.log(Date())

而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。

```
console.log(new Image); 
console.log (Image ());// 抛出错误
```

再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。值得一提的是，在 ES6 之后 => 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：

    new (a => 0) // error

对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。我们看一下示例。

```
function f(){
    return 1;
}
var v = f(); //把f作为函数调用
var o = new f(); //把f作为构造器调用
```

我们大致可以认为，它们 [[construct]] 的执行过程如下：1）以 Object.protoype 为原型创建一个新对象；2）以新对象为 this，执行函数的 [[call]]；3）如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。

这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现「私有」。

```
function cls(){
    this.a = 100;
    return {
        getValue:() => this.a
    }
}
var o = new cls;
o.getValue(); //100
//a在外面永远无法访问到
```

6、特殊行为的对象。除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。1）Array：Array 的 length 属性根据最大的下标自动发生变化。2）Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。3）String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。4）Arguments：arguments 的非负整数型下标属性跟对应的变量联动。5）模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。6）类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。7）bind 后的 function：跟原来的函数相关联。

我们这次课程留一个挑战任务：不使用 new 运算符，尽可能找到获得对象的方法。例子：

```
var o = {}
var o = function(){}
```

小实验：获取全部 JavaScript 固有对象。我们从 JavaScript 标准中可以找到全部的 JavaScript 对象定义。JavaScript 语言规定了全局对象的属性。

三个值：Infinity、NaN、undefined。

九个函数：eval、isFinite、isNaN、parseFloat、parseInt、decodeURI、decodeURIComponent、encodeURI、encodeURIComponent。

一些构造器：Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeakSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。

四个用于当作命名空间的对象：Atomics、JSON、Math、Reflect。

我们使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter，就可以获得 JavaScript 中所有的固有对象。请你试着先不看我的代码，在自己的浏览器中计算出来 JavaScript 有多少固有对象。

### 黑板墙

利用构造器的执行规则来实现私有，真是个意外的发现。之前用 class 构建一个类，有一些方法暴露给外面总觉得怪怪的。现在好了，在 constructor 函数里 return 一个对象，在对象里写方法来对应返回类里写的需要暴露的 method 就解决了。

老师提到原生构造器无法继承。而阮一峰老师在 [Class 的继承 - ECMAScript 6入门](https://es6.ruanyifeng.com/#docs/class-extends) 中表示，es6 已经可以继承原生构造函数，并且能定义子类。以我的理解来看，阮一峰老师的说法没有问题。

关于原生构造器无法用 class/extend 语法来继承的观点，能否举例说明呢？我写个 demo 跑了一下，发现还是可以的呐。作者回复：能继承方法，但是没办法跟原生的一模一样。

本文用对象来模拟函数与构造器：如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。在《Javascript 高级程序设计》—— 第 6 章，面对对象的程序设计 p160-p161 的寄生构造函数模式有类似讲解：构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。


## 0102. JavaScript2

### 1. 逻辑脉络

5、宿主发起的任务称为宏观任务，JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。

6、有编程语言的概念闭包；各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。

7、认识了 ES2018 中规定的各种函数，简单介绍了 8 种函数。围绕 this 这个中心，介绍了函数的执行上下文切换机制。同时我们还讲解了 this 中的一些相关知识。包括了操作 this 的内置函数。



### 2. 摘录及评论

### 0105JavaScript执行1Promise里的代码为什么比setTimeout先执行.md

JavaScript 执行部分的知识，首先我们学习了 JavaScript 的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。除此之外，我们还展开介绍了用 Promise 来添加微观任务的方式，并且介绍了 async/await 这个语法的改进。

JavaScript 的执行。首先我们考虑一下，如果我们是浏览器或者 Node 的开发者，我们该如何使用 JavaScript 引擎。当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。

然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。

在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。

1、宏观和微观任务。JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：

```
while(TRUE) {
    r = wait();
    execute(r);
}
```

我们可以看到，整个循环做的事情基本上就是反复「等待 - 执行」。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。

这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：

有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。接下来，我们来详细介绍一下 Promise。

2、Promise。Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个「承诺」，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。Promise 的基本用法示例如下：

```
    function sleep(duration) {
        return new Promise(function(resolve, reject) {
            setTimeout(resolve,duration);
        })
    }
    sleep(1000).then( ()=> console.log("finished"));
```

这段代码定义了一个函数 sleep，它的作用是等候传入参数指定的时长。Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序，我们来看一段代码示例：

```
    var r = new Promise(function(resolve, reject){
        console.log("a");
        resolve()
    });
    r.then(() => console.log("c"));
    console.log("b")
```

我们执行这段代码后，注意输出的顺序是 a b c。在进入 console.log ("b") 之前，毫无疑问 r 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。接下来我们试试跟 setTimeout 混用的 Promise。在这段代码中，我设置了两段互不相干的异步操作：通过 setTimeout 执行 console.log ("d")，通过 Promise 执行 console.log ("c")。


```
    var r = new Promise(function(resolve, reject){
        console.log("a");
        resolve()
    });
    setTimeout(()=>console.log("d"), 0)
    r.then(() => console.log("c"));
    console.log("b")
```

我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时 1 秒的 Promise。

```
    setTimeout(()=>console.log("d"), 0)
    var r = new Promise(function(resolve, reject){
        resolve()
    });
    r.then(() => { 
        var begin = Date.now();
        while(Date.now() - begin < 1000);
        console.log("c1") 
        new Promise(function(resolve, reject){
            resolve()
        }).then(() => console.log("c2"))
    });
```

这里我们强制了 1 秒的执行耗时，这样，我们可以确保任务 c2 是在 d 之后被添加到任务队列。我们可以看到，即使耗时一秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行了，这很好地解释了微任务优先的原理。

通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：1）首先我们分析有多少个宏任务；2）在每个宏任务中，分析有多少个微任务；3）根据调用次序，确定宏任务中的微任务执行次序；4）根据宏任务的触发规则和调用次序，确定宏任务的执行次序；5）确定整个顺序。我们再来看一个稍微复杂的例子：

```
    function sleep(duration) {
        return new Promise(function(resolve, reject) {
            console.log("b");
            setTimeout(resolve,duration);
        })
    }
    console.log("a");
    sleep(5000).then(()=>console.log("c"));
```

这是一段非常常用的封装方法，利用 Promise 把 setTimeout 封装成可以用于异步的函数。我们首先来看，setTimeout 把整个代码分割成了 2 个宏观任务，这里不论是 5 秒还是 0 秒，都是一样的。第一个宏观任务中，包含了先后同步执行的 console.log ("a"); 和 console.log ("b");。setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log ("c")，最终输出的顺序才是： a b c。

Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。

3、新特性：async/await。async/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise，面对这种比较新的特性，我们先来看一下基本用法。async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。

```
function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,duration);
    })
}
async function foo(){
    console.log("a")
    await sleep(2000)
    console.log("b")
}
```

这段代码利用了我们之前定义的 sleep 函数。在异步函数 foo 中，我们调用 sleep。async 函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。

```
function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,duration);
    })
}
async function foo(name){
    await sleep(2000)
    console.log(name)
}
async function foo2(){
    await foo("a");
    await foo("b");
}
```

这里 foo2 用 await 调用了两次异步函数 foo，可以看到，如果我们把 sleep 这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解 Promise 的概念即可进行异步编程了。此外，generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。

### 黑板墙

留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色，你会怎样编写这个代码呢？欢迎你留言讨论。


```
function sleep(duration){
    return new Promise(function(resolve){
        setTimeout(resolve, duration);
    })
}
async function changeColor(duration,color){
    document.getElementById("traffic-light").style.background = color;
    await sleep(duration);

}
async function main(){
    while(true){
        await changeColor(3000,"green");
        await changeColor(1000, "yellow");
        await changeColor(2000, "red");
    }
}
main()
```

[Tasks, microtasks, queues and schedules - JakeArchibald.com](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

为了更深入的理解宏任务和微任务，读了这篇。感觉文中说的微任务总是先于宏任务会让人产生误解，更准确的说法应该是微任务总会在下一个宏任务之前执行，在本身所属的宏任务结束后立即执行。

async/await 函数属于宏观还是微观？作者回复：它产生 Promise，当然是微观任务了

async/await ，遇到 await 时就会退出执行，我想问下，退出之后是处于等待 await 执行完再开始之后吗？作者回复：是的；如果 promise 中产生 setTimeout 函数，那么在这里的 setTimeout 是处于微观任务对吗？因为这是 js 引擎直接发起的？作者回复：还是宏观任务，因为你调用到了引擎以外的 API。

### 0106JavaScript执行2闭包和执行上下文到底是怎么回事.md

梳理了一些概念：有编程语言的概念闭包，也有各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从 var、let、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm的设计。

JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据「由 JavaScript 引擎发起」还是「由宿主发起」，分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。

一段 JavaScript 代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。我们今天要讲的知识在网上有不同的名字，比较常见的可能有：1）闭包；2）作用域链；3）执行上下文；4）this 值。

实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。

1、闭包。闭包翻译自英文单词 closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。

闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了 applicative expression 和 closure 的概念。在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是「带有一系列信息的 λ 表达式」。对函数式语言而言，λ 表达式其实就是函数。

我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。

这个古典的闭包定义中，闭包包含两个部分。1）环境部分：环境、标识符列表。2）表达式部分。当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。环境部分。环境：函数的词法环境（执行上下文的一部分）。标识符列表：函数中用到的未声明的变量。表达式部分：函数体。

至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。

实际上 JavaScript 中跟闭包对应的概念就是「函数」，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的「作用域」吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。

2、执行上下文：执行的基础设施。相比普通函数，JavaScript 函数的主要复杂性来自于它携带的「环境部分」。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。JavaScript 中与闭包「环境部分」相对应的术语是「词法环境」，但是 JavaScript 函数比 λ 函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ 函数中可没有这些东西，所以，在 JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：「执行上下文」。因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。

执行上下文在 ES3 中，包含三个部分。1）scope：作用域，也常常被叫做作用域链。2）variable object：变量对象，用于存储变量的对象。3）this value：this 值。

在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。1）lexical environment：词法环境，当获取变量时使用。2）variable environment：变量环境，当声明变量时使用。3）this value：this 值。

在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。1）lexical environment：词法环境，当获取变量或者 this 值时使用。2）variable environment：变量环境，当声明变量时使用。3）code evaluation state：用于恢复代码执行位置。4）Function：执行的任务是函数时使用，表示正在被执行的函数。5）ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。6）Realm：使用的基础库和内置对象实例。7）Generator：仅生成器上下文有这个属性，表示当前生成器。

我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。

尽管我们介绍了这些定义，但我并不打算按照 JavaScript 标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。

比如，我们看以下的这段 JavaScript 代码：

```
var b = {}
let c = 1
this.a = 2;
```

要想正确执行它，我们需要知道以下信息：

1）var 把 b 声明到哪里；2）b 表示哪个变量；3）b 的原型是哪个对象；4）let 把 c 声明到哪里；5）this 指向哪个对象。

这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲 var 声明与赋值，let，realm 三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。

3、var 声明与赋值。我们来分析一段代码：

    var b = 1

通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。

由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。

```
(function(){
    var a;
    //code
}());

(function(){
    var a;
    //code
})();
```

但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。

```
;(function(){
    var a;
    //code
}())

;(function(){
    var a;
    //code
})()
```

我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。

```
void function(){
    var a;
    //code
}();
```

这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：

```
var b;
void function(){
    var env = {b:1};
    b = 2;
    console.log("In function b:", b);
    with(env) {
        var b = 3;
        console.log("In with b:", b);
    }
}();
console.log("Global b:", b);
```

在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。

4、let。let 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。我简单统计了下，以下语句会产生 let 使用的作用域：for；if；switch；try/catch/finally。

5、Realm。在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是「国度」「领域」「范围」。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。我们继续来看这段代码：

    var b = {}

在 ES2016 之前的版本中，标准中甚少提及 {} 的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。

以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：

```
var iframe = document.createElement('iframe')
document.documentElement.appendChild(iframe)
iframe.src="javascript:var b = {};"

var b1 = iframe.contentWindow.b;
var b2 = {};

console.log(typeof b1, typeof b2); //object object

console.log(b1 instanceof Object, b2 instanceof Object); //false true
```

可以看到，由于 b1、 b2 由同样的代码 {}  在不同的 Realm 中执行，所以表现出了不同的行为。

### 黑板墙

let 和 var 都不好用，98% 的情况都是用 const。

```
var b = 10;
(function b(){
b = 20;
console.log(b); // [Function: b]
})();
```

作者回复：这个地方比较特殊，「具有名称的函数表达式」会在外层词法环境和它自己执行产生的词法环境之间产生一个词法环境，再把自己的名称和值当作变量塞进去，所以你这里的 b = 20 并没有改变外面的 b，而是试图改变一个只读的变量 b。这块知识有点偏，随便看看就好。

凡是 {} 包裹的代码都会产生 let/const 作用域吧？除了文中提到的 for 等，还有 while，do while，代码块等。

我觉得应该用 global object，和 active object 来解释这个闭包，作用域，执行器上下文。作者回复：这是 ES3 里的解释法，现在已经解释不了很多语法了。

仔细看了下维基百科上面闭包的定义：闭包是一个 record，它存储了一个函数和它的环境，这个环境存储了该函数的自由变量，js 的函数完全符合这个定义，所以说 js 的函数其实就是闭包。倒是普通函数有点特别，我自己理解，这样的函数才是普通函数：

```
function(a, b) {
    const c = 10
    return a + b + c;
}
```

这个函数只访问了自己的函数作用域内部的变量和参数，这样的函数才是所谓的普通函数。

我认为在目前的环境下，var 已经没有存在的必要了，所有以前用 var 的情况都可以通过 let 和 const 代替，而且 let 和 const 更加符合大多数编程语言的习惯，而且现在有 babel 的话，写 ES6 语法也非常安全。

今天是自己第一次结构性整理清楚 JavaScript 的函数部分。原来它除了函数体之外，还包括了函数所处的环境，而其中的词法环境，其实只是执行上下文七个部分中的的一支。个人感觉 var 声明在不同的执行上下文中相对 let 更容易出错，同时也会增加冗余的临时变量。比如在 for loop 中，会遇到需要为不同的 loop 声明 i、j、k 变量。代码不仅是写给机器看，也是写给同行看的。let 会使代码更加简洁易读。

我一般都会更多使用 let 作用于每一块函数，或者业务逻辑，var 一般除非是一些全局不变的，会单独放一个文件来引用。

3『

[IIFE - MDN Web Docs Glossary: Definitions of Web-related terms | MDN](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)

An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.

```
(function () {
    statements
})();
```
It is a design pattern which is also known as a Self-Executing Anonymous Function and contains two major parts: 1) The first is the anonymous function with lexical scope enclosed within the Grouping Operator (). This prevents accessing variables within the IIFE idiom as well as polluting the global scope. 2) The second part creates the immediately invoked function expression () through which the JavaScript engine will directly interpret the function.

### Examples

The function becomes a function expression which is immediately executed. The variable within the expression can not be accessed from outside it.

```
(function () {
    var aName = "Barry";
})();
// Variable aName is not accessible from the outside scope
aName // throws "Uncaught ReferenceError: aName is not defined"
```

Assigning the IIFE to a variable stores the function's return value, not the function definition itself.

```
var result = (function () {
    var name = "Barry"; 
    return name; 
})(); 
// Immediately creates the output: 
result; // "Barry"
```
』

### 0107JavaScript执行3你知道现在有多少种函数吗.md

认识了 ES2018 中规定的各种函数，我一共简单介绍了 8 种函数。我们围绕 this 这个中心，介绍了函数的执行上下文切换机制。同时我们还讲解了 this 中的一些相关知识。包括了操作 this 的内置函数。

任何语句的执行都会依赖特定的上下文。一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。在 JavaScript，切换上下文最主要的场景是函数调用。

1、函数。在 ES2018 中，函数已经是一个很复杂的体系了，我在这里整理了一下。第一种，普通函数：用 function 关键字定义的函数。

```
function foo(){
    // code
}
```

第二种，箭头函数：用 => 运算符定义的函数。

```
const foo = () => {
    // code
}
```

第三种，方法：在 class 中定义的函数。

```
class C {
    foo(){
        //code
    }
}
```


第四种，生成器函数：用 function * 定义的函数。

```
function* foo(){
    // code
}
```

第五种，类：用 class 定义的类，实际上也是函数。

```
class Foo {
    constructor(){
        //code
    }
}
```

第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。

```
async function foo(){
    // code
}
const foo = async () => {
    // code
}
async function foo*(){
    // code
}
```

ES6 以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。对普通变量而言，这些函数并没有本质区别，都是遵循了「继承定义时环境」的规则，它们的一个行为差异在于 this 关键字。

2、this 关键字的行为。this 是 JavaScript 中的一个关键字，它的使用方法类似于一个变量（但是 this 跟变量的行为有很多不同，上一节课我们讲了一些普通变量的行为和机制，也就是 var 声明和赋值、let 的内容）。this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同，我们看一个例子：

```
function showThis(){
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); // global
o.showThis(); // o
```

在这个例子中，我们定义了函数 showThis，我们把它赋值给一个对象 o 的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的 this 值。

普通函数的 this 值由「调用它所使用的引用」决定，其中奥秘就在于：我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型（记得我们在类型一章讲过七种标准类型吗，正是其中之一）。Reference 类型由两部分组成：一个对象和一个属性值。不难理解 o.showThis 产生的 Reference 类型，即由对象 o 和属性「showThis」构成。

当做一些算术运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。在这个例子中，Reference 类型中的对象被当作 this 值，传入了执行函数时的上下文当中。

至此，我们对 this 的解释已经非常清晰了：调用函数时使用的引用，决定了函数执行时刻的 this 值。实际上从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。这个设计来自 JavaScript 早年，通过这样的方式，巧妙地模仿了 Java 的语法，但是仍然保持了纯粹的「无类」运行时设施。如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了：

2『this 的解释做一张术语卡片。』

```
const showThis = () => {
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); // global
o.showThis(); // global
```

我们看到，改为箭头函数后，不论用什么引用来调用它，都不影响它的 this 值。接下来我们看看「方法」，它的行为又不一样了：


```
const showThis = () => {
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); // global
o.showThis(); // global
```

我们看到，改为箭头函数后，不论用什么引用来调用它，都不影响它的 this 值。接下来我们看看「方法」，它的行为又不一样了：

```
class C {
    showThis() {
        console.log(this);
    }
}
var o = new C();
var showThis = o.showThis;

showThis(); // undefined
o.showThis(); // o
```

这里我们创建了一个类 C，并且实例化出对象 o，再把 o 的方法赋值给了变量 showThis。这时候，我们使用 showThis 这个引用去调用方法时，得到了 undefined。所以，在方法中，我们看到 this 的行为也不太一样，它得到了 undefined 的结果。按照我们上面的方法，不难验证出：生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。

3、this 关键字的机制。说完了 this 行为，我们再来简单谈谈在 JavaScript 内部，实现 this 这些行为的机制，让你对这部分知识有一个大概的认知。函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。

在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的 [[Environment]]。这个动作就是切换上下文了，我们假设有这样的代码：

```
var a = 1;
foo();

在别处定义了foo：

var b = 2;
function foo(){
    console.log(b); // 2
    console.log(a); // error
}
```

这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制了。JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：

![](./res/2019031.png)

当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。[[thisMode]] 私有属性有三个取值。1）lexical：表示从上下文中找 this，这对应了箭头函数。2）global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。3）strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。

非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。我们可以用 strict 达成与上一节中方法的例子一样的效果:

```
"use strict"
function showThis(){
    console.log(this);
}

var o = {
    showThis: showThis
}

showThis(); // undefined
o.showThis(); // o
```

函数创建新的执行上下文中的词法环境记录时，会根据 [[thisMode]] 来标记新纪录的 [[ThisBindingStatus]] 私有属性。代码执行遇到 this 时，会逐层检查当前词法环境记录中的 [[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层 this，例如：

```
var o = {}
o.foo = function foo(){
    console.log(this);
    return () => {
        console.log(this);
        return () => console.log(this);
    }
}

o.foo()()(); // o, o, o
```

这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。这里调用三个函数，获得的 this 值是一致的，都是对象 o。JavaScript 还提供了一系列函数的内置方法来操纵 this 值，下面我们来了解一下。

4、操作 this 的内置函数。Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值，示例如下：

```
function foo(a, b, c){
    console.log(this);
    console.log(a, b, c);
}
foo.call({}, 1, 2, 3);
foo.apply({}, [1, 2, 3]);
```

这里 call 和 apply 作用是一样的，只是传参方式有区别。此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数：

```
function foo(a, b, c){
    console.log(this);
    console.log(a, b, c);
}
foo.bind({}, 1, 2, 3)();
```

有趣的是，call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。这时候，它们无法实现改变 this 的能力，但是可以实现传参。

补充阅读：new 与 this。我们在之前的对象部分已经讲过 new 的执行过程，我们再来看一下：1）以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；2）将 this 和调用参数传给构造器，执行；3）如果构造器返回的是对象，则返回，否则返回第一步创建的对象。显然，通过 new 调用函数，跟直接调用的 this 取值有明显区别。那么我们今天讲的这些函数跟 new 搭配又会产生什么效果呢？这里我整理了一张表；我们可以看到，仅普通函数和类能够跟 new 搭配使用，这倒是给我们省去了不少麻烦。

### 黑板墙

关于 this，Kyle Simpson 有四条总结：1）由 new 调用？绑定到新创建的对象。2）由 call 或者 apply (或者 bind) 调用？绑定到指定的对象。3）由上下文对象调用？绑定到那个上下文对象。4）默认：在严格模式下绑定到 undefined，否则绑定到全局对象。例外：箭头函数不适用以上四条规则，它会继承外层函数调用的 this 绑定 (无论 this 绑定到什么)。

老师写的「在别处定义了 foo」的意思是，这句话上下两部分的代码，不在同一个文件哒。已经有同学贴了代码，是这样的：

```js
// 这是 foo.js 文件里的代码
var b = 2;
module.exports = function() { // 导出function
  console.log(b);
  console.log(a);
};
```
```js
// 这是test.js 文件里的代码
var foo = require("./foo.js"); // 引入function 为foo
var a = 1;
foo();
// node 执行 test.js 输出：
// -> 2
// -> ReferenceError: a is not defined
```

### 0108JavaScript执行4try里面放return-finally还会执行吗.md

8、 JavaScript 语句执行的原理。因为 JavaScript 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行，树形结构的每一个节点执行后产生 Completion Record，根据语句的结构和 Completion Record，JavaScript 实现了各种分支和跳出逻辑。

我们以 Completion Record 类型为线索，为你讲解了 JavaScript 语句执行的原理。因为 JavaScript 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行，树形结构的每一个节点执行后产生 Completion Record，根据语句的结构和 Completion Record，JavaScript 实现了各种分支和跳出逻辑。

已经了解了关于执行上下文、作用域、闭包之间的关系。说一下更为细节的部分：语句。语句是任何编程语言的基础结构，与 JavaScript 对象一样，JavaScript 语句同样具有「看起来很像其它语言，但是其实一点都不一样」的特点。我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。为了了解 JavaScript 语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍 JavaScript 语句执行机制涉及的一种基础类型：Completion 类型。











