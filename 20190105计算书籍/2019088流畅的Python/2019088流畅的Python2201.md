Plone 的联合创始人

Alan 的精辟定义道出了 Python 最好的特质之一：它不妨碍你，让你做你该做的事。这也意味着，它不会给你提供工具，让你限制其他人能对你的代码和代码所构建的对象做什么。

当然，Python 不完美。对我来说，最没法接受的是，Python 在标准库中混用驼峰式和蛇底式，或者直接把单词连在一起。但是，语言的定义和标准库只是生态系统的一部分。用户和贡献者组成的社区才是 Python 生态系统最重要的部分。

有一个例子可以说明社区的好处。一天早上，我在撰写 asyncio 包相关的内容时，感到很沮丧，因为那个包的 API 有很多函数，其中有些是协程，可是协程必须使用 yield from 调用，而常规的函数不能这么做。这在 asyncio 包的文档中有说明，可是有时阅读几段文字之后才能确定某个函数是不是协程。因此，我给 python-tulip 邮件列表发了一个消息，题为「Proposal: make coroutines stand out in the asyncio docs」。asyncio 包的核心开发者 Victor Stinner、aiohttp 包的主要作者 Andrew Svetlov、Tornado 的首席开发者 Ben Darnell，以及 Twisted 的发明者 Glyph Lefkowitz 加入了讨论。Darnell 提出了一个方案，Alexander Shorin 解说如何在 Sphinx 中实现，Stinner 添加了所需的配置和标记。我提出这个问题不到 12 小时，asyncio 包的整个线上文档都更新了，添加了今天你所看到的「coroutine」标签。

在排外的社区中绝不会有这种事。任何人都能加入 python-tulip 邮件列表，我编写那个提议之前只发布过几次消息而已。这个故事表明，Python 社区特别开放，广纳新想法和新成员。Guido van Rossum 也在 python-tulip 邮件列表中，即使是简单的问题也经常回答。

还有一个例子能说明 Python 的开放：Python 软件基金会（Python Software Foundation，PSF）一直在努力提升 Python 社区的多样性，而且已经达成一些令人欣喜的成果。2013— 2014 年，PSF 董事会首次选出了女性董事 ——Jessica McKellar 和 Lynn Root。2015 年在蒙特利尔举办的 PyCon North America 大会（Diana Clarke 主持），约 1/3 的演讲者是女性。我还没见过其他 IT 大会如此追求性别平等。

如果你是 Python 程序员，但尚未加入社区，我建议你快点加入。寻找你所在地区的 Python 用户组（Python Users Group，PUG）。如果没有，那就创建一个。任何地方都有人使用 Python，你并不孤独。如果可能的话，参加别处举办的会议。来参加 PythonBrasil 大会吧，多年以来这个大会都有来自世界各地的演讲者。与其他 Python 程序员见面比任何线上互动都好，除了可以获得别人分享的知识外，还有很多好处，例如工作机会和真正的友谊。

我知道，如果没有多年来我在 Python 社区中结交的朋友的帮助，我不可能写出这本书。

我的父亲说过，「Só erra quem trabalha」，这是葡萄牙语，意思是「只有真正做事的人才会犯错」。这个建议很棒，能让你不再害怕失败，迈步向前。撰写这本书的过程中，我肯定犯了错误。审校、编辑和预先发布版的读者帮我找出了很多错误。早期发布版刚发布几小时，就有一个读者在本书的勘误页面报告拼写错误。其他读者报告了更多错误，我的朋友还直接联系我，提供建议和更正。我写完本书后，O'Reilly 的文字编辑会在出版过程中找出其他错误。如果还有任何错误和词不达意的表述，责任都在我，在此向各位读者致歉。

终于写完这本书了，我特别高兴，无论有没有错误，我都十分感激一路上给我帮助的每个人。希望很快就能在会议上见到你。如果见到我，请过来打声招呼。

延伸阅读

在本书的最后，我要介绍一些「Python 风格」的参考资料 —— 这正是本书尝试解决的主要问题。

Brandon Rhodes 是位出色的 Python 教师，他的演讲「A Python Æsthetic: Beauty and Why I Python」很精彩，从标题中使用的 Unicode 字符 U+00C6（拉丁语大写字母 AE）开始谈起。另一位出色的教师 Raymond Hettinger，在 2013 年的 PyCon US 大会上谈了 Python 之美：「Transforming Code into Beautiful, Idiomatic Python」。

Ian Lee 在 Python-ideas 邮件列表中发起的「Evolution of Style Guides」话题值得一读。Lee 是 pep8 包的维护者，这个包的作用是检查 Python 代码是否符合 PEP 8。检查书中的代码时，我用的是 flake8（https://pypi.python.org/pypi/flake8），这个包融合了 pep8、pyflakes（https://pypi.python.org/pypi/pyflakes）和 Ned Batchelder 开发的 McCabe 复杂度插件。

除了 PEP 8，Google 的 Python 风格指南和 Pocoo 风格指南也有很大的影响。Pocoo 团队为我们开发了 Flask、Sphinx、Jinja 2 和其他优秀的 Python 库。

The Hitchhiker's Guide to Python! 由多人维护，说明如何编写符号 Python 风格的代码。为这个项目贡献最多内容的是 Kenneth Reitz，他因开发特别符合 Python 风格的 requests 包而被社区视为英雄。David Goodger 在 2008 年举办的 PyCon US 大会上办了一场教学活动，题为「Code Like a Pythonista: Idiomatic Python」。如果打印出来，这个教程的教案有 30 页。当然，教案的 reStructuredText 源码能下载到，可以使用 docutils 将其渲染成 HTML 和 S5 幻灯片。毕竟，reStructuredText 和 docutils 都是 Goodger 的作品。这两个工具是 Sphinx 的基础。Sphinx 是优秀的 Python 文档系统，顺便提一下，MongoDB 和很多其他项目的官方文档系统都是 Sphinx。

Martijn Faassen 直接回答了「什么是 Python 风格」这个问题，python-list 邮件列表中也有一个相同标题的话题。Martijn 的文章是 2005 年写的，那个话题是 2003 年讨论的，不过 Python 风格的思想没怎么变化，Python 语言本身也是如此。「Pythonic way to sum n-th list element?」话题对 Python 风格做了深入讨论，我在第 10 章的「杂谈」中有大量引用。

「PEP 3099 — Things that will Not Change in Python 3000」解释了经过 Python 3 大幅度的调整之后，为何许多东西仍是现在的样子。长久以来，Python 3 有个昵称 ——Python 3000，不过诞生时间早了几个世纪，这让一些人失望。PEP 3099 的作者是 Georg Brandl，他收集了仁慈的独裁者（即 Guido van Rossum）的很多观点。Python Essays 页面列出了很多 Guido 自己写的文章。

附录 A　辅助脚本

有些脚本太长，在正文里放不下，这里将其完整列出。此外，有些脚本用于生成书中的表格和数据，这里一并列出。

这里列出的脚本，以及书中几乎每个代码片段，见于本书的代码仓库。

A.1　第 3 章：in 运算符的性能测试

表 3-6 中的计时数据是我使用示例 A-1 中的代码生成的，这段代码用到了 timeit 模块。这个脚本主要用于设置 haystack 和 needles 样本，并格式化输出。

编写示例 A-1 时，我发现的确能客观比较 dict 的性能。如果在「详细模式」（指定命令行选项 -v）中运行这个脚本，用时几乎是表 3-5 中的两倍。但是注意，对这个脚本来说，在「详细模式」中，只是多了用于设置测试内容的四个 print 调用，以及在各个测试结束后显示找到多少个 needles 的那个 print 调用。在 haystack 中搜索 needles 的那个循环没有输出，不过这五个 print 调用耗费的时间与搜索 1000 个 needles 差不多。

示例 A-1　container_perftest.py：运行时以内置集合类型的名称为命令行参数（例如 container_perftest.py dict）

"""对容器的``in``运算符做性能测试""" import sys import timeit SETUP = ''' import array selected = array.array ('d') with open ('selected.arr', 'rb') as fp: selected.fromfile (fp, {size}) if {container_type} is dict: haystack = dict.fromkeys (selected, 1) else: haystack = {container_type}(selected) if {verbose}: print (type (haystack), end=' ') print ('haystack: %10d' % len (haystack), end=' ') needles = array.array ('d') with open ('not_selected.arr', 'rb') as fp: needles.fromfile (fp, 500) needles.extend (selected [::{size}//500]) if {verbose}: print (' needles: %10d' % len (needles), end=' ') ''' TEST = ''' found = 0 for n in needles: if n in haystack: found += 1 if {verbose}: print (' found: %10d' % found) ''' def test (container_type, verbose): MAX_EXPONENT = 7 for n in range (3, MAX_EXPONENT + 1): size = 10**n setup = SETUP.format (container_type=container_type, size=size, verbose=verbose) test = TEST.format (verbose=verbose) tt = timeit.repeat (stmt=test, setup=setup, repeat=5, number=1) print ('|{:{} d}|{:f}'.format (size, MAX_EXPONENT + 1, min (tt))) if __name__=='__main__': if '-v' in sys.argv: sys.argv.remove ('-v') verbose = True else: verbose = False if len (sys.argv) != 2: print ('Usage: % s <container_type>' % sys.argv [0]) else: test (sys.argv [1], verbose)

container_perftest_datagen.py 脚本（见示例 A-2）为示例 A-1 中的脚本生成固件数据。

示例 A-2　container_perftest_datagen.py：生成由不同的浮点数组成的数组，然后写入文件，供示例 A-1 使用

"""生成容器性能测试所需的数据""" import random import array MAX_EXPONENT = 7 HAYSTACK_LEN = 10 ** MAX_EXPONENT NEEDLES_LEN = 10 ** (MAX_EXPONENT - 1) SAMPLE_LEN = HAYSTACK_LEN + NEEDLES_LEN // 2 needles = array.array ('d') sample = {1/random.random () for i in range (SAMPLE_LEN)} print ('initial sample: % d elements' % len (sample)) # 完整的样本，防止丢弃了重复的随机数 while len (sample) <SAMPLE_LEN: sample.add (1/random.random ()) print ('complete sample: % d elements' % len (sample)) sample = array.array ('d', sample) random.shuffle (sample) not_selected = sample [:NEEDLES_LEN // 2] print ('not selected: % d samples' % len (not_selected)) print (' writing not_selected.arr') with open ('not_selected.arr', 'wb') as fp: not_selected.tofile (fp) selected = sample [NEEDLES_LEN // 2:] print ('selected: % d samples' % len (selected)) print (' writing selected.arr') with open ('selected.arr', 'wb') as fp: selected.tofile (fp)

A.2　第 3 章：比较散列后的位模式

示例 A-3 是个简单的脚本，告诉你相似浮点数（例如 1.0001、1.0002，等等）的位模式有什么差异。这个脚本的输出在示例 3-16 中。

示例 A-3　hashdiff.py：显示散列值的位模式有何差异

import sys MAX_BITS = len(format(sys.maxsize, 'b')) print('%s-bit Python build' % (MAX_BITS + 1)) def hash_diff(o1, o2): h1 = '{:>0{}b}'.format(hash(o1), MAX_BITS) h2 = '{:>0{}b}'.format(hash(o2), MAX_BITS) diff = ''.join('!' if b1 != b2 else ' ' for b1, b2 in zip(h1, h2)) count = '!= {}'.format(diff.count('!')) width = max(len(repr(o1)), len(repr(o2)), 8) sep = '-' * (width * 2 + MAX_BITS) return '{!r:{width}} {}\n{:{width}} {} {}\n{!r:{width}} {}\n{}'.format( o1, h1, ' ' * width, diff, count, o2, h2, sep, width=width) if __name__ == '__main__': print(hash_diff(1, 1.0)) print(hash_diff(1.0, 1.0001)) print(hash_diff(1.0001, 1.0002)) print(hash_diff(1.0002, 1.0003))

A.3　第 9 章：有或没有 __slots__ 时，RAM 的用量

memtest.py 脚本用于支持 9.8 节的一个演示 —— 示例 9-12。

memtest.py 脚本从命令行中接收一个模块的名称，加载那个模块。假设模块中定义有一个名为 Vector 的类，memtest.py 脚本会创建一个由一千万个实例组成的列表，然后报告创建列表前后内存的用量。

示例 A-4　memtest.py：创建大量 Vector 实例，报告内存用量

import importlib import sys import resource NUM_VECTORS = 10**7 if len(sys.argv) == 2: module_name = sys.argv[1].replace('.py', '') module = importlib.import_module(module_name) else: print('Usage: {} <vector-module-to-test>'.format()) sys.exit(1) fmt = 'Selected Vector2d type: {.__name__}.{.__name__}' print(fmt.format(module, module.Vector2d)) mem_init = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss print('Creating {:,} Vector2d instances'.format(NUM_VECTORS)) vectors = [module.Vector2d(3.0, 4.0) for i in range(NUM_VECTORS)] mem_final = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss print('Initial RAM usage: {:14,}'.format(mem_init)) print(' Final RAM usage: {:14,}'.format(mem_final))

A.4　第 14 章：转换数据库的 isis2json.py 脚本

示例 A-5 是 14.13 节讨论的 isis2json.py 脚本。这个脚本使用生成器函数，以惰性的方式把 CDS/ISIS 数据库转换成 JSON 格式，以便载入到 CouchDB 或 MongoDB。

注意，这是个 Python 2 脚本，针对 CPython 或 Jython，支持 Python 2.5~2.7，不能使用 Python 3 运行。在 CPython 中，只能读取 .iso 文件；在 Jython 中，使用 GitHub 中 fluentpython/isis2json 仓库里的 Bruma 库，还可以读取 .mst 文件。详情参见该仓库里的用法文档。

示例 A-5　isis2json.py：依赖和文档在 GitHub 中的 fluentpython/isis2json 仓库里

# 这个脚本支持 Python 和 Jython（版本 >=2.5 且 & lt;3） import sys import argparse from uuid import uuid4 import os try: import json except ImportError: if os.name == 'java': # 在 Jython 中运行 from com.xhaus.jyson import JysonCodec as json else: import simplejson as json SKIP_INACTIVE = True DEFAULT_QTY = 2**31 ISIS_MFN_KEY = 'mfn' ISIS_ACTIVE_KEY = 'active' SUBFIELD_DELIMITER = '^' INPUT_ENCODING = 'cp1252' def iter_iso_records (iso_file_name, isis_json_type): ➊ from iso2709 import IsoFile from subfield import expand iso = IsoFile (iso_file_name) for record in iso: fields = {} for field in record.directory: field_key = str (int (field.tag)) # 删除前导零 field_occurrences = fields.setdefault (field_key, []) content = field.value.decode (INPUT_ENCODING, 'replace') if isis_json_type == 1: field_occurrences.append (content) elif isis_json_type == 2: field_occurrences.append (expand (content)) elif isis_json_type == 3: field_occurrences.append (dict (expand (content))) else: raise NotImplementedError ('ISIS-JSON type % s conversion ' 'not yet implemented for .iso input' % isis_json_type) yield fields iso.close () def iter_mst_records (master_file_name, isis_json_type): ➋ try: from bruma.master import MasterFactory, Record except ImportError: print ('IMPORT ERROR: Jython 2.5 and Bruma.jar ' 'are required to read .mst files') raise SystemExit mst = MasterFactory.getInstance (master_file_name).open () for record in mst: fields = {} if SKIP_INACTIVE: if record.getStatus () != Record.Status.ACTIVE: continue else: # 仅当没有活动的记录时才保存状态 fields [ISIS_ACTIVE_KEY] = (record.getStatus () == Record.Status.ACTIVE) fields [ISIS_MFN_KEY] = record.getMfn () for field in record.getFields (): field_key = str (field.getId ()) field_occurrences = fields.setdefault (field_key, []) if isis_json_type == 3: content = {} for subfield in field.getSubfields (): subfield_key = subfield.getId () if subfield_key == '*': content ['_'] = subfield.getContent () else: subfield_occurrences = content.setdefault (subfield_key, []) subfield_occurrences.append (subfield.getContent ()) field_occurrences.append (content) elif isis_json_type == 1: content = [] for subfield in field.getSubfields (): subfield_key = subfield.getId () if subfield_key == '*': content.insert (0, subfield.getContent ()) else: content.append (SUBFIELD_DELIMITER + subfield_key + subfield.getContent ()) field_occurrences.append (''.join (content)) else: raise NotImplementedError ('ISIS-JSON type % s conversion ' 'not yet implemented for .mst input' % isis_json_type) yield fields mst.close () def write_json (input_gen, file_name, output, qty, skip, id_tag, ➌ gen_uuid, mongo, mfn, isis_json_type, prefix, constant): start = skip end = start + qty if id_tag: id_tag = str (id_tag) ids = set () else: id_tag = '' for i, record in enumerate (input_gen): if i >= end: break if not mongo: if i == 0: output.write ('[') elif i > start: output.write (',') if start <= i < end: if id_tag: occurrences = record.get (id_tag, None) if occurrences is None: msg = 'id tag #% s not found in record % s' if ISIS_MFN_KEY in record: msg = msg + (' (mfn=% s)' % record [ISIS_MFN_KEY]) raise KeyError (msg % (id_tag, i)) if len (occurrences) > 1: msg = 'multiple id tags #% s found in record % s' if ISIS_MFN_KEY in record: msg = msg + (' (mfn=% s)' % record [ISIS_MFN_KEY]) raise TypeError (msg % (id_tag, i)) else: # 好吧，有且仅有一个 id 字段 if isis_json_type == 1: id = occurrences [0] elif isis_json_type == 2: id = occurrences [0][0][1] elif isis_json_type == 3: id = occurrences [0]['_'] if id in ids: msg = 'duplicate id % s in tag #% s, record % s' if ISIS_MFN_KEY in record: msg = msg + (' (mfn=% s)' % record [ISIS_MFN_KEY]) raise TypeError (msg % (id, id_tag, i)) record ['_id'] = id ids.add (id) elif gen_uuid: record ['_id'] = unicode (uuid4 ()) elif mfn: record ['_id'] = record [ISIS_MFN_KEY] if prefix: # 迭代一个固定的标签序列 for tag in tuple (record): if str (tag).isdigit (): record [prefix+tag] = record [tag] del record [tag] # 这就是迭代元组的原因 # 获取标签，但不直接从记录字典中获取 if constant: constant_key, constant_value = constant.split (':') record [constant_key] = constant_value output.write (json.dumps (record).encode ('utf-8')) output.write ('\n') if not mongo: output.write (']\n') def main (): ➍ # 创建解析器 parser = argparse.ArgumentParser ( description='Convert an ISIS .mst or .iso file to a JSON array') # 添加参数 parser.add_argument ('file_name', metavar='INPUT.(mst|iso)', help='.mst or .iso file to read') parser.add_argument ('-o', '--out', type=argparse.FileType ('w'), default=sys.stdout, metavar='OUTPUT.json', help='the file where the JSON output should be written' ' (default: write to stdout)') parser.add_argument ('-c', '--couch', action='store_true', help='output array within a "docs" item in a JSON document' ' for bulk insert to CouchDB via POST to db/_bulk_docs') parser.add_argument ('-m', '--mongo', action='store_true', help='output individual records as separate JSON dictionaries, one' ' per line for bulk insert to MongoDB via mongoimport utility') parser.add_argument ('-t', '--type', type=int, metavar='ISIS_JSON_TYPE', default=1, help='ISIS-JSON type, sets field structure: 1=string, 2=alist,' ' 3=dict (default=1)') parser.add_argument ('-q', '--qty', type=int, default=DEFAULT_QTY, help='maximum quantity of records to read (default=ALL)') parser.add_argument ('-s', '--skip', type=int, default=0, help='records to skip from start of .mst (default=0)') parser.add_argument ('-i', '--id', type=int, metavar='TAG_NUMBER', default=0, help='generate an "_id" from the given unique TAG field number' ' for each record') parser.add_argument ('-u', '--uuid', action='store_true', help='generate an "_id" with a random UUID for each record') parser.add_argument ('-p', '--prefix', type=str, metavar='PREFIX', default='', help='concatenate prefix to every numeric field tag' ' (ex. 99 becomes "v99")') parser.add_argument ('-n', '--mfn', action='store_true', help='generate an "_id" from the MFN of each record' ' (available only for .mst input)') parser.add_argument ('-k', '--constant', type=str, metavar='TAG:VALUE', default='', help='Include a constant tag:value in every record (ex. -k type:AS)') ''' # TODO: 实现这个功能，导出大量记录供给 CouchDB parser.add_argument ('-r', '--repeat', type=int, default=1, help='repeat operation, saving multiple JSON files' ' (default=1, use -r 0 to repeat until end of input)') ''' # 解析命令行 args = parser.parse_args () if args.file_name.lower ().endswith ('.mst'): input_gen_func = iter_mst_records ➎ else: if args.mfn: print ('UNSUPORTED: -n/--mfn option only available for .mst input.') raise SystemExit input_gen_func = iter_iso_records ➏ input_gen = input_gen_func (args.file_name, args.type) ➐ if args.couch: args.out.write ('{ "docs" : ') write_json (input_gen, args.file_name, args.out, args.qty, ➑ args.skip, args.id, args.uuid, args.mongo, args.mfn, args.type, args.prefix, args.constant) if args.couch: args.out.write ('}\n') args.out.close () if __name__ == '__main__': main ()

❶ iter_iso_records 生成器函数读取 .iso 文件，产出记录。

❷ iter_mst_records 生成器函数读取 .mst 文件，产出记录。

❸ write_json 函数迭代 input_gen 生成器，输出 .json 文件。

❹ main 函数读取命令行参数，然后根据输入文件的扩展名选择……

❺ ……iter_mst_records 生成器函数……

❻ …… 或者 iter_iso_records 生成器函数。

❼ 使用选中的生成器函数构建生成器对象。

❽ 把生成器作为第一个参数传给 write_json 函数。

A.5　第 16 章：出租车队离散事件仿真

示例 A-6 是 16.9.2 节讨论的 taxi_sim.py 脚本的完整代码。

示例 A-6　taxi_sim.py：出租车队仿真程序

"""出租车仿真程序 ============== 在控制台中驱动出租车:: >>> from taxi_sim import taxi_process >>> taxi = taxi_process (ident=13, trips=2, start_time=0) >>> next (taxi) Event (time=0, proc=13, action='leave garage') >>> taxi.send (_.time + 7) Event (time=7, proc=13, action='pick up passenger') >>> taxi.send (_.time + 23) Event (time=30, proc=13, action='drop off passenger') >>> taxi.send (_.time + 5) Event (time=35, proc=13, action='pick up passenger') >>> taxi.send (_.time + 48) Event (time=83, proc=13, action='drop off passenger') >>> taxi.send (_.time + 1) Event (time=84, proc=13, action='going home') >>> taxi.send (_.time + 10) Traceback (most recent call last): File"<stdin>", line 1, in <module> StopIteration

运行示例：有两辆出租车，随机种子是 10。这是有效的 doctest::

>>> main(num_taxis=2, seed=10) taxi: 0 Event(time=0, proc=0, action='leave garage') taxi: 0 Event(time=5, proc=0, action='pick up passenger') taxi: 1 Event(time=5, proc=1, action='leave garage') taxi: 1 Event(time=10, proc=1, action='pick up passenger') taxi: 1 Event(time=15, proc=1, action='drop off passenger') taxi: 0 Event(time=17, proc=0, action='drop off passenger') taxi: 1 Event(time=24, proc=1, action='pick up passenger') taxi: 0 Event(time=26, proc=0, action='pick up passenger') taxi: 0 Event(time=30, proc=0, action='drop off passenger') taxi: 0 Event(time=34, proc=0, action='going home') taxi: 1 Event(time=46, proc=1, action='drop off passenger') taxi: 1 Event(time=48, proc=1, action='pick up passenger') taxi: 1 Event(time=110, proc=1, action='drop off passenger') taxi: 1 Event(time=139, proc=1, action='pick up passenger') taxi: 1 Event(time=140, proc=1, action='drop off passenger') taxi: 1 Event(time=150, proc=1, action='going home') *** end of events ***

模块末尾有个更长的运行示例。

"""import random import collections import queue import argparse import time DEFAULT_NUMBER_OF_TAXIS = 3 DEFAULT_END_TIME = 180 SEARCH_DURATION = 5 TRIP_DURATION = 20 DEPARTURE_INTERVAL = 5 Event = collections.namedtuple ('Event', 'time proc action') # BEGIN TAXI_PROCESS def taxi_process (ident, trips, start_time=0):""" 每次状态变化时向仿真程序产出一个事件 """time = yield Event (start_time, ident, 'leave garage') for i in range (trips): time = yield Event (time, ident, 'pick up passenger') time = yield Event (time, ident, 'drop off passenger') yield Event (time, ident, 'going home') # 结束出租车进程 # END TAXI_PROCESS # BEGIN TAXI_SIMULATOR class Simulator: def __init__(self, procs_map): self.events = queue.PriorityQueue () self.procs = dict (procs_map) def run (self, end_time):""" 调度并显示事件，直到时间结束 """# 调度各辆出租车的第一个事件 for _, proc in sorted (self.procs.items ()): first_event = next (proc) self.events.put (first_event) # 此次仿真的主循环 sim_time = 0 while sim_time <end_time: if self.events.empty (): print ('*** end of events ***') break current_event = self.events.get () sim_time, proc_id, previous_action = current_event print ('taxi:', proc_id, proc_id * ' ', current_event) active_proc = self.procs [proc_id] next_time = sim_time + compute_duration (previous_action) try: next_event = active_proc.send (next_time) except StopIteration: del self.procs [proc_id] else: self.events.put (next_event) else: msg = '*** end of simulation time: {} events pending ***' print (msg.format (self.events.qsize ())) # END TAXI_SIMULATOR def compute_duration (previous_action):""" 使用指数分布计算操作的耗时 """if previous_action in ['leave garage', 'drop off passenger']: # 新状态是四处徘徊 interval = SEARCH_DURATION elif previous_action == 'pick up passenger': # 新状态是行程开始 interval = TRIP_DURATION elif previous_action == 'going home': interval = 1 else: raise ValueError ('Unknown previous_action: % s' % previous_action) return int (random.expovariate (1/interval)) + 1 def main (end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS, seed=None):""" 初始化随机生成器，构建过程，运行仿真程序 """if seed is not None: random.seed (seed) # 获得可复现的结果 taxis = {i: taxi_process (i, (i+1)*2, i*DEPARTURE_INTERVAL) for i in range (num_taxis)} sim = Simulator (taxis) sim.run (end_time) if __name__ == '__main__': parser = argparse.ArgumentParser (description='Taxi fleet simulator.') parser.add_argument ('-e', '--end-time', type=int, default=DEFAULT_END_TIME, help='simulation end time; default = % s' % DEFAULT_END_TIME) parser.add_argument ('-t', '--taxis', type=int, default=DEFAULT_NUMBER_OF_TAXIS, help='number of taxis running; default = % s' % DEFAULT_NUMBER_OF_TAXIS) parser.add_argument ('-s', '--seed', type=int, default=None, help='random generator seed (for testing)') args = parser.parse_args () main (args.end_time, args.taxis, args.seed)""" 命令行中的运行示例：seed=3，最长用时 = 120:: # BEGIN TAXI_SAMPLE_RUN $ python3 taxi_sim.py -s 3 -e 120 taxi: 0 Event (time=0, proc=0, action='leave garage') taxi: 0 Event (time=2, proc=0, action='pick up passenger') taxi: 1 Event (time=5, proc=1, action='leave garage') taxi: 1 Event (time=8, proc=1, action='pick up passenger') taxi: 2 Event (time=10, proc=2, action='leave garage') taxi: 2 Event (time=15, proc=2, action='pick up passenger') taxi: 2 Event (time=17, proc=2, action='drop off passenger') taxi: 0 Event (time=18, proc=0, action='drop off passenger') taxi: 2 Event (time=18, proc=2, action='pick up passenger') taxi: 2 Event (time=25, proc=2, action='drop off passenger') taxi: 1 Event (time=27, proc=1, action='drop off passenger') taxi: 2 Event (time=27, proc=2, action='pick up passenger') taxi: 0 Event (time=28, proc=0, action='pick up passenger') taxi: 2 Event (time=40, proc=2, action='drop off passenger') taxi: 2 Event (time=44, proc=2, action='pick up passenger') taxi: 1 Event (time=55, proc=1, action='pick up passenger') taxi: 1 Event (time=59, proc=1, action='drop off passenger') taxi: 0 Event (time=65, proc=0, action='drop off passenger') taxi: 1 Event (time=65, proc=1, action='pick up passenger') taxi: 2 Event (time=65, proc=2, action='drop off passenger') taxi: 2 Event (time=72, proc=2, action='pick up passenger') taxi: 0 Event (time=76, proc=0, action='going home') taxi: 1 Event (time=80, proc=1, action='drop off passenger') taxi: 1 Event (time=88, proc=1, action='pick up passenger') taxi: 2 Event (time=95, proc=2, action='drop off passenger') taxi: 2 Event (time=97, proc=2, action='pick up passenger') taxi: 2 Event (time=98, proc=2, action='drop off passenger') taxi: 1 Event (time=106, proc=1, action='drop off passenger') taxi: 2 Event (time=109, proc=2, action='going home') taxi: 1 Event (time=110, proc=1, action='going home') *** end of events *** # END TAXI_SAMPLE_RUN """

A.6　第 17 章：加密示例

这几个脚本用于展示如何使用 futures.ProcessPoolExecutor 执行 CPU 密集型任务。

示例 A-7 使用 RC4 算法加密并解密随机的字节数组，需要 arcfour.py 模块（见示例 A-8）支持才能运行。

示例 A-7　arcfour_futures.py：futures.ProcessPoolExecutor 用法示例

import sys import time from concurrent import futures from random import randrange from arcfour import arcfour JOBS = 12 SIZE = 2**18 KEY = b"'Twas brillig, and the slithy toves\nDid gyre" STATUS = '{} workers, elapsed time: {:.2f}s' def arcfour_test(size, key): in_text = bytearray(randrange(256) for i in range(size)) cypher_text = arcfour(key, in_text) out_text = arcfour(key, cypher_text) assert in_text == out_text, 'Failed arcfour_test' return size def main(workers=None): if workers: workers = int(workers) t0 = time.time() with futures.ProcessPoolExecutor(workers) as executor: actual_workers = executor._max_workers to_do = [] for i in range(JOBS, 0, -1): size = SIZE + int(SIZE / JOBS * (i - JOBS/2)) job = executor.submit(arcfour_test, size, KEY) to_do.append(job) for future in futures.as_completed(to_do): res = future.result() print('{:.1f} KB'.format(res/2**10)) print(STATUS.format(actual_workers, time.time() - t0)) if __name__ == '__main__': if len(sys.argv) == 2: workers = int(sys.argv[1]) else: workers = None main(workers)

示例 A-8 纯粹使用 Python 实现 RC4 加密算法。

示例 A-8　arcfour.py：兼容 RC4 的算法

"""兼容 RC4 的算法""" def arcfour (key, in_bytes, loops=20): kbox = bytearray (256) # 创建存储键的数组 for i, car in enumerate (key): # 复制键和向量 kbox [i] = car j = len (key) for i in range (j, 256): # 重复到底 kbox [i] = kbox [i-j] # [1] 初始化 sbox sbox = bytearray (range (256)) # 按照 CipherSaber-2 的建议，不断打乱 sbox # http://ciphersaber.gurus.com/faq.html#cs2 j = 0 for k in range (loops): for i in range (256): j = (j + sbox [i] + kbox [i]) % 256 sbox [i], sbox [j] = sbox [j], sbox [i] # 主循环 i = 0 j = 0 out_bytes = bytearray () for car in in_bytes: i = (i + 1) % 256 # [2] 打乱 sbox j = (j + sbox [i]) % 256 sbox [i], sbox [j] = sbox [j], sbox [i] # [3] 计算 t t = (sbox [i] + sbox [j]) % 256 k = sbox [t] car = car ^ k out_bytes.append (car) return out_bytes def test (): from time import time clear = bytearray (b'1234567890' * 100000) t0 = time () cipher = arcfour (b'key', clear) print ('elapsed time: %.2fs' % (time () - t0)) result = arcfour (b'key', cipher) assert result == clear, '% r != % r' % (result, clear) print ('elapsed time: %.2fs' % (time () - t0)) print ('OK') if __name__ == '__main__': test ()

示例 A-9 使用 SHA-256 散列算法打乱字节数组。这个脚本使用标准库中的 hashlib 模块，而这个模块使用 C 语言编写的 OpenSSL 库。

示例 A-9　sha_futures.py：futures.ProcessPoolExecutor 用法示例

import sys import time import hashlib from concurrent import futures from random import randrange JOBS = 12 SIZE = 2**20 STATUS = '{} workers, elapsed time: {:.2f}s' def sha(size): data = bytearray(randrange(256) for i in range(size)) algo = hashlib.new('sha256') algo.update(data) return algo.hexdigest() def main(workers=None): if workers: workers = int(workers) t0 = time.time() with futures.ProcessPoolExecutor(workers) as executor: actual_workers = executor._max_workers to_do = (executor.submit(sha, SIZE) for i in range(JOBS)) for future in futures.as_completed(to_do): res = future.result() print(res) print(STATUS.format(actual_workers, time.time() - t0)) if __name__ == '__main__': if len(sys.argv) == 2: workers = int(sys.argv[1]) else: workers = None main(workers)

A.7　第 17 章：flags2 系列 HTTP 客户端示例

17.5 节的 flags2 系列示例都使用了 flags2_common.py 模块（见示例 A-10）里的函数。

示例 A-10　flags2_common.py

"""为后续 flag 示例提供实用函数。""" import os import time import sys import string import argparse from collections import namedtuple from enum import Enum Result = namedtuple ('Result', 'status data') HTTPStatus = Enum ('Status', 'ok not_found error') POP20_CC = ('CN IN US ID BR PK NG BD RU JP ' 'MX PH VN ET EG DE IR TR CD FR').split () DEFAULT_CONCUR_REQ = 1 MAX_CONCUR_REQ = 1 SERVERS = { 'REMOTE': 'http://flupy.org/data/flags', 'LOCAL': 'http://localhost:8001/flags', 'DELAY': 'http://localhost:8002/flags', 'ERROR': 'http://localhost:8003/flags',} DEFAULT_SERVER = 'LOCAL' DEST_DIR = 'downloads/' COUNTRY_CODES_FILE = 'country_codes.txt' def save_flag (img, filename): path = os.path.join (DEST_DIR, filename) with open (path, 'wb') as fp: fp.write (img) def initial_report (cc_list, actual_req, server_label): if len (cc_list) <= 10: cc_msg = ', '.join (cc_list) else: cc_msg = 'from {} to {}'.format (cc_list [0], cc_list [-1]) print ('{} site: {}'.format (server_label, SERVERS [server_label])) msg = 'Searching for {} flag {}: {}' plural = 's' if len (cc_list) != 1 else '' print (msg.format (len (cc_list), plural, cc_msg)) plural = 's' if actual_req != 1 else '' msg = '{} concurrent connection {} will be used.' print (msg.format (actual_req, plural)) def final_report (cc_list, counter, start_time): elapsed = time.time () - start_time print ('-' * 20) msg = '{} flag {} downloaded.' plural = 's' if counter [HTTPStatus.ok] != 1 else '' print (msg.format (counter [HTTPStatus.ok], plural)) if counter [HTTPStatus.not_found]: print (counter [HTTPStatus.not_found], 'not found.') if counter [HTTPStatus.error]: plural = 's' if counter [HTTPStatus.error] != 1 else '' print ('{} error {}.'.format (counter [HTTPStatus.error], plural)) print ('Elapsed time: {:.2f} s'.format (elapsed)) def expand_cc_args (every_cc, all_cc, cc_args, limit): codes = set () A_Z = string.ascii_uppercase if every_cc: codes.update (a+b for a in A_Z for b in A_Z) elif all_cc: with open (COUNTRY_CODES_FILE) as fp: text = fp.read () codes.update (text.split ()) else: for cc in (c.upper () for c in cc_args): if len (cc) == 1 and cc in A_Z: codes.update (cc+c for c in A_Z) elif len (cc) == 2 and all (c in A_Z for c in cc): codes.add (cc) else: msg = 'each CC argument must be A to Z or AA to ZZ.' raise ValueError ('*** Usage error: '+msg) return sorted (codes)[:limit] def process_args (default_concur_req): server_options = ', '.join (sorted (SERVERS)) parser = argparse.ArgumentParser (description='Download flags for country codes. ' 'Default: top 20 countries by population.') parser.add_argument ('cc', metavar='CC', nargs='*', help='country code or 1st letter (eg. B for BA...BZ)') parser.add_argument ('-a', '--all', action='store_true', help='get all available flags (AD to ZW)') parser.add_argument ('-e', '--every', action='store_true', help='get flags for every possible code (AA...ZZ)') parser.add_argument ('-l', '--limit', metavar='N', type=int, help='limit to N first codes', default=sys.maxsize) parser.add_argument ('-m', '--max_req', metavar='CONCURRENT', type=int, default=default_concur_req, help='maximum concurrent requests (default={})' .format (default_concur_req)) parser.add_argument ('-s', '--server', metavar='LABEL', default=DEFAULT_SERVER, help='Server to hit; one of {} (default={})' .format (server_options, DEFAULT_SERVER)) parser.add_argument ('-v', '--verbose', action='store_true', help='output detailed progress info') args = parser.parse_args () if args.max_req < 1: print ('*** Usage error: --max_req CONCURRENT must be>= 1') parser.print_usage () sys.exit (1) if args.limit <1: print ('*** Usage error: --limit N must be>= 1') parser.print_usage () sys.exit (1) args.server = args.server.upper () if args.server not in SERVERS: print ('*** Usage error: --server LABEL must be one of', server_options) parser.print_usage () sys.exit (1) try: cc_list = expand_cc_args (args.every, args.all, args.cc, args.limit) except ValueError as exc: print (exc.args [0]) parser.print_usage () sys.exit (1) if not cc_list: cc_list = sorted (POP20_CC) return args, cc_list def main (download_many, default_concur_req, max_concur_req): args, cc_list = process_args (default_concur_req) actual_req = min (args.max_req, max_concur_req, len (cc_list)) initial_report (cc_list, actual_req, args.server) base_url = SERVERS [args.server] t0 = time.time () counter = download_many (cc_list, base_url, args.verbose, actual_req) assert sum (counter.values ()) == len (cc_list), \ 'some downloads are unaccounted for' final_report (cc_list, counter, t0)

flags2_sequential.py 脚本（见示例 A-11）是对比两种并发实现的基准。flags2_threadpool.py 脚本（见示例 17-14）还使用了 flags2_sequential.py 脚本中的 get_flag 和 download_one 两个函数。

示例 A-11　flags2_sequential.py

"""下载多个国家的国旗（包含错误处理代码）。依序下载版 运行示例:: $ python3 flags2_sequential.py -s DELAY b DELAY site: http://localhost:8002/flags Searching for 26 flags: from BA to BZ 1 concurrent connection will be used. -------------------- 17 flags downloaded. 9 not found. Elapsed time: 13.36s""" import collections import requests import tqdm from flags2_common import main, save_flag, HTTPStatus, Result DEFAULT_CONCUR_REQ = 1 MAX_CONCUR_REQ = 1 # BEGIN FLAGS2_BASIC_HTTP_FUNCTIONS def get_flag (base_url, cc): url = '{}/{cc}/{cc}.gif'.format (base_url, cc=cc.lower ()) resp = requests.get (url) if resp.status_code != 200: resp.raise_for_status () return resp.content def download_one (cc, base_url, verbose=False): try: image = get_flag (base_url, cc) except requests.exceptions.HTTPError as exc: res = exc.response if res.status_code == 404: status = HTTPStatus.not_found msg = 'not found' else: raise else: save_flag (image, cc.lower () + '.gif') status = HTTPStatus.ok msg = 'OK' if verbose: print (cc, msg) return Result (status, cc) # END FLAGS2_BASIC_HTTP_FUNCTIONS # BEGIN FLAGS2_DOWNLOAD_MANY_SEQUENTIAL def download_many (cc_list, base_url, verbose, max_req): counter = collections.Counter () cc_iter = sorted (cc_list) if not verbose: cc_iter = tqdm.tqdm (cc_iter) for cc in cc_iter: try: res = download_one (cc, base_url, verbose) except requests.exceptions.HTTPError as exc: error_msg = 'HTTP error {res.status_code} - {res.reason}' error_msg = error_msg.format (res=exc.response) except requests.exceptions.ConnectionError as exc: error_msg = 'Connection error' else: error_msg = '' status = res.status if error_msg: status = HTTPStatus.error counter [status] += 1 if verbose and error_msg: print ('*** Error for {}: {}'.format (cc, error_msg)) return counter # END FLAGS2_DOWNLOAD_MANY_SEQUENTIAL if __name__ == '__main__': main (download_many, DEFAULT_CONCUR_REQ, MAX_CONCUR_REQ)

A.8　第 19 章：处理 OSCON 日程表的脚本和测试

示例 A-12 是 schedule1.py 模块（示例 19-9）的测试脚本，使用 py.test 库和测试运行程序实现。

示例 A-12　test_schedule1.py

import shelve import pytest import schedule1 as schedule @pytest.yield_fixture def db(): with shelve.open(schedule.DB_NAME) as the_db: if schedule.CONFERENCE not in the_db: schedule.load_db(the_db) yield the_db def test_record_class(): rec = schedule.Record(spam=99, eggs=12) assert rec.spam == 99 assert rec.eggs == 12 def test_conference_record(db): assert schedule.CONFERENCE in db def test_speaker_record(db): speaker = db['speaker.3471'] assert speaker.name == 'Anna Martelli Ravenscroft' def test_event_record(db): event = db['event.33950'] assert event.name == 'There *Will* Be Bugs' def test_event_venue(db): event = db['event.33950'] assert event.venue_serial == 1449

19.1.5 节分四部分列出了 schedule2.py 脚本里的代码，示例 A-13 是完整的代码清单。

示例 A-13　schedule2.py

"""schedule2.py: 遍历 OSCON 的日程数据 >>> import shelve >>> db = shelve.open (DB_NAME) >>> if CONFERENCE not in db: load_db (db) # BEGIN SCHEDULE2_DEMO >>> DbRecord.set_db (db) >>> event = DbRecord.fetch ('event.33950') >>> event <Event 'There *Will* Be Bugs'> >>> event.venue <DbRecord serial='venue.1449'> >>> event.venue.name 'Portland 251' >>> for spkr in event.speakers: ... print ('{0.serial}: {0.name}'.format (spkr)) ... speaker.3471: Anna Martelli Ravenscroft speaker.5199: Alex Martelli # END SCHEDULE2_DEMO >>> db.close ()""" # BEGIN SCHEDULE2_RECORD import warnings import inspect import osconfeed DB_NAME = 'data/schedule2_db' CONFERENCE = 'conference.115' class Record: def __init__(self, **kwargs): self.__dict__.update (kwargs) def __eq__(self, other): if isinstance (other, Record): return self.__dict__ == other.__dict__ else: return NotImplemented # END SCHEDULE2_RECORD # BEGIN SCHEDULE2_DBRECORD class MissingDatabaseError (RuntimeError): """Raised when a database is required but was not set.""" class DbRecord (Record): __db = None @staticmethod def set_db (db): DbRecord.__db = db @staticmethod def get_db (): return DbRecord.__db @classmethod def fetch (cls, ident): db = cls.get_db () try: return db [ident] except TypeError: if db is None: msg = "database not set; call '{}.set_db (my_db)'" raise MissingDatabaseError (msg.format (cls.__name__)) else: raise def __repr__(self): if hasattr (self, 'serial'): cls_name = self.__class__.__name__ return '<{} serial={!r}>'.format (cls_name, self.serial) else: return super ().__repr__() # END SCHEDULE2_DBRECORD # BEGIN SCHEDULE2_EVENT class Event (DbRecord): @property def venue (self): key = 'venue.{}'.format (self.venue_serial) return self.__class__.fetch (key) @property def speakers (self): if not hasattr (self, '_speaker_objs'): spkr_serials = self.__dict__['speakers'] fetch = self.__class__.fetch self._speaker_objs = [fetch ('speaker.{}'.format (key)) for key in spkr_serials] return self._speaker_objs def __repr__(self): if hasattr (self, 'name'): cls_name = self.__class__.__name__ return '<{} {!r}>'.format (cls_name, self.name) else: return super ().__repr__() # END SCHEDULE2_EVENT # BEGIN SCHEDULE2_LOAD def load_db (db): raw_data = osconfeed.load () warnings.warn ('loading ' + DB_NAME) for collection, rec_list in raw_data ['Schedule'].items (): record_type = collection [:-1] cls_name = record_type.capitalize () cls = globals ().get (cls_name, DbRecord) if inspect.isclass (cls) and issubclass (cls, DbRecord): factory = cls else: factory = DbRecord for record in rec_list: key = '{}.{}'.format (record_type, record ['serial']) record ['serial'] = key db [key] = factory (**record) # END SCHEDULE2_LOAD

示例 A-14 使用 py.test 测试示例 A-13。

示例 A-14　test_schedule2.py

import shelve import pytest import schedule2 as schedule @pytest.yield_fixture def db(): with shelve.open(schedule.DB_NAME) as the_db: if schedule.CONFERENCE not in the_db: schedule.load_db(the_db) yield the_db def test_record_attr_access(): rec = schedule.Record(spam=99, eggs=12) assert rec.spam == 99 assert rec.eggs == 12 def test_record_repr(): rec = schedule.DbRecord(spam=99, eggs=12) assert 'DbRecord object at 0x' in repr(rec) rec2 = schedule.DbRecord(serial=13) assert repr(rec2) == "<DbRecord serial=13>" def test_conference_record(db): assert schedule.CONFERENCE in db def test_speaker_record(db): speaker = db['speaker.3471'] assert speaker.name == 'Anna Martelli Ravenscroft' def test_missing_db_exception(): with pytest.raises(schedule.MissingDatabaseError): schedule.DbRecord.fetch('venue.1585') def test_dbrecord(db): schedule.DbRecord.set_db(db) venue = schedule.DbRecord.fetch('venue.1585') assert venue.name == 'Exhibit Hall B' def test_event_record(db): event = db['event.33950'] assert repr(event) == "<Event 'There *Will* Be Bugs'>" def test_event_venue(db): schedule.Event.set_db(db) event = db['event.33950'] assert event.venue_serial == 1449 assert event.venue == db['venue.1449'] assert event.venue.name == 'Portland 251' def test_event_speakers(db): schedule.Event.set_db(db) event = db['event.33950'] assert len(event.speakers) == 2 anna_and_alex = [db['speaker.3471'], db['speaker.5199']] assert event.speakers == anna_and_alex def test_event_no_speakers(db): schedule.Event.set_db(db) event = db['event.36848'] assert len(event.speakers) == 0

Python 术语表

当然，这里列出的很多术语不是 Python 专用的，不过某些术语的定义对 Python 社区有特殊的意义。

此外，也可以参阅官方的 Python 词汇表。

ABC（编程语言）

Leo Geurts、Lambert Meertens 和 Steven Pemberton 创造的一门编程语言。20 世纪 80 年代，Python 之父 Guido van Rossum 是实现 ABC 环境的程序员。Python 的一些特色出自 ABC，例如使用缩进划分块、内置元组和字典、元组拆包、for 循环的语义，以及对所有序列类型的统一处理方式。

BDFL

Benevolent Dictator For Life 的简称，意为「仁慈的独裁者」，指代 Python 之父 Guido van Rossum。

BOM

Byte Order Mark 的简称，意为「字节序标记」，指可能出现在 UTF-16 编码文件开头的字节序列。BOM 是 U+FEFF 字符（零宽不换行空格），在大字节序的 CPU 中，编码成 b'\xfe\xff'；在小字节序的 CPU 中，编码成 b'\xff\xfe'。因为 Unicode 中没有 U+FFFE 字符，所以这些字节的作用只有一个 —— 表示编码方式使用的字节序。虽然多余，但是在 UTF-8 文件中可能会找到编码成 b'\xef\xbb\xbf' 的 BOM。

CPython

标准的 Python 解释器，使用 C 语言实现。讨论不同实现特有的行为，以及多个可用的 Python 解释器（如 PyPy）时才会使用这个术语。

CRUD

Create、Read、Update、Delete 的首字母缩写，这是存储记录的应用程序中的四种基本操作。

doctest

一个模块，其中的函数能解析并运行 Python 模块或纯文本文件的文档字符串中内嵌的示例。也可以在命令行中使用，如下所示：

python -m doctest module_with_tests.py

DRY

Don't Repeat Yourself（不要自我重复）的缩写，一种软件工程原则，意思是：「系统中的每一项知识都必须具有单一、无歧义、权威的表示。」首先由 Andy Hunt 与 Dave Thomas 的《程序员修炼之道：从小工到专家》一书提出。

dunder

首尾有两条下划线的特殊方法和属性的简洁读法（即把 __len__ 读成「dunder len」）。

dunder 方法

参见 dunder 和特殊方法词条。

EAFP

「it's easier to ask forgiveness than permission」（取得原谅比获得许可容易）的首字母缩写。人们认为这句话是计算机先驱 Grace Hopper 说的，Python 程序员使用这个缩写指代一种动态编程方式，例如访问属性前不测试有没有属性，如果没有就捕获异常。hasattr 函数的文档字符串是这样描述它的工作方式的：「调用 getattr (object, name)，然后捕获 AttributeError 异常。」

genexp

generator expression（生成器表达式）的简称。

GoF 书

指代《设计模式：可复用面向对象软件的基础》一书，作者是四个人，被称为「四人组」（Gang of Four，GoF），包括 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides。

KISS 原则

KISS 是「Keep It Simple, Stupid」的首字母缩写。这个原则要求尽量寻找最简单的方案，尽量减少可变部分。这个警句是 Kelly Johnson 首创的。Kelly 是一位多才多艺的航空工程师，在真实存在的 51 区工作，设计出了 20 世纪最先进的几架航天飞机。

listcomp

list comprehension（列表推导）的简称。

ORM

Object-Relational Mapper（对象关系映射器）的缩写，通过这种 API 可以使用 Python 类和对象访问数据库中的表和记录，而且调用方法可以执行数据库操作。SQLAlchemy 是流行的独立 Python ORM，Django 和 Web2py 自带了 ORM。

PyPI

Python 包索引，里面有超过 60 000 个包可用。也叫奶酪店（参见奶酪店词条）。为了防止与 PyPy 混淆，PyPI 应该读作「pie-P-eye」。

PyPy

Python 编程语言的另一种实现，使用一个工具链把部分 Python 编译成机器码，因此解释器的源码其实是使用 Python 编写的。PyPy 还提供了 JIT，即时把用户的程序编译成机器码 —— 与 Java VM 的作用相同。根据 PyPy 公布的基准测试，从 2014 年 11 月起，PyPy 平均比 CPython 快 6.8 倍。为了防止与 PyPI 混淆，PyPy 应该读作「pie-pie」。

Pythonic

用于赞扬符合 Python 风格的代码，即充分利用 Python 语言的特性，写出简洁明了、可读性强，通常运行速度也快的代码。还指 API 符合 Python 高手的编程方式。参见惯用句法词条。

Python 之禅

从 Python 2.2 起，在 Python 控制台中输入 import this 后看到的输出。

REPL

read-eval-print loop（读取－求值－输出循环）的简称，一种交互式控制台，如标准的 python 或非主流的 ipython 和 bpython，以及 Python Anywhere。

YAGNI

You Ain't Gonna Need It（你不需要这个）的首字母缩写，这个口号的意思是，根据对未来需求的预测，不要实现非立即需要的功能。

绑定方法（bound method）

通过实例访问的方法会绑定到那个实例上。方法其实是描述符，访问方法时，会返回一个包装自身的对象，把方法绑定到实例上。那个对象就是绑定方法。调用绑定方法时，可以不传入 self 的值。例如，像 my_method = my_obj.method 这样赋值之后，可以通过 my_method () 调用绑定方法。请与非绑定方法相比较。

编码解码器（codec）

（编码器 / 解码器）提供编码和解码函数的模块，通常在 str 和 bytes 之间转换，不过 Python 也提供了在 bytes 和 bytes，以及 str 和 str 之间转换的编码解码器。

变值方法（mutator）

参见存取方法词条。

别名（aliasing）

为同一个对象指定两个或多个名称。例如，在 a = []; b = a 中，a 和 b 是别名，指向同一个列表对象。对于把对象引用存储在变量中的语言来说，别名无处不在。为了避免混淆，要摒弃这种想法：变量是存储对象的盒子（毕竟同一个对象不可能放在两个盒子里）。我们要把变量看做对象的标注（一个对象可以有多个标注）。

并行赋值（parallel assignment）

使用类似 a, b = [c, d] 这样的句法，把可迭代对象中的元素赋值给多个变量，也叫解构赋值。这是元组拆包的常见用途。

抽象基类（abstract base class，ABC）

无法实例化，只能扩展的类。Python 通过 ABC 实现接口。除了继承 ABC 之外，类还可以注册成为 ABC 的虚拟子类，声明自己实现了接口。

初始化方法（initializer）

__init__ 方法更贴切的名称（取代构造方法）。__init__ 方法的任务是初始化通过 self 参数传入的实例。实例其实是由 __new__ 方法构建的。参见构造方法词条。

储存属性（storage attribute）

托管实例中的属性，用于存储由描述符管理的属性的值。另见托管属性词条。

存取方法（accessor）

用于存取单个数据属性的方法。有些作者把存取方法当作通用术语使用，包括读值方法和设值方法；另一些作者则用存取方法指代读值方法，而用变值方法指代设值方法。

代码异味（code smell）

一种代码形式，表明程序的设计可能有问题。例如，过度使用 isinstance 检查具体的类是一种代码异味，因为这样会导致程序以后难以扩展，无法处理新类型。

单例（singleton）

一个类唯一存在的实例 —— 这通常不是巧合，而是故意为之，防止类创建多个实例。有一种设计模式就叫单例模式，指明如何编写这样的类。在 Python 中，None 对象是单例。

导入时（import time）

Python 解释器加载模块，从上到下计算，把里面的代码编译成字节码之后，开始执行模块的那一刻。类和函数在此时定义，变成真实存在的对象。装饰器也在此时执行。

迭代器（iterator）

实现了无参数方法 __next__ 的对象；这个方法返回级数里的下一个元素，如果没有元素了就抛出 StopIteration 异常。在 Python 中，迭代器还实现了 __iter__ 方法，因此迭代器也是可迭代的对象。根据最初的设计模式，经典迭代器返回集合里的元素。生成器也是迭代器，不过更灵活。参见生成器词条。

惰性求值（lazy）

指可迭代的对象按需生成元素。在 Python 中，生成器会惰性求值。请与及早求值相比较。

二进制序列（binary sequence）

一个通用术语，表示元素是二进制数据的序列类型。内置的二进制序列类型有 byte、bytearray 和 memoryview。

泛函数（generic function）

以不同的方式为不同类型的对象实现相同操作的一组函数。从 Python 3.4 起，创建泛函数的标准方式是使用 functools.singledispatch 装饰器。在其他语言中，这叫多分派方法。

非绑定方法（unbound method）

直接通过类访问的实例方法没有绑定到特定的实例上，因此把这种方法称为「非绑定方法」。若想成功调用非绑定方法，必须显式传入类的实例作为第一个参数。那个实例会赋值给方法的 self 参数。参见绑定方法词条。

非覆盖型描述符（nonoverriding descriptor）

未实现 __set__ 方法的描述符，不干涉托管实例中托管属性的设置。因此，托管实例中的同名属性会遮盖实例中的描述符。也叫非数据描述符或遮盖型描述符。请与覆盖型描述符相比较。

覆盖型描述符（overriding descriptor）

实现了 __set__ 方法的描述符，设置托管实例中的托管属性时会遭到拦截并覆盖相关操作。也叫数据描述符或强制描述符。请与非覆盖型描述符相比较。

高阶函数（higher-order function）

以其他函数为参数的函数，例如 sorted、map 和 filter；或者，返回值为函数的函数，例如 Python 中的装饰器。

构造方法（constructor）

类的 __init__ 实例方法称为类的构造方法，因为这个方法的语义类似于 Java 中的构造方法。然而，这样称呼并不规范，__init__ 更应该称为初始化方法，因为它并不会构建实例，而是把实例传给 self 参数。Python 在 __init__ 方法之前调用的 __new__ 类方法更合乎构造方法这个术语，__new__ 方法才会创建实例并将其返回。参见初始化方法词条。

惯用句法（idiom）

根据普林斯顿大学 WordNet 字典的定义，惯用句法指「说母语的人说话的方式」。

函数（function）

严格来说，是指 def 块或 lambda 表达式计算得到的对象。通常，函数这个词用于表示任何可调用的对象，例如方法，有时甚至表示类。官方文档中的内置函数列表列出了几个内置的类，例如 dict、range 和 str。另见可调用的对象词条。

猴子补丁（monkey patching）

在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在内存中发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。

混入方法（mixin method）

抽象基类或混入类中方法的具体实现。

混入类（mixin class）

用于随着多重继承类树中的一个或多个类一起扩展的类。混入类绝不能实例化，它的具体子类也应该是其他非混入类的子类。

活性（liveness）

异步系统、线程系统或分布式系统在「期待的事情终于发生」（即虽然期待的计算不会立即发生，但最终会完成）时展现出来的特性叫活性。如果系统死锁了，活性也就没有了。

及早求值（eager）

指可迭代对象一次构建好全部元素。在 Python 中，列表推导会及早求值。请与惰性求值相比较。

集合（collection）

泛指由元素组成，可以单独访问各个元素的数据结构。有些集合可以包含任意类型的对象（参见容器词条），有些则只能包含一种原子类型的对象（参见平坦序列词条）。list 和 bytes 都是集合，只不过 list 是容器，而 bytes 是平坦序列。

假值（falsy）

只要 bool (x) 返回 False，x 就是假值。需要布尔值时，Python 会隐式使用 bool 计算对象，例如控制 if 和 while 循环的表达式。与此相对的是真值（truthy）。

尽早失败（fail-fast）

一种系统设计方式，建议应该尽早报告错误。Python 比其他大多数动态编程语言更遵守这一原则。例如，Python 中没有「未定义」的值：在初始化之前引用变量会报错；如果 k 不存在，my_dict [k] 会抛出异常（JavaScript 则不然）。还有一例：在 Python 中通过元组拆包做并行赋值，必须显式处理元组的每一个元素才行；而在 Ruby 中，如果 = 两边的元素数量不一致，右边未用到的元素会被忽略，或者把 nil 赋给左边多余的变量。

可迭代的（iterable）

使用内置的 iter 函数可以从中获得迭代器的对象。可迭代的对象为 for 循环、列表推导和元组拆包提供元素。如果对象的 __iter__ 方法能返回迭代器，这就是可迭代的对象。序列都是可迭代的对象；此外，实现 __getitem__ 方法的对象也是可迭代的对象。

可迭代对象的拆包（iterable unpacking）

元组拆包更现代、更精确的同义词。另见并行赋值词条。

可散列的（hashable）

在散列值永不改变，而且如果 a == b，那么 hash (a) == hash (b) 也是 True 的情况下，如果对象既有 __hash__ 方法，也有 __eq__ 方法，那么这样的对象称为可散列的对象。在内置的类型中，大多数不可变的类型都是可散列的；但是，仅当元组的每一个元素都是可散列的时，元组才是可散列的。

可调用的对象（callable object）

可以使用调用运算符 () 调用，能返回结果或执行某项操作的对象。在 Python 中，可调用的对象有七种：用户定义的函数、内置的函数、内置的方法、实例方法、生成器函数、类，还有实现特殊方法 __call__ 的类的实例。

类（class）

定义新类型的程序结构，里面有数据属性，以及用于操作数据属性的方法。参见类型词条。

类型（type）

程序中的各种数据，限定可取的值和可对数据做的操作。有些 Python 类型近似于机器数据类型（例如 float 和 bytes），而另一些则是机器数据类型的扩展（例如，int 不受 CPU 字长的限制，str 包含多字节 Unicode 数据码位）和特别高层的抽象（例如 dict、 deque，等等）。类型分为两类：用户定义的类型和解释器内置的类型。在 Python 2.2 统一类型和类之前，类型和类是不同的实体，用户定义的类不能扩展内置的类型。而在那之后，内置的类型和新式类兼容了，类是 type 的实例。在 Python 3 中，所有类都是新式类。参见类和元类词条。

列表推导（list comprehension）

放在方括号里的表达式，使用关键字 for 和 in，通过处理和过滤一个或多个可迭代对象里的元素构建列表。列表推导会及早求值。参见及早求值词条。

码位（code point）

介于 0~0x10FFFF 之间的整数，用于标识 Unicode 字符数据库中的字符。截至 Unicode 7.0，所有码位中只有不到 3% 指定了字符。在 Python 文档中，这个术语可能拼成一个词，也可能拼成两个词。例如，在 Python 标准库参考手册的「2. Built-in Functions」一章中，说 char 函数的参数是一个整数「码位」（codepoint），却说作用相反的 ord 函数返回一个「Unicode 码位」（Unicode code point）。

描述符（descriptor）

一个类，实现 __get__、__set__ 和 __delete__ 特殊方法中的一个或多个，其实例作为另一个类（托管类）的类属性。描述符管理托管类中托管属性的存取和删除，数据通常存储在托管实例中。

名称改写（name mangling）

Python 解释器在运行时自动把私有属性 __x 重命名为 _MyClass__x。

魔术方法（magic method）

同特殊方法。

奶酪店（Cheese Shop）

Python 包索引（Python Package Index，PyPI，https://pypi.python.org/pypi）原来的名称，以「巨蟒剧团」表演的幽默短剧《奶酪店》命名。虽然是奶酪店，但是店里却什么奶酪都没有。写作本书时，https://cheeseshop.python.org 这个别名链接还有效。参见 PyPI 词条。

内置函数（built-in function，BIF）

随 Python 解释器一起提供的函数，使用底层实现语言（也就是说，CPython 用 C 语言，Jython 用 Java，以此类推）编写。这个术语通常指代无需导入就能使用的函数，参见 Python 标准库参考手册中的「2. Built-in Functions」一章。不过，内置的模块（如 sys、math、re 等）也包含内置函数。

平坦序列（flat sequence）

这种序列类型存储的是元素的值本身，而不是其他对象的引用。内置的类型中，str、bytes、bytearray、memoryview 和 array.array 是平坦序列；而 list、tuple 和 collections.deque 是容器序列。参见容器词条。

浅复制（shallow copy）

一种对象副本，引用源对象的全部属性对象。请与深复制相比较。另见别名词条。

强引用（strong reference）

让对象始终存在于 Python 中的引用。请与弱引用相比较。

切片（slicing）

使用切片表示法生成序列的子集，例如 my_sequence [2:6]。切片经常复制数据，生成新对象；然而，my_sequence [:] 是对整个序列的浅复制。不过，memoryview 对象的切片虽是一个 memoryview 新对象，但会与源对象共享数据。

容器（container）

包含其他对象引用的对象。Python 中的大多数集合类型都是容器，不过有些不是。请与平坦序列相比较，这种序列是集合，但不是容器。

弱引用（weak reference）

一种特殊的对象引用方式，不计入指示对象的引用计数。弱引用使用 weakref 模块里的某个函数和数据结构创建。

上下文管理器（context manager）

实现了 __enter__ 和 __exit__ 特殊方法的对象，在 with 块中使用。

蛇底式（snake_case）

标识符的一种命名约定，使用下划线（_）连接单词，例如 run_until_complete。PEP-8 把这种风格称为「使用下划线分隔的小写单词」，建议用于命名函数、方法、参数和变量。PEP-8 建议包名直接把各个单词拼接起来，不使用分隔符。Python 标准库中有很多使用蛇底式命名的标识符，不过也有单词之间没有分隔的标识符（例如，getattr、classmethod、isinstance、str.endswith，等等）。参见驼峰式词条。

深复制（deep copy）

复制对象时把对象的所有属性一起复制。请与浅复制相比较。

生成器（generator）

使用生成器函数或生成器表达式构建的迭代器，无需迭代集合就可能生成值。生成斐波纳契数列的生成器是个典型示例，这是一种无穷数列，在集合中绝对放不下。这个术语除了表示调用生成器函数得到的对象之外，有时还表示生成器函数。

生成器表达式（generator expression）

放在括号里的表达式，句法与列表推导一样，不过返回的不是列表，而是生成器。生成器表达式可以理解为列表推导的惰性版本。参见惰性求值词条。

生成器函数（generator function）

定义体中有 yield 关键字的函数。调用生成器函数得到的是生成器。

实参（argument）

调用函数时传给函数的表达式。按照 Python 习惯的说法，实参和形参几乎等价。关于二者的区别以及各自的用途，参见形参词条。

视图（view）

在 Python 3 中，视图是一种特殊的数据结构，由字典的 .keys ()、.values () 和 .items () 方法返回，作用是在不重复数据的前提下，提供字典的键和值的动态视图。在 Python 2 中，那些方法返回的是列表。字典视图都是可迭代的对象，支持 in 运算符。此外，如果视图引用的元素都是可散列的对象，那么视图还实现了 collections.abc.Set 接口。.keys () 方法返回的视图都是这样；对 .items () 方法返回的视图来说，如果其中的值都是可散列的对象，那么也是如此。

视为有害（considered harmful）

Edsger Dijkstra 写过一封题为「Go To Statement Considered Harmful」的信函，这为批评计算机科学技术的文章提供了一种标题格式。维基百科中的「Considered harmful」一文列出了很多这种文章，包括 Eric A. Meyer 写的「Considered Harmful Essays Considered Harmful」。

属性（attribute）

在 Python 中，方法和数据属性（即 Java 术语中的「字段」）都是属性。方法也是属性，只不过恰好是可调用的对象（通常是函数，但也不一定）。

特殊方法（special method）

名称特殊的方法，首尾各有两条下划线，例如 __getitem__。Python 中的特殊方法几乎都在 Python 语言参考手册中的「3. Data model」一章做了说明，不过在特定上下文中使用的个别特殊方法在文档的其他部分里说明。例如，映射的 __missing__ 方法在 Python 标准库文档的「4.10. Mapping Types」一节提到。

统一访问原则（uniform access principle）

Eiffel 语言之父 Bertrand Meyer 写道：「不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。」在 Python 中，可以使用特性和描述符实现统一访问原则。由于没有 new 运算符，函数调用和对象实例化看起来相似，这也体现了这一原则：调用方无需知道被调用的对象是类、函数，还是其他可调用的对象。

托管类（managed class）

使用描述符对象管理类中某个属性的类。参见描述符词条。

托管实例（managed instance）

托管类的实例。参见托管属性和描述符词条。

托管属性（managed attribute）

由描述符对象管理的公开属性。虽然托管属性在托管类中定义，但是作用相当于实例属性（即各个实例通常有各自的值，存储在储存属性中）。参见描述符词条。

驼峰式（CamelCase）

标识符的一种命名约定，单词的首字母大写，然后连接起来（例如 Connection RefusedError）。PEP-8 建议类名使用驼峰式，但是 Python 标准库没有遵守这个建议。参见蛇底式词条。

文档字符串（docstring）

documentation string 的简称。如果模块、类或函数的第一个语句是字符串字面量，那个字符串会当作所在对象的文档字符串，解释器把那个字符串存储在对象的 __doc__ 属性中。另见 doctest 词条。

瑕疵（wart）

指 Python 语言的不足。Andrew Kuchling 发表过一篇著名的文章 ——「Python warts」，仁慈的独裁者承认，他在设计 Python 3 的过程中受此文影响，决定不向后兼容，否则无法修正大多数缺陷。Kuchling 提到的多数问题在 Python 3 中修正了。

像文件的对象（file-like object）

官方文档使用的一个非正式称呼，指代实现了文件协议的对象，有 read、write 和 close 等方法。常见的变体有：逐行读写，包含编码字符串的纯文本文件；作为保存在内存中的纯文本文件的 StringIO 实例；包含未编码的字节的二进制文件。最后一种可能有缓冲，也可能没有缓冲。从 Python 2.6 起，这些标准文件类型的抽象基类在 io 模块里。

像字节的对象（bytes-like object）

泛指字节序列。最常见的像字节的类型有 bytes、bytearray 和 memoryview；不过，支持低层 CPython 缓冲协议的对象，如果元素是单个字节，那么也属于此类。

协程（coroutine）

用于并发编程的生成器，从调度程序，或者通过 coro.send (value) 方法从事件循环中接收值。这个术语可以表示通过调用生成器函数获得的生成器函数或生成器对象。参见生成器词条。

形参（parameter）

声明函数时指定的零个或多个「形式参数」，这些是未绑定的局部变量。调用函数时，传入的实参（「实际参数」）会绑定给这些变量。在本书中，我尽量使用实参指代传给函数的实际参数，使用形参指代声明函数时使用的形式参数。然而，并不一定会始终这样做，因为 Python 文档和 API 经常混用形参和实参。参见实参词条。

虚拟子类（virtual subclass）

不继承自超类，而是使用 TheSuperClass.register (TheSubClass) 注册的类。参见 abc.ABCMeta.register 方法的文档。

序列（sequence）

泛指长度（例如，len (s)）固定，可以使用从零开始的整数索引（例如 s [0]）获取元素的数据结构。Python 出现伊始，序列这个词就存在了，不过直到 Python 2.6 才由 collections.abc.Sequence 确定为一个抽象类。

序列化（serialization）

把对象在内存中的结构转换成便于存储或传输的二进制或文本格式，而且以后可以在同一个系统或不同的系统中重建对象的副本。pickle 模块能把任何 Python 对象序列化成二进制格式。

鸭子类型（duck typing）

多态的一种形式，在这种形式中，不管对象属于哪个类，也不管声明的具体接口是什么，只要对象实现了相应的方法，函数就可以在对象上执行操作。

一等函数（first-class function）

在语言中属于一等对象的函数（即能在运行时创建，赋值给变量，当作参数传入，以及作为另一个函数的返回值）。Python 中的函数都是一等函数。

引用计数（refcount）

CPython 内部对各个对象的引用计数，用于确定垃圾回收程序何时销毁对象。

用户定义的（user-defined）

在 Python 文档中，用户这个词几乎都是指我和你，即使用 Python 语言的程序员。用户与实现 Python 解释器的开发者是相对的。因此，「用户定义的类」表示使用 Python 编写的类，而不是使用 C 语言编写的内置类，如 str。

预激（prime，动词）

在协程上调用 next (coro)，让协程向前运行到第一个 yield 表达式，准备好从后续的 coro.send (value) 调用中接收值。

元编程（metaprogramming）

编写的程序使用程序的运行时信息改变程序的行为。例如，ORM 可能会内省模型类的声明，确定如何验证数据库记录里的字段，以及如何把数据库类型转换成 Python 类型。

元类（metaclass）

实例为类的类。默认情况下，Python 中的类是 type 类的实例；例如，type (int) 得到的结果是 type 类，因此 type 是元类。用户可以通过扩展 type 类定义元类。

元组拆包（tuple unpacking）

把可迭代对象中的元素赋值给多个变量（例如，first, second, third == my_list）。Python 高手通常使用这个术语，不过也有人使用可迭代对象的拆包。

真值（truthy）

只要 bool (x) 返回 True，x 就是真值。需要布尔值时，Python 会隐式使用 bool 计算对象，例如控制 if 和 while 循环的表达式。与此相对的是假值。

指示对象（referent）

引用的目标对象。谈及弱引用时最常使用这个术语。

装饰器（decorator）

一个可调用的对象 A，返回另一个可调用的对象 B，在可调用的对象 C 的定义体之前使用句法 @A 调用。Python 解释器读取这样的代码时，会调用 A (C)，把返回的 B 绑定给之前赋予 C 的变量，也就是把 C 的定义体换成 B。如果目标可调用对象 C 是函数，那么 A 是函数装饰器；如果 C 是类，那么 A 是类装饰器。

字节字符串（byte string）

可惜，在 Python 3 中仍然使用这个名称指代 bytes 或 bytearray。在 Python 2 中，str 类型其实是字节字符串，为了把 str 和 unicode 字符串区分开，才用了这个名称。在 Python 3 中没理由继续使用这个术语了，泛指字节序列时，我都尽量使用字节序列（byte sequence）这个术语。

作者简介

Luciano Ramalho 在 1995 年 Netscape 首次公开募股以前就是一名 Web 开发者了，他先后用过 Perl 和 Java，1998 年开始使用 Python。自那以后，他在巴西的几个新闻门户网站工作，使用 Python 做开发，还为巴西的媒体、银行和政府部门做 Python Web 开发培训。他经常在开发者大会上演讲，比如 PyCon US（2013）、OSCON（2002、2013 和 2014），还有多年在 PythonBrasil（在巴西举办的 PyCon）以及 FISL（南半球最大的 FLOSS 大会）上做过的 15 次演讲。Ramalho 是 Python 软件基金会的成员，还是巴西第一个众创空间 Garoa Hacker Clube 的联合创始人。他也是培训公司 Python.pro.br 的共同所有人。

关于封面

本书封面的动物是纳马沙蜥（学名：Pedioplanis namaquensis），身体细长，有一条呈红棕色的长尾巴。这种沙蜥身体为黑色，有四条白纹；四肢呈棕色，带白点；腹部为白色。

纳马沙蜥白天活动，是速度最快的蜥蜴之一。它们栖息在草木稀疏的沙砾平地，冬季在灌木丛边挖的洞穴里休眠。纳马沙蜥分布于纳米比亚全境的干旱稀树草原和半荒漠地区，以小昆虫为食。在 11 月，雌性会产下 3~5 枚蛋。

O'Reilly 出版的图书，封面上很多动物都濒临灭绝。这些动物都是地球的至宝。如果你想知道如何保护这些动物，请访问 animals.oreilly.com。

封面图片出自 Wood 的 Natural History, Vol 3。

看完了

如果您对本书内容有疑问，可发邮件至 contact@turingbook.com，会有编辑或作译者协助答疑。也可访问图灵社区，参与本书讨论。

如果是有关电子书的建议或问题，请联系专用客服邮箱：ebook@turingbook.com。

在这里可以找到我们：

微博 @图灵教育：好书、活动每日播报

微博 @图灵社区：电子书和好文章的消息

微博 @图灵新知：图灵教育的科普小组

微信 图灵访谈 : ituring_interview，讲述码农精彩人生

微信 图灵教育 : turingbooks

* * *

091507240605ToBeReplacedWithUserId

Table of Contents

版权信息

版权声明

O'Reilly Media, Inc. 介绍 业界评论

前言 目标读者

非目标读者

本书的结构

以实践为基础

硬件

杂谈：个人的一点看法

Python 术语表

Python 版本表

排版约定

使用代码示例

Safari® Books Online

联系我们

致谢

电子书

第一部分　序幕

第 1 章　Python 数据模型 1.1　一摞 Python 风格的纸牌

1.2　如何使用特殊方法 1.2.1　模拟数值类型

1.2.2　字符串表示形式

1.2.3　算术运算符

1.2.4　自定义的布尔值

1.3　特殊方法一览

1.4　为什么 len 不是普通方法

1.5　本章小结

1.6　延伸阅读

第二部分　数据结构

第 2 章　序列构成的数组 2.1　内置序列类型概览

2.2　列表推导和生成器表达式 2.2.1　列表推导和可读性

2.2.2　列表推导同 filter 和 map 的比较

2.2.3　笛卡儿积

2.2.4　生成器表达式

2.3　元组不仅仅是不可变的列表 2.3.1　元组和记录

2.3.2　元组拆包

2.3.3　嵌套元组拆包

2.3.4　具名元组

2.3.5　作为不可变列表的元组

2.4　切片 2.4.1　为什么切片和区间会忽略最后一个元素

2.4.2　对对象进行切片

2.4.3　多维切片和省略

2.4.4　给切片赋值

2.5　对序列使用 + 和 * 建立由列表组成的列表

2.6　序列的增量赋值 一个关于 += 的谜题

2.7　list.sort 方法和内置函数 sorted

2.8　用 bisect 来管理已排序的序列 2.8.1　用 bisect 来搜索

2.8.2　用 bisect.insort 插入新元素

2.9　当列表不是首选时 2.9.1　数组

2.9.2　内存视图

2.9.3　NumPy 和 SciPy

2.9.4　双向队列和其他形式的队列

2.10　本章小结

2.11　延伸阅读

第 3 章　字典和集合 3.1　泛映射类型

3.2　字典推导

3.3　常见的映射方法 用 setdefault 处理找不到的键

3.4　映射的弹性键查询 3.4.1　defaultdict：处理找不到的键的一个选择

3.4.2　特殊方法 __missing__

3.5　字典的变种

3.6　子类化 UserDict

3.7　不可变映射类型

3.8　集合论 3.8.1　集合字面量

3.8.2　集合推导

3.8.3　集合的操作

3.9　dict 和 set 的背后 3.9.1　一个关于效率的实验

3.9.2　字典中的散列表

3.9.3　dict 的实现及其导致的结果

3.9.4　set 的实现以及导致的结果

3.10　本章小结

3.11　延伸阅读

第 4 章　文本和字节序列 4.1　字符问题

4.2　字节概要 结构体和内存视图

4.3　基本的编解码器

4.4　了解编解码问题 4.4.1　处理 UnicodeEncodeError

4.4.2　处理 UnicodeDecodeError

4.4.3　使用预期之外的编码加载模块时抛出的 SyntaxError

4.4.4　如何找出字节序列的编码

4.4.5　BOM：有用的鬼符

4.5　处理文本文件 编码默认值：一团糟

4.6　为了正确比较而规范化 Unicode 字符串 4.6.1　大小写折叠

4.6.2　规范化文本匹配实用函数

4.6.3　极端「规范化」：去掉变音符号

4.7　Unicode 文本排序 使用 Unicode 排序算法排序

4.8　Unicode 数据库

4.9　支持字符串和字节序列的双模式 API 4.9.1　正则表达式中的字符串和字节序列

4.9.2　os 函数中的字符串和字节序列

4.10　本章小结

4.11　延伸阅读

第三部分　把函数视作对象

第 5 章　一等函数 5.1　把函数视作对象

5.2　高阶函数 map、filter 和 reduce 的现代替代品

5.3　匿名函数

5.4　可调用对象

5.5　用户定义的可调用类型

5.6　函数内省

5.7　从定位参数到仅限关键字参数

5.8　获取关于参数的信息

5.9　函数注解

5.10　支持函数式编程的包 5.10.1　operator 模块

5.10.2　使用 functools.partial 冻结参数

5.11　本章小结

5.12　延伸阅读

第 6 章　使用一等函数实现设计模式 6.1　案例分析：重构「策略」模式 6.1.1　经典的「策略」模式

6.1.2　使用函数实现「策略」模式

6.1.3　选择最佳策略：简单的方式

6.1.4　找出模块中的全部策略

6.2　「命令」模式

6.3　本章小结

6.4　延伸阅读

第 7 章　函数装饰器和闭包 7.1　装饰器基础知识

7.2　Python 何时执行装饰器

7.3　使用装饰器改进「策略」模式

7.4　变量作用域规则

7.5　闭包

7.6　nonlocal 声明

7.7　实现一个简单的装饰器 工作原理

7.8　标准库中的装饰器 7.8.1　使用 functools.lru_cache 做备忘

7.8.2　单分派泛函数

7.9　叠放装饰器

7.10　参数化装饰器 7.10.1　一个参数化的注册装饰器

7.10.2　参数化 clock 装饰器

7.11　本章小结

7.12　延伸阅读

第四部分　面向对象惯用法

第 8 章　对象引用、可变性和垃圾回收 8.1　变量不是盒子

8.2　标识、相等性和别名 8.2.1　在 == 和 is 之间选择

8.2.2　元组的相对不可变性

8.3　默认做浅复制 为任意对象做深复制和浅复制

8.4　函数的参数作为引用时 8.4.1　不要使用可变类型作为参数的默认值

8.4.2　防御可变参数

8.5　del 和垃圾回收

8.6　弱引用 8.6.1　WeakValueDictionary 简介

8.6.2　弱引用的局限

8.7　Python 对不可变类型施加的把戏

8.8　本章小结

8.9　延伸阅读

第 9 章　符合 Python 风格的对象 9.1　对象表示形式

9.2　再谈向量类

9.3　备选构造方法

9.4　classmethod 与 staticmethod

9.5　格式化显示

9.6　可散列的 Vector2d

9.7　Python 的私有属性和「受保护的」属性

9.8　使用 __slots__ 类属性节省空间 __slots__ 的问题

9.9　覆盖类属性

9.10　本章小结

9.11　延伸阅读

第 10 章　序列的修改、散列和切片 10.1　Vector 类：用户定义的序列类型

10.2　Vector 类第 1 版：与 Vector2d 类兼容

10.3　协议和鸭子类型

10.4　Vector 类第 2 版：可切片的序列 10.4.1　切片原理

10.4.2　能处理切片的__getitem__方法

10.5　Vector 类第 3 版：动态存取属性

10.6　Vector 类第 4 版：散列和快速等值测试

10.7　Vector 类第 5 版：格式化

10.8　本章小结

10.9　延伸阅读

第 11 章　接口：从协议到抽象基类 11.1　Python 文化中的接口和协议

11.2　Python 喜欢序列

11.3　使用猴子补丁在运行时实现协议

11.4　Alex Martelli 的水禽

11.5　定义抽象基类的子类

11.6　标准库中的抽象基类 11.6.1　collections.abc 模块中的抽象基类

11.6.2　抽象基类的数字塔

11.7　定义并使用一个抽象基类 11.7.1　抽象基类句法详解

11.7.2　定义 Tombola 抽象基类的子类

11.7.3　Tombola 的虚拟子类

11.8　Tombola 子类的测试方法

11.9　Python 使用 register 的方式

11.10　鹅的行为有可能像鸭子

11.11　本章小结

11.12　延伸阅读

第 12 章　继承的优缺点 12.1　子类化内置类型很麻烦

12.2　多重继承和方法解析顺序

12.3　多重继承的真实应用

12.4　处理多重继承 Tkinter 好的、不好的和令人厌恶的方面

12.5　一个现代示例：Django 通用视图中的混入

12.6　本章小结

12.7　延伸阅读

第 13 章　正确重载运算符 13.1　运算符重载基础

13.2　一元运算符

13.3　重载向量加法运算符 +

13.4　重载标量乘法运算符 *

13.5　众多比较运算符

13.6　增量赋值运算符

13.7　本章小结

13.8　延伸阅读

第五部分　控制流程

第 14 章　可迭代的对象、迭代器和生成器 14.1　Sentence 类第 1 版：单词序列 序列可以迭代的原因：iter 函数

14.2　可迭代的对象与迭代器的对比

14.3　Sentence 类第 2 版：典型的迭代器 把 Sentence 变成迭代器：坏主意

14.4　Sentence 类第 3 版：生成器函数 生成器函数的工作原理

14.5　Sentence 类第 4 版：惰性实现

14.6　Sentence 类第 5 版：生成器表达式

14.7　何时使用生成器表达式

14.8　另一个示例：等差数列生成器 使用 itertools 模块生成等差数列

14.9　标准库中的生成器函数

14.10　Python 3.3 中新出现的句法：yield from

14.11　可迭代的归约函数

14.12　深入分析 iter 函数

14.13　案例分析：在数据库转换工具中使用生成器

14.14　把生成器当成协程

14.15　本章小结

14.16　延伸阅读

第 15 章　上下文管理器和 else 块 15.1　先做这个，再做那个：if 语句之外的 else 块

15.2　上下文管理器和 with 块

15.3　contextlib 模块中的实用工具

15.4　使用 @contextmanager

15.5　本章小结

15.6　延伸阅读

第 16 章　协程 16.1　生成器如何进化成协程

16.2　用作协程的生成器的基本行为

16.3　示例：使用协程计算移动平均值

16.4　预激协程的装饰器

16.5　终止协程和异常处理

16.6　让协程返回值

16.7　使用 yield from

16.8　yield from 的意义

16.9　使用案例：使用协程做离散事件仿真 16.9.1　离散事件仿真简介

16.9.2　出租车队运营仿真

16.10　本章小结

16.11　延伸阅读

第 17 章　使用期物处理并发 17.1　示例：网络下载的三种风格 17.1.1　依序下载的脚本

17.1.2　使用 concurrent.futures 模块下载

17.1.3　期物在哪里

17.2　阻塞型 I/O 和 GIL

17.3　使用 concurrent.futures 模块启动进程

17.4　实验 Executor.map 方法

17.5　显示下载进度并处理错误 17.5.1　flags2 系列示例处理错误的方式

17.5.2　使用 futures.as_completed 函数

17.5.3　线程和多进程的替代方案

17.6　本章小结

17.7　延伸阅读

第 18 章　使用 asyncio 包处理并发 18.1　线程与协程对比 18.1.1　asyncio.Future：故意不阻塞

18.1.2　从期物、任务和协程中产出

18.2　使用 asyncio 和 aiohttp 包下载

18.3　避免阻塞型调用

18.4　改进 asyncio 下载脚本 18.4.1　使用 asyncio.as_completed 函数

18.4.2　使用 Executor 对象，防止阻塞事件循环

18.5　从回调到期物和协程 每次下载发起多次请求

18.6　使用 asyncio 包编写服务器 18.6.1　使用 asyncio 包编写 TCP 服务器

18.6.2　使用 aiohttp 包编写 Web 服务器

18.6.3　更好地支持并发的智能客户端

18.7　本章小结

18.8　延伸阅读

第六部分　元编程

第 19 章　动态属性和特性 19.1　使用动态属性转换数据 19.1.1　使用动态属性访问 JSON 类数据

19.1.2　处理无效属性名

19.1.3　使用 __new__ 方法以灵活的方式创建对象

19.1.4　使用 shelve 模块调整 OSCON 数据源的结构

19.1.5　使用特性获取链接的记录

19.2　使用特性验证属性 19.2.1　LineItem 类第 1 版：表示订单中商品的类

19.2.2　LineItem 类第 2 版：能验证值的特性

19.3　特性全解析 19.3.1　特性会覆盖实例属性

19.3.2　特性的文档

19.4　定义一个特性工厂函数

19.5　处理属性删除操作

19.6　处理属性的重要属性和函数 19.6.1　影响属性处理方式的特殊属性

19.6.2　处理属性的内置函数

19.6.3　处理属性的特殊方法

19.7　本章小结

19.8　延伸阅读

第 20 章　属性描述符 20.1　描述符示例：验证属性 20.1.1　LineItem 类第 3 版：一个简单的描述符

20.1.2　LineItem 类第 4 版：自动获取储存属性的名称

20.1.3　LineItem 类第 5 版：一种新型描述符

20.2　覆盖型与非覆盖型描述符对比 20.2.1　覆盖型描述符

20.2.2　没有 __get__ 方法的覆盖型描述符

20.2.3　非覆盖型描述符

20.2.4　在类中覆盖描述符

20.3　方法是描述符

20.4　描述符用法建议

20.5　描述符的文档字符串和覆盖删除操作

20.6　本章小结

20.7　延伸阅读

第 21 章　类元编程 21.1　类工厂函数

21.2　定制描述符的类装饰器

21.3　导入时和运行时比较 理解计算时间的练习

21.4　元类基础知识 理解元类计算时间的练习

21.5　定制描述符的元类

21.6　元类的特殊方法 __prepare__

21.7　类作为对象

21.8　本章小结

21.9　延伸阅读

结语 延伸阅读

附录 A　辅助脚本 A.1　第 3 章：in 运算符的性能测试

A.2　第 3 章：比较散列后的位模式

A.3　第 9 章：有或没有 __slots__ 时，RAM 的用量

A.4　第 14 章：转换数据库的 isis2json.py 脚本

A.5　第 16 章：出租车队离散事件仿真

A.6　第 17 章：加密示例

A.7　第 17 章：flags2 系列 HTTP 客户端示例

A.8　第 19 章：处理 OSCON 日程表的脚本和测试

Python 术语表

作者简介

关于封面

看完了

