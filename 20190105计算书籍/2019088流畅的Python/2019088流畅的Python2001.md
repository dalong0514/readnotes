第 19 章　动态属性和特性

特性至关重要的地方在于，特性的存在使得开发者可以非常安全并且确定可行地将公共数据属性作为类的公共接口的一部分开放出来。1

——Alex Martelli

Python 贡献者和图书作者

1《Python 技术手册（第 2 版）》第 101 页。（该书中文版把「property」译为属性，这里改为「特性」，其他内容与原来的翻译相同。—— 译者注）

在 Python 中，数据的属性和处理数据的方法统称属性（attribute）。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变类接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。这与统一访问原则相符：

不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。2

2Bertrand Meyer, Object-Oriented Software Construction, 2E, p. 57.

除了特性，Python 还提供了丰富的 API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如 obj.attr），Python 解释器会调用特殊的方法（如 __getattr__ 和 __setattr__）计算属性。用户自己定义的类可以通过 __getattr__ 方法实现「虚拟属性」，当访问不存在的属性时（如 obj.no_such_attribute），即时计算属性的值。

动态创建属性是一种元编程，框架的作者经常这么做。然而，在 Python 中，相关的基础技术十分简单，任何人都可以使用，甚至在日常的数据转换任务中也能用到。下面以这种任务开启本章的话题。

19.1　使用动态属性转换数据

在接下来的几个示例中，我们要使用动态属性处理 O'Reilly 为 OSCON 2014 大会提供的 JSON 格式数据源。示例 19-1 是那个数据源中的 4 个记录。3

3 关于这个数据源及其使用规则，请阅读「DIY: OSCON schedule」一文。那个 JSON 文件有 744KB，我写作本书时还在网上。本书代码仓库中的 oscon-schedule/data/ 目录里有个副本，文件名为 osconfeed.json。

示例 19-1　osconfeed.json 文件中的记录示例；节略了部分字段的内容

{ "Schedule": { "conferences": [{"serial": 115 }], "events": [ { "serial": 34505, "name": "Why Schools Don´t Use Open Source to Teach Programming", "event_type": "40-minute conference session", "time_start": "2014-07-23 11:30:00", "time_stop": "2014-07-23 12:10:00", "venue_serial": 1462, "description": "Aside from the fact that high school programming...", "website_url": "http://oscon.com/oscon2014/public/schedule/detail/34505", "speakers": [157509], "categories": ["Education"] } ], "speakers": [ { "serial": 157509, "name": "Robert Lefkowitz", "photo": null, "url": "http://sharewave.com/", "position": "CTO", "affiliation": "Sharewave", "twitter": "sharewaveteam", "bio": "Robert ´r0ml´ Lefkowitz is the CTO at Sharewave, a startup..." } ], "venues": [ { "serial": 1462, "name": "F151", "category": "Conference Venues" } ] } }

那个 JSON 源中有 895 条记录，示例 19-1 只列出了 4 条。可以看出，整个数据集是一个 JSON 对象，里面有一个键，名为 "Schedule"；这个键对应的值也是一个映像，有 4 个键： "conferences"、"events"、"speakers" 和 "venues"。这 4 个键对应的值都是一个记录列表。在示例 19-1 中，各个列表中只有一条记录。然而，在完整的数据集中，列表中有成百上千条记录。不过，"conferences" 键对应的列表中只有一条记录，如上述示例所示。这 4 个列表中的每个元素都有一个名为 "serial" 的字段，这是元素在各个列表中的唯一标识符。

我编写的第一个脚本只用于下载那个 OSCON 数据源。为了避免浪费流量，我会先检查本地有没有副本。这么做是合理的，因为 OSCON 2014 大会已经结束，数据源不会再更新。

示例 19-2 没用到元编程，几乎所有代码的作用可以用这一个表达式概括：json.load (fp)。不过，这样足以处理那个数据集了。osconfeed.load 函数会在后面几个示例中用到。

示例 19-2　osconfeed.py：下载 osconfeed.json（doctest 在示例 19-3 中）

from urllib.request import urlopen import warnings import os import json URL = 'http://www.oreilly.com/pub/sc/osconfeed' JSON = 'data/osconfeed.json' def load(): if not os.path.exists(JSON): msg = 'downloading {} to {}'.format(URL, JSON) warnings.warn(msg) ➊ with urlopen(URL) as remote, open(JSON, 'wb') as local: ➋ local.write(remote.read()) with open(JSON) as fp: return json.load(fp) ➌

❶ 如果需要下载，就发出提醒。

❷ 在 with 语句中使用两个上下文管理器（从 Python 2.7 和 Python 3.1 起允许这么做），分别用于读取和保存远程文件。

❸ json.load 函数解析 JSON 文件，返回 Python 原生对象。在这个数据源中有这几种数据类型：dict、list、str 和 int。

有了示例 19-2 中的代码，我们可以审查数据源中的任何字段，如示例 19-3 所示。

示例 19-3　osconfeed.py：示例 19-2 的 doctest

>>> feed = load() ➊ >>> sorted(feed['Schedule'].keys()) ➋ ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed['Schedule'].items()): ... print('{:3} {}'.format(len(value), key)) ➌ ... 1 conferences 494 events 357 speakers 53 venues >>> feed['Schedule']['speakers'][-1]['name'] ➍ 'Carina C. Zona' >>> feed['Schedule']['speakers'][-1]['serial'] ➎ 141590 >>> feed['Schedule']['events'][40]['name'] 'There *Will* Be Bugs' >>> feed['Schedule']['events'][40]['speakers'] ➏ [3471, 5199]

❶ feed 的值是一个字典，里面嵌套着字典和列表，存储着字符串和整数。

❷ 列出 "Schedule" 键中的 4 个记录集合。

❸ 显示各个集合中的记录数量。

❹ 深入嵌套的字典和列表，获取最后一个演讲者的名字。

❺ 获取那位演讲者的编号。

❻ 每个事件都有一个'speakers' 字段，列出 0 个或多个演讲者的编号。

19.1.1　使用动态属性访问 JSON 类数据

示例 19-2 十分简单，不过，feed ['Schedule']['events'][40]['name'] 这种句法很冗长。在 JavaScript 中，可以使用 feed.Schedule.events [40].name 获取那个值。在 Python 中，可以实现一个近似字典的类（网上有大量实现）4，达到同样的效果。我自己实现了 FrozenJSON 类，比大多数实现都简单，因为只支持读取，即只能访问数据。不过，这个类能递归，自动处理嵌套的映射和列表。

4 最常提到的一个实现是 AttrDict，还有一个实现能快速创建嵌套的映射 ——addict。

示例 19-4 演示 FrozenJSON 类的用法，源代码在示例 19-5 中。

示例 19-4　 示例 19-5 定义的 FrozenJSON 类能读取属性，如 name，还能调用方法，如 .keys () 和 .items ()

>>> from osconfeed import load >>> raw_feed = load() >>> feed = FrozenJSON(raw_feed) ➊ >>> len(feed.Schedule.speakers) ➋ 357 >>> sorted(feed.Schedule.keys()) ➌ ['conferences', 'events', 'speakers', 'venues'] >>> for key, value in sorted(feed.Schedule.items()): ➍ ... print('{:3} {}'.format(len(value), key)) ... 1 conferences 494 events 357 speakers 53 venues >>> feed.Schedule.speakers[-1].name ➎ 'Carina C. Zona' >>> talk = feed.Schedule.events[40] >>> type(talk) ➏ <class 'explore0.FrozenJSON'> >>> talk.name 'There *Will* Be Bugs' >>> talk.speakers ➐ [3471, 5199] >>> talk.flavor ➑ Traceback (most recent call last): ... KeyError: 'flavor'

❶ 传入嵌套的字典和列表组成的 raw_feed，创建一个 FrozenJSON 实例。

❷ FrozenJSON 实例能使用属性表示法遍历嵌套的字典；这里，我们获取演讲者列表的元素数量。

❸ 也可以使用底层字典的方法，例如 .keys ()，获取记录集合的名称。

❹ 使用 items () 方法获取各个记录集合及其内容，然后显示各个记录集合中的元素数量。

❺ 列表，例如 feed.Schedule.speakers，仍是列表；但是，如果里面的元素是映射，会转换成 FrozenJSON 对象。

❻ events 列表中的 40 号元素是一个 JSON 对象，现在则变成一个 FrozenJSON 实例。

❼ 事件记录中有一个 speakers 列表，列出演讲者的编号。

❽ 读取不存在的属性会抛出 KeyError 异常，而不是通常抛出的 AttributeError 异常。

FrozenJSON 类的关键是 __getattr__ 方法。我们在 10.5 节的 Vector 示例中用过这个方法，那时用于通过字母获取 Vector 对象的分量（例如 v.x、v.y、v.z）。我们要记住重要的一点，仅当无法使用常规的方式获取属性（即在实例、类或超类中找不到指定的属性），解释器才会调用特殊的 __getattr__ 方法。

示例 19-4 的最后一行揭露了这个实现的一个小问题：理论上，尝试读取不存在的属性应该抛出 AttributeError 异常。其实，一开始我对这个异常做了处理，但是 __getattr__ 方法的代码量增加了一倍，而且偏离了我最想展示的重要逻辑，因此为了教学，后来我把那部分代码去掉了。

如示例 19-5 所示，FrozenJSON 类只有两个方法（__init__ 和 __getattr__）和一个实例属性 __data。因此，尝试获取其他属性会触发解释器调用 __getattr__ 方法。这个方法首先查看 self.__data 字典有没有指定名称的属性（不是键），这样 FrozenJSON 实例便可以处理字典的所有方法，例如把 items 方法委托给 self.__data.items () 方法。如果 self.__data 没有指定名称的属性，那么 __getattr__ 方法以那个名称为键，从 self.__data 中获取一个元素，传给 FrozenJSON.build 方法。这样就能深入 JSON 数据的嵌套结构，使用类方法 build 把每一层嵌套转换成一个 FrozenJSON 实例。

示例 19-5　 explore0.py：把一个 JSON 数据集转换成一个嵌套着 FrozenJSON 对象、列表和简单类型的 FrozenJSON 对象

from collections import abc class FrozenJSON: """一个只读接口，使用属性表示法访问 JSON 类对象""" def __init__(self, mapping): self.__data = dict (mapping) ➊ def __getattr__(self, name): ➋ if hasattr (self.__data, name): return getattr (self.__data, name) ➌ else: return FrozenJSON.build (self.__data [name]) ➍ @classmethod def build (cls, obj): ➎ if isinstance (obj, abc.Mapping): ➏ return cls (obj) elif isinstance (obj, abc.MutableSequence): ➐ return [cls.build (item) for item in obj] else: ➑ return obj

❶ 使用 mapping 参数构建一个字典。这么做有两个目的：(1) 确保传入的是字典（或者是能转换成字典的对象）；(2) 安全起见，创建一个副本。

❷ 仅当没有指定名称（name）的属性时才调用 __getattr__ 方法。

❸ 如果 name 是实例属性 __data 的属性，返回那个属性。调用 keys 等方法就是通过这种方式处理的。

❹ 否则，从 self.__data 中获取 name 键对应的元素，返回调用 FrozenJSON.build () 方法得到的结果。5

5 这一行中的 self.__data [name] 表达式可能抛出 KeyError 异常。我们应该处理这个异常，抛出 AttributeError 异常，因为这才是 __getattr__ 方法应该抛出的异常种类。建议勤奋的读者实现错误处理代码，当作一个练习。

❺ 这是一个备选构造方法，@classmethod 装饰器经常这么用。

❻ 如果 obj 是映射，那就构建一个 FrozenJSON 对象。

❼ 如果是 MutableSequence 对象，必然是列表，6 因此，我们把 obj 中的每个元素递归地传给 .build () 方法，构建一个列表。

6 数据源是 JSON 格式，而在 JSON 中，只有字典和列表是集合类型。

❽ 如果既不是字典也不是列表，那么原封不动地返回元素。

注意，我们没有缓存或转换原始数据源。在迭代数据源的过程中，嵌套的数据结构不断被转换成 FrozenJSON 对象。这么做没问题，因为数据集不大，而且这个脚本只用于访问或转换数据。

从随机源中生成或仿效动态属性名的脚本都必须处理一个问题：原始数据中的键可能不适合作为属性名。下一节处理这个问题。

19.1.2　处理无效属性名

FrozenJSON 类有个缺陷：没有对名称为 Python 关键字的属性做特殊处理。比如说像下面这样构建一个对象：

>>> grad = FrozenJSON({'name': 'Jim Bo', 'class': 1982})

此时无法读取 grad.class 的值，因为在 Python 中 class 是保留字：

>>> grad.class File "<stdin>", line 1 grad.class ^ SyntaxError: invalid syntax

当然，可以这么做：

>>> getattr(grad, 'class') 1982

但是，FrozenJSON 类的目的是为了便于访问数据，因此更好的方法是检查传给 FrozenJSON.__init__ 方法的映射中是否有键的名称为关键字，如果有，那么在键名后加上 _，然后通过下述方式读取：

>>> grad.class_ 1982

为此，我们可以把示例 19-5 中只有一行代码的 __init__ 方法改成示例 19-6 中的版本。

示例 19-6　explore1.py：在名称为 Python 关键字的属性后面加上 _

def __init__(self, mapping): self.__data = {} for key, value in mapping.items(): if keyword.iskeyword(key): ➊ key += '_' self.__data[key] = value

➊ keyword.iskeyword (...) 正是我们所需的函数；为了使用它，必须导入 keyword 模块；这个代码片段没有列出导入语句。

如果 JSON 对象中的键不是有效的 Python 标识符，也会遇到类似的问题：

>>> x = FrozenJSON({'2be':'or not'}) >>> x.2be File "<stdin>", line 1 x.2be ^ SyntaxError: invalid syntax

这种有问题的键在 Python 3 中易于检测，因为 str 类提供的 s.isidentifier () 方法能根据语言的语法判断 s 是否为有效的 Python 标识符。但是，把无效的标识符变成有效的属性名却不容易。对此，有两个简单的解决方法，一个是抛出异常，另一个是把无效的键换成通用名称，例如 attr_0、attr_1，等等。为了简单起见，我将忽略这个问题。

对动态属性的名称做了一些处理之后，我们要分析 FrozenJSON 类的另一个重要功能 —— 类方法 build 的逻辑。这个方法把嵌套结构转换成 FrozenJSON 实例或 FrozenJSON 实例列表，因此 __getattr__ 方法使用这个方法访问属性时，能为不同的值返回不同类型的对象。

除了在类方法中实现这样的逻辑之外，还可以在特殊的 __new__ 方法中实现，如下一节所述。

19.1.3　使用 __new__ 方法以灵活的方式创建对象

我们通常把 __init__ 称为构造方法，这是从其他语言借鉴过来的术语。其实，用于构建实例的是特殊方法 __new__：这是个类方法（使用特殊方式处理，因此不必使用 @classmethod 装饰器），必须返回一个实例。返回的实例会作为第一个参数（即 self）传给 __init__ 方法。因为调用 __init__ 方法时要传入实例，而且禁止返回任何值，所以 __init__ 方法其实是「初始化方法」。真正的构造方法是 __new__。我们几乎不需要自己编写 __new__ 方法，因为从 object 类继承的实现已经足够了。

刚才说明的过程，即从 __new__ 方法到 __init__ 方法，是最常见的，但不是唯一的。__new__ 方法也可以返回其他类的实例，此时，解释器不会调用 __init__ 方法。

也就是说，Python 构建对象的过程可以使用下述伪代码概括：

# 构建对象的伪代码 def object_maker (the_class, some_arg): new_object = the_class.__new__(some_arg) if isinstance (new_object, the_class): the_class.__init__(new_object, some_arg) return new_object # 下述两个语句的作用基本等效 x = Foo ('bar') x = object_maker (Foo, 'bar')

示例 19-7 是 FrozenJSON 类的另一个版本，把之前在类方法 build 中的逻辑移到了 __new__ 方法中。

示例 19-7　explore2.py：使用 __new__ 方法取代 build 方法，构建可能是也可能不是 FrozenJSON 实例的新对象

from collections import abc class FrozenJSON: """一个只读接口，使用属性表示法访问 JSON 类对象""" def __new__(cls, arg): ➊ if isinstance (arg, abc.Mapping): return super ().__new__(cls) ➋ elif isinstance (arg, abc.MutableSequence): ➌ return [cls (item) for item in arg] else: return arg def __init__(self, mapping): self.__data = {} for key, value in mapping.items (): if iskeyword (key): key += '_' self.__data [key] = value def __getattr__(self, name): if hasattr (self.__data, name): return getattr (self.__data, name) else: return FrozenJSON (self.__data [name]) ➍

❶ __new__ 是类方法，第一个参数是类本身，余下的参数与 __init__ 方法一样，只不过没有 self。

❷ 默认的行为是委托给超类的 __new__ 方法。这里调用的是 object 基类的 __new__ 方法，把唯一的参数设为 FrozenJSON。

❸ __new__ 方法中余下的代码与原先的 build 方法完全一样。

❹ 之前，这里调用的是 FrozenJSON.build 方法，现在只需调用 FrozenJSON 构造方法。

__new__ 方法的第一个参数是类，因为创建的对象通常是那个类的实例。所以，在 FrozenJSON.__new__ 方法中，super ().__new__(cls) 表达式会调用 object.__new__(FrozenJSON)，而 object 类构建的实例其实是 FrozenJSON 实例，即那个实例的 __class__ 属性存储的是 FrozenJSON 类的引用。不过，真正的构建操作由解释器调用 C 语言实现的 object.__new__ 方法执行。

OSCON 的 JSON 数据源有一个明显的缺点：索引为 40 的事件，即名为 'There *Will* Be Bugs' 的那个，有两位演讲者，3471 和 5199，但却不容易找到他们，因为提供的是编号，而 Schedule.speakers 列表没有使用编号建立索引。此外，每条事件记录中都有 venue_serial 字段，存储的值也是编号，但是如果想找到对应的记录，那就要线性搜索 Schedule.venues 列表。接下来的任务是，调整数据结构，以便自动获取所链接的记录。

19.1.4　使用 shelve 模块调整 OSCON 数据源的结构

标准库中有个 shelve（架子）模块，这名字听起来怪怪的，可是如果知道 pickle（泡菜）是 Python 对象序列化格式的名字，还是在那个格式与对象之间相互转换的某个模块的名字，就会觉得以 shelve 命名是合理的。泡菜坛子摆放在架子上，因此 shelve 模块提供了 pickle 存储方式。

shelve.open 高阶函数返回一个 shelve.Shelf 实例，这是简单的键值对象数据库，背后由 dbm 模块支持，具有下述特点。

shelve.Shelf 是 abc.MutableMapping 的子类，因此提供了处理映射类型的重要方法。

此外，shelve.Shelf 类还提供了几个管理 I/O 的方法，如 sync 和 close；它也是一个上下文管理器。

只要把新值赋予键，就会保存键和值。

键必须是字符串。

值必须是 pickle 模块能处理的对象。

shelve（https://docs.python.org/3/library/shelve.html）、dbm（https://docs.python.org/3/library/dbm.html）和 pickle 模块（https://docs.python.org/3/library/pickle.html）的详细用法和注意事项参见文档。现在值得关注的是，shelve 模块为识别 OSCON 的日程数据提供了一种简单有效的方式。我们将从 JSON 文件中读取所有记录，将其存在一个 shelve.Shelf 对象中，键由记录类型和编号组成（例如，'event.33950' 或'speaker.3471'），而值是我们即将定义的 Record 类的实例。

实例 19-8 是 schedule1.py 脚本的 doctest，使用 shelve 模块处理数据源。若想以交互式方式测试，要执行 python -i schedule1.py 命令运行脚本，启动加载了 schedule1 模块的控制台。主要工作由 load_db 函数完成：调用 osconfeed.load 方法（在示例 19-2 中定义）读取 JSON 数据，把通过 db 传入的 Shelf 对象中的各条记录存储为一个个 Record 实例。这样处理之后，获取演讲者的记录就容易了，例如 speaker = db ['speaker.3471']。

示例 19-8　测试 schedule1.py 脚本（见示例 19-9）提供的功能

>>> import shelve >>> db = shelve.open(DB_NAME) ➊ >>> if CONFERENCE not in db: ➋ ... load_db(db) ➌ ... >>> speaker = db['speaker.3471'] ➍ >>> type(speaker) ➎ <class 'schedule1.Record'> >>> speaker.name, speaker.twitter ➏ ('Anna Martelli Ravenscroft', 'annaraven') >>> db.close() ➐

❶ shelve.open 函数打开现有的数据库文件，或者新建一个。

❷ 判断数据库是否填充的简便方法是，检查某个已知的键是否存在；这里检查的键是 conference.115，即 conference 记录（只有一个）的键。7

7 也可以使用 len (db) 判断，不过，如果是大型 dbm 数据库，那就很耗费时间。

❸ 如果数据库是空的，那就调用 load_db (db)，加载数据。

❹ 获取一条 speaker 记录。

❺ 它是示例 19-9 中定义的 Record 类的实例。

❻ 各个 Record 实例都有一系列自定义的属性，对应于底层 JSON 记录里的字段。

❼ 一定要记得关闭 shelve.Shelf 对象。如果可以，使用 with 块确保 Shelf 对象会关闭。8

8doctest 有个突出的弱点：无法正确地设置资源并保证将其销毁。我使用 py.test 为 schedule1.py 脚本写了很多测试，在示例 A-12 中。

schedule1.py 脚本的代码在示例 19-9 中。

示例 19-9　schedule1.py：访问保存在 shelve.Shelf 对象里的 OSCON 日程数据

import warnings import osconfeed ➊ DB_NAME = 'data/schedule1_db' CONFERENCE = 'conference.115' class Record: def __init__(self, **kwargs): self.__dict__.update(kwargs) ➋ def load_db(db): raw_data = osconfeed.load() ➌ warnings.warn('loading ' + DB_NAME) for collection, rec_list in raw_data['Schedule'].items(): ➍ record_type = collection[:-1] ➎ for record in rec_list: key = '{}.{}'.format(record_type, record['serial']) ➏ record['serial'] = key ➐ db[key] = Record(**record) ➑

❶ 加载示例 19-2 中的 osconfeed.py 模块。

❷ 这是使用关键字参数传入的属性构建实例的常用简便方式（详情参见下文）。

❸ 如果本地没有副本，从网上下载 JSON 数据源。

❹ 迭代集合（例如 'conferences'、'events'，等等）。

❺ record_type 的值是去掉尾部's' 后的集合名（即把 'events' 变成 'event'）。

❻ 使用 record_type 和'serial' 字段构成 key。

❼ 把'serial' 字段的值设为完整的键。

❽ 构建 Record 实例，存储在数据库中的 key 键名下。

Record.__init__ 方法展示了一个流行的 Python 技巧。我们知道，对象的 __dict__ 属性中存储着对象的属性 —— 前提是类中没有声明 __slots__ 属性，如 9.8 节所述。因此，更新实例的 __dict__ 属性，把值设为一个映射，能快速地在那个实例中创建一堆属性。9

9 顺便说一下，2001 年 Alex Martelli 在「The simple but handy‘collector of a bunch of named stuff’class」诀窍中分享这个技巧时使用的类名是 Bunch。

我不会重述 19.1.2 节讨论的细节，不过要知道，在某些应用中，Record 类可能要处理不能作为属性名使用的键。

示例 19-9 中定义的 Record 类太简单了，因此你可能会问，为什么之前没用，而是使用更复杂的 FrozenJSON 类。原因有两个。第一，FrozenJSON 类要递归转换嵌套的映射和列表；而 Record 类不需要这么做，因为转换好的数据集中没有嵌套的映射和列表，记录中只有字符串、整数、字符串列表和整数列表。第二，FrozenJSON 类要访问内嵌的 __data 属性（值是字典，用于调用 keys 等方法），而现在我们也不需要这么做了。

Python 标准库中至少有两个与 Record 类似的类，其实例可以有任意个属性，由传给构造方法的关键字参数构建 ——multiprocessing.Namespace 类 [文档，源码] 和 argparse.Namespace 类 [文档，源码]。我之所以自己实现 Record，是为了说明一个重要的做法：在 __init__ 方法中更新实例的 __dict__ 属性。

像上面那样调整日程数据集之后，我们可以扩展 Record 类，让它提供一个有用的服务：自动获取 event 记录引用的 venue 和 speaker 记录。这与 Django ORM 访问 models.ForeignKey 字段时所做的事类似：得到的不是键，而是链接的模型对象。在下一个示例中，我们要使用特性来实现这个服务。

19.1.5　使用特性获取链接的记录

下一个版本的目标是，对于从 Shelf 对象中获取的 event 记录来说，读取它的 venue 或 speakers 属性时返回的不是编号，而是完整的记录对象。用法如示例 19-10 中的交互代码片段所示。

示例 19-10　摘自 schedule2.py 脚本的 doctest

>>> DbRecord.set_db(db) ➊ >>> event = DbRecord.fetch('event.33950') ➋ >>> event ➌ <Event 'There *Will* Be Bugs'> >>> event.venue ➍ <DbRecord serial='venue.1449'> >>> event.venue.name ➎ 'Portland 251' >>> for spkr in event.speakers: ➏ ... print('{0.serial}: {0.name}'.format(spkr)) ... speaker.3471: Anna Martelli Ravenscroft speaker.5199: Alex Martelli

❶ DbRecord 类扩展 Record 类，添加对数据库的支持：为了操作数据库，必须为 DbRecord 提供一个数据库的引用。

❷ DbRecord.fetch 类方法能获取任何类型的记录。

❸ 注意，event 是 Event 类的实例，而 Event 类扩展 DbRecord 类。

❹ event.venue 返回一个 DbRecord 实例。

❺ 现在，想找出 event.venue 的名称就容易了。这种自动取值是这个示例的目标。

❻ 还可以迭代 event.speakers 列表，获取表示各位演讲者的 DbRecord 对象。

图 19-1 绘出了本节要分析的几个类。

Record

__init__ 方法与 schedule1.py 脚本（见示例 19-9）中的一样；为了辅助测试，增加了 __eq__ 方法。

DbRecord

Record 类的子类，添加了 __db 类属性，用于设置和获取 __db 属性的 set_db 和 get_db 静态方法，用于从数据库中获取记录的 fetch 类方法，以及辅助调试和测试的 __repr__ 实例方法。

Event

DbRecord 类的子类，添加了用于获取所链接记录的 venue 和 speakers 属性，以及特殊的 __repr__ 方法。

图 19-1：改进的 Record 类和两个子类（DbRecord 和 Event）的 UML 类图

DbRecord.__db 类属性的作用是存储打开的 shelve.Shelf 数据库引用，以便在需要使用数据库的 DbRecord.fetch 方法及 Event.venue 和 Event.speakers 属性中使用。我把 __db 设为私有类属性，然后定义了普通的读值方法和设值方法，以防不小心覆盖 __db 属性的值。基于一个重要的原因，我没有使用特性去管理 __db 属性：特性是用于管理实例属性的类属性。10

10Stack Overflow 中有个题为「Class-level read only properties in Python」的问题，为类中的只读属性提供了解决方案，其中包括 Alex Martelli 提供的一个方案。这些方案要用到元类，因此学习那些方案之前可能要先读本书第 21 章。

本节的代码在本书仓库里的 schedule2.py 模块中。这个模块有 100 多行，因此我会分成几部分分析。

schedule2.py 脚本的前几个语句在示例 19-11 中。

示例 19-11　schedule2.py：导入模块，定义常量和增强的 Record 类

import warnings import inspect ➊ import osconfeed DB_NAME = 'data/schedule2_db' ➋ CONFERENCE = 'conference.115' class Record: def __init__(self, **kwargs): self.__dict__.update(kwargs) def __eq__(self, other): ➌ if isinstance(other, Record): return self.__dict__ == other.__dict__ else: return NotImplemented

➊ inspect 模块在 load_db 函数中使用（参见示例 19-14）。

➋ 因为要存储几个不同类的实例，所以我们要创建并使用不同的数据库文件；这里不用示例 19-9 中的'schedule1_db'，而是使用'schedule2_db'。

➌ __eq__ 方法对测试有重大帮助。

在 Python 2 中，只有「新式」类支持特性。在 Python 2 中定义新式类的方法是，直接或间接继承 object 类。示例 19-11 中的 Record 类是一个继承体系的基类，用到了特性；因此，在 Python 2 中声明 Record 类时，开头要这么写：11

class Record (object): # 余下的代码……

11 在 Python 3 中明确指明继承 object 类没有错，但是多余，因为现在所有类都是新式的。此例说明，与过去告别能让语言更简洁。如果要在 Python 2 和 Python 3 中运行同一段代码，应该显式继承 object 类。

接下来，schedule2.py 脚本定义了两个类 —— 一个自定义的异常类型和 DbRecord 类，参见示例 19-12。

示例 19-12　schedule2.py：MissingDatabaseError 类和 DbRecord 类

class MissingDatabaseError (RuntimeError): """需要数据库但没有指定数据库时抛出。""" ➊ class DbRecord (Record): ➋ __db = None ➌ @staticmethod ➍ def set_db (db): DbRecord.__db = db ➎ @staticmethod ➏ def get_db (): return DbRecord.__db @classmethod ➐ def fetch (cls, ident): db = cls.get_db () try: return db [ident] ➑ except TypeError: if db is None: ➒ msg = "database not set; call '{}.set_db (my_db)'" raise MissingDatabaseError (msg.format (cls.__name__)) else: ➓ raise def __repr__(self): if hasattr (self, 'serial'): ⓫ cls_name = self.__class__.__name__ return '<{} serial={!r}>'.format (cls_name, self.serial) else: return super ().__repr__() ⓬

❶ 自定义的异常通常是标志类，没有定义体。写一个文档字符串，说明异常的用途，比只写一个 pass 语句要好。

❷ DbRecord 类扩展 Record 类。

❸ __db 类属性存储一个打开的 shelve.Shelf 数据库引用。

❹ set_db 是静态方法，以此强调不管调用多少次，效果始终一样。

❺ 即使调用 Event.set_db (my_db)，__db 属性仍在 DbRecord 类中设置。

❻ get_db 也是静态方法，因为不管怎样调用，返回值始终是 DbRecord.__db 引用的对象。

❼ fetch 是类方法，因此在子类中易于定制它的行为。

❽ 从数据库中获取 ident 键对应的记录。

❾ 如果捕获到 TypeError 异常，而且 db 变量的值是 None，抛出自定义的异常，说明必须设置数据库。

❿ 否则，重新抛出 TypeError 异常，因为我们不知道怎么处理。

⓫ 如果记录有 serial 属性，在字符串表示形式中使用。

⓬ 否则，调用继承的 __repr__ 方法。

现在到这个示例的重要部分了 ——Event 类，如示例 19-13 所示。

示例 19-13　schedule2.py：Event 类

class Event(DbRecord): ➊ @property def venue(self): key = 'venue.{}'.format(self.venue_serial) return self.__class__.fetch(key) ➋ @property def speakers(self): if not hasattr(self, '_speaker_objs'): ➌ spkr_serials = self.__dict__['speakers'] ➍ fetch = self.__class__.fetch ➎ self._speaker_objs = [fetch('speaker.{}'.format(key)) for key in spkr_serials] ➏ return self._speaker_objs ➐ def __repr__(self): if hasattr(self, 'name'): ➑ cls_name = self.__class__.__name__ return '<{} {!r}>'.format(cls_name, self.name) else: return super().__repr__() ➒

❶ Event 类扩展 DbRecord 类。

❷ 在 venue 特性中使用 venue_serial 属性构建 key，然后传给继承自 DbRecord 类的 fetch 类方法（详情参见下文）。

❸ speakers 特性检查记录是否有 _speaker_objs 属性。

❹ 如果没有，直接从 __dict__ 实例属性中获取'speakers' 属性的值，防止无限递归，因为这个特性的公开名称也是 speakers。

❺ 获取 fetch 类方法的引用（稍后会说明这么做的原因）。

❻ 使用 fetch 获取 speaker 记录列表，然后赋值给 self._speaker_objs。

❼ 返回前面获取的列表。

❽ 如果记录有 name 属性，在字符串表示形式中使用。

❾ 否则，调用继承的 __repr__ 方法。

在示例 19-13 中的 venue 特性里，最后一行返回的是 self.__class__.fetch (key)，为什么不直接使用 self.fetch (key) 呢？对这个 OSCON 数据源来说，可以使用后者，因为事件记录都没有 'fetch' 键。哪怕只有一个事件记录有名为 'fetch' 的键，那么在那个 Event 实例中，self.fetch 获取的是 fetch 字段的值，而不是 Event 继承自 DbRecord 的 fetch 类方法。这个缺陷不明显，很容易被测试忽略；在生产环境中，如果会场或演讲者记录链接到那个事件记录，获取事件记录时才会暴露出来。

从数据中创建实例属性的名称时肯定有可能会引入缺陷，因为类属性（例如方法）可能被遮盖，或者由于意外覆盖现有的实例属性而丢失数据。这个问题可能是 Python 字典默认不能像 JavaScript 对象那样访问的主要原因。

如果 Record 类的行为更像映射，可以把动态的 __getattr__ 方法换成动态的 __getitem__ 方法，这样就不会出现由于覆盖或遮盖而引起的缺陷了。使用映射实现 Record 类或许更符合 Python 风格。可是，如果我采用那种方式，就发掘不了动态属性编程的技巧和陷阱了。

这个示例最后的代码是重写的 load_db 函数，如示例 19-14。

示例 19-14　schedule2.py：load_db 函数

def load_db(db): raw_data = osconfeed.load() warnings.warn('loading ' + DB_NAME) for collection, rec_list in raw_data['Schedule'].items(): record_type = collection[:-1] ➊ cls_name = record_type.capitalize() ➋ cls = globals().get(cls_name, DbRecord) ➌ if inspect.isclass(cls) and issubclass(cls, DbRecord): ➍ factory = cls ➎ else: factory = DbRecord ➏ for record in rec_list: ➐ key = '{}.{}'.format(record_type, record['serial']) record['serial'] = key db[key] = factory(**record) ➑

❶ 目前，与 schedule1.py 脚本（见示例 19-9）中的 load_db 函数一样。

❷ 把 record_type 变量的值首字母变成大写（例如，把 'event' 变成 'Event'），获取可能的类名。

❸ 从模块的全局作用域中获取那个名称对应的对象；如果找不到对象，使用 DbRecord。

❹ 如果获取的对象是类，而且是 DbRecord 的子类……

❺ …… 把对象赋值给 factory 变量。因此，factory 的值可能是 DbRecord 的任何一个子类，具体的类取决于 record_type 的值。

❻ 否则，把 DbRecord 赋值给 factory 变量。

❼ 这个 for 循环创建 key，然后保存记录，这与之前一样，不过……

❽ …… 存储在数据库中的对象由 factory 构建，factory 可能是 DbRecord 类，也可能是根据 record_type 的值确定的某个子类。

注意，只有事件类型的记录有自定义的类 ——Event。不过，如果定义了 Speaker 或 Venue 类，load_db 函数构建和保存记录时会自动使用这两个类，而不会使用默认的 DbRecord 类。

本章目前所举的示例是为了展示如何使用基本的工具，如 __getattr__ 方法、hasattr 函数、getattr 函数、@property 装饰器和 __dict__ 属性，来实现动态属性。

特性经常用于把公开的属性变成使用读值方法和设值方法管理的属性，且在不影响客户端代码的前提下实施业务规则，如下一节所述。

19.2　使用特性验证属性

目前，我们只介绍了如何使用 @property 装饰器实现只读特性。本节要创建一个可读写的特性。

19.2.1　LineItem 类第 1 版：表示订单中商品的类

假设有个销售散装有机食物的电商应用，客户可以按重量订购坚果、干果或杂粮。在这个系统中，每个订单中都有一系列商品，而每个商品都可以使用示例 19-15 中的类表示。

示例 19-15　bulkfood_v1：最简单的 LineItem 类

class LineItem: def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price

这个类很精简，不过或许太简单了。示例 19-16 揭示了一个问题。

示例 19-16　重量为负值时，金额小计为负值

>>> raisins = LineItem ('Golden raisins', 10, 6.95) >>> raisins.subtotal () 69.5>>> raisins.weight = -20 # 无效输入…… >>> raisins.subtotal () # 无效输出…… -139.0

这个示例像玩具一样，但是没有想象中的那么好玩。下面是亚马逊早期的真实故事。

我们发现顾客买书时可以把数量设为负数！然后，我们把金额打到顾客的信用卡上，苦苦等待他们把书寄出（想得美）。12

——Jeff Bezos

亚马逊创始人和 CEO

12 摘自《华尔街日报》的文章，「Birth of a Salesman」（2011 年 10 月 15 日），这是 Jeff Bezos 的原话。

这个问题怎么解决呢？我们可以修改 LineItem 类的接口，使用读值方法和设值方法管理 weight 属性。这是 Java 采用的方式，这里也完全可行。

但是，如果能直接设定商品的 weight 属性，显得更自然。此外，系统可能在生产环境中，而其他部分已经直接访问 item.weight 了。此时，符合 Python 风格的做法是，把数据属性换成特性。

19.2.2　LineItem 类第 2 版：能验证值的特性

实现特性之后，我们可以使用读值方法和设值方法，但是 LineItem 类的接口保持不变（即，设置 LineItem 对象的 weight 属性依然写成 raisins.weight = 12）。

示例 19-17 列出可读写的 weight 特性的代码。

示例 19-17　bulkfood_v2.py：定义了 weight 特性的 LineItem 类

class LineItem: def __init__(self, description, weight, price): self.description = description self.weight = weight ➊ self.price = price def subtotal(self): return self.weight * self.price @property ➋ def weight(self): ➌ return self.__weight ➍ @weight.setter ➎ def weight(self, value): if value > 0: self.__weight = value ➏ else: raise ValueError('value must be > 0') ➐

❶ 这里已经使用特性的设值方法了，确保所创建实例的 weight 属性不能为负值。

❷ @property 装饰读值方法。

❸ 实现特性的方法，其名称都与公开属性的名称一样 ——weight。

❹ 真正的值存储在私有属性 __weight 中。

❺ 被装饰的读值方法有个 .setter 属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。

❻ 如果值大于零，设置私有属性 __weight。

❼ 否则，抛出 ValueError 异常。

注意，现在不能创建重量为无效值的 LineItem 对象：

>>> walnuts = LineItem('walnuts', 0, 10.00) Traceback (most recent call last): ... ValueError: value must be > 0

现在，我们禁止用户为 weight 属性提供负值或零。虽然买家通常不能设置商品的价格，但是工作人员可能犯错，应用程序也可能有缺陷，从而导致 LineItem 对象的 price 属性为负值。为了防止出现这种情况，我们也可以把 price 属性变成特性，但是这样我们的代码中就存在一些重复。

还记得第 14 章引述 Paul Graham 的那句话吗？他说：「当我在自己的程序中发现用到了模式，我觉得这就表明某个地方出错了。」去除重复的方法是抽象。抽象特性的定义有两种方式：使用特性工厂函数，或者使用描述符类。后者更灵活，第 20 章会全面讨论。其实，特性本身就是使用描述符类实现的。不过，这里我们要继续探讨特性，实现一个特性工厂函数。

但是，在实现特性工厂函数之前，我们要深入理解特性。

19.3　特性全解析

虽然内置的 property 经常用作装饰器，但它其实是一个类。在 Python 中，函数和类通常可以互换，因为二者都是可调用的对象，而且没有实例化对象的 new 运算符，所以调用构造方法与调用工厂函数没有区别。此外，只要能返回新的可调用对象，代替被装饰的函数，二者都可以用作装饰器。

property 构造方法的完整签名如下：

property(fget=None, fset=None, fdel=None, doc=None)

所有参数都是可选的，如果没有把函数传给某个参数，那么得到的特性对象就不允许执行相应的操作。

property 类型在 Python 2.2 中引入，但是直到 Python 2.4 才出现 @ 装饰器句法，因此有那么几年，若想定义特性，则只能把存取函数传给前两个参数。

不使用装饰器定义特性的「经典」句法如示例 19-18 所示。

示例 19-18　bulkfood_v2b.py：效果与示例 19-17 一样，只不过没使用装饰器

class LineItem: def __init__(self, description, weight, price): self.description = description self.weight = weight self.price = price def subtotal(self): return self.weight * self.price def get_weight(self): ➊ return self.__weight def set_weight(self, value): ➋ if value > 0: self.__weight = value else: raise ValueError('value must be > 0') weight = property(get_weight, set_weight) ➌

❶ 普通的读值方法。

❷ 普通的设值方法。

❸ 构建 property 对象，然后赋值给公开的类属性。

某些情况下，这种经典形式比装饰器句法好；稍后讨论的特性工厂函数就是一例。但是，在方法众多的类定义体中使用装饰器的话，一眼就能看出哪些是读值方法，哪些是设值方法，而不用按照惯例，在方法名的前面加上 get 和 set。

类中的特性能影响实例属性的寻找方式，而一开始这种方式可能会让人觉得意外。下一节会详细说明。

19.3.1　特性会覆盖实例属性

特性都是类属性，但是特性管理的其实是实例属性的存取。

9.9 节说过，如果实例和所属的类有同名数据属性，那么实例属性会覆盖（或称遮盖）类属性 —— 至少通过那个实例读取属性时是这样。示例 19-19 阐明了这一点。

示例 19-19　实例属性遮盖类的数据属性

>>> class Class: # ➊ ... data = 'the class data attr' ... @property ... def prop(self): ... return 'the prop value' ... >>> obj = Class() >>> vars(obj) # ➋ {} >>> obj.data # ➌ 'the class data attr' >>> obj.data = 'bar' # ➍ >>> vars(obj) # ➎ {'data': 'bar'} >>> obj.data # ➏ 'bar' >>> Class.data # ➐ 'the class data attr'

❶ 定义 Class 类，这个类有两个类属性：data 数据属性和 prop 特性。

❷ vars 函数返回 obj 的 __dict__ 属性，表明没有实例属性。

❸ 读取 obj.data，获取的是 Class.data 的值。

❹ 为 obj.data 赋值，创建一个实例属性。

❺ 审查实例，查看实例属性。

❻ 现在读取 obj.data，获取的是实例属性的值。从 obj 实例中读取属性时，实例属性 data 会遮盖类属性 data。

❼ Class.data 属性的值完好无损。

下面尝试覆盖 obj 实例的 prop 特性。接着前面的控制台会话，输入示例 19-20 中的代码。

示例 19-20　实例属性不会遮盖类特性（接续示例 19-19）

>>> Class.prop # ➊ <property object at 0x1072b7408> >>> obj.prop # ➋ 'the prop value' >>> obj.prop = 'foo' # ➌ Traceback (most recent call last): ... AttributeError: can't set attribute >>> obj.__dict__['prop'] = 'foo' # ➍ >>> vars(obj) # ➎ { 'data': 'bar','prop': 'foo'} >>> obj.prop # ➏ 'the prop value' >>> Class.prop = 'baz' # ➐ >>> obj.prop # ➑ 'foo'

❶ 直接从 Class 中读取 prop 特性，获取的是特性对象本身，不会运行特性的读值方法。

❷ 读取 obj.prop 会执行特性的读值方法。

❸ 尝试设置 prop 实例属性，结果失败。

❹ 但是可以直接把 'prop' 存入 obj.__dict__。

❺ 可以看到，obj 现在有两个实例属性：data 和 prop。

❻ 然而，读取 obj.prop 时仍会运行特性的读值方法。特性没被实例属性遮盖。

❼ 覆盖 Class.prop 特性，销毁特性对象。

❽ 现在，obj.prop 获取的是实例属性。Class.prop 不是特性了，因此不会再覆盖 obj.prop。

最后再举一个例子，为 Class 类新添一个特性，覆盖实例属性。示例 19-21 接续示例 19-20。

示例 19-21　新添的类特性遮盖现有的实例属性（接续示例 19-20）

>>> obj.data # ➊ 'bar' >>> Class.data # ➋ 'the class data attr' >>> Class.data = property(lambda self: 'the "data" prop value') # ➌ >>> obj.data # ➍ 'the "data" prop value' >>> del Class.data # ➎ >>> obj.data # ➏ 'bar'

❶ obj.data 获取的是实例属性 data。

❷ Class.data 获取的是类属性 data。

❸ 使用新特性覆盖 Class.data。

❹ 现在，obj.data 被 Class.data 特性遮盖了。

❺ 删除特性。

❻ 现在恢复原样，obj.data 获取的是实例属性 data。

本节的主要观点是，obj.attr 这样的表达式不会从 obj 开始寻找 attr，而是从 obj.__class__ 开始，而且，仅当类中没有名为 attr 的特性时，Python 才会在 obj 实例中寻找。这条规则不仅适用于特性，还适用于一整类描述符 —— 覆盖型描述符（overriding descriptor）。第 20 章会进一步讨论描述符，那时你会发现，特性其实是覆盖型描述符。

现在回到特性。各种 Python 代码单元（模块、函数、类和方法）都可以有文档字符串。下一节说明如何把文档依附到特性上。

19.3.2　特性的文档

控制台中的 help () 函数或 IDE 等工具需要显示特性的文档时，会从特性的 __doc__ 属性中提取信息。

如果使用经典调用句法，为 property 对象设置文档字符串的方法是传入 doc 参数：

weight = property(get_weight, set_weight, doc='weight in kilograms')

使用装饰器创建 property 对象时，读值方法（有 @property 装饰器的方法）的文档字符串作为一个整体，变成特性的文档。图 19-2 显示的是从示例 19-22 里的代码中生成的帮助界面。

图 19-2：在 Python 控制台中执行 help (Foo.bar) 和 help (Foo) 命令时的截图；源码在示例 19-22 中

示例 19-22　特性的文档

class Foo: @property def bar(self): '''The bar attribute''' return self.__dict__['bar'] @bar.setter def bar(self, value): self.__dict__['bar'] = value

至此，我们介绍了特性的重要知识。下面回过头来解决前面遇到的问题：保护 LineItem 对象的 weight 和 price 属性，只允许设为大于零的值；但是，不用手动实现两对几乎一样的读值方法和设值方法。

19.4　定义一个特性工厂函数

我们将定义一个名为 quantity 的特性工厂函数，取这个名字是因为，在这个应用中要管理的属性表示不能为负数或零的量。示例 19-23 是 LineItem 类的简洁版，用到了 quantity 特性的两个实例：一个用于管理 weight 属性，另一个用于管理 price 属性。

示例 19-23　bulkfood_v2prop.py：使用特性工厂函数 quantity

class LineItem: weight = quantity('weight') ➊ price = quantity('price') ➋ def __init__(self, description, weight, price): self.description = description self.weight = weight ➌ self.price = price def subtotal(self): return self.weight * self.price ➍

❶ 使用工厂函数把第一个自定义的特性 weight 定义为类属性。

❷ 第二次调用，构建另一个自定义的特性，price。

❸ 这里，特性已经激活，确保不能把 weight 设为负数或零。

❹ 这里也用到了特性，使用特性获取实例中存储的值。

前文说过，特性是类属性。构建各个 quantity 特性对象时，要传入 LineItem 实例属性的名称，让特性管理。可惜，这一行要两次输入单词 weight：

weight = quantity('weight')

这里很难避免重复输入，因为特性根本不知道要绑定哪个类属性名。记住，赋值语句的右边先计算，因此调用 quantity () 时，weight 类属性还不存在。

如果想改进 quantity 特性，避免用户重复输入属性名，那么对元编程来说是个挑战。第 20 章会介绍一种变通方法，真正的解决方法在第 21 章说明，因为要么得使用类装饰器，要么得使用元类。

示例 19-24 列出 quantity 特性工厂函数的实现。13

13 这段代码改编自 David Beazley 与 Brian K. Jones 的《Python Cookbook（第 3 版）中文版》一书中的「9.21 避免出现重复的属性方法」一节。

示例 19-24　bulkfood_v2prop.py：quantity 特性工厂函数

def quantity(storage_name): ➊ def qty_getter(instance): ➋ return instance.__dict__[storage_name] ➌ def qty_setter(instance, value): ➍ if value > 0: instance.__dict__[storage_name] = value ➎ else: raise ValueError('value must be > 0') return property(qty_getter, qty_setter) ➏

❶ storage_name 参数确定各个特性的数据存储在哪儿；对 weight 特性来说，存储的名称是 'weight'。

❷ qty_getter 函数的第一个参数可以命名为 self，但是这么做很奇怪，因为 qty_getter 函数不在类定义体中；instance 指代要把属性存储其中的 LineItem 实例。

❸ qty_getter 引用了 storage_name，把它保存在这个函数的闭包里；值直接从 instance.__dict__ 中获取，为的是跳过特性，防止无限递归。

❹ 定义 qty_setter 函数，第一个参数也是 instance。

❺ 值直接存到 instance.__dict__ 中，这也是为了跳过特性。

❻ 构建一个自定义的特性对象，然后将其返回。

示例 19-24 中值得仔细分析的代码是与 storage_name 变量相关的部分。使用传统方式定义特性时，用于存储值的属性名硬编码在读值方法和设值方法中。但是，这里的 qty_getter 和 qty_setter 函数是通用的，要依靠 storage_name 变量判断从 __dict__ 中获取哪个属性，或者设置哪个属性。每次调用 quantity 工厂函数构建属性时，都要把 storage_name 参数设为独一无二的值。

在工厂函数的最后一行，我们使用 property 对象包装 qty_getter 和 qty_setter 函数。需要运行这两个函数时，它们会从闭包中读取 storage_name，确定从哪里获取属性的值，或者在哪里存储属性的值。

在示例 19-25 中，我创建并审查了一个 LineItem 示例，说明存储值的是哪个属性。

示例 19-25　bulkfood_v2prop.py：quantity 特性工厂函数

>>> nutmeg = LineItem('Moluccan nutmeg', 8, 13.95) >>> nutmeg.weight, nutmeg.price ➊ (8, 13.95) >>> sorted(vars(nutmeg).items()) ➋ [('description', 'Moluccan nutmeg'), ('price', 13.95), ('weight', 8)]

➊ 通过特性读取 weight 和 price，这会遮盖同名实例属性。

➋ 使用 vars 函数审查 nutmeg 实例，查看真正用于存储值的实例属性。

注意，工厂函数构建的特性利用了 19.3.1 节所述的行为：weight 特性覆盖了 weight 实例属性，因此对 self.weight 或 nutmeg.weight 的每个引用都由特性函数处理，只有直接存取 __dict__ 属性才能跳过特性的处理逻辑。

示例 19-25 中的代码有点难理解，不过够简洁，与示例 19-17 中使用装饰器声明读值方法和设值方法的代码行数一样，但是那里只定义了 weight 特性。示例 19-23 中定义的 LineItem 类没有干扰人的读值方法和设值方法，看起来舒服多了。

在真实的系统中，分散在多个类中的多个字段可能要做同样的验证，此时最好把 quantity 工厂函数放在实用工具模块中，以便重复使用。最终可能要重构那个简单的工厂函数，改成更易扩展的描述符类，然后使用专门的子类执行不同的验证。在第 20 章中，我们会这么做。

下面要分析删除属性的问题，以此结束对特性的讨论。

19.5　处理属性删除操作

学过 Python 教程，我们知道，对象的属性可以使用 del 语句删除：

del my_object.an_attribute

其实，使用 Python 编程时不常删除属性，通过特性删除属性更少见。但是，Python 支持这么做，我可以虚构一个示例，演示这种处理方式。

定义特性时，可以使用 @my_propety.deleter 装饰器包装一个方法，负责删除特性管理的属性。下面兑现承诺，虚构一个示例，说明如何定义特性删值方法，如示例 19-26 所示。

示例 19-26　blackknight.py：灵感来自电影《巨蟒与圣杯》中的黑衣骑士角色

class BlackKnight: def __init__(self): self.members = ['an arm', 'another arm', 'a leg', 'another leg'] self.phrases = ["'Tis but a scratch.", "It's just a flesh wound.", "I'm invincible!", "All right, we'll call it a draw."] @property def member(self): print('next member is:') return self.members[0] @member.deleter def member(self): text = 'BLACK KNIGHT (loses {})\n-- {}' print(text.format(self.members.pop(0), self.phrases.pop(0)))

blackknight.py 脚本的 doctest 在示例 19-27 中。

示例 19-27　blackknight.py：示例 19-26 的 doctest（黑衣骑士从不屈服）

>>> knight = BlackKnight() >>> knight.member next member is: 'an arm' >>> del knight.member BLACK KNIGHT (loses an arm) -- 'Tis but a scratch. >>> del knight.member BLACK KNIGHT (loses another arm) -- It's just a flesh wound. >>> del knight.member BLACK KNIGHT (loses a leg) -- I'm invincible! >>> del knight.member BLACK KNIGHT (loses another leg) -- All right, we'll call it a draw.

在不使用装饰器的经典调用句法中，fdel 参数用于设置删值函数。例如，在 BlackKnight 类的定义体中可以像下面这样创建 member 特性：

member = property(member_getter, fdel=member_deleter)

如果不使用特性，还可以实现低层特殊的 __delattr__ 方法处理删除属性的操作，参见 19.6.3 节。留给喜欢拖延的读者一个练习：虚构一个类，定义 __delattr__ 方法。

特性是个强大的功能，不过有时更适合使用简单的或底层的替代方案。在本章的最后一节中，我们将回顾 Python 为动态属性编程提供的部分核心 API。

19.6　处理属性的重要属性和函数

本章及本书前面的章节多次用到 Python 为处理动态属性而提供的内置函数和特殊的方法。这些函数和方法的文档散布在官方文档中，因此我专门写了一节集中介绍它们。

19.6.1　影响属性处理方式的特殊属性

后面几节中的很多函数和特殊方法，其行为受下述 3 个特殊属性的影响。

__class__

对象所属类的引用（即 obj.__class__ 与 type (obj) 的作用相同）。Python 的某些特殊方法，例如 __getattr__，只在对象的类中寻找，而不在实例中寻找。

__dict__

一个映射，存储对象或类的可写属性。有 __dict__ 属性的对象，任何时候都能随意设置新属性。如果类有 __slots__ 属性，它的实例可能没有 __dict__ 属性。参见下面对 __slots__ 属性的说明。

__slots__

类可以定义这个这属性，限制实例能有哪些属性。__slots__ 属性的值是一个字符串组成的元组，指明允许有的属性。14 如果 __slots__ 中没有 '__dict__'，那么该类的实例没有 __dict__ 属性，实例只允许有指定名称的属性。

14Alex Martelli 指出，__slots__ 属性的值虽然可以是一个列表，但是最好始终使用元组，因为处理完类的定义体之后再修改 __slots__ 列表没有任何作用，所以使用可变的序列容易让人误解。

19.6.2　处理属性的内置函数

下述 5 个内置函数对对象的属性做读、写和内省操作。

dir([object])

列出对象的大多数属性。官方文档说，dir 函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组「重要的」属性名。dir 函数能审查有或没有 __dict__ 属性的对象。dir 函数不会列出 __dict__ 属性本身，但会列出其中的键。dir 函数也不会列出类的几个特殊属性，例如 __mro__、__bases__ 和 __name__。如果没有指定可选的 object 参数，dir 函数会列出当前作用域中的名称。

getattr(object, name[, default])

从 object 对象中获取 name 字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，getattr 函数抛出 AttributeError 异常，或者返回 default 参数的值（如果设定了这个参数的话）。

hasattr(object, name)

如果 object 对象中存在指定的属性，或者能以某种方式（例如继承）通过 object 对象获取指定的属性，返回 True。文档说道：「这个函数的实现方法是调用 getattr (object, name) 函数，看看是否抛出 AttributeError 异常。」

setattr(object, name, value)

把 object 对象指定属性的值设为 value，前提是 object 对象能接受那个值。这个函数可能会创建一个新属性，或者覆盖现有的属性。

vars([object])

返回 object 对象的 __dict__ 属性；如果实例所属的类定义了 __slots__ 属性，实例没有 __dict__ 属性，那么 vars 函数不能处理那个实例（相反，dir 函数能处理这样的实例）。如果没有指定参数，那么 vars () 函数的作用与 locals () 函数一样：返回表示本地作用域的字典。

19.6.3　处理属性的特殊方法

在用户自己定义的类中，下述特殊方法用于获取、设置、删除和列出属性。

使用点号或内置的 getattr、hasattr 和 setattr 函数存取属性都会触发下述列表中相应的特殊方法。但是，直接通过实例的 __dict__ 属性读写属性不会触发这些特殊方法 —— 如果需要，通常会使用这种方式跳过特殊方法。

Python 文档「Data model」一章中的「3.3.9. Special method lookup」一节警告说：

对用户自己定义的类来说，如果隐式调用特殊方法，仅当特殊方法在对象所属的类型上定义，而不是在对象的实例字典中定义时，才能确保调用成功。

也就是说，要假定特殊方法从类上获取，即便操作目标是实例也是如此。因此，特殊方法不会被同名实例属性遮盖。

在下述示例中，假设有个名为 Class 的类，obj 是 Class 类的实例，attr 是 obj 的属性。

不管是使用点号存取属性，还是使用 19.6.2 节列出的某个内置函数，都会触发下述特殊方法中的一个。例如，obj.attr 和 getattr (obj, 'attr', 42) 都会触发 Class.__getattribute__(obj, 'attr') 方法。

__delattr__(self, name)

只要使用 del 语句删除属性，就会调用这个方法。例如，del obj.attr 语句触发 Class.__delattr__(obj, 'attr') 方法。

__dir__(self)

把对象传给 dir 函数时调用，列出属性。例如，dir (obj) 触发 Class.__dir__(obj) 方法。

__getattr__(self, name)

仅当获取指定的属性失败，搜索过 obj、Class 和超类之后调用。表达式 obj.no_such_attr、getattr (obj, 'no_such_attr') 和 hasattr (obj, 'no_such_attr') 可能会触发 Class.__getattr__(obj, 'no_such_attr') 方法，但是，仅当在 obj、Class 和超类中找不到指定的属性时才会触发。

__getattribute__(self, name)

尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。点号与 getattr 和 hasattr 内置函数会触发这个方法。调用 __getattribute__ 方法且抛出 AttributeError 异常时，才会调用 __getattr__ 方法。为了在获取 obj 实例的属性时不导致无限递归，__getattribute__ 方法的实现要使用 super ().__getattribute__(obj, name)。

__setattr__(self, name, value)

尝试设置指定的属性时总会调用这个方法。点号和 setattr 内置函数会触发这个方法。例如，obj.attr = 42 和 setattr (obj, 'attr', 42) 都会触发 Class.__setattr__(obj, ‘attr’, 42) 方法。

其实，特殊方法 __getattribute__ 和 __setattr__ 不管怎样都会调用，几乎会影响每一次属性存取，因此比 __getattr__ 方法（只处理不存在的属性名）更难正确使用。与定义这些特殊方法相比，使用特性或描述符相对不易出错。

我们对特性、特殊方法和其他动态属性编程技术的讨论到此结束。

19.7　本章小结

本章的话题是动态属性编程。我们首先举了几个实例，定义了几个简单的类，简化处理 JSON 数据源的方式。第一个示例是 FrozenJSON 类，把嵌套的字典和列表转换成嵌套的 FrozenJSON 实例和实例列表。FrozenJSON 类的代码展示了如何使用特殊的 __getattr__ 方法在读取属性时即时转换数据结构。FrozenJSON 类的最后一版展示了如何使用 __new__ 构造方法把一个类转换成一个灵活的对象工厂函数，不受实例本身的限制。

然后，我们把 JSON 源转换成一个 shelve.Shelf 数据库，把序列化的 Record 实例存在里面。第 1 版 Record 类只有几行代码，介绍了「集束」惯用法：使用传给 __init__ 方法的关键字参数，调用 self.__dict__.update (**kwargs) 构建任意属性。这个示例的第 2 版对 Record 类做了扩展：一个是 DbRecord 类，集成数据库操作；另一个是 Event 类，通过特性自动获取所链接的记录。

接着，本章讨论了特性。我们定义的 LineItem 类中有个特性，确保 weight 属性的值不能是对业务没有意义的负数或零。然后，我们深入说明了特性的句法和语义。随后，创建了一个特性工厂函数，在不定义多个读值方法和设值方法的前提下，对 weight 和 price 属性做相同的验证。那个特性工厂函数用到了几个精妙的概念，例如闭包和被特性覆盖的实例属性，提供了优雅的通用方案，代码行数与用手工编码的特性来验证单个属性的一样多。

最后，我们简要说明了如何使用特性处理删除属性的操作，随后概览了 Python 核心语言为支持属性元编程而提供的重要的特殊属性、内置函数和特殊方法。

19.8　延伸阅读

属性处理和内置的内省函数的官方文档在 Python 标准库文档的第 2 章中，题为「Built-in Functions」。相关的特殊方法和特殊的 __slots__ 属性在 Python 语言参考手册中的「3.3.2. Customizing attribute access」一节里说明。调用特殊方法会跳过实例的语意原因在「3.3.9. Special method lookup」一节中说明。在 Python 标准库文档的第 4 章「Built-in Types」里，「4.13. Special Attributes」一节说明了 __class__ 和 __dict__ 属性。

David Beazley 与 Brian K. Jones 的《Python Cookbook（第 3 版）中文版》一书中有几个诀窍涉及本章的话题，不过我要重点提出三个：「8.8 在子类中扩展属性」，解决了在继承自超类的特性中覆盖方法这个棘手问题；「8.15 委托属性的访问」，实现了一个代理类，展示了本书 19.6.3 节所列的大多数特殊方法；还有出色的「9.21 避免出现重复的属性方法」一节，示例 19-24 中定义的特性工厂函数就以那一节为基础。

Alex Martelli 写的《Python 技术手册（第 2 版）》只涵盖了 Python 2.5，不过基础知识也适用于 Python 3。他写书的风格严谨而客观，讲到特性时，只用了 3 页，但这是由于那本书采用了符合逻辑的行文方式：之前的 15 页已经对 Python 的类做了详尽的说明，包括描述符，而特性就是使用描述符实现的。因此讲到特性时，他可以在 3 页的篇幅中发表很多见解，例如本章开篇引用的那句话。

本章开头引用的统一访问原则定义出自 Bertrand Meyer 的优秀著作 Object-Oriented Software Construction, Second Edition（Prentice-Hall 出版社）。这本书超过 1250 页，我承认我没有读完，不过前六章对面向对象分析和设计相关概念的介绍是我见过最好的之一，第 11 章介绍了契约式设计（Meyer 发明了这种设计方法，创造了这个术语），第 35 章阐述了他对重要的面向对象语言的评价，包括 Simula、Smalltalk、CLOS（Lisp 的面向对象扩展）、 Objective-C、C++ 和 Java，还对其他语言做了简要评述。他还发明了伪伪代码（pseudo- pseudocode），直到那本书的最后一页他才披露，全书用于编写伪代码的句法其实出自 Eiffel 语言。

杂谈

站在美学的角度来看，Meyer 提出的统一访问原则（Unifrom Access Principle，喜欢简称的人有时称之为 UAP）很吸引人。作为使用 API 的程序员，我不应该关心 coconut.price 只是获取数据属性还是执行计算。但是，作为消费者和公民，我应该关心：在电子商务发达的今天，coconut.price 的值通常取决于这个问题由谁提出，因此它绝不仅仅是个数据属性。其实，如果查询来自网店外部（例如比价引擎），价格通常会低一些。显然，这对喜欢浏览特定网店的忠实消费者来说，利益受到了损害。但是我不同意。

前一段离题了，可是却提出了与编程有关的问题：虽然统一访问原则在理想的世界中完全合理，但在现实中，API 的用户可能需要知道读取 coconut.price 是否太耗资源或时间。Ward Cunningham 的维基对软件工程方面的话题有很多独到的见解，他对统一访问原则的功过也做了富有洞察力的论述。

在面向对象编程语言中，是否遵守统一访问原则通常体现在句法上：究竟是读取公开的数据属性，还是调用读值方法和设值方法。

Smalltalk 和 Ruby 使用简单而优雅的方式解决这个问题：根本不支持公开的数据属性。在这两门语言中，所有实例属性都是私有的，因此必须通过方法来存取。不过，这两门语言的句法把这个过程变得毫不费力：在 Ruby 中，coconut.price 会调用读值方法 price；在 Smalltalk 中，只需使用 coconut price。

Java 采用的是另一种方式，让程序员在四种访问级别修饰符中选择。15 不过，普通大众并不认同 Java 设计者制定的这种句法。Java 世界的人都认为，属性应该是私有的，但是每一次都要写出 private，因为这不是默认的访问级别。如果所有属性都是私有的，那么从类外部访问属性就必须使用存取方法。Java IDE 提供了自动生成存取方法的快捷方式。但是，六个月后不得不阅读代码时，IDE 没有多大帮助。我们要在众多什么也没做的存取方法中找出所需的那一个，添加实现某些业务逻辑所需的值。

Alex Martelli 把存取方法称为「愚蠢的惯用法」，这道出了 Python 社区中大多数人的心声。他举了下面两个例子，外观差异很大，但是作用相同：16

someInstance.widgetCounter += 1 # 而不用…… someInstance.setWidgetCounter (someInstance.getWidgetCounter () + 1)

设计 API 时，我有时会想，能否把没有参数（除了 self）、返回一个值（除了 None）的纯函数（即没有副作用）替换成只读特性。在本章中，LineItem.subtotal 方法（如示例 19-23 所示）就可以替换成只读特性。当然，用于修改对象的方法（如 my_list.clear ()）不在此列。把这样的方法变成特性是个糟糕的想法，因为直接访问 my_list.clear 就会删除列表中的内容。

在 GPIO 库 Pingo.io（3.4.2 节提过）中，多数用户级别的 API 都基于特性实现。例如，为了读取模拟针脚的当前值，用户要编写 pin.value；为了设置数字针脚的模式，要写成 pin.mode = OUT。在背后，读取模拟针脚的值或设置数字针脚的模式可能涉及大量代码，这取决于具体的主板驱动。我们决定在 Pingo 中使用特性，是因为我们想让 API 用起来舒服，即便是在 iPython Notebook 等交互环境中也是如此，而且我们觉得 pin.mode = OUT 看起来和输入起来都比 pin.set_mode (OUT) 容易。

我觉得 Smalltalk 和 Ruby 的处理方式很简洁，但也认为 Python 的处理方式比 Java 更合理。一开始，我们可以从简单的方式入手，把数据成员定义为公开的属性，因为我们知道这些属性可以使用特性（或下一章讨论的描述符）来包装。

__new__ 方法比 new 运算符好

在 Python 中还有一处体现了统一访问原则（或者它的变体）：函数调用和对象实例化使用相同的句法 ——my_obj = foo ()，其中 foo 是类或其他可调用的对象。

受 C++ 句法影响的其他语言提供了 new 运算符，致使实例化不像是调用。大多数时候，API 的用户不关心 foo 是函数还是类。直到最近，我才意识到，property 是个函数。在常规的用法中，这没什么区别。

把构造方法替换成工厂方法有很多充足的理由。17 一个重要的原因是，通过返回之前构建的实例，限制实例的数量（体现了单例模式）。有个相关的功能是，缓存构建过程开销大的对象。此外，有时便于根据指定的参数返回不同类型的对象。

定义构造方法较为简单；提供工厂方法虽然增加了灵活性，但是要编写更多的代码。在有 new 运算符的语言中，API 的设计者必须提前决定：究竟是坚持使用简单的构造方法，还是投入工厂方法的怀抱。如果一开始选择错了，那么修正的代价可能很大 —— 这一切都因为 new 是运算符。

有时可能更适合走另一条路，把简单的函数换成类。

在 Python 中，很多情况下类和函数可以互换。这不仅是因为 Python 没有 new 运算符，还因为有特殊的 __new__ 方法，可以把类变成工厂方法，生成不同类型的对象（如 19.1.3 节所述），或者返回事先构建好的实例，而不是每次都创建一个新实例。

如果「PEP 8—Style Guide for Python Code」不推荐类名使用驼峰式（CamelCase），那么函数与类的对偶性更易于使用。不过，标准库中有很多类的名称是小写的（例如 property、str、defaultdict，等等）。因此，使用小写的类名可能是个特色，而不是缺陷。但是，不管怎么看，Python 标准库在类名大小写上的不一致会导致可用性问题。

虽然调用函数与调用类没有区别，但是最好知道哪个是哪个，因为类还有一个功能：子类化。因此，我编写的每个类都使用驼峰式名称，而且希望 Python 标准库中的所有类也使用这一约定。我在盯着你呢，collections.OrderedDict 和 collections.defaultdict。

15 包括没有名称的默认级别，Java 教程称其为「包级私有」。

16《Python 技术手册（第 2 版）》第 101 页。

17 我将要提到的原因出自 Jonathan Amsterdam 发布在 Dr. Dobbs Journal 中的一篇文章，题为「Java's new Considered Harmful」，以及 Joshua Bloch 写的获奖图书 Effective Java 中的第一条，「考虑用静态工厂方法代替构造函数」。

