第 16 章　协程

如果 Python 书籍有一定的指导作用，那么（协程就是）文档最匮乏、最鲜为人知的 Python 特性，因此表面上看是最无用的特性。

——David Beazley

Python 图书作者

字典为动词「to yield」给出了两个释义：产出和让步。对于 Python 生成器中的 yield 来说，这两个含义都成立。yield item 这行代码会产出一个值，提供给 next (...) 的调用方；此外，还会作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用 next ()。调用方会从生成器中拉取值。

从句法上看，协程与生成器类似，都是定义体中包含 yield 关键字的函数。可是，在协程中，yield 通常出现在表达式的右边（例如，datum = yield），可以产出值，也可以不产出 —— 如果 yield 关键字后面没有表达式，那么生成器产出 None。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 .send (datum) 方法，而不是 next (...) 函数。通常，调用方会把值推送给协程。

yield 关键字甚至还可以不接收或传出数据。不管数据如何流动，yield 都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。

从根本上把 yield 视作控制流程的方式，这样就好理解协程了。

本书前面介绍的生成器函数作用不大，但是进行一系列功能改进之后，得到了 Python 协程。了解 Python 协程的进化过程有助于理解各个阶段改进的功能和复杂度。

本章首先要简单介绍生成器如何变成协程，然后再进入核心内容。本章涵盖以下话题：

生成器作为协程使用时的行为和状态

使用装饰器自动预激协程

调用方如何使用生成器对象的 .close () 和 .throw (...) 方法控制协程

协程终止时如何返回值

yield from 新句法的用途和语义

使用案例 —— 使用协程管理仿真系统中的并发活动

16.1　生成器如何进化成协程

协程的底层架构在「PEP 342—Coroutines via Enhanced Generators」中定义，并在 Python 2.5（2006 年）实现了。自此之后，yield 关键字可以在表达式中使用，而且生成器 API 中增加了 .send (value) 方法。生成器的调用方可以使用 .send (...) 方法发送数据，发送的数据会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。

除了 .send (...) 方法，PEP 342 还添加了 .throw (...) 和 .close () 方法：前者的作用是让调用方抛出异常，在生成器中处理；后者的作用是终止生成器。下一节和 16.5 节会说明这些方法。

协程最近的演进来自 Python 3.3（2012 年）实现的「PEP 380—Syntax for Delegating to a Subgenerator」。PEP 380 对生成器函数的句法做了两处改动，以便更好地作为协程使用。

现在，生成器可以返回一个值；以前，如果在生成器中给 return 语句提供值，会抛出 SyntaxError 异常。

新引入了 yield from 句法，使用它可以把复杂的生成器重构成小型的嵌套生成器，省去了之前把生成器的工作委托给子生成器所需的大量样板代码。

这两个最新的改动分别在 16.6 节和 16.7 节讨论。

按照本书的惯例，我们先从基本概念和示例入手，然后再深入越来越难以理解的特性。

16.2　用作协程的生成器的基本行为

示例 16-1 展示了协程的行为。

示例 16-1　可能是协程最简单的使用演示

>>> def simple_coroutine(): # ➊ ... print('-> coroutine started') ... x = yield # ➋ ... print('-> coroutine received:', x) ... >>> my_coro = simple_coroutine() >>> my_coro # ➌ <generator object simple_coroutine at 0x100c2be10> >>> next(my_coro) # ➍ -> coroutine started >>> my_coro.send(42) # ➎ -> coroutine received: 42 Traceback (most recent call last): # ➏ ... StopIteration

❶ 协程使用生成器函数定义：定义体中有 yield 关键字。

❷ yield 在表达式中使用；如果协程只需从客户那里接收数据，那么产出的值是 None—— 这个值是隐式指定的，因为 yield 关键字右边没有表达式。

❸ 与创建生成器的方式一样，调用函数得到生成器对象。

❹ 首先要调用 next (...) 函数，因为生成器还没启动，没在 yield 语句处暂停，所以一开始无法发送数据。

❺ 调用这个方法后，协程定义体中的 yield 表达式会计算出 42；现在，协程会恢复，一直运行到下一个 yield 表达式，或者终止。

❻ 这里，控制权流动到协程定义体的末尾，导致生成器像往常一样抛出 StopIteration 异常。

协程可以身处四个状态中的一个。当前状态可以使用 inspect.getgeneratorstate (...) 函数确定，该函数会返回下述字符串中的一个。

'GEN_CREATED'

等待开始执行。

'GEN_RUNNING'

解释器正在执行。1

1 只有在多线程应用中才能看到这个状态。此外，生成器对象在自己身上调用 getgeneratorstate 函数也行，不过这样做没什么用。

'GEN_SUSPENDED'

在 yield 表达式处暂停。

'GEN_CLOSED'

执行结束。

因为 send 方法的参数会成为暂停的 yield 表达式的值，所以，仅当协程处于暂停状态时才能调用 send 方法，例如 my_coro.send (42)。不过，如果协程还没激活（即，状态是 'GEN_CREATED'），情况就不同了。因此，始终要调用 next (my_coro) 激活协程 —— 也可以调用 my_coro.send (None)，效果一样。

如果创建协程对象后立即把 None 之外的值发给它，会出现下述错误：

>>> my_coro = simple_coroutine() >>> my_coro.send(1729) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can't send non-None value to a just-started generator

注意错误消息，它表述得相当清楚。

最先调用 next (my_coro) 函数这一步通常称为「预激」（prime）协程（即，让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）。

下面举个产出多个值的例子，以便更好地理解协程的行为，如示例 16-2 所示。

示例 16-2　产出两个值的协程

>>> def simple_coro2(a): ... print('-> Started: a =', a) ... b = yield a ... print('-> Received: b =', b) ... c = yield a + b ... print('-> Received: c =', c) ... >>> my_coro2 = simple_coro2(14) >>> from inspect import getgeneratorstate >>> getgeneratorstate(my_coro2) ➊ 'GEN_CREATED' >>> next(my_coro2) ➋ -> Started: a = 14 14 >>> getgeneratorstate(my_coro2) ➌ 'GEN_SUSPENDED' >>> my_coro2.send(28) ➍ -> Received: b = 28 42 >>> my_coro2.send(99) ➎ -> Received: c = 99 Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration >>> getgeneratorstate(my_coro2) ➏ 'GEN_CLOSED'

❶ inspect.getgeneratorstate 函数指明，处于 GEN_CREATED 状态（即协程未启动）。

❷ 向前执行协程到第一个 yield 表达式，打印 -> Started: a = 14 消息，然后产出 a 的值，并且暂停，等待为 b 赋值。

❸ getgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态（即协程在 yield 表达式处暂停）。

❹ 把数字 28 发给暂停的协程；计算 yield 表达式，得到 28，然后把那个数绑定给 b。打印 -> Received: b = 28 消息，产出 a + b 的值（42），然后协程暂停，等待为 c 赋值。

❺ 把数字 99 发给暂停的协程；计算 yield 表达式，得到 99，然后把那个数绑定给 c。打印 -> Received: c = 99 消息，然后协程终止，导致生成器对象抛出 StopIteration 异常。

❻ getgeneratorstate 函数指明，处于 GEN_CLOSED 状态（即协程执行结束）。

关键的一点是，协程在 yield 关键字所在的位置暂停执行。前面说过，在赋值语句中，= 右边的代码在赋值之前执行。因此，对于 b = yield a 这行代码来说，等到客户端代码再激活协程时才会设定 b 的值。这种行为要花点时间才能习惯，不过一定要理解，这样才能弄懂异步编程中 yield 的作用（后文探讨）。

simple_coro2 协程的执行过程分为 3 个阶段，如图 16-1 所示。

(1) 调用 next (my_coro2)，打印第一个消息，然后执行 yield a，产出数字 14。

(2) 调用 my_coro2.send (28)，把 28 赋值给 b，打印第二个消息，然后执行 yield a + b，产出数字 42。

(3) 调用 my_coro2.send (99)，把 99 赋值给 c，打印第三个消息，协程终止。

图 16-1：执行 simple_coro2 协程的 3 个阶段（注意，各个阶段都在 yield 表达式中结束，而且下一个阶段都从那一行代码开始，然后再把 yield 表达式的值赋给变量）

下面来看一个稍微复杂的协程示例。

16.3　示例：使用协程计算移动平均值

第 7 章讨论闭包时，我们分析了如何使用对象计算移动平均值：示例 7-8 定义的是一个简单的类；示例 7-14 定义的是一个高阶函数，用于生成一个闭包，在多次调用之间跟踪 total 和 count 变量的值。示例 16-3 展示如何使用协程实现相同的功能。2

2 这个示例的灵感来自 Jacob Holm 在 Python-ideas 邮件列表中发布的一个代码片段，他发布的消息题为「Yield-From: Finalization guarantees」。在那个消息的后续回复中，那段代码有几个变体。Holm 在 003912 号消息中进一步说明了自己的想法。

示例 16-3　coroaverager0.py：定义一个计算移动平均值的协程

def averager(): total = 0.0 count = 0 average = None while True: ➊ term = yield average ➋ total += term count += 1 average = total/count

➊ 这个无限循环表明，只要调用方不断把值发给这个协程，它就会一直接收值，然后生成结果。仅当调用方在协程上调用 .close () 方法，或者没有对协程的引用而被垃圾回收程序回收时，这个协程才会终止。

➋ 这里的 yield 表达式用于暂停执行协程，把结果发给调用方；还用于接收调用方后面发给协程的值，恢复无限循环。

使用协程的好处是，total 和 count 声明为局部变量即可，无需使用实例属性或闭包在多次调用之间保持上下文。示例 16-4 是使用 averager 协程的 doctest。

示例 16-4　coroaverager0.py：示例 16-3 中定义的移动平均值协程的 doctest

>>> coro_avg = averager() ➊ >>> next(coro_avg) ➋ >>> coro_avg.send(10) ➌ 10.0 >>> coro_avg.send(30) 20.0 >>> coro_avg.send(5) 15.0

❶ 创建协程对象。

❷ 调用 next 函数，预激协程。

❸ 计算移动平均值：多次调用 .send (...) 方法，产出当前的平均值。

在上述 doctest 中（示例 16-4），调用 next (coro_avg) 函数后，协程会向前执行到 yield 表达式，产出 average 变量的初始值 ——None，因此不会出现在控制台中。此时，协程在 yield 表达式处暂停，等到调用方发送值。coro_avg.send (10) 那一行发送一个值，激活协程，把发送的值赋给 term，并更新 total、count 和 average 三个变量的值，然后开始 while 循环的下一次迭代，产出 average 变量的值，等待下一次为 term 变量赋值。

细心的读者可能迫切地想知道如何终止执行 averager 实例（如 coro_avg），因为定义体中有个无限循环。16.5 节会讨论这个话题。

讨论如何终止协程之前，我们要先谈谈如何启动协程。使用协程之前必须预激，可是这一步容易忘记。为了避免忘记，可以在协程上使用一个特殊的装饰器。接下来介绍这样一个装饰器。

16.4　预激协程的装饰器

如果不预激，那么协程没什么用。调用 my_coro.send (x) 之前，记住一定要调用 next (my_coro)。为了简化协程的用法，有时会使用一个预激装饰器。示例 16-5 中的 coroutine 装饰器是一例。3

3 网上有多个类似的装饰器。这个改自 ActiveState 中的一个诀窍 ——「Pipeline made of coroutines」，作者是 Chaobin Tang，而他是受到了 David Beazley 的启发。

示例 16-5　coroutil.py：预激协程的装饰器

from functools import wraps def coroutine (func): """装饰器：向前执行到第一个`yield`表达式，预激`func`""" @wraps (func) def primer (*args,**kwargs): ➊ gen = func (*args,**kwargs) ➋ next (gen) ➌ return gen ➍ return primer

❶ 把被装饰的生成器函数替换成这里的 primer 函数；调用 primer 函数时，返回预激后的生成器。

❷ 调用被装饰的函数，获取生成器对象。

❸ 预激生成器。

❹ 返回生成器。

示例 16-6 展示 @coroutine 装饰器的用法。请与示例 16-3 对比。

示例 16-6　coroaverager1.py：使用示例 16-5 中定义的 @coroutine 装饰器定义并测试计算移动平均值的协程

"""用于计算移动平均值的协程 >>> coro_avg = averager () ➊>>> from inspect import getgeneratorstate >>> getgeneratorstate (coro_avg) ➋ 'GEN_SUSPENDED' >>> coro_avg.send (10) ➌ 10.0 >>> coro_avg.send (30) 20.0 >>> coro_avg.send (5) 15.0""" from coroutil import coroutine ➍ @coroutine ➎ def averager (): ➏ total = 0.0 count = 0 average = None while True: term = yield average total += term count += 1 average = total/count

❶ 调用 averager () 函数创建一个生成器对象，在 coroutine 装饰器的 primer 函数中已经预激了这个生成器。

❷ getgeneratorstate 函数指明，处于 GEN_SUSPENDED 状态，因此这个协程已经准备好，可以接收值了。

❸ 可以立即开始把值发给 coro_avg—— 这正是 coroutine 装饰器的目的。

❹ 导入 coroutine 装饰器。

❺ 把装饰器应用到 averager 函数上。

❻ 函数的定义体与示例 16-3 完全一样。

很多框架都提供了处理协程的特殊装饰器，不过不是所有装饰器都用于预激协程，有些会提供其他服务，例如勾入事件循环。比如说，异步网络库 Tornado 提供了 tornado.gen 装饰器。

使用 yield from 句法（参见 16.7 节）调用协程时，会自动预激，因此与示例 16-5 中的 @coroutine 等装饰器不兼容。Python 3.4 标准库里的 asyncio.coroutine 装饰器（第 18 章介绍）不会预激协程，因此能兼容 yield from 句法。

接下来探讨协程的重要特性 —— 用于终止协程，以及在协程中抛出异常的方法。

16.5　终止协程和异常处理

协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象）。示例 16-7 举例说明如何使用示例 16-6 中由装饰器定义的 averager 协程。

示例 16-7　未处理的异常会导致协程终止

>>> from coroaverager1 import averager >>> coro_avg = averager() >>> coro_avg.send(40) # ➊ 40.0 >>> coro_avg.send(50) 45.0 >>> coro_avg.send('spam') # ➋ Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +=: 'float' and 'str' >>> coro_avg.send(60) # ➌ Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration

❶ 使用 @coroutine 装饰器装饰的 averager 协程，可以立即开始发送值。

❷ 发送的值不是数字，导致协程内部有异常抛出。

❸ 由于在协程内没有处理异常，协程会终止。如果试图重新激活协程，会抛出 StopIteration 异常。

出错的原因是，发送给协程的'spam' 值不能加到 total 变量上。

示例 16-7 暗示了终止协程的一种方式：发送某个哨符值，让协程退出。内置的 None 和 Ellipsis 等常量经常用作哨符值。Ellipsis 的优点是，数据流中不太常有这个值。我还见过有人把 StopIteration 类（类本身，而不是实例，也不抛出）作为哨符值；也就是说，是像这样使用的：my_coro.send (StopIteration)。

从 Python 2.5 开始，客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。

这两个方法是 throw 和 close。

generator.throw(exc_type[, exc_value[, traceback]])

致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。

generator.close()

致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。

生成器对象方法的官方文档深藏在 Python 语言参考手册中，参见「6.2.9.1.Generator-iterator methods」。

下面举例说明如何使用 close 和 throw 方法控制协程。示例 16-8 列出的是接下来的例子使用的 demo_exc_handling 函数。

示例 16-8　coro_exc_demo.py：学习在协程中处理异常的测试代码

class DemoException (Exception): """为这次演示定义的异常类型。""" def demo_exc_handling (): print ('-> coroutine started') while True: try: x = yield except DemoException: ➊ print ('*** DemoException handled. Continuing...') else: ➋ print ('-> coroutine received: {!r}'.format (x)) rai se RuntimeError ('This line should never run.') ➌

❶ 特别处理 DemoException 异常。

❷ 如果没有异常，那么显示接收到的值。

❸ 这一行永远不会执行。

示例 16-8 中的最后一行代码不会执行，因为只有未处理的异常才会中止那个无限循环，而一旦出现未处理的异常，协程会立即终止。

demo_exc_handling 函数的常规用法如示例 16-9 所示。

示例 16-9　激活和关闭 demo_exc_handling，没有异常

>>> exc_coro = demo_exc_handling() >>> next(exc_coro) -> coroutine started >>> exc_coro.send(11) -> coroutine received: 11 >>> exc_coro.send(22) -> coroutine received: 22 >>> exc_coro.close() >>> from inspect import getgeneratorstate >>> getgeneratorstate(exc_coro) 'GEN_CLOSED'

如果把 DemoException 异常传入 demo_exc_handling 协程，它会处理，然后继续运行，如示例 16-10 所示。

示例 16-10　把 DemoException 异常传入 demo_exc_handling 不会导致协程中止

>>> exc_coro = demo_exc_handling() >>> next(exc_coro) -> coroutine started >>> exc_coro.send(11) -> coroutine received: 11 >>> exc_coro.throw(DemoException) *** DemoException handled. Continuing... >>> getgeneratorstate(exc_coro) 'GEN_SUSPENDED'

但是，如果传入协程的异常没有处理，协程会停止，即状态变成 'GEN_CLOSED'。示例 16-11 演示了这种情况。

示例 16-11　如果无法处理传入的异常，协程会终止

>>> exc_coro = demo_exc_handling() >>> next(exc_coro) -> coroutine started >>> exc_coro.send(11) -> coroutine received: 11 >>> exc_coro.throw(ZeroDivisionError) Traceback (most recent call last): ... ZeroDivisionError >>> getgeneratorstate(exc_coro) 'GEN_CLOSED'

如果不管协程如何结束都想做些清理工作，要把协程定义体中相关的代码放入 try/finally 块中，如示例 16-12。

示例 16-12　coro_finally_demo.py：使用 try/finally 块在协程终止时执行操作

class DemoException (Exception): """为这次演示定义的异常类型。""" def demo_finally (): print ('-> coroutine started') try: while True: try: x = yield except DemoException: print ('*** DemoException handled. Continuing...') else: print ('-> coroutine received: {!r}'.format (x)) finally: print ('-> coroutine ending')

Python 3.3 引入 yield from 结构的主要原因之一与把异常传入嵌套的协程有关。另一个原因是让协程更方便地返回值。请继续往下读，了解详情。

16.6　让协程返回值

示例 16-13 是 averager 协程的不同版本，这一版会返回结果。为了说明如何返回值，每次激活协程时不会产出移动平均值。这么做是为了强调某些协程不会产出值，而是在最后返回一个值（通常是某种累计值）。

示例 16-13 中的 averager 协程返回的结果是一个 namedtuple，两个字段分别是项数（count）和平均值（average）。我本可以只返回平均值，但是返回一个元组可以获得累积数据的另一个重要信息 —— 项数。

示例 16-13　coroaverager2.py：定义一个求平均值的协程，让它返回一个结果

from collections import namedtuple Result = namedtuple('Result', 'count average') def averager(): total = 0.0 count = 0 average = None while True: term = yield if term is None: break ➊ total += term count += 1 average = total/count return Result(count, average) ➋

➊ 为了返回值，协程必须正常终止；因此，这一版 averager 中有个条件判断，以便退出累计循环。

➋ 返回一个 namedtuple，包含 count 和 average 两个字段。在 Python 3.3 之前，如果生成器返回值，解释器会报句法错误。

下面在控制台中说明如何使用新版 averager，如示例 16-14 所示。

示例 16-14　coroaverager2.py：说明 averager 行为的 doctest

>>> coro_avg = averager() >>> next(coro_avg) >>> coro_avg.send(10) ➊ >>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> coro_avg.send(None) ➋ Traceback (most recent call last): ... StopIteration: Result(count=3, average=15.5)

❶ 这一版不产出值。

❷ 发送 None 会终止循环，导致协程结束，返回结果。一如既往，生成器对象会抛出 StopIteration 异常。异常对象的 value 属性保存着返回的值。

注意，return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性。这样做有点不合常理，但是能保留生成器对象的常规行为 —— 耗尽时抛出 StopIteration 异常。

示例 16-15 展示如何获取协程返回的值。

示例 16-15　捕获 StopIteration 异常，获取 averager 返回的值

>>> coro_avg = averager() >>> next(coro_avg) >>> coro_avg.send(10) >>> coro_avg.send(30) >>> coro_avg.send(6.5) >>> try: ... coro_avg.send(None) ... except StopIteration as exc: ... result = exc.value ... >>> result Result(count=3, average=15.5)

获取协程的返回值虽然要绕个圈子，但这是 PEP 380 定义的方式，当我们意识到这一点之后就说得通了：yield from 结构会在内部自动捕获 StopIteration 异常。这种处理方式与 for 循环处理 StopIteration 异常的方式一样：循环机制使用用户易于理解的方式处理异常。对 yield from 结构来说，解释器不仅会捕获 StopIteration 异常，还会把 value 属性的值变成 yield from 表达式的值。可惜，我们无法在控制台中使用交互的方式测试这种行为，因为在函数外部使用 yield from（以及 yield）会导致句法出错。4

4iPython 有个扩展 ——ipython-yf，安装这个扩展后可以在 iPython 控制台中直接执行 yield from。这个扩展用于测试异步代码，可以结合 asyncio 模块使用。这个扩展已经提交为 Python 3.5 的补丁，但是没有被接受。参见 Python 缺陷追踪系统中的 22412 号工单： Towards an asyncio-enabled command line。

下一节会举例说明如何使用 yield from 结构按照 PEP 380 定义的方式获取 averager 协程返回的值。下面讨论 yield from 结构。

16.7　使用 yield from

首先要知道，yield from 是全新的语言结构。它的作用比 yield 多很多，因此人们认为继续使用那个关键字多少会引起误解。在其他语言中，类似的结构使用 await 关键字，这个名称好多了，因为它传达了至关重要的一点：在生成器 gen 中使用 yield from subgen () 时，subgen 会获得控制权，把产出的值传给 gen 的调用方，即调用方可以直接控制 subgen。与此同时，gen 会阻塞，等待 subgen 终止。5

5 写作本书时，有个 PEP 正在讨论中，提议增加 await 和 async 关键字：PEP 492—Coroutines with async and await syntax。

第 14 章说过，yield from 可用于简化 for 循环中的 yield 表达式。例如：

>>> def gen(): ... for c in 'AB': ... yield c ... for i in range(1, 3): ... yield i ... >>> list(gen()) ['A', 'B', 1, 2]

可以改写为：

>>> def gen(): ... yield from 'AB' ... yield from range(1, 3) ... >>> list(gen()) ['A', 'B', 1, 2]

14.10 节首次提到 yield from 时举了一个例子，演示这个结构的用法，如示例 16-16 所示。6

6 示例 16-16 仅供教学使用。itertools 模块提供了优化版 chain 函数，使用 C 语言编写。

示例 16-16　使用 yield from 链接可迭代的对象

>>> def chain(*iterables): ... for it in iterables: ... yield from it ... >>> s = 'ABC' >>> t = tuple(range(3)) >>> list(chain(s, t)) ['A', 'B', 'C', 0, 1, 2]

在 Beazley 与 Jones 的《Python Cookbook（第 3 版）中文版》一书中，「4.14 扁平化处理嵌套型的序列」一节有个稍微复杂（不过更有用）的 yield from 示例（源码在 GitHub 中）。

yield from x 表达式对 x 对象所做的第一件事是，调用 iter (x)，从中获取迭代器。因此，x 可以是任何可迭代的对象。

可是，如果 yield from 结构唯一的作用是替代产出值的嵌套 for 循环，这个结构很有可能不会添加到 Python 语言中。yield from 结构的本质作用无法通过简单的可迭代对象说明，而要发散思维，使用嵌套的生成器。因此，引入 yield from 结构的 PEP 380 才起了「Syntax for Delegating to a Subgenerator」（「把职责委托给子生成器的句法」）这个标题。

yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。

若想使用 yield from 结构，就要大幅改动代码。为了说明需要改动的部分，PEP 380 使用了一些专门的术语。

委派生成器

包含 yield from <iterable> 表达式的生成器函数。

子生成器

从 yield from 表达式中 <iterable> 部分获取的生成器。这就是 PEP 380 的标题（「Syntax for Delegating to a Subgenerator」）中所说的「子生成器」（subgenerator）。

调用方

PEP 380 使用「调用方」这个术语指代调用委派生成器的客户端代码。在不同的语境中，我会使用「客户端」代替「调用方」，以此与委派生成器（也是调用方，因为它调用了子生成器）区分开。

PEP 380 经常使用「迭代器」这个词指代子生成器。这样会让人误解，因为委派生成器也是迭代器。因此，我选择使用「子生成器」这个术语，与 PEP 380 的标题（「Syntax for Delegating to a Subgenerator」）保持一致。然而，子生成器可能是简单的迭代器，只实现了 __next__ 方法；但是，yield from 也能处理这种子生成器。不过，引入 yield from 结构的目的是为了支持实现了 __next__、send、close 和 throw 方法的生成器。

示例 16-17 能更好地说明 yield from 结构的用法。图 16-2 把该示例中各个相关的部分标识出来了。7

7 图 16-2 的灵感来自 Paul Sokolovsky 绘制的示意图。

图 16-2：委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给子生成器，子生成器再把产出的值发给调用方。子生成器返回之后，解释器会抛出 StopIteration 异常，并把返回值附加到异常对象上，此时委派生成器会恢复

coroaverager3.py 脚本从一个字典中读取虚构的七年级男女学生的体重和身高。例如，'boys;m' 键对应于 9 个男学生的身高（单位是米），'girls;kg' 键对应于 10 个女学生的体重（单位是千克）。这个脚本把各组数据传给前面定义的 averager 协程，然后生成一个报告，如下所示：

$ python3 coroaverager3.py 9 boys averaging 40.42kg 9 boys averaging 1.39m 10 girls averaging 42.04kg 10 girls averaging 1.43m

示例 16-17 中列出的代码显然不是解决这个问题最简单的方案，但是通过实例说明了 yield from 结构的用法。这个示例的灵感来自「What's New in Python 3.3」一文给出的例子。

示例 16-17　coroaverager3.py：使用 yield from 计算平均值并输出统计报告

from collections import namedtuple Result = namedtuple ('Result', 'count average') # 子生成器 def averager (): ➊ total = 0.0 count = 0 average = None while True: term = yield ➋ if term is None: ➌ break total += term count += 1 average = total/count return Result (count, average) ➍ # 委派生成器 def grouper (results, key): ➎ while True: ➏ results [key] = yield from averager () ➐ # 客户端代码，即调用方 def main (data): ➑ results = {} for key, values in data.items (): group = grouper (results, key) ➒ next (group) ➓ for value in values: group.send (value) ⓫ group.send (None) # 重要！ ⓬ # print (results) # 如果要调试，去掉注释 report (results) # 输出报告 def report (results): for key, result in sorted (results.items ()): group, unit = key.split (';') print ('{:2} {:5} averaging {:.2f}{}'.format ( result.count, group, result.average, unit)) data = {'girls;kg': [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5], 'girls;m': [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43], 'boys;kg': [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3], 'boys;m': [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46], } if __name__ == '__main__': main (data)

❶ 与示例 16-13 中的 averager 协程一样。这里作为子生成器使用。

❷ main 函数中的客户代码发送的各个值绑定到这里的 term 变量上。

❸ 至关重要的终止条件。如果不这么做，使用 yield from 调用这个协程的生成器会永远阻塞。

❹ 返回的 Result 会成为 grouper 函数中 yield from 表达式的值。

❺ grouper 是委派生成器。

❻ 这个循环每次迭代时会新建一个 averager 实例；每个实例都是作为协程使用的生成器对象。

❼ grouper 发送的每个值都会经由 yield from 处理，通过管道传给 averager 实例。grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的值。averager 实例运行完毕后，返回的值绑定到 results [key] 上。while 循环会不断创建 averager 实例，处理更多的值。

❽ main 函数是客户端代码，用 PEP 380 定义的术语来说，是「调用方」。这是驱动一切的函数。

❾ group 是调用 grouper 函数得到的生成器对象，传给 grouper 函数的第一个参数是 results，用于收集结果；第二个参数是某个键。group 作为协程使用。

❿ 预激 group 协程。

⓫ 把各个 value 传给 grouper。传入的值最终到达 averager 函数中 term = yield 那一行；grouper 永远不知道传入的值是什么。

⓬ 把 None 传入 grouper，导致当前的 averager 实例终止，也让 grouper 继续运行，再创建一个 averager 实例，处理下一组值。

示例 16-17 中最后一个标号前面有个注释 ——「重要！」，强调这行代码（group.send (None)）至关重要：终止当前的 averager 实例，开始执行下一个。如果注释掉那一行，这个脚本不会输出任何报告。此时，把 main 函数靠近末尾的 print (results) 那行的注释去掉，你会发现，results 字典是空的。

研究为何没有收集到数据，能检验自己有没有理解 yield from 结构的运作方式。本书的代码仓库中有 coroaverager3.py 脚本的代码。原因说明如下。

下面简要说明示例 16-17 的运作方式，还会说明把 main 函数中调用 group.send (None) 那一行代码（带有「重要！」注释的那一行）去掉会发生什么事。

外层 for 循环每次迭代会新建一个 grouper 实例，赋值给 group 变量；group 是委派生成器。

调用 next (group)，预激委派生成器 grouper，此时进入 while True 循环，调用子生成器 averager 后，在 yield from 表达式处暂停。

内层 for 循环调用 group.send (value)，直接把值传给子生成器 averager。同时，当前的 grouper 实例（group）在 yield from 表达式处暂停。

内层循环结束后，group 实例依旧在 yield from 表达式处暂停，因此，grouper 函数定义体中为 results [key] 赋值的语句还没有执行。

如果外层 for 循环的末尾没有 group.send (None)，那么 averager 子生成器永远不会终止，委派生成器 group 永远不会再次激活，因此永远不会为 results [key] 赋值。

外层 for 循环重新迭代时会新建一个 grouper 实例，然后绑定到 group 变量上。前一个 grouper 实例（以及它创建的尚未终止的 averager 子生成器实例）被垃圾回收程序回收。

这个试验想表明的关键一点是，如果子生成器不终止，委派生成器会在 yield from 表达式处永远暂停。如果是这样，程序不会向前执行，因为 yield from（与 yield 一样）把控制权转交给客户代码（即，委派生成器的调用方）了。显然，肯定有任务无法完成。

示例 16-17 展示了 yield from 结构最简单的用法，只有一个委派生成器和一个子生成器。因为委派生成器相当于管道，所以可以把任意数量个委派生成器连接在一起：一个委派生成器使用 yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 yield from 调用另一个子生成器，以此类推。最终，这个链条要以一个只使用 yield 表达式的简单生成器结束；不过，也能以任何可迭代的对象结束，如示例 16-16 所示。

任何 yield from 链条都必须由客户驱动，在最外层委派生成器上调用 next (...) 函数或 .send (...) 方法。可以隐式调用，例如使用 for 循环。

下面综述 PEP 380 对 yield from 结构的正式说明。

16.8　yield from 的意义

制定 PEP 380 时，有人质疑作者 Greg Ewing 提议的语义过于复杂了。他的回应之一是：「对人类来说，几乎所有最重要的信息都在靠近顶部的某个段落里。」他还引述了 PEP 380 草稿中的一段话，当时那段话是这样的：

「把迭代器当作生成器使用，相当于把子生成器的定义体内联在 yield from 表达式中。此外，子生成器可以执行 return 语句，返回一个值，而返回的值会成为 yield from 表达式的值。」8

8 摘自 Python-Dev 邮件列表中的一个消息：「PEP 380 (yield from a subgenerator) comments」（发布于 2009 年 3 月 21 日）。

PEP 380 中已经没有这段宽慰人心的话，因为没有涵盖所有极端情况。不过，一开始可以这样粗略地说。

批准后的 PEP 380 在「Proposal」一节分六点说明了 yield from 的行为。这里，我几乎原封不动地引述，不过把有歧义的「迭代器」一词都换成了「子生成器」，还做了进一步说明。示例 16-17 阐明了下述四点。

子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。

使用 send () 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的 __next__() 方法。如果发送的值不是 None，那么会调用子生成器的 send () 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。

生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration (expr) 异常抛出。

yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数。

yield from 结构的另外两个特性与异常和终止有关。

传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的 throw () 方法。如果调用 throw () 方法时抛出 StopIteration 异常，委派生成器恢复运行。StopIteration 之外的异常会向上冒泡，传给委派生成器。

如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用 close () 方法，那么在子生成器上调用 close () 方法，如果它有的话。如果调用 close () 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。

yield from 的具体语义很难理解，尤其是处理异常的那两点。Greg Ewing 做得很好，在 PEP 380 中使用英语阐述了 yield from 的语义。

Ewing 还使用伪代码（使用 Python 句法）演示了 yield from 的行为。我个人认为值得花时间研究 PEP 380 中的伪代码。不过，那段伪代码长达 40 行，看一遍很难理解。

若想研究那段伪代码，最好将其简化，只涵盖 yield from 最基本且最常见的用法。

假设 yield from 出现在委派生成器中。客户端代码驱动着委派生成器，而委派生成器驱动着子生成器。那么，为了简化涉及到的逻辑，我们假设客户端没有在委派生成器上调用 .throw (...) 或 .close () 方法。此外，我们还假设子生成器不会抛出异常，而是一直运行到终止，让解释器抛出 StopIteration 异常。

示例 16-17 中的脚本就做了这些简化逻辑的假设。其实，在真实的代码中，委派生成器应该运行到结束。下面来看一下在这个简化的美满世界中，yield from 是如何运作的。

请看示例 16-18，那里列出的代码是委派生成器的定义体中下面这一行代码的扩充：

RESULT = yield from EXPR

自己试着理解示例 16-18 中的逻辑。

示例 16-18　简化的伪代码，等效于委派生成器中的 RESULT = yield from EXPR 语句（这里针对的是最简单的情况：不支持 .throw (...) 和 .close () 方法，而且只处理 StopIteration 异常）

_i = iter(EXPR) ➊ try: _y = next(_i) ➋ except StopIteration as _e: _r = _e.value ➌ else: while 1: ➍ _s = yield _y ➎ try: _y = _i.send(_s) ➏ except StopIteration as _e: ➐ _r = _e.value break RESULT = _r ➑

❶ EXPR 可以是任何可迭代的对象，因为获取迭代器 _i（这是子生成器）使用的是 iter () 函数。

❷ 预激子生成器；结果保存在 _y 中，作为产出的第一个值。

❸ 如果抛出 StopIteration 异常，获取异常对象的 value 属性，赋值给 _r—— 这是最简单情况下的返回值（RESULT）。

❹ 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道。

❺ 产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。注意，这个代码清单中只有这一个 yield 表达式。

❻ 尝试让子生成器向前执行，转发调用方发送的 _s。

❼ 如果子生成器抛出 StopIteration 异常，获取 value 属性的值，赋值给 _r，然后退出循环，让委派生成器恢复运行。

❽ 返回的结果（RESULT）是 _r，即整个 yield from 表达式的值。

在这段简化的伪代码中，我保留了 PEP 380 中那段伪代码使用的变量名称。这些变量是：

_i（迭代器）

子生成器

_y（产出的值）

子生成器产出的值

_r（结果）

最终的结果（即子生成器运行结束后 yield from 表达式的值）

_s（发送的值）

调用方发给委派生成器的值，这个值会转发给子生成器

_e（异常）

异常对象（在这段简化的伪代码中始终是 StopIteration 实例）

除了没有处理 .throw (...) 和 .close () 方法之外，这段简化的伪代码还在子生成器上调用 .send (...) 方法，以此达到客户调用 next () 函数或 .send (...) 方法的目的。首次阅读时不要担心这些细微的差别。前面说过，即使 yield from 结构只做示例 16-18 中展示的事情，示例 16-17 也依旧能正常运行。

但是，现实情况要复杂一些，因为要处理客户对 .throw (...) 和 .close () 方法的调用，而这两个方法执行的操作必须传入子生成器。此外，子生成器可能只是纯粹的迭代器，不支持 .throw (...) 和 .close () 方法，因此 yield from 结构的逻辑必须处理这种情况。如果子生成器实现了这两个方法，而在子生成器内部，这两个方法都会触发异常抛出，这种情况也必须由 yield from 机制处理。调用方可能会无缘无故地让子生成器自己抛出异常，实现 yield from 结构时也必须处理这种情况。最后，为了优化，如果调用方调用 next (...) 函数或 .send (None) 方法，都要转交职责，在子生成器上调用 next (...) 函数；仅当调用方发送的值不是 None 时，才使用子生成器的 .send (...) 方法。

为了方便对比，下面列出 PEP 380 中扩充 yield from 表达式的完整伪代码，而且加上了带标号的注解。示例 16-19 中的代码是一字不差复制过来的，只有标注是我自己加的。

再次说明，示例 16-19 中的代码是委派生成器的定义体中下面这一个语句的扩充：

RESULT = yield from EXPR

示例 16-19　伪代码，等效于委派生成器中的 RESULT = yield from EXPR 语句

_i = iter(EXPR) ➊ try: _y = next(_i) ➋ except StopIteration as _e: _r = _e.value ➌ else: while 1: ➍ try: _s = yield _y ➎ except GeneratorExit as _e: ➏ try: _m = _i.close except AttributeError: pass else: _m() raise _e except BaseException as _e: ➐ _x = sys.exc_info() try: _m = _i.throw except AttributeError: raise _e else: ➑ try: _y = _m(*_x) except StopIteration as _e: _r = _e.value break else: ➒ try: ➓ if _s is None: ⓫ _y = next(_i) else: _y = _i.send(_s) except StopIteration as _e: ⓬ _r = _e.value break RESULT = _r ⓭

❶ EXPR 可以是任何可迭代的对象，因为获取迭代器 _i（这是子生成器）使用的是 iter () 函数。

❷ 预激子生成器；结果保存在 _y 中，作为产出的第一个值。

❸ 如果抛出 StopIteration 异常，获取异常对象的 value 属性，赋值给 _r—— 这是最简单情况下的返回值（RESULT）。

❹ 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道。

❺ 产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。这个代码清单中只有这一个 yield 表达式。

❻ 这一部分用于关闭委派生成器和子生成器。因为子生成器可以是任何可迭代的对象，所以可能没有 close 方法。

❼ 这一部分处理调用方通过 .throw (...) 方法传入的异常。同样，子生成器可以是迭代器，从而没有 throw 方法可调用 —— 这种情况会导致委派生成器抛出异常。

❽ 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。子生成器可能会处理传入的异常（然后继续循环）；可能抛出 StopIteration 异常（从中获取结果，赋值给 _r，循环结束）；还可能不处理，而是抛出相同的或不同的异常，向上冒泡，传给委派生成器。

❾ 如果产出值时没有异常……

❿ 尝试让子生成器向前执行……

⓫ 如果调用方最后发送的值是 None，在子生成器上调用 next 函数，否则调用 send 方法。

⓬ 如果子生成器抛出 StopIteration 异常，获取 value 属性的值，赋值给 _r，然后退出循环，让委派生成器恢复运行。

⓭ 返回的结果（RESULT）是 _r，即整个 yield from 表达式的值。

这段 yield from 伪代码的大多数逻辑通过六个 try/except 块实现，而且嵌套了四层，因此有点难以阅读。此外，用到的其他流程控制关键字有一个 while、一个 if 和一个 yield。找到 while 循环、yield 表达式以及 next (...) 函数和 .send (...) 方法调用，这些代码有助于对 yield from 结构的运作方式有个整体的了解。

就在示例 16-19 所列伪代码的顶部，有行代码（标号❷）揭示了一个重要的细节：要预激子生成器。9 这表明，用于自动预激的装饰器（如 16.4 节定义的那个）与 yield from 结构不兼容。

9Nick Coghlan 于 2009 年 4 月 5 日在 Python-ideas 邮件列表中发布的一个消息中质疑，yield from 结构隐式预激是不是好主意。

在本节开头引用的那个消息中，关于扩充 yield from 结构的伪代码，Greg Ewing 说：

我不是让你通过扩充的伪代码学习这个结构，那段伪代码是为了让语言专家弄明白细节。

仔细研究扩充的伪代码可能没什么用 —— 这与你的学习方式有关。显然，分析真正使用 yield from 结构的代码要比深入研究实现这一结构的伪代码更有好处。不过，我见过的 yield from 示例几乎都使用 asyncio 模块做异步编程，因此要有有效的事件循环才能运行。第 18 章会多次用到 yield from 结构。16.11 节中有几个链接，指向使用 yield from 结构的一些有趣代码，而且无需事件循环。

下面分析一个使用协程的经典案例：仿真编程。这个案例没有展示 yield from 结构的用法，但是揭示了如何使用协程在单个线程中管理并发活动。

16.9　使用案例：使用协程做离散事件仿真

协程能自然地表述很多算法，例如仿真、游戏、异步 I/O，以及其他事件驱动型编程形式或协作式多任务。10

——Guido van Rossum 和 Phillip J. Eby

PEP 342—Coroutines via Enhanced Generators

10PEP 342 中「Motivation」一节开头的第一句话。

本节我会说明如何只使用协程和标准库中的对象实现一个特别简单的仿真系统。在计算机科学领域，仿真是协程的经典应用。第一门面向对象的语言 Simula 引入了协程这个概念，目的就是为了支持仿真。

下述仿真示例不是为了做学术研究。协程是 asyncio 包的基础构建。通过仿真系统能说明如何使用协程代替线程实现并发的活动，而且对理解第 18 章讨论的 asyncio 包有极大的帮助。

分析示例之前，先简单介绍一下仿真。

16.9.1　离散事件仿真简介

离散事件仿真（Discrete Event Simulation，DES）是一种把系统建模成一系列事件的仿真类型。在离散事件仿真中，仿真「钟」向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。假如我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。不管乘客坐了 5 分钟还是 50 分钟，一旦乘客下车，仿真钟就会更新，指向此次运营的结束时间。使用离散事件仿真可以在不到一秒钟的时间内模拟一年的出租车运营过程。这与连续仿真不同，连续仿真的仿真钟以固定的量（通常很小）不断向前推进。

显然，回合制游戏就是离散事件仿真的例子：游戏的状态只在玩家操作时变化，而且一旦玩家决定下一步怎么走了，仿真钟就会冻结。而实时游戏则是连续仿真，仿真钟一直在运行，游戏的状态在一秒钟之内更新很多次，因此反应慢的玩家特别吃亏。

这两种仿真类型都能使用多线程或在单个线程中使用面向事件的编程技术（例如事件循环驱动的回调或协程）实现。可以说，为了实现连续仿真，在多个线程中处理实时并行的操作更自然。而协程恰好为实现离散事件仿真提供了合理的抽象。SimPy11 是一个实现离散事件仿真的 Python 包，通过一个协程表示离散事件仿真系统中的各个进程。

11 参见 SimPy 的官方文档。不要和著名的 SymPy 混淆了。SymPy 是一个符号数学库，与 DES 无关。

在仿真领域，进程这个术语指代模型中某个实体的活动，与操作系统中的进程无关。仿真系统中的一个进程可以使用操作系统中的一个进程实现，但是通常会使用一个线程或一个协程实现。

如果对仿真感兴趣，值得研究一下 SimPy。不过，在这一节我会说明如何只使用标准库提供的功能实现一个特别简单的离散事件仿真系统。我的目的是增进你对使用协程管理并发操作的感性认知。若想理解下一节所讲的内容，要仔细研究，不过这一付出能得到很大回报，让我们洞悉 asyncio、Twisted 和 Tornado 等库是如何在单个线程中管理多个并发活动的。

16.9.2　出租车队运营仿真

仿真程序 taxi_sim.py 会创建几辆出租车，每辆车会拉几个乘客，然后回家。出租车首先驶离车库，四处徘徊，寻找乘客；拉到乘客后，行程开始；乘客下车后，继续四处徘徊。

四处徘徊和行程所用的时间使用指数分布生成。为了让显示的信息更加整洁，时间使用取整的分钟数，不过这个仿真程序也能使用浮点数表示耗时。12 每辆出租车每次的状态变化都是一个事件。图 16-3 是运行这个程序的输出示例。

12 我不是运营出租车队的行家，因此别太在意显示的时间。离散事件仿真经常使用指数分布。你会看到一些非常短的行程，你就假设那是一个雨天，一些乘客坐出租车只走了一个街区。在理想的城市中，即使下雨也有出租车。

图 16-3：运行 taxi_sim.py 创建 3 辆出租车的输出示例。-s 3 参数设置随机数生成器的种子，这样在调试和演示时可以重复运行程序，输出相同的结果。不同颜色的箭头表示不同出租车的行程 13

13 图 16-3 的彩色图片可从本书页面的「随书下载」部分获取。—— 编者注

图 16-3 中最值得注意的一件事是，3 辆出租车的行程是交叉进行的。那些箭头是我加上的，为的是让你看清各辆出租车的行程：箭头从乘客上车时开始，到乘客下车后结束。有了箭头，能直观地看出如何使用协程管理并发的活动。

图 16-3 中还有几件事值得注意。

出租车每隔 5 分钟从车库中出发。

0 号出租车 2 分钟后拉到乘客（time=2），1 号出租车 3 分钟后拉到乘客（time=8），2 号出租车 5 分钟后拉到乘客（time=15）。

0 号出租车拉了两个乘客（紫色箭头）：第一个乘客从 time=2 时上车，到 time=18 时下车；第二个乘客从 time=28 时上车，到 time=65 时下车 —— 这是此次仿真中最长的行程。

1 号出租车拉了四个乘客（绿色箭头），在 time=110 时回家。

2 号出租车拉了六个乘客（红色箭头），在 time=109 时回家。这辆车最后一次行程从 time=97 时开始，只持续了一分钟。14

1 号出租车的第一次行程从 time=8 时开始，在这个过程中 2 号出租车离开了车库（time=10），而且完成了两次行程（那两个短的红色箭头）。

在此次运行示例中，所有排定的事件都在默认的仿真时间内（180 分钟）完成；最后一次事件发生在 time=110 时。

14 乘客是我，我发现忘了带钱包。

仿真结束时可能还有未完成的事件。如果是这种情况，最后一条消息会是下面这样：

*** end of simulation time: 3 events pending ***

taxi_sim.py 脚本的完整代码在示例 A-6 中，本章只会列出与协程相关的部分。真正重要的函数只有两个：taxi_process（一个协程），以及执行仿真主循环的 Simulator.run 方法。

示例 16-20 是 taxi_process 函数的代码。这个协程用到了别处定义的两个对象：compute_delay 函数，返回单位为分钟的时间间隔；Event 类，一个 namedtuple，定义方式如下：

Event = collections.namedtuple('Event', 'time proc action')

在 Event 实例中，time 字段是事件发生时的仿真时间，proc 字段是出租车进程实例的编号，action 字段是描述活动的字符串。

下面逐行分析示例 16-20 中的 taxi_process 函数。

示例 16-20　taxi_sim.py：taxi_process 协程，实现各辆出租车的活动

def taxi_process (ident, trips, start_time=0): ➊ """每次改变状态时创建事件，把控制权让给仿真器""" time = yield Event (start_time, ident, 'leave garage') ➋ for i in range (trips): ➌ time = yield Event (time, ident, 'pick up passenger') ➍ time = yield Event (time, ident, 'drop off passenger') ➎ yield Event (time, ident, 'going home') ➏ # 出租车进程结束 ➐

❶ 每辆出租车调用一次 taxi_process 函数，创建一个生成器对象，表示各辆出租车的运营过程。ident 是出租车的编号（如上述运行示例中的 0、1、2）；trips 是出租车回家之前的行程数量；start_time 是出租车离开车库的时间。

❷ 产出的第一个 Event 是 'leave garage'。执行到这一行时，协程会暂停，让仿真主循环着手处理排定的下一个事件。需要重新激活这个进程时，主循环会发送（使用 send 方法）当前的仿真时间，赋值给 time。

❸ 每次行程都会执行一遍这个代码块。

❹ 产出一个 Event 实例，表示拉到乘客了。协程在这里暂停。需要重新激活这个协程时，主循环会发送（使用 send 方法）当前的时间。

❺ 产出一个 Event 实例，表示乘客下车了。协程在这里暂停，等待主循环发送时间，然后重新激活。

❻ 指定的行程数量完成后，for 循环结束，最后产出 'going home' 事件。此时，协程最后一次暂停。仿真主循环发送时间后，协程重新激活；不过，这里没有把产出的值赋值给变量，因为用不到了。

❼ 协程执行到最后时，生成器对象抛出 StopIteration 异常。

你可以在 Python 控制台中调用 taxi_process 函数，自己「驾驶」（drive）一辆出租车 15，如示例 16-21 所示。

15 描述协程的操作时经常使用「drive」这个动词，例如：客户代码把值发给协程，驱动协程。在示例 16-21 中，客户代码是你在控制台中输入的代码。（drive 一词有不同的含义，因此在不同的语境中有不同的译法，例如这个脚注所在的那句话中译为「驾驶」。—— 译者注）

示例 16-21　驱动 taxi_process 协程

>>> from taxi_sim import taxi_process >>> taxi = taxi_process(ident=13, trips=2, start_time=0) ➊ >>> next(taxi) ➋ Event(time=0, proc=13, action='leave garage') >>> taxi.send(_.time + 7) ➌ Event(time=7, proc=13, action='pick up passenger') ➍ >>> taxi.send(_.time + 23) ➎ Event(time=30, proc=13, action='drop off passenger') >>> taxi.send(_.time + 5) ➏ Event(time=35, proc=13, action='pick up passenger') >>> taxi.send(_.time + 48) ➐ Event(time=83, proc=13, action='drop off passenger') >>> taxi.send(_.time + 1) Event(time=84, proc=13, action='going home') ➑ >>> taxi.send(_.time + 10) ➒ Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration

❶ 创建一个生成器对象，表示一辆出租车。这辆出租车的编号是 13（ident=13），从 t=0 时开始工作，有两次行程。

❷ 预激协程；产出第一个事件。

❸ 现在可以发送当前时间。在控制台中，_ 变量绑定的是前一个结果；这里我在时间上加 7，意思是这辆出租车 7 分钟后找到第一个乘客。

❹ 这个事件由 for 循环在第一个行程的开头产出。

❺ 发送 _.time + 23，表示第一个乘客的行程持续了 23 分钟。

❻ 然后，这辆出租车会徘徊 5 分钟。

❼ 最后一次行程持续 48 分钟。

❽ 两次行程完成后，for 循环结束，产出 'going home' 事件。

❾ 如果尝试再把值发给协程，会执行到协程的末尾。协程返回后，解释器会抛出 StopIteration 异常。

注意，在示例 16-21 中，我使用控制台模拟仿真主循环。我从 taxi 协程产出的 Event 实例中获取 .time 属性，随意与一个数相加，然后调用 taxi.send 方法发送两数之和，重新激活协程。在这个仿真系统中，各个出租车协程由 Simulator.run 方法中的主循环驱动。仿真「钟」保存在 sim_time 变量中，每次产出事件时都会更新仿真钟。

为了实例化 Simulator 类，taxi_sim.py 脚本的 main 函数构建了一个 taxis 字典，如下所示：

taxis = {i: taxi_process(i, (i + 1) * 2, i * DEPARTURE_INTERVAL) for i in range(num_taxis)} sim = Simulator(taxis)

DEPARTURE_INTERVAL 的值是 5；如果 num_taxis 的值与前面的运行示例一样也是 3，这三行代码的作用与下述代码一样：

taxis = {0: taxi_process(ident=0, trips=2, start_time=0), 1: taxi_process(ident=1, trips=4, start_time=5), 2: taxi_process(ident=2, trips=6, start_time=10)} sim = Simulator(taxis)

因此，taxis 字典的值是三个参数不同的生成器对象。例如，1 号出租车从 start_time=5 时开始，寻找四个乘客。构建 Simulator 实例只需这个字典参数。

Simulator.__init__ 方法如示例 16-22 所示。Simulator 类的主要数据结构如下。

self.events

PriorityQueue 对象，保存 Event 实例。元素可以放进（使用 put 方法）PriorityQueue 对象中，然后按 item [0]（即 Event 对象的 time 属性）依序取出（使用 get 方法）。

self.procs

一个字典，把出租车的编号映射到仿真过程中激活的进程（表示出租车的生成器对象）。这个属性会绑定前面所示的 taxis 字典副本。

示例 16-22　taxi_sim.py：Simulator 类的初始化方法

class Simulator: def __init__(self, procs_map): self.events = queue.PriorityQueue() ➊ self.procs = dict(procs_map) ➋

❶ 保存排定事件的 PriorityQueue 对象，按时间正向排序。

❷ 获取的 procs_map 参数是一个字典（或其他映射），可是又从中构建一个字典，创建本地副本，因为在仿真过程中，出租车回家后会从 self.procs 属性中移除，而我们不想修改用户传入的对象。

优先队列是离散事件仿真系统的基础构件：创建事件的顺序不定，放入这种队列之后，可以按照各个事件排定的时间顺序取出。例如，可能会把下面两个事件放入优先队列：

Event(time=14, proc=0, action='pick up passenger') Event(time=11, proc=1, action='pick up passenger')

这两个事件的意思是，0 号出租车 14 分钟后拉到第一个乘客，而 1 号出租车（time=10 时出发）1 分钟后（time=11）拉到乘客。如果这两个事件在队列中，主循环从优先队列中获取的第一个事件将是 Event (time=11, proc=1, action='pick up passenger')。

下面分析这个仿真系统的主算法 ——Simulator.run 方法。在 main 函数中，实例化 Simulator 类之后立即就调用了这个方法，如下所示：

sim = Simulator(taxis) sim.run(end_time)

Simulator 类带有注解的代码清单在示例 16-23 中，下面先概述 Simulator.run 方法实现的算法。

(1) 迭代表示各辆出租车的进程。

a. 在各辆出租车上调用 next () 函数，预激协程。这样会产出各辆出租车的第一个事件。

b. 把各个事件放入 Simulator 类的 self.events 属性（队列）中。

(2) 满足 sim_time < end_time 条件时，运行仿真系统的主循环。

a. 检查 self.events 属性是否为空；如果为空，跳出循环。

b. 从 self.events 中获取当前事件（current_event），即 PriorityQueue 对象中时间值最小的 Event 对象。

c. 显示获取的 Event 对象。

d. 获取 current_event 的 time 属性，更新仿真时间。

e. 把时间发给 current_event 的 proc 属性标识的协程，产出下一个事件（next_event）。

f. 把 next_event 添加到 self.events 队列中，排定 next_event。

Simulator 类完整的代码如示例 16-23 所示。

示例 16-23　taxi_sim.py：Simulator，一个简单的离散事件仿真类；关注的重点是 run 方法

class Simulator: def __init__(self, procs_map): self.events = queue.PriorityQueue () self.procs = dict (procs_map) def run (self, end_time): ➊ """排定并显示事件，直到时间结束""" # 排定各辆出租车的第一个事件 for _, proc in sorted (self.procs.items ()): ➋ first_event = next (proc) ➌ self.events.put (first_event) ➍ # 这个仿真系统的主循环 sim_time = 0 ➎ while sim_time <end_time: ➏ if self.events.empty (): ➐ print ('*** end of events ***') break current_event = self.events.get () ➑ sim_time, proc_id, previous_action = current_event ➒ print ('taxi:', proc_id, proc_id * ' ', current_event) ➓ active_proc = self.procs [proc_id] ⓫ next_time = sim_time + compute_duration (previous_action) ⓬ try: next_event = active_proc.send (next_time) ⓭ except StopIteration: del self.procs [proc_id] ⓮ else: self.events.put (next_event) ⓯ else: ⓰ msg = '*** end of simulation time: {} events pending ***' print (msg.format (self.events.qsize ()))

❶ run 方法只需要仿真结束时间（end_time）这一个参数。

❷ 使用 sorted 函数获取 self.procs 中按键排序的元素；用不到键，因此赋值给 _。

❸ 调用 next (proc) 预激各个协程，向前执行到第一个 yield 表达式，做好接收数据的准备。产出一个 Event 对象。

❹ 把各个事件添加到 self.events 属性表示的 PriorityQueue 对象中。如示例 16-20 中的运行示例，各辆出租车的第一个事件是 'leave garage'。

❺ 把 sim_time 变量（仿真钟）归零。

❻ 这个仿真系统的主循环：sim_time 小于 end_time 时运行。

❼ 如果队列中没有未完成的事件，退出主循环。

❽ 获取优先队列中 time 属性最小的 Event 对象；这是当前事件（current_event）。

❾ 拆包 Event 对象中的数据。这一行代码会更新仿真钟 sim_time，对应于事件发生时的时间。16

16 这通常是离散事件仿真：每次循环时仿真钟不会以固定的量推进，而是根据各个事件持续的时间推进。

❿ 显示 Event 对象，指明是哪辆出租车，并根据出租车的编号缩进。

⓫ 从 self.procs 字典中获取表示当前活动的出租车的协程。

⓬ 调用 compute_duration (...) 函数，传入前一个动作（例如，'pick up passenger'、'drop off passenger' 等），把结果加到 sim_time 上，计算出下一次活动的时间。

⓭ 把计算得到的时间发给出租车协程。协程会产出下一个事件（next_event），或者抛出 StopIteration 异常（完成时）。

⓮ 如果抛出了 StopIteration 异常，从 self.procs 字典中删除那个协程。

⓯ 否则，把 next_event 放入队列中。

⓰ 如果循环由于仿真时间到了而退出，显示待完成的事件数量（有时可能碰巧是零）。

注意，示例 16-23 中的 Simulator.run 方法有两处用到了第 15 章介绍的 else 块，而且都不在 if 语句中。

主 while 循环有一个 else 语句，报告仿真系统由于到达结束时间而结束，而不是由于没有事件要处理而结束。

* 靠近主 while 循环底部那个 try 语句把 next_time 发给当前的出租车进程，尝试获取下一个事件（next_event），如果成功，执行 else 块，把 next_event 放入 self.events 队列中。

我觉得，如果没有这两个 else 块，Simulator.run 方法的代码会有点难以阅读。

这个示例的要旨是说明如何在一个主循环中处理事件，以及如何通过发送数据驱动协程。这是 asyncio 包底层的基本思想，我们在第 18 章会学习这个包。

16.10　本章小结

Guido van Rossum 写道，生成器有三种不同的代码编写风格：

有传统的「拉取式」（迭代器）、「推送式」（例如计算平均值那个示例），还有「任务式」（读过 Dave Beazley 写的协程教程了吗……）。17

17 摘自对 Python-ideas 邮件列表中「Yield-From: Finalization guarantees」消息的回复。Guido 所说的 David Beazley 写的教程是「A Curious Course on Coroutines and Concurrency」。

第 14 章专门介绍了迭代器，本章则介绍了「推送式」协程，还介绍了特别简单的「任务式」—— 仿真示例中的出租车进程。第 18 章会在并发编程中使用这两种技术实现异步任务。

计算移动平均值的示例展示了协程的常见用途：累加器，处理接收到的值。我们知道，可以在协程上应用装饰器，预激协程；在某些情况下，这么做更方便。不过要记住，预激装饰器与协程的某些用法不兼容。尤其是 yield from subgenerator ()，这个结构假定 subgenerator 没有预激，然后自动预激。

每次调用 send 方法时，作为累加器使用的协程可以获取部分结果，不过能返回值的协程更有用。这个特性在 PEP 380 中定义，于 Python 3.3 引入。我们知道，现在生成器中的 return the_result 语句会抛出 StopIteration (the_result) 异常，这样调用方可以从异常的 value 属性中获取 the_result。这样获取协程的结果还是很麻烦，不过 PEP 380 引入的 yield from 句法能自动处理。

探讨 yield from 结构时，我们首先从使用简单的迭代器的示例入手，然后又举了一个例子，重点说明 yield from 结构的三个主要组件：委派生成器（在定义体中使用 yield from），yield from 激活的子生成器，以及通过委派生成器中 yield from 表达式架设起来的通道把值发给子生成器，从而驱动整个过程的客户代码。最后，那一节参照 PEP 380 中使用的英语和类似 Python 的伪代码分析了 yield from 结构的正式定义。

本章最后举了一个离散事件仿真示例，说明如何使用生成器代替线程和回调，实现并发。那个出租车仿真系统虽然简单，但是首次一窥了事件驱动型框架（如 Tornado 和 asyncio）的运作方式：在单个线程中使用一个主循环驱动协程执行并发活动。使用协程做面向事件编程时，协程会不断把控制权让步给主循环，激活并向前运行其他协程，从而执行各个并发活动。这是一种协作式多任务：协程显式自主地把控制权让步给中央调度程序。而多线程实现的是抢占式多任务。调度程序可以在任何时刻暂停线程（即使在执行一个语句的过程中），把控制权让给其他线程。

最后要说明一点，本章对协程的定义是宽泛的、不正式的，即：通过客户调用 .send (...) 方法发送数据或使用 yield from 结构驱动的生成器函数。写作本书时，「PEP 342— Coroutines via Enhanced Generators」和现有的大多数 Python 书籍都使用这个宽泛的定义。第 18 章介绍的 asyncio 库建构在协程之上，不过采用的协程定义更为严格：在 asyncio 库中，协程（通常）使用 @asyncio.coroutine 装饰器装饰，而且始终使用 yield from 结构驱动，而不通过直接在协程上调用 .send (...) 方法驱动。当然，在 asyncio 库的底层，协程使用 next (...) 函数和 .send (...) 方法驱动，不过在用户代码中只使用 yield from 结构驱动协程运行。

16.11　延伸阅读

David Beazley 是 Python 生成器和协程的终极权威。他与 Brian Jones 合著的《Python Cookbook（第 3 版）中文版》一书中有很多使用协程编写的诀窍。Beazley 在 PyCon 期间开设的课程兼有深度和广度，因此享有盛名。首先是 PyCon US 2008 期间的「Generator Tricks for Systems Programmers」课程，在 PyCon US 2009 期间又开设了声名远播的「A Curious Course on Coroutines and Concurrency」课程（三个部分的全部视频链接很难找到：第一部分；第二部分；第三部分）。他最新的课程在蒙特利尔 PyCon 2014 期间开设，题为「Generators: The Final Frontier」。在这个课程中，他举了更多并发的例子，因此与本书第 18 章的话题联系更大。他根本不担心学员的大脑会爆炸，因此在「The Final Frontier」课程的最后一部分用协程代替了经典的访问者模式，用于计算算术表达式。

使用协程能以多种新方式组织代码，不过与递归和多态（动态调度）一样，要花点时间才能习惯。James Powell 写了一篇文章，题为「Greedy algorithm with coroutines」。他在这篇文章中使用协程重写了经典的算法。你可能还想浏览 ActiveState Code 诀窍数据库中标记为协程的流行诀窍。

Paul Sokolovsky 为 Damien George 开发的超级精简的 MicroPython（针对微控制器）解释器实现了 yield from 结构。在研究这个特性的过程中，他制作了非常详细的示意图，解说 yield from 结构的工作原理，并在 python-tulip 邮件列表中分享。Sokolovsky 很友好，允许我把那个 PDF 文件复制到本书的网站中，那个文件的固定链接是 http://flupy.org/resources/yield-from.pdf。

写作本书时，只有 asyncio 库本身和使用这个库的代码大量使用 yield from。我花了很多时间，想找到不依赖 asyncio 库的 yield from 示例。Greg Ewing（PEP 380 的作者，为 CPython 实现了 yield from）发表了一些 yield from 的使用示例：BinaryTree 类、一个简单的 XML 解析器和一个任务调度程序。

Brett Slatkin 写的《Effective Python：编写高质量 Python 代码的 59 个有效方法》一书中的第 40 条短小精辟，题为「考虑用协程来并发地运行多个函数」（网上有免费的英文版样章）。这一节中使用 yield from 驱动生成器的示例是我见过最棒的：那个示例实现了 John Conway 发明的「生命游戏」，使用协程管理游戏运行过程中各个细胞的状态。该书的随书代码在一个 GitHub 仓库中。我重构了那个「生命游戏」示例 —— 把 Slatkin 书中的函数和类与测试代码分开（原来的代码）。我还编写了 doctest 形式的测试，因此不用运行脚本就能看到各个协程和类的输出。重构后的示例发布在 GitHub Gist 网站上。

还有几个有趣的示例没用 asyncio 库，只用了 yield from：Peter Otten 在 Python Tutor 邮件列表中发布的消息，「Comparing two CSV files using Python」；Ian Ward 以 iPython Notebook 形式发布的「Iterables, Iterators, and Generators」教程，实现的是剪刀石头布游戏。

Guido van Rossum 在 python-tulip Google Group 中发表了一篇内容很长的消息，题为「The difference between yield and yield-from」，值得一读。2009 年 3 月 21 日，Nick Coghlan 在 Python-Dev 邮件列表中发布了带有大量注释的 yield from 扩充实现（https://mail.python.org/pipermail/python-dev/2009-March/087382.html）。在那篇消息中，他写道：

不管人们是否觉得使用 yield from 结构的代码难以理解，也不管人们能否领会协作式多线程相关的概念，yield from 结构底层的精巧处理能实现真正的嵌套生成器。

Yury Selivanov 撰写的「PEP 492—Coroutines with async and await syntax」提议为 Python 增加两个关键字：async 和 await。async 与其他现有的关键字结合使用，用于定义新的语言结构。例如，async def 用于定义协程，async for 用于使用异步迭代器（实现 __aiter__ 和 __anext__ 方法，这是协程版的 __iter__ 和 __next__ 方法）迭代可迭代的异步对象。为了避免与即将引入的 async 关键字冲突，asyncio.async () 函数将在 Python 3.4.4 中重命名为 asyncio.ensure_future ()。await 关键字的作用与 yield from 结构类似，不过只能在以 async def 定义的协程（禁止使用 yield 和 yield from）中使用。PEP 492 使用新句法把发展成类似协程对象的生成器与全新的原生协程对象明确地区分开了。得益于 async 和 await 关键字，以及几个特殊的新方法，Python 语言将对原生的协程对象提供更好的支持。协程已经做好准备，会成为 Python 未来特别重要的特性，因此 Python 语言应该更好地集成协程。

使用离散事件仿真系统做试验是熟悉协作式多任务的好方法。维基百科中的「Discrete event simulation」一文是不错的入门资料。18Ashish Gupta 写的短篇教程「Writing a Discrete Event Simulation: Ten Easy Lessons」说明了如何自己动手（不使用特别的库）编写离散事件仿真系统。那篇教程中的代码使用 Java 编写，因此是基于类的，而且没使用协程，不过可以轻松地移植到 Python。除了代码之外，那篇简短的教程还介绍了离散事件仿真的术语和组件。把 Gupta 教程中的示例转换成 Python 类，然后再转换成利用协程的类，是个很好的练习。

18 如今，即使终身教授也同意，维基百科几乎是学习任何计算机科学知识的入门首选。对其他知识而言虽然不是如此，但是在计算机科学这方面，维基百科特别棒。

如果想使用现成的 Python 协程库，可以使用 SimPy。这个库的在线文档中说道：

SimPy 是使用标准的 Python 开发的基于进程的离散事件仿真框架，事件调度程序基于 Python 的生成器实现，因此还可用于异步网络或实现多智能体系统（即可模拟，也可真正通信）。

协程不是特别新的 Python 特性，但是得到异步编程框架支持（Tornado 最先支持）之前，只在较窄的应用领域内使用。Python 3.3 引入的 yield from 结构和 Python 3.4 添加的 asyncio 包可能会提升协程（和 Python 3.4 本身）的使用量。但写作本书时，Python 3.4 发布还不到一年，因此观看 David Beazley 的课程，阅读涉及这个话题的经典实例时，不会有太多内容深入探讨 Python 协程编程。不过，这只是暂时的。

杂谈

raise from lambda

对编程语言来说，关键字的作用是建立控制流程和表达式计算的基本规则。

语言的关键字像是棋盘游戏中的棋子。对国际象棋来说，关键字是♔、♕、、、和；对围棋来说，关键字是●。

国际象棋的棋手实现计划时，有六种类型的棋子可用；而围棋的棋手看起来只有一种类型的棋子可用。可是，在围棋的玩法中，相邻的棋子能构成更大更稳定的棋子，形状各异，不受束缚。围棋棋子的某些排列是不可摧毁的。围棋的表现力比国际象棋强。围棋的开局走法有 361 种，大约有 1e+170 个合规的位置；而国际象棋的开局走法有 20 种，有 1e+50 个位置。

如果为国际象棋添加一个新棋子，将带来颠覆性的改变；为编程语言添加一个新的关键字也是如此。因此，语言的设计者谨慎考虑引入新关键字是合理的。

表 16-1：不同编程语言中的关键字数量

关键字数量

语言

备注

5

Smalltalk-80

以句法极简而著称

25

Go

编程语言，而不是围棋 *

32

C

指 ANSI C。C99 有 37 个关键字，C11 有 44 个

33

Python

Python 2.7 有 31 个关键字，Python 1.5 有 28 个

41

Ruby

关键字可以作为标识符使用（例如，class 也是一个方法的名称）

49

Java

与 C 语言一样，基本类型的名称（char、float 等）是保留字

60

JavaScript

包含 Java 1.0 的所有关键字，很多都没用（http://mzl.la/1JIr8fM）

65

PHP

PHP 5.3 之后引入了七个关键字，如 goto、trait 和 yield

85

C++

据 cppreference.com 网站给出的信息，C++11 在现有的 75 个关键字的基础上添加了 10 个

555

COBOL

这不是我捏造的。参见 IBM ILE COBOL 手册

∞

Scheme

任何人都能定义新关键字

* 围棋的英文是 Go，因此作者备注这里说的是 Go 语言。—— 译者注

Python 3 添加了 nonlocal 关键字，把 None、True 和 False 提升为关键字，废弃了 print 和 exec。在语言的发展过程中，弃用关键字十分罕见。表 16-1 列出了几门语言，按照关键字的数量排序。

Scheme 继承了 Lisp 的宏，允许任何人创建特殊的形式，为语言添加新的控制结构和计算规则。用户定义的这种标识符叫作「句法关键字」。Scheme R5RS 标准声称，「这门语言没有保留的标识符」（标准的第 45 页，但是 MIT/GNU Scheme 这种特殊的实现预定义了 34 个句法关键字，例如 if、lambda 和 define-syntax（用于创建新关键字的关键字）。19

Python 像国际象棋，而 Scheme 像围棋。

现在，回到 Python 句法。我觉得 Guido 对关键字的态度过于保守了。关键字的数量应该少，添加新关键字可能会破坏大量代码，但是在循环中使用 else 揭示了一个递归问题：在更适合使用新关键字的地方重用现有的关键字。在 for、while 和 try 的上下文中，应该使用 then 关键字，而不该妄用 else。

在这个问题上，最严重的一点是重用 def。现在，这个关键字用于定义函数、生成器和协程，而这些对象之间的差异很大，不应该使用相同的句法声明。20

引入 yield from 句法尤其让人失望。再次声明，我觉得真的应该为 Python 使用者提供新的关键字。更糟的是，这开启了新的趋势：把现有的关键字串起来，创建新的句法，而不添加描述性的合理关键字。恐怕有一天我们要苦苦思索 raise from lambda 是什么意思。

突发新闻

完成本书的技术审校之后，Yury Selivanov 提交的「PEP 492 — Coroutines with async and await syntax」好像要被接受了，将在 Python 3.5 中实现。21Guido van Rossum 和 Victor Stinner 都支持这个 PEP，前者是 Python 语言的创造者，后者是 asyncio 库的主要维护者，而 asyncio 库将是新句法的主要使用案例。回应 Selivanov 在 Python-ideas 邮件列表中发布的消息时，Guido 甚至暗示，为了实现这个 PEP，可能会延迟发布 Python 3.5。

当然，这会平息前一节所述的大部分抱怨。

19「The Value Of Syntax?」一文对可扩展的句法和编程语言的可用性做了有趣的探讨。Lambda the Ultimate 讨论组是编程语言极客的度假胜地。

20JavaScript、Python 和其他语言都有这样的问题。推荐阅读 Bob Nystrom 写的「What Color Is Your Function?」一文。

21Python 3.5 已经接受了 PEP 492，增加了两个关键字：async 和 await。—— 编者注

