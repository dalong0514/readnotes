## 记忆时间

## 20200409Why-should-you-use-Vuejs-when-using-Laravel.md

### 01. What is Vue.js?

Straight from the horse’s mouth, “Vue is a progressive framework for building user interfaces”. Vue at its core is focused on the view layer only of an application, so integrating with other platforms or existing applications is really easy. You can also use Vue on its own to build sophisticated single page applications.

1『 vue 是用于视图层的框架。』

### 02. How does Vue work?

If you have programmed for the web before the era of event-driven frontend JavaScript frameworks, you would understand there are considerable difficulties and inefficiencies that arise from trying to update the Document Object Model (DOM).

To update the DOM directly means you would have to take the page, make the change to a small part of it, then reload the entire DOM so the changes can take effect. If say you are watching a YouTube video and there is a new comment, the entire page would reload and your video would have to start afresh.

1『 DOM 的一大弊端，页面改动一点点需要重新渲染整个 DOM。』

Vue tries to solve these challenges by utilizing a virtual DOM to manage the view a user sees. Vue essentially creates a copy of the DOM and stores it. When a change is made to any part of the DOM, it just updates only that section of the DOM without reloading the DOM. This means the comments would update without you even noticing it.

1『 Vue 的基本原理。』

Vue provides reactive and composable view components. Vue responds to events and triggers changes on the DOM instantaneously. Its composable components can be selected and assembled in various combinations to satisfy whatever need arises. You can have components for everything and reuse them however you need.

### 03. Why you should use Vue with Laravel

This is one question that you need to take your time to answer. It is important to understand what Vue has to offer and what that means for your work. We are going to explore a few reasons why you should use Vue with Laravel.

#### 1. Everything happens on the frontend

Applications on the internet today are event-driven. They are built to ensure users have a seamless experience like they would if they used an application installed on their computer. Everything now happens on the frontend and users never have to reload a page again (thank you JavaScript).

#### 2. Reactive components make for an excellent event-driven app

Vue lets you build a full-scale application that is event-driven and has all activity completely handle on the frontend. It also provides composable components that can be used however you wish. Given that it couples nicely with Laravel, you will only need to make a few trips to request data from your Laravel application and make UI changes by switching components without reloading the page.

1『上面的观点又想到，laravel 就负责做 api？』

You can trigger UI changes that are seamless with your Vue frontend, which in turn gives your users an amazing experience. It could be as simple as making a text on your page editable or swapping out an entire component to load up a video requested by a user without reloading the page. Given Vue’s speed and performance, this happens very fast and smoothly without taking up so much of your computer resources.

#### 3. Building optimal complex frontend pages

If you think of building an application with parts that need to update frequently, you have no other choice than to make the frontend run completely on JavaScript. The challenge with vanilla JavaScript or jQuery or other JavaScript libraries that do not have a virtual DOM is that you quickly hit performance issues with the frequency of update increases or the volume of data to track for changes increases significantly. Changes to the DOM will gradually cease to be instantaneous and you begin to experience noticeable performance lags.

When you compose your application with Vue components, each component’s dependencies are automatically tracked during its render, so the system knows precisely which component actually needs to be updated when there is a change in data. This makes all updates to the DOM use minimal resources, thereby improving the overall application efficiency.

Vue is also compatible with state managers like Flux, Redux, and Vuex which are excellent in managing data flow in complex applications. Vue’s utilization of a one-way data binding model also makes state management easier in complex applications.

#### 4. Single Page Application

I would like to share a personal opinion – Single Page Applications are the greatest thing to happen to the internet in the last decade. It opens up applications to a wider audience of users than was possible before. When you consider that many internet users outside of some parts of America and Europe have challenges getting on the internet, you begin to appreciate the role single page applications play in delivering a rich web experience to them. Your entire application assets get loaded once (and most of it cached), all that your application does as the user engages with it is request data which typically requires low bandwidth to fulfill.

#### 5. Easy to learn and use

Vue is easy to get into. It provides very few options for you as the developer and has a lot abstracted away. You feel like you are writing plain JavaScript when you use Vue and you can make a simple application with plain JavaScript and it remains valid in Vue.

Another great thing about Vue is that your valid HTML is also a valid Vue template. You can keep your CSS external or you can process it with JavaScript depending on your application needs. You can also take advantage of scoped styling, to apply style changes to a single component on the fly without the change affecting other components. If you are familiar with JavaScript, you can build a non-trivial application with Vue after just one day of reading the documentation.

### 04. Basic Vue usage with Laravel

Vue integrates nicely with Laravel. You can create Vue components and use them like you would use regular HTML tags inside your blade file. You can pass props to the component from the output generated when your blade file renders. To try it out, create a new Laravel installation using the Laravel installer:

    $ composer create-project laravel/laravel vueapp --prefer-dist '6.*'

1『

composer create-project laravel/laravel laravel --prefer-dist '6.*'

目前新建项目：

```
Package jakub-onderka/php-console-color is abandoned, you should avoid using it. Use php-parallel-lint/php-console-color instead.
Package jakub-onderka/php-console-highlighter is abandoned, you should avoid using it. Use php-parallel-lint/php-console-highlighter instead.
```

』

Install Vue and other JavaScript libraries your application needs to run:

    $ npm install

1『

这里改用 yarn 安装：

```
yarn install --no-bin-links
yarn add cross-env
```

发现跑 watch 还是失败，最后还是通过 npm 安装解决的：npm install。安装后有 2 个警告：

```
npm WARN sass-loader@8.0.2 requires a peer of node-sass@^4.0.0 but none is installed. You must install peer dependencies yourself.
npm WARN sass-loader@8.0.2 requires a peer of fibers@>= 3.1.0 but none is installed. You must install peer dependencies yourself.
```

手动安装下 2 个包：

```
npm install node-sass
npm install fibers
```

』

Setup your application to reload when you make changes to your js assets:

    $ npm run watch

1『用 npm run watch-poll 命令。』

If you like seeing your changes as you make them, especially since you are learning, then you should definitely run watch to watch the applications. Now, open another terminal instance and start the Laravel application server:

    $ php artisan serve

### 05. Creating your first Vue Component

1『在 resources/js/ 下新建文件夹 components，该文件夹下新建 Welcome.vue 并把原文中的代码复制过去。』

### 06. Using the component in your blade file

We have made our first Vue component (I know, it is that easy). To use it in the welcome.blade.php file, we would need to make Vue aware that it exists and give it a name Vue would label it with. Open the resources/assets/js/app.js file and edit it to the following:

```
require('./bootstrap');

window.Vue = require('vue');

Vue.component('welcome', require('./components/Welcome.vue'));

const app = new Vue({
    el: '#app'
});
```

1『

上面是配置的关键。报错：

```
ERROR in ./resources/js/app.js
Module not found: Error: Can't resolve 'vue' in '/Users/Daglas/laravel/vueapp/resources/js'
 @ ./resources/js/app.js 3:13-27
 @ multi ./resources/js/app.js ./resources/sass/app.scss
```

问题在这个语句：window.Vue = require('vue'); 从哪引入 vue 呢？因为之前 laravel 里没装 vue 框架。vue 官网上找到了答案：NPM，在用 Vue 构建大型应用时推荐使用 NPM 安装。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。

```
# 最新稳定版
$ npm install vue
```

用 npm 装完后，上面 app.js 里的代码就没问题了。

』

Next, use the Vue component inside of your resources/views/welcome.blade.php file:

```html
[...]
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Laravel</title>

[...]
    <body>
        <div id="app">
            <welcome></welcome>
        </div>
        <script type="text/javascript" src="js/app.js"></script>
    </body>
[...]
```

1『

报错：Failed to mount component: template or render function not defined

搜索获得解决方案：[[Vue warn]: Failed to mount component: template or render function not defined. (found in root instance) · Issue #198 · JeffreyWay/laravel-mix](https://github.com/JeffreyWay/laravel-mix/issues/198)

It should be require('./components/Example.vue').default. Since v13, vue-loader exports the component as the default key, which still works the same when using import, but requires the above when using require.

把 app.js 里 vue 的引入语句改为：Vue.component('welcome', require('./components/Welcome.vue').default);

』

Make sure to edit the file accordingly and include the script tag in it so that your Vue component can be visible on the page. If you set your application to watch for changes to your js assets, then you should see that it already built the entire application and would output compiled successfully in XXXms.

### 07. Passing data to the component

Let us assume we want to output the details of the developer of the application, and we cannot know it because only the application can give that detail. We can easily pass the details to the component and have it display it when it renders. Next, we will pass a title to the component and see what it looks like. Open the welcome blade file located at resources/views/welcome.blade.php and add the following:

```html
[...]
<div id="app">
   <welcome :title="'This cool app'"></welcome>
</div>
[...]
```

We just passed data into the component by binding the data to a variable we would receive in the component as a property (prop). Then, open the Welcome.vue file located at resources/assets/js/components/Welcome.vue and add the following to it:

```js
<template>
            [...]
            <div class="title m-b-md">
                {{title}}
            </div>

            [...]
</template>

<script>
    export default {
        props : ['title']
    }
</script>
```

From the above code, you will see we replaced the Welcome to Vue.js on Laravel with {{title}}. This is the way to output the content of a variable in your Vue template, just like with Laravel blade template. In the script section, we received a prop using props : ['title'] and the prop we received is what we displayed.

Next, we will pass the title from our application server. Open the routes/web.php file and edit as follows:

```php
[...]
Route::get('/', function () {
    return view('welcome',
        [
            'title' => "An even cooler way to do the title"
        ]
    );
});
```

Then, edit the welcome.blade.php file as follows:

```html
[...]
<div id="app">
   <welcome :title="'{{$title}}'"></welcome>
</div>
[...]
```

1『注意，绑定 title 变量时不要漏掉单引号。』

We just output the content title from the server and pass it directly to the component. Next, we will add a second page to our application and make a second component. Create a new file resources/assets/js/components/Page.vue and add the following to it:

```html
<template>
    <div class="flex-center position-ref full-height">
        <div class="content">
            <div class="title m-b-md">
                {{title}}
            </div>

            <div class="links">
                <span class="subtitle">Name : {{author.name}}</span><br/>
                <span class="subtitle">Role : {{author.role}}</span><br/>
                <span class="subtitle">Code : {{author.code}}</span><br/>
            </div>
        </div>
    </div>
</template>

<script>
    export default {
        props : ['title', 'author']
    }
</script>
<style scoped>
    html, body {
        background-color: #fff;
        color: #939b9f;
        font-family: 'Raleway', sans-serif;
        font-weight: 100;
        height: 100vh;
        margin: 0;
    }
    .title {
        font-size: 60px;
    }
    .subtitle {
        font-size: 20px;
    }
    .full-height {
        height: 100vh;
    }

    .flex-center {
        align-items: center;
        display: flex;
        justify-content: center;
    }
    .position-ref {
        position: relative;
    }

    .top-right {
        position: absolute;
        right: 10px;
        top: 18px;
    }
    .content {
        text-align: center;
    }
    .m-b-md {
        margin-bottom: 30px;
    }
</style>
```

Like the first page, we received a second prop that is a json object that contains author information. We have rendered the page with the Author information. Let us make Vue aware of the new component we just created. Open resources/assets/js/app.js file and add the following:

```
[...]

Vue.component('welcome', require('./components/Welcome.vue'));
Vue.component('page', require('./components/Page.vue'));

[...]
```

Now, create a new file resources/views/page.blade.php and add the following to it:

```html
<!doctype html>
<html lang="{{ app()->getLocale() }}">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Page</title>

        <link href="https://fonts.googleapis.com/css?family=Raleway:100,600" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="app">
            <page :title="'{{$title}}'" :author="{{$author}}"></page>
        </div>
        <script type="text/javascript" src="js/app.js"></script>
    </body>
</html>
```

Finally, open routes/web.php and add a route for loading the page at the end of the file:

```php
[...]

Route::get('/page', function () {
    return view('page',
        [
            'title' => "Page 2 - A little about the Author",
            'author' => json_encode([
                    "name" => "Fisayo Afolayan",
                    "role" => "Software Enginner",
                    "code" => "Always keeping it clean"
            ])
        ]
    );
});
```

To view our new route, visit http://127.0.0.1:8000/page on your browser.

### 08. Building the entire frontend in Vue

So far, we have looked at one way to use Vue and Laravel. When we started this article, we talked about everything running on the frontend and users not having to reload anything. We are going to see how to build a Single Page App (SPA) a user would only have to load once and fetch everything by making API calls.

1『单页 APP，这个思想好，就最开始构建一次页面，后面所有的更新通过掉 api 的数据来交互。』

### 09. Installing vue router

Vue router is the Vue tool for building navigation on the frontend application. It would allow you navigate an SPA like you would a regular application. To install vue router, run the following command on your terminal:

    $ npm install vue-router

Exit the watch process we initiated earlier using ctrl + c. We would start watching for changes again after vue router is installed.

### 10. Setting up the routes

Now that vue router is installed, we need to define the routes of the application. This will be the guide for switching between the components we have made. Create a new file resources/assets/js/vueapp.js and edit it as follows:

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

import App from './components/App'
import Welcome from './components/Welcome'
import Page from './components/Page'

const router = new VueRouter({
    mode: 'history',
    routes: [
        {
            path: '/home',
            name: 'welcome',
            component: Welcome,
            props: { title: "This is the SPA home" }
        },
        {
            path: '/spa-page',
            name: 'page',
            component: Page,
            props: { 
                title: "This is the SPA Second Page",
                author : {
                    name : "Fisayo Afolayan",
                    role : "Software Engineer",
                    code : "Always keep it clean"
                }
            }
        },    
    ],
})
const app = new Vue({
    el: '#app',
    components: { App },
    router,
});
```

### 11. What sorcery was that?

You are already familiar with what import does in JavaScript and how to do it. In the above code, we have imported everything we want to use for our SPA.

Vue.use(VueRouter) – telling vue to use the router package, so it can access all the functionalities of the router and interpret the route we are about to create.

const router = new VueRouter – defines the routes our application is going to have. Through the application, the routes definitions will not be changed, so we have to make them constant.

mode – this is the mode we want the router to use in managing the navigation of the application. The default mode is hash mode which uses the URL hash to simulate a full URL so that the page won’t be reloaded when the URL changes. The other is history mode, which leverages the history.pushState API to achieve URL navigation without a page reload.

routes – the routes we would like our application to have.

path – the url to access this route.

name – the name we would like to give this route (useful when navigating in-component).

component – the component we want loaded when this route is visited.

props – we are passing props to the component as we mount them.

The last part creates the Vue application and defines the parent component the router will use as it’s entry point. In our case, we used the App component as the parent component.

### 12. Setting up the parent container

We need to create the App component in resources/assets/js/components directory. Add the following to it:

```html
<template>
    <div>
        <nav class="navbar navbar-expand-md navbar-light navbar-laravel">
            <div class="container">
                <ul class="navbar-nav">
                    <router-link :to="{ name: 'welcome' }" class="nav-link">Home</router-link>
                    <router-link :to="{ name: 'page' }" class="nav-link" >Spa-Page</router-link>
                </ul>
            </div>
        </nav>
        <main>
            <router-view></router-view>
        </main>
    </div>
</template>
<script>
    export default {}
</script>
```

Vue will use \<router-view> as the outlet for any component we visit as its URL. The \<router-link> is responsible for navigating between components. If you notice, we are assigning the name we gave the routes to the to attribute of the route.

1『在 components 文件夹下新建文件 App.vue。』

### 13. Mounting our components

We need to do a few things before we can use our SPA. We need to first set the vueapp.js file to be built. We need to also define the blade file our SPA will use as it’s entry point. Finally, we need to define the route that w enable us to access the SPA.

To set vueapp.js to be built, edit the webpack.mix.js file as follows:

```js
[...]

mix.js('resources/assets/js/app.js', 'public/js')
   .js('resources/assets/js/vueapp.js', 'public/js')
   .sass('resources/assets/sass/app.scss', 'public/css');
```

Now, create the file vueapp.blade.php inside the resources/views directory. Edit it as follows:

```html
<!doctype html>
<html lang="{{ app()->getLocale() }}">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Outlet for SPA</title>

        <link href="https://fonts.googleapis.com/css?family=Raleway:100,600" rel="stylesheet" type="text/css">
        <link rel="stylesheet" type="text/css" href="css/app.css">
    </head>
    <body>
        <div id="app">
            <app></app>
        </div>
        <script type="text/javascript" src="js/vueapp.js"></script>
    </body>
</html>
```

Then define the route in routes/web.php file as follows:

```php
[...]
Route::get('/{any}', function(){
        return view('vueapp');
})->where('any', '.*');
```

Now, build the application by running the following command:

    $ npm run prod

Visit the application on http://127.0.0.1:8000/home

1『跑完后，public 文件夹下的 js 文件夹会自动生成 vueapp.js。』

### Conclusion

In this guide we have looked at what Vue.js can do and how it can work with Laravel. We explored some reasons why you should consider using Vue with Laravel. We also looked at how to use Vue with Laravel, including making a single page application that will run on Laravel.

There is a whole lot you can build with Vue and Laravel. Only the surface was scratched in this article to give you an idea of what is obtainable. Vue is very easy to use and works well with Laravel. You should read the documentation to learn of the cool thing you can build with it.

2『 [fisayoafolayan/laravel-vue: This project creates a simple SPA application using Laravel and VueJS.](https://github.com/fisayoafolayan/laravel-vue) 已下载项目源码「2020016laravel-vue」存入「2020017forked」。』

## 20200428JavaScript1-2-and-in-between.md

Brendan Eich, 2005

Inventing toolkits and extension systems on top of JS is cool. I hoped that would happen, because during Netscape 2 and 3 days I was under great pressure to minimize JS-the-language, implement JS-the-DOM, and defer to Java for “real programming” (this was a mistake, but until Netscape hired more than temporary intern or loaner help, around the time Netscape 4 work began, I was the entire “JS team” — so delegating to Java seemed like a good idea at the time). Therefore in minimizing JS-the-language, I added explicit prototype-based delegation, allowing users to supplement built-in methods with their own in the same given single-prototype namespace.

In listening to user feedback, participating in ECMA TG1 (back during Edition 1 days, and again recently for E4X and the revived Edition 4 work), and all the while watching how the several major “JS” implementors have maintained and evolved their implementations, I’ve come to some conclusions about what JS does and does not need.

1『关键知识来了，EC 总结了 JS 需要进化的内容以及不需要做的。』

1. JS is not going away, so it ought to evolve. As with sharks (and relationships, see Annie Hall), a programming language is either moving forward, or it’s dead. Now dead languages (natural and programming) have their uses; fixed denotation and grammar, and in general a lack of “versionitis”, are virtues. You could argue that JS’s stagnation, along with HTML’s, was beneficial for the “Web 1.0” build-out of the last decade. But given all the ferment on the web today, in XUL and its stepchildren, and with user scripting, there should be a JS2, and even a JS1.6 on the way toward JS2.

2. JS does not need to become Java, or C#, or any other language. 

3. JS does need some of its sharp corners rounded safely. See the table below for details.

4. Beyond fixing what was broken in JS1, JS should evolve to solve problems that users face today in the domains where JS lives: web page and application content (including Flash), server-side scripting (whether Rhino or .NET), VXML and similar embeddings, and games.

5. For example, it should be trivial in a future version of JS to produce or consume a “package” of useful script that presents a consistent interface to consumers, even as its implementation details and new interfaces evolve to better meet existing requirements, and to meet entirely new requirements. In no case should internal methods or properties be exposed by default.

6. It’s clear to me that some users want obfuscated source code, but I am not in favor of standardizing an obfuscator. Mozilla products could support the IE obfuscator, if someone wants to fix bug 125525. A standard obfuscator is that much less obscure, besides being unlikely to be adopted by those who have already invented their own (who appear to be the only users truly motivated by a need for obfuscation at this point).
A more intuitive numeric type or type tower would help many users, although to be effective it would have to be enabled via a new compile-time option of some sort. Numeric type improvements, together with Edition 4’s extensible operator and unit proposals, would address many user requests for enhancement I’ve heard over the years.

7. Too much JS, in almost every embedding I’ve seen, suffers from an execution model that appears single-threaded (which is good for most users) yet lacks coroutining or more specific forms of it such as generators (Boo has particularly nice forms, building on Python with a cleanup or two). So users end up writing lots of creepy callbacks, setTimeout chains, and explicit control block state machines, instead of simply writing loops and similar constructs that can deliver results one by one, suspending after each delivery until called again.

That’s my “do and don’t” list for any future JS, and I will say more, with more specifics, about what to add to the language. What to fix is easier to identify, provided we can fix compatibly without making a mess of old and new.

Here are the three most-duplicated bug reports against core language design elements tracked by Mozilla’s bugzilla installation:

I argue that we ought to fix these, in backward-compatible fashion if possible, in a new Edition of ECMA-262. If we solve other real problems that have not racked up duplicate bug counts, but fail to fix these usability flaws, we have failed to listen to JS users. Let’s consider these one by one:

1. Unlike object and array initialisers, and E4X’s XML literals, regular expression literals correspond one-for-one with objects created during parsing. While this is often optimal and even useful, when combined with the g (global) flag and the lastIndex property, these singleton literals make for a pigeon-hole problem, and a gratuitous inconsistency with other kinds of “literals”. To fix this compatibly, we could add a new flag, although it would be good to pick a letter not used by Perl (or Perl 6, which fearlessly revamps Perl’s regular expression sub-language in ways that ECMA-262 will likely not follow).

2. The Date.prototype.getYear method is a botch and a blight, the only Y2K bug in Mozilla-based browsers that still ships for compatibility with too many web sites. This bug came directly from java.util.Date, which was deprecated long ago. I’d like to get rid of it, but in the mean time, perhaps we should throw in the towel and emulate IE’s non-ECMA behavior (ECMA-262 did standardize getYear in a non-normative annex).
The solution here is a new default number type, with arbitrary precision and something equivalent to decimal radix. Mike Cowlishaw has advocated and implemented his own flavor of decimal arithmetic, but it is not popular in ECMA TG1. Still, I bet we could make life better for many JS users with some innovation here.

There are other bugs in JS1 to fix, particularly to do with Unicode in regular expressions, and even in source text (see the infamous ZWNJ and ZWJ should not be ignored bug). More on these too, shortly, but in a wiki, linked with informal discussion here.










