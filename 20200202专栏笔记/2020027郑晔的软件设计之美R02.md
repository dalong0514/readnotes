# 2020027郑晔的软件设计之美R02

## 记忆时间

## 0301. 编程范式：明明写的是 Java，为什么被人说成了 C 代码？

今天讨论了编程范式。编程范式指的是程序的编写模式。现在主流的编程范式主要有三种：结构化编程、面向对象编程和函数式编程。编程范式对程序员的能力施加了约束，理解编程范式的一个关键点在于，哪些事情不要做。从道理上讲，编程范式与具体语言的关系不大，但很多语言都有着自己主流的编程范式。但现在的一个趋势是，打破编程范式的「次元壁」，把不同编程范式中优秀的元素放在一起。一方面，我们可以通过设计，模拟出其他编程范式中的元素，另一方面，程序设计语言的发展趋势也是要融合不同编程范式中优秀的元素。学习不同的编程范式，已经成为每个程序员的必修课。如果今天的内容你只能记住一件事，那请记住：学习不同的编程范式，将其中优秀的元素运用在日常工作中。

在上一个小模块，我给你讲了程序设计语言，帮助你重新审视一下自己最熟悉的日常工具。但是，使用程序设计语言是每个程序员都能做到的，可写出的程序却是千差万别的。这一讲，我们就来看看这些差异到底是怎样造成的。

在开始之前，我先给你讲一个小故事。在一次代码评审中，小李兴致勃勃地给大家讲解自己用心编写的一段代码。这段代码不仅实现了业务功能，还考虑了许多异常场景。所以，面对同事们提出的各种问题，小李能够应对自如。在讲解的过程中，小李看到同事们纷纷点头赞许，心中不由得生出一丝骄傲：我终于写出一段拿得出手的代码了！讲解完毕，久久未曾发言的技术负责人老赵站了起来：「小李啊！你这段代码从功能上来说，考虑得已经很全面了，这段时间你确实进步很大啊！」

要知道，老赵的功力之深是全公司人所共知的。能得到老赵的肯定，对小李来说，那简直是莫大的荣耀。还没等小李窃喜的劲过去，老赵接着说了，「但是啊，写代码不能只考虑功能，你看你这代码写的，虽然用的是 Java，但写出来的简直就是 C 代码。」

正在兴头上的小李仿佛被人当头泼了一盆冷水，我用的是 Java 啊！一门正经八百的面向对象程序设计语言，咋就被说成写的是 C 代码了呢？「你看啊！所有的代码都是把字段取出来计算，然后，再塞回去。各种不同层面的业务计算混在一起，将来有一点调整，所有的代码都得跟着变。」老赵很不客气地说。还没缓过神来的小李虽然想辩解，但他知道老赵说得是一针见血，指出的问题让人无法反驳。

在实际的开发过程中，有不少人遇到过类似的问题。老赵的意思并不是小李的代码真就成了 C 代码，而是说用 Java 写的代码应该有 Java 的风格，而小李的代码却处处体现着 C 的风格。那这里所谓代码的风格到底是什么呢？它就是编程范式。

### 1.1. 编程范式

编程范式（Programming paradigm），指的是程序的编写模式。使用了什么编程范式，通常意味着，你主要使用的是什么样的代码结构。从设计的角度说，编程范式决定了你在设计的时候，可以使用的元素有哪些。

现在主流的编程范式主要有三种：1）结构化编程（structured programming）；2）面向对象编程（object-oriented programming）；3）函数式编程（functional programming）。

结构化编程，是大部分程序员最熟悉的编程范式，它通过一些结构化的控制结构进行程序的构建。你最熟悉的控制结构应该就是 if/else 这样的选择结构和 do/while 这样的循环结构了。结构化编程是最早普及的编程范式，现在最典型的结构化编程语言是 C 语言。C 语言控制结构的影响极其深远，成为了很多程序设计语言的基础。

面向对象编程，是现在最主流的编程范式，它的核心概念就是对象。用面向对象风格写出的程序，本质上就是一堆对象之间的交互。面向对象编程给我们提供了一种管理程序复杂性的方式，其中最重要的概念就是多态（polymorphism）。现在主流的程序设计语言几乎都提供面向对象编程能力，其中最典型的代表当属 Java。

函数式编程，是近些年重新崛起的编程范式。顾名思义，它的核心概念是函数。但是，它的函数来自于数学里面的函数，所以，和我们常规理解的函数有一个极大的不同：不变性。也就是说，一个符号一旦创建就不再改变。函数式编程的代表性语言应该是 LISP。我们在第 8 讲曾经提到过它。之所以要把这位老祖宗搬出来，因为确实还没有哪门函数式编程语言能够完全独霸一方。

编程范式不仅仅是提供了一个个的概念，更重要的是，它对程序员的能力施加了约束。1）结构化编程，限制使用 goto 语句，它是对程序控制权的直接转移施加了约束。2）面向对象编程，限制使用函数指针，它是对程序控制权的间接转移施加了约束。3）函数式编程，限制使用赋值语句，它是对程序中的赋值施加了约束。之后讲到具体的编程范式时，我们再来展开讨论，这些约束到底是什么意思。

与其说这些编程范式是告诉你如何编写程序，倒不如说它们告诉你不要怎样做。理解这一点，你才算是真正理解了这些编程范式。如果你去搜索编程范式的概念，你可能会找到更多的编程范式，比如，逻辑式编程，典型的代表是 Prolog 语言。但这些编程范式的影响力和受众面都相当有限。如果你想扩展自己的知识面，可以去了解一下。

### 1.2 多范式编程

从道理上讲，编程范式与具体语言的关系不大，这就好比你的思考与用什么语言表达是无关的。但在实际情况中，每一种语言都有自己的主流编程范式。比如，C 语言主要是结构化编程，而 Java 主要是面向对象编程。不过，虽然每种语言都有自己的主流编程范式，但丝毫不妨碍程序员们在学习多种编程范式之后，打破「次元壁」，将不同编程范式中的优秀元素吸纳进来。这里的重点是「优秀」，而非「所有」。

举个例子，在 Linux 的设计中，有一个虚拟文件系统（Virtual File System，简称 VFS）的概念，你可以把它理解成一个文件系统的接口。在所有的接口中，其中最主要的是 file_operations，它就对应着我们熟悉的各种文件操作。下面是这个结构的定义，这个结构很长，我从中截取了一些我们最熟悉的操作：

```c
struct file_operations {
  loff_t (*llseek) (struct file *, loff_t, int);
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  int (*open) (struct inode *, struct file *);
  int (*flush) (struct file *, fl_owner_t id);
  int (*release) (struct inode *, struct file *);
  ...
}
```

如果你要开发一个自己的文件系统，只需要把支持的接口对应着实现一遍，也就是给这个结构体的字段赋值。我们换个角度看，这个结构体主要的字段都是函数指针，文件系统展现的行为与这些函数的赋值息息相关。只要给这个结构体的字段赋值成不同的参数，也就是把不同的函数关联上，这个文件系统就有了不同的行为。如果熟悉面向对象编程，你会发现，这不就是多态吗？

C 是一门典型的结构化编程语言，而 VFS 的设计展现出来的却是面向对象编程的特点，编程范式的「次元壁」在这里被打破了。

事实上，类似的设计还有很多，比如，Java 里有一个著名的基础库，Google 出的 Guava。它里面就提供了函数式编程的基础设施。在 Java 8 之前，Java 在语法上并不支持函数式编程，但这并不妨碍我们通过类模拟出函数。配合着 Guava 提供的基础设施，我很早就开始把函数式编程的方式运用在 Java 中了。同样，C++ 有一个 functor 的概念，也就是函数对象，通过重载 () 这个运算符，让对象模拟函数的行为。无论是在以结构化编程为主的语言中引入面向对象编程，还是在面向对象为主的语言中引入函数式编程，在一个程序中应用多种编程范式已经成为了一个越来越明显的趋势。

不仅仅是在设计中，现在越来越多的程序设计语言开始将不同编程范式的内容融合起来。Java 从 Java 8 开始引入了 Lambda 语法，现在我们可以更优雅地写出函数式编程的代码了。同样，C++ 11 开始，语法上也开始支持 Lambda 了。

之所以多范式编程会越来越多，是因为我们的关注点是做出好的设计，写出更容易维护的代码，所以，我们会尝试着把不同编程风格中优秀的元素放在一起。比如，我们采用面向对象来组织程序，而在每个类具体的接口设计上，采用函数式编程的风格，在具体的实现中使用结构化编程提供的控制结构。

让我们回过头，看看开篇故事小李的委屈吧！老赵之所以批评小李，关键点就是小李并没有把各种编程范式中优秀的元素放到一起。Java 是提供对面向对象的支持，面向对象的强项在于程序的组织，它归功的设计元素应该是对象，程序应该是靠对象的组合来完成，而小李去把它写成了平铺直叙的结构化代码，这当然是不值得鼓励的。

对于今天的程序员来说，学习不同的编程范式，将不同编程范式中的优秀元素应用在我们日常的软件设计之中，已经由原来的可选项变成了现在的必选项。否则，你即便拥有强大的现代化武器，也只能用作古代的冷兵器。

### 黑板墙

今天我们谈到了编程范式，每个程序员都会有自己特别熟悉的编程范式，但今天我想请你分享一下，你在学习其他编程范式时，给你思想上带来最大冲击的内容是什么。

当 Bob 大叔说出那句，「编程范式本质是从某方面对程序员编程能力的限制和规范」时，真有些振聋发聩。作者回复：哈哈，你看出我从哪吸收营养了。2020-06-22

不单止编程范式对程序员的能力做了限制，编程框架也在开始做这一方面的努力了。努力提高程序员的下限。作者回复：这个理解是对的，编程框架本来就是让你少和底层细节打交道。2020-06-22

而在每个类具体的接口设计上，采用函数式编程的风格。老师，这句话具体如何理解，我脑子里出现的是 java8 里面的 @FunctionalInterface，很多接口中的函数入参都是一个个 @FunctionalInterface，比如：

```java
public interface Predicate<T> {
default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }
...
}
```

作者回复：后面讲到函数式编程的时候，你就会看到我的做法了，简言之，设计可以组合的接口。2020-06-22

主流的编程语言都有结构化编程，面向对象编程，函数编程。纯粹单一的使用某个编程范式在现代编程语言其实会越来越少，现代语言都是吸收了各种编程范式的优点组合编程。作者回复：没错！2020-06-22

以函数式编程为例。1）我能理解不变性的价值，毕竟在应对并发场景时我也用 cow 的模式。但很难接受将 cow 贯彻到每个函数，本能的觉得浪费。2）我看得到函数式编程在代码上的简洁（可读性高）。但将功能实现成函数式编程的风格，感觉比较难（也可能是我水平不行，毕竟没有刻意练习），而难本身就是成本。（业务逻辑翻译成功能代码，从易到难：面向过程，面向对象，函数式编程）。3）虽然我理解鸭子理论。但我就想明确的定义接口。因为，当我作为调用方时，我只想知道意图，而没有实现的接口，显然是比较整洁的。4）虽然我理解函数是一等公民（单方法接口）的定位。但我就喜欢接口下定义多个方法（行为），因为我认为接口是一类事务共同行为的抽象，那么行为很可能是捆绑出现。比如说，对动物行为做抽象，吃和拉必须一起出现，只有吃没有拉，只有拉没有吃都挺尴尬。作者回复：不同的系统会有不同的原则，性能不关键的系统，用不变对象带来的优势大于性能损耗。2020-06-22

## 0302. 结构化编程：为什么做设计时仅有结构化编程是不够的？

今天我们讲了程序员们最熟悉的编程范式：结构化编程。其实，从编程范式的角度，大概每个程序员都能够比较熟练地使用结构化编程提供给我们的编程元素。今天这一讲，我主要带着你回顾了一下结构化编程的由来，让你知道即便是我们已经非常熟悉的一些控制结构，也是前人经过不断努力得来的。除了知道结构化编程给我们提供了什么，我们还要看到它限制了什么，也就是 goto 语句。goto 语句实际上就是一种对程序控制权的直接转移，它可以让程序跑到任何地方去执行。而对它施加限制之后，程序就不再是随意编写的了。结构化编程带来的另一个重要方面是功能分解，也就是将大问题拆分成可以解决的小问题，这一思想影响深远，是我们做设计的根基所在。我还给你讲了结构化编程的不足，主要就是在结构化编程中，各模块的依赖关系太强，不能有效地将变化隔离开来。所以，它还需要与其他的编程范式进行配合。下一讲，我们就来讲讲现在最主流的组织程序的方式：面向对象编程。如果今天的内容你只能记住一件事，那请记住：结构化编程不能有效地隔离变化，需要与其他编程范式配合使用。

很多人学习编程都是从 C 语言起步的，C 语言就是一种典型的结构化编程语言。C 的结构化编程也渗透进了后来的程序设计语言之中，比如，C++、Java、C# 等等。说起结构化编程，你一定会想起那些典型的控制结构，比如：顺序结构、选择结构和循环结构，还会想到函数（如果用术语讲，应该叫 subroutine）和代码块（block）。这几乎是程序员们每天都在使用的东西，对于这些内容，你已经熟悉得不能再熟悉了。

但是，不知道你是否想过这样一个问题？面向对象编程之所以叫面向对象，是因为其中主要的概念是对象，而函数式编程主要的概念是函数。可结构化编程为什么叫结构化呢，难道它的主要概念是结构？这好像也不太对。其实，所谓结构化，是相对于非结构化编程而言的。所以，要想真正了解结构化编程，就要回到非结构化的古老年代，看看那时候是怎么写程序的。也就是说，只有了解结构化编程的发展历程，你才能更好地认清结构化编程的不足。没错，正是因为你太熟悉结构化编程了，我反而要说说它的不足，告诉你在今天做设计，仅仅有结构化编程已经不够了。好，我们就先从结构化编程的演化讲起。

### 2.1 结构从何而来

你一定知道，结构化编程中的顺序结构就是代码按照编写的顺序执行，选择结构就是 if/else，而循环结构就是 do/while。这几个关键字一出，是不是就有一股亲切感扑面而来？但是，你有没有想过，这些结构是怎么来的呢？

我们都知道，今天的编程语言都是高级语言，那对应着就应该有低级语言。就今天这个讨论而言，比高级语言低级的就是汇编语言。如果你去了解汇编指令，你会发现，它的编程模式与我们习惯的高级语言的编程模式有着很大的差异。使用汇编写代码，你面对的是各种寄存器和内存地址。那些我们在高级语言中经常面对的变量，需要我们自己想办法解决，而类型，则统统没有。至于前面提及的那些控制结构，除了顺序结构之外，在汇编层面也是不存在的。

连 if/else 和 do/while 都没有，让我怎么写程序啊？别急，在汇编里有个 goto，它可以让代码跳转到另外一个地方继续执行。还有几个比较指令，让你可以比较两个值。

我们先想一下，if 语句做的是什么呢？执行一个表达式，然后，根据这个表达式返回值是真是假，决定执行 if 后面的代码，还是 else 后面的代码。好，如果我们这么写汇编代码，就是先执行一段代码，把执行结果和 0 比较。如果不等于 0 就接着执行，等于 0 就跳转到另外一个地方执行，这不就和 if 语句的执行逻辑是一样的吗？没错，如果你尝试反汇编一段有 if 语句的 C 代码，也会看到类似的汇编代码。如果你是一个 Java 程序员，也可以通过 javap 反汇编一段 Java 类，也可以看到类似的字节码，因为字节码在 Java 里就相当于汇编。

有了对 if 语句的理解，再来理解 do/while 就容易了，就是在判断之后，是决定跳到另外一个地方，还是继续执行下面的代码。如果执行下面的代码，执行到后面就会有一个 goto 让我们跳回来，再作一次判断。了解这些，再加上汇编语言本身的顺序执行，你最熟悉的控制结构就都回来了。所以，即便是用汇编，你依然可以放心地以原来的方式写代码了。

对于已经有了编程基础的你而言，理解这些内容并不难。但你有没有想过，以前的程序员真的就是用这样的控制结构写程序的吗？并不是。原来的程序员面对的的确是这些汇编指令，但是他们是站在直接使用指令的角度去思考。所以，他们更习惯按照自己的逻辑去写，这其中最方便的写法当然就是需要用到哪块逻辑，就 goto 到哪里执行一段代码，然后，再 goto 到另外一个地方。

这种写起来自由自在的方式，在维护起来却会遇到极大的挑战，因为你很难预测代码的执行结果。有人可能只是图个方便，就 goto 到一个地方继续执行。可只要代码规模稍微一大，就几乎难以维护了，这便是非结构化的编程方式。

### 2.2 Goto 是有害的

于是，有人站了出来，提出编程要有结构，不能这么肆无忌惮，结构化编程的概念应运而生。这其中有个重要人物，你一定听说过，叫迪杰斯特拉（Dijkstra），他是 1972 年的图灵奖的获得者。学习算法的时候，你肯定学过以他名字命名的最短路算法；学习操作系统时，你肯定学过 PV 原语，PV 原语这个名字之所以看起来有些奇怪，主要因为 Dijkstra 是荷兰人。

1968 年，他在 ACM 通讯上发表了一篇文章，题目叫做《Goto 是有害的》（Go To Statement Considered Harmful），这篇文章引起了轩然大波。不是所有人都会接受这种新想法，那些习惯了自由放纵的程序员对 Dijkstra 进行了无情的冷嘲热讽。他们认为，按照结构化的方法写效率太低。今天的你可能很难想象，C 语言初问世之际，遭到最大的质疑是效率低。对，你没听错，C 语言被质疑效率低，和 Java 面世之初遇到的挑战如出一辙。提出这种质疑的人只看到了新生事物初生时的不足，却忽略了它们强大的可能性。他们不知道，一旦构建起新的模型，底层实现是可以不断优化的。

3『[Go To Statement Considered Harmful](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html)，已下载该论文并存入 Zotero「2020017Go-to-Statement-Considered-Harmful」。』

更重要的是，有了新的更高级却也更简单的模型，入门门槛就大幅度降低了，更多的人就可以加入进来，进一步促进这门语言的发展。程序员数量的增多，就可以证明这一点。现在的很多程序员其实对底层知识的了解并不多，但丝毫不妨碍他们完成基本的业务功能。只要使用的人足够多，人们就会有更强的驱动力去优化底层实现。时至今日，已经很少有人敢说自己手写的汇编性能一定优于编译器优化后的结果。最终这场争论逐渐平息，新的结构逐渐普及，也证明了 Dijkstra 是对的。goto 语句的重要性逐渐降低，一些现代程序设计语言干脆在设计上就把 goto 语句拿掉了。

### 2.3 功能分解

你可能没有想过，这种结构化编程的思想最初是为了证明程序正确性而诞生的。Dijkstra 很早就得出一个结论：编程是一项难度很大的活动。因为一个程序会包含非常多的细节，远超一个人的认知能力范围，任何一个细微的错误都会导致整个程序出现问题。

所以，他提出 goto 语句是有害的，还有一个重要的原因是，Dijkstra 为了证明程序的正确性，在借助数学推导的方法，将大问题拆分成小问题，逐步递归下去，拆分成更小的、可证明的单元时，他发现 goto 语句的存在影响了问题的递归拆分，导致问题无法被拆分。

你也许看出来了，我要说的就是结构化编程另一个重要的方面：功能分解。功能分解就是将模块按照功能进行拆分。这样一来，一个大问题就会被拆解成一系列高级函数的组合，而这些高级函数各自再进一步拆分，拆分成一系列的低一级的函数，如此一步步拆分下去，每一个函数都需要按照结构化编程的方式进行开发。这一思想符合人们解决问题的直觉，对软件开发产生了深远的印象。

以此为基础，后来出现各种结构化分析和结构化设计的方法。将大型系统拆分成模块和组件，这些模块和组件再做进一步的拆分，这些都是来自结构化编程的设计思想。在今天看来，这一切简直再正常不过了，几乎融入了每个程序员的日常话语体系之中。好，说完了结构化编程的发展历程，我们自然也就能看出它的不足之处了。

虽然，结构化编程是比汇编更高层次的抽象，程序员们有了更强大的工具，但人们从来不会就此满足，随之而来的是，程序规模越来越大。这时，结构化编程就显得力不从心了。用一个设计上的说法形容结构编程就是「抽象级别不够高」。

这就好比你拿着一个显微镜去观察，如果你观察的目标是细菌，它能够很好地完成工作，但如果用它观察一个人，你恐怕就很难去掌握全貌了。结构化编程是为了封装低层的指令而生的，而随着程序规模的膨胀，它组织程序的方式就显得很僵硬，因为它是自上而下进行分解的。

一旦需求变动，经常是牵一发而动全身，关联的模块由于依赖关系的存在都需要变动，无法有效隔离变化。显然，如何有效地组织这么大规模的程序并不是它的强项，所以，结构化编程注定要成为其它编程范式的基石。如果站在今天的角度看，结构化编程还存在一个问题，就是可测试性不够，道理和上面是一样的，它的依赖关系太强，很难拆出来单独测试一个模块。所以，仅仅会结构化编程，并不足以让我们做出好的设计，必须把它与其他编程范式结合起来，才能应对已经日益膨胀的软件规模。

### 黑板墙

Dijkstra 在结构化编程这件事上的思考远远大于我们今天看到的样子。你是否也有这样的经历，你在学习哪门技术时，了解到其背后思想之后，让你觉得受到了很大的震撼。

1、结构化编程 / 过程式编程，感觉栏主漏了一个很重要的点，贫血模型。结构化编程里面有结构体（自定义的类型）的概念，站 java 角度看，这其实这就是一个「类」，但这个类只承接属性却不会有行为。也就是说过程式编程里面，行为和数据是完全分离的（我不认为这是坏处，毕竟这样代码实现和阅读都相对简单）。并且结合对过程的抽象（这里应该算得上函数了）, 可以定义各种复杂的指令，以便达到复用和隔离复杂性的效果。（这些特性也是导致大部分开发都面向过程编程的主要原因）

2、既然结构化编程能做到复用和隔离复杂性，那么还要面向对象干嘛？或者说面向对象相较于结构化编程优秀在哪里？我认为至少有两点优秀的地方，1）易用。2）更好的复杂性隔离。易用，某种带有数据结构的「类」，其具备哪些行为一目了然 （打点可见）。而不像过程式编程，数据与过程的关系是松散的（java 开发可以理解为所有代码都以静态方法 + 贫血模型实现）; 更好的复杂性隔离，这主要依托于面向对象的一个特性，封装。面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节，如此一来对象内部的变动与所有使用方就隔离了，换句话说，只有在对象内部才能变更对象的属性，变更点全部收敛。（封装其实是一种约束，让代码没办法那么灵活。但这个约束对于代码的可读和可维护却有着深远的价值）

3、学习 ddd 让我受到了很大的震撼。起初，我看了一遍领域驱动设计实战那本号称比较好理解的「红皮佳作」。然并软，看了一遍基本不理解各中缘由，也就拿着专业名称跟别人瞎应付几句，表示自己也学过。但后来，深入去学习设计原则与设计模式，面向对象思想，并做了大量的重构（期间经常会翻到「红皮佳作」的某些章节思考）。对于 ddd 为啥这么做有了自己的见解。1）为什么依赖倒置，基础层要在最上层。因为这样做技术相关代码可以从应用层和领域层抽离，保证应用层和领域层业务代码的干净（技术组件可以单独升级）。2）为什么要封装充血模型？为了更好的复用以及隔离复杂性。3）为什么要分应用层和领域层？将基础的领域服务代码和上层的应用服务代码隔离，将不同的领域服务代码相隔离，将不同的应用服务代码相隔离。做到，虽然将多个模型（基础模型和应用模型）写在一个包里，但以目录和编程规范的方式将之间的代码隔离，为后续业务拓展后的调整铺平道路。（也包含去重的理念）4）为什么要制定规范，为什么要抽象系统模型图？为了降低认知差异（同规范下，相互间代码可读性自然会更好），提高共识度（没办法产品技术一体两面，就在业务逻辑和代码实现间再架设一层中间语言，方便两者沟通。是不是有点 IR「高级语言与机器语言的中间表达式」的味道）。等等。。。作者回复：我还真的不把贫血模型的讨论放在结构化编程里，它更多的属于 OO 部分。你的 DDD 理解很有道理，但有一些内容其实属于 OO，比如依赖倒置，后面会讲到。2020-06-24

看了一下 Edgar Dijkstra 的那篇 Go To Statement Considered Harmful，其中说到，go to statements should be abolished from all「higer level」programming languages. 论文里面提到两个 remark，一个是说一旦程序被编写完成，那么程序的控制权就交给了机器；第二个是说，程序员（人）对于静态关系掌控和动态过程视觉化都有一定的局限，所以要尽量减少静态程序代码和动态过程的「认知鸿沟」。专栏里面提到了「非结构化编程」，结合 Dijkstra 的论文，感觉使用 go to 语句的非结构化编程更像是一种「线性编程」，在一个很长的代码文件上给出了几个索引（标签），然后使用 go to 语句来跳转。如果不怕重复，把所有的 go to 都展开，那么应该就是更长的一段代码。

而使用了 if/else、do/while 的结构化编程，感觉是把一条线变成了一棵树，从一维坐标到二维坐标（？）。从认知的角度，更有利于程序员去开发程序 —— 其实也就是前面 Dijkstra 说的，程序的复杂度超出了程序员的控制，所以需要结构化编程来降低认知的难度。1969 年阿波罗 11 号登月的时候，使用的编程语言应该是汇编吧，即没有结构化也没有面向对象。后来看到了左耳朵耗子在酷壳上的一片文章《50 年前的登月程序和程序员有多硬核》，确实 hardcore。最早学的也是 C 语言，然后学到面向对象的时候（C#）的时候，看到那些小猫小狗、继承多态的例子，感觉也很震撼，后来才发现在实际的工作中，面向对象的分析并不简单，面向对象的落地也不容易。作者回复：理解是一个难度，设计是一个难度，所以，Dijkstra 能拿到图灵奖。2020-06-24

刚开始接触函数式编程时，就被它背后的数学理论所震到，之前一直把计算机看成是工程学。后来看到它的不变性天生适合并发时，又深深体会到它的美感。作者回复：震撼的感觉是非常爽的，让人找到了新的前进方向。2020-06-24

在学习机器学习和深度学习编程的过程中，被其背后的数学思想所震撼，这是第一次觉得数学离编程这么近且不可或缺。作者回复：机器学习和深度学习，终于让数学走近了程序员。2020-06-29

汇编的 goto 特性使得编程不可控，不受约束，为了约束编程行为，结构式编程应运而生，其自上而下的编程方法使得程序易于编写和理解，但由于自上而下，每行代码紧密相连，下层代码的运行依赖于上层代码，耦合度太高，约束性太强，一旦代码变动，所有相关连的代码可能都得变动，灵活度太低，于是面向对象编程横空出世，就拿 java 来说，其强大的语言特性使得代码灵活性大大提高，与汇编的 goto 特性相比，java 的 if else ，for 循环等对程序的行为起到了约束作用，这些结构类代码将原本不受约束的代码行为控制在了结构代码内，它的各种访问修饰符所带来的封装特性对代码的行为也起到了约束作用，同时也一定程度提高了代码的安全性。继承特性的出现使得重复使用的代码变得可复用，减少了大量冗余代码，还能在继承之外添加自己的功能行为，多态的出现在继承的基础上进一步加强了这一行为，使代码的灵活性更高。为了进一步增强代码的灵活性，反射机制出现了，与结构化编程的按步骤执行不同，它能在代码的运行阶段操控代码，可以说，面向对象的编程范式通过对象模型的映射，配合其特性，极大地提高了代码的灵活性，减少了大量冗余的代码。不知道以上理解对不对？作者回复：大部分理解是对的，但是，继承，我们很快就会说到，到时候，你再来看。2020-06-24

flutter 一切皆 widget 的思考，远大于我们能看见的表面。作者回复：很好的分享！2020-06-24

相信很多人一开始学习 c 编程语言入门的，这时教材上会告诉这是结构化编程编程语言。学习了体系结构和汇编相关知识之后，会发现底层语言是非结构化的，这给编码效率带来不便，于是出现结构化编程，也出现了更高层次的分层与封装。结构化编程符合人类的思维。当我们开发系统时，分解各个小系统，小系统分解成模块，模块分解为组件，组件分解类，类分解为功能函数。一步一步下来，完成整体的功能拆分。当然结构化编程不是银弹，它也有缺点，比如高层依赖底层模块强，不容易测试等，这些需要其它编程范式一起解决。作者回复：结构化何止不是银弹，现在作为普通的工具，能力都是不够的。简言之，现在打仗不能只靠弓箭和马匹了，而结构化编程大概就是这么个级别的东西，冷兵器时代的产物。2020-06-24

## 0303. 面向对象之封装：怎样的封装才算是高内聚？

今天我们学习了面向对象编程，它是一种以对象为编程元素的编程范式。面向对象有三个特点：封装、继承和多态。1）封装，是面向对象的根基。面向对象编程就是要设计出一个一个可以组合，可以复用的单元。然后，组合这些单元完成不同的功能。2）封装的重点在于对象提供了哪些行为，而不是有哪些数据。即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，应该是稳定的；数据是实现，是易变的，应该隐藏起来。设计一个类的方法，先要考虑其对象应该提供哪些行为，然后，根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。getter 和 setter 是暴露实现细节的，尽可能不提供，尤其是 setter。封装，除了要减少内部实现细节的暴露，还要减少对外接口的暴露。一个原则是最小化接口暴露。有了对封装的理解，即便我们用的是 C 语言这样非面向对象的语言，也可以按照这个思路把程序写得更具模块性。理解了封装，下一讲，我们再来看面向对象另外一个特征：继承。如果今天的内容你只能记住一件事，那请记住：基于行为进行封装，不要暴露实现细节，最小化接口暴露。

上一讲，我讲了你最熟悉的编程范式：结构化编程。结构化编程有效地解决了过去的很多问题，它让程序员们解决问题的规模得以扩大。随着程序规模的逐渐膨胀，结构化编程在解决问题上的局限也越发凸显出来。因为在它提供的解决方案中，各模块的依赖关系太强，不能有效地将变化隔离开来。这时候，面向对象编程登上了大舞台，它为我们提供了更好的组织程序的方式。

在一些从结构化编程起步的程序员的视角里，面向对象就是数据加函数。虽然这种理解不算完全错误，但理解的程度远远不够。结构化编程的思考方式类似于用显微镜看世界，这种思考方式会让人只能看到局部。而想要用好面向对象编程，则需要我们有一个更宏观的视角。谈到面向对象，你可能会想到面向对象的三个特点：封装、继承和多态。在接下来的三讲，我们就分别谈谈面向对象的这三个特点。

也许你会觉得，学面向对象程序设计语言的时候，这些内容都学过，没什么好讲的。但从我接触过的很多程序员写程序的风格来看，大多数人还真的不太理解这三个特点。还记得我们在第 12 讲中提到的那个故事吗？小李之所以被老赵批评，主要就是因为他虽然用了面向对象的语言，代码里却没有体现出面向对象程序的特点，没有封装，更遑论继承和多态。嘴上说得明明白白，代码写得稀里糊涂，这就是大多数人学习面向对象之后的真实情况。所以，虽然看上去很简单，但还是有必要聊聊这些特点。

### 3.1 理解封装

我们知道，面向对象是解决更大规模应用开发的一种尝试，它提升了程序员管理程序的尺度。封装，则是面向对象的根基。它把紧密相关的信息放在一起，形成一个单元。如果这个单元是稳定的，我们就可以把这个单元和其他单元继续组合，构成更大的单元。然后，我们再用这个组合出来的新单元继续构建更大的单元。由此，一层一层地逐步向上。

为了让你更好地理解这个过程，我们先回到面向对象的最初。「面向对象」这个词是由 Alan Kay 创造的，他是 2003 年图灵奖的获得者。在他最初的构想中，对象就是一个细胞。当细胞一点一点组织起来，就可以组成身体的各个器官，再一点一点组织起来，就构成了人体。而当你去观察人的时候，就不用再去考虑每个细胞是怎样的。所以，面向对象给了我们一个更宏观的思考方式。但是，这一切的前提是，每个对象都要构建好，也就是封装要做好，这就像每个细胞都有细胞壁将它与外界隔离开来，形成了一个完整的个体。

在 Alan Kay 关于面向对象的描述中，他强调对象之间只能通过消息来通信。如果按今天程序设计语言的通常做法，发消息就是方法调用，对象之间就是靠方法调用来通信的。但这个方法调用并不是简单地把对象内部的数据通过方法暴露。在 Alan Kay 的构想中，他甚至想把数据去掉。

因为，封装的重点在于对象提供了哪些行为，而不是有哪些数据。也就是说，即便我们把对象理解成数据加函数，数据和函数也不是对等的地位。函数是接口，而数据是内部的实现，正如我们一直说的那样，接口是稳定的，实现是易变的。

理解了这一点，我们来看一个很多人都有的日常编程习惯。他们编写一个类的方法是，把这个类有哪些字段写出来，然后，生成一大堆 getter 和 setter，将这些字段的访问暴露出去。这种做法的错误就在于把数据当成了设计的核心，这一堆的 getter 和 setter，就等于把实现细节暴露了出去。

一个正确的做法应该是，我们设计一个类，先要考虑其对象应该提供哪些行为。然后，我们根据这些行为提供对应的方法，最后才是考虑实现这些方法要有哪些字段。请注意，方法的命名，体现的是你的意图，而不是具体怎么做。所以，getXXX 和 setXXX 绝对不是一个好的命名。举个例子，设计一个让用户修改密码的功能，有些人直觉的做法可能是这样：

```java

class User {
  private String username;
  private String password;
  
  ...
  
  // 修改密码
  public void setPassword(final String password) {
    this.password = password;
  }
}
```

但我们鼓励的做法是，把意图表现出来：

```java

class User {
  private String username;
  private String password;
  
  ...
  
  // 修改密码
  public void changePassword(final String password) {
    this.password = password;
  }
}
```

这两段代码相比，只是修改密码的方法名变了，但二者更重要的差异是，一个在说做什么，一个在说怎么做。将意图与实现分离开来，这是一个优秀设计必须要考虑的问题。不过，在真实的项目中，有时确实需要暴露一些数据，所以，等到你确实需要暴露的时候，再去写 getter 也不迟，你一定要问问自己为什么要加 getter。至于 setter，首先，大概率是你用错了名字，应该用一个表示意图的名字；其次，setter 通常意味着修改，这是我们不鼓励的。

我后面讲函数式编程时，会讲到不变性，可变的对象会带来很多的问题，到时候我们再来更具体地讨论。所以，设计中更好的做法是设计不变类。

### 3.2 减少暴露接口

之所以我们需要封装，就是要构建一个内聚的单元。所以，我们要减少这个单元对外的暴露。这句话的第一层含义是减少内部实现细节的暴露，它还有第二层含义，减少对外暴露的接口。

一般面向对象程序设计语言都支持 public、private 这样的修饰符。程序员在日常开发中，经常会很草率地给一个方法加上 public，从而不经意间将一些本来应该是内部实现的部分暴露出去。举个例子，一个服务要停下来的时候，你可能要把一些任务都停下来，代码可能会这样写：

```java
class Service {
  public void shutdownTimerTask() {
    // 停止定时器任务
  }
  
  public void shutdownPollTask() {
    // 停止轮询服务
  }
}
```

别人调用时，可能会这样调用这段代码：

```java
class Application {
  private Service service;
  
  public void onShutdown() {
    service.shutdownTimerTask();
    service.shutdownPollTask();
  }
}
```

突然有一天，你发现，停止轮询任务必须在停止定时器任务之前，你就不得不要求别人改代码。而这一切就是因为我们很草率地给那两个方法加上了 public，让别人有机会看到了这两个方法。从设计的角度来说，我们必须谨慎地问一下，这个方法真的有必要暴露出去吗？就这个例子而言，我们可以仅仅暴露一个方法：

```java
class Service {
  private void shutdownTimerTask() {
    // 停止定时器任务
  }
  
  private void shutdownPollTask() {
    // 停止轮询服务
  }
  
  public void shutdown() {
    this.shutdownTimerTask();
    this.shutdownPollTask();
  }
}
```

我们调用代码也会简单很多：

```java
class Application {
  private Service service;
  
  public void onShutdown() {
    service.shutdown();
  }
}
```

尽可能减少接口暴露，这个原则不仅仅适用于类的设计，同样适用于系统设计。在我的职业生涯中，看到了很多团队非常随意地在系统里面添加接口，一个看似不那么复杂的系统里，随随便便就有成百上千个接口。如果你想改造系统去掉一些接口时，很有可能会造成线上故障，因为你根本不知道哪个团队在什么时候用到了它。所以，在软件设计中，暴露接口需要非常谨慎。关于这一点，你可以有一个统一的原则：最小化接口暴露。也就是，每增加一个接口，你都要找到一个合适的理由。

### 3.3 不局限于面向对象的封装

虽说封装是面向对象的一个重要特征，但是，当理解了封装之后，你同样可以把它运用于非面向对象的程序设计语言中，把代码写得更具模块性。比如，我们知道 C 语言有头文件（.h 文件）和定义文件（.c 文件），在通常的理解中，头文件放的是各种声明：函数声明、结构体等等。很多 C 程序员甚至有一个函数就在头文件里加一个声明。

有了今天对于封装的讲解，再来看 C 语言的头文件，我们可以让它扮演接口的角色，而定义文件就成了实现。根据今天的内容，既然，接口只有相当于 public 接口的函数才可以放到头文件里，那么，在头文件里声明一个函数时，我们首先要问的就是，它需要成为一个公开的函数吗？C 语言没有 public 和 private 这样的修饰符，但我曾在一些 C 的项目上加入了自己的定义：

```c
#define PUBLIC
#define PRIVATE static
```

然后，我们规定头文件里只能放公有接口，而在实现文件中的每个函数前面，加上了 PUBLIC 和 PRIVATE，以示区分。这里将 PRIVATE 定义成了 static，是利用了 C 语言 static 函数只能在一个文件中可见的特性。我们还可以把一个头文件和一个定义文件合在一起，把它们看成一个类，不允许随意在头文件中声明不相关的函数。比如，下面是我在一个头文件里定义了一个点（Point）：

```c
struct Point;
struct Point* makePoint(double x, double y);
double distance(struct Point* x, struct Point* y);
```

你可能注意到了，Point 这个结构体我只给了声明，没有给定义。因为我并不希望给它的用户访问其字段的权限，结构体的具体定义是实现，应该被隐藏起来。对应的定义文件很简单，就不在这里罗列代码了。说到这里，你也许发现了，C 语言的封装做得更加彻底。如果用 Java 或 C++ 定义 Point 类的话，必然会给出具体的字段。从某种程度上来说，Java 和 C++ 的做法削弱了封装性。

讲到这里，你应该已经感受到面向对象和结构化编程在思考问题上的一些差异了。有了封装，对象就成了一个个可以组合的单元，也形成了一个个可以复用的单元。面向对象编程的思考方式就是组合这些单元，完成不同的功能。同结构化编程相比，这种思考问题的方式站在了一个更宏观的视角上。

### 黑板墙

想请你了解一下迪米特法则（Law of Demeter），结合今天的课程，分享一下你对迪米特法则的理解。

我平时用 java 语言开发，java 语言的特点就是一切皆对象。我自己的理解是，java 中对象的概念跟面向对象中对象的概念是不一样的。前者是语言的特性，后者跟作者说的一样，是一种编程范式。在具体的编码实践中，哪些属于对象，哪些不属于对象，应该是程序员掌控的。比如 DDD 中的领域实体，就是对象，需要仔细设计其行为接口。至于平时说的一些 POJO 的对象，可以看成是数据载体，是可以加 getter、setter 的（没有这些默认的 getter、setter，很多第三方的数据转化都很不方便，比如 json，sql 等）。在使用的时候，不归结为对象就可以了。作者回复：能分清楚面向对象和 Java 语言，这就是一个很好的区分。能分清楚传输数据和业务对象，这就是一个很好的区分。2020-06-28

针对本章：1）说封装往往会提到复用。但实际编码后，我认为这个提高复用是个假象。因为如果我不封装，将函数和属性分离，函数的实现依赖入参属性。那么站在调用方角度。是使用领域实体打点空参数方法，还是从实体中拿取属性调一个有参数的接口。在复用这件事上，效果是一样的。2）封装是为了屏蔽实现，属性是实现的一部分。调用方只需要知道自己要做什么。不需要关心实体内部有多少属性，以及属性间的交互。（降低调用方的复杂度，也是松耦合和 lod 的体现）。3）封装可能会导致类的肿大，在接口隔离上会有矛盾。有时我们需要为实体定义多个接口，不同的调用方调用不同的接口，以实现接口隔离。（至于类内部代码行数过多的问题，我没有什么更好的方法，因为复杂性需要收敛在内部。也只能是加一些分隔线或则构建内部类，尽量去为它分割代码）

课后题：1）lod 是一个通用的概念，既可以放在类与类，也可以放在模块和系统。2）lod 是面向关系的，首先，面向外部要尽量减少一级关联的建立。其次，只与一级关联发生关系。比如，放在代码层面。首先要尽量减少一个类中一级关联的类的数量（实例中属性上注入的其他实例，本地方法中创建的实例，这些都算一级关联。而比如注入的实例打点返回一个新的实例，这就是二级关联）。其次只使用注入的实体，创建的实体和自己本身的方法。（说白点就是不要 chain，链试调用，链中节点返回的实体都不一样时）3）lod 是不稳定的。随着软件的发展，关系是不停在变化的，所以要坚守 lod，代码实现，模块划分，系统组合都需要随着变动。（相对来说，接口隔离和单一职责就比较稳定，因为关注的都是自身）2020-06-26

经常听说一句话，程序设计应该关注数据结构，设计好了数据结构，工作就完成了一半。今天的封装更偏向能力（方法），内部数据甚至可以去掉。不知道这两个原则是否冲突呢？作者回复：不矛盾，模型和实现的差别。模型关心能力，实现关心怎么做。如果还不会做，先弄明白怎么做，模型考虑的是如何组织这些元素。2020-06-26

首先，Demeter 不是一个人，而是一个项目，项目主页 http://www.ccs.neu.edu/research/demeter/。最早提到迪米特法则的论文出版于 1989 年，Assuring good style for object-oriented programs。还有一本书，1996 年出版，Adaptive Object-Oriented Software: The Demeter Method with Propagation Patterns。没有看过。Demeter 是希腊神话中的大地和丰收女神，也叫做德墨忒尔。迪米特法则简单的说，分为两个部分：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。其实如果用另一个名字「最小知识原则」可能更容易理解一些，这个也算是程序员的「黑话」吧。虽然接触面向对象编程已经很久了，也知道封装、继承和多态，不过写程序的时候，似乎还是习惯「一个对象一张表」的方式，也没有太多的考虑过封装的问题。整个类里面都是 getter、setter 的事情也做过，有点像是用「面向对象的语言写面向过程的代码」。软件设计的大部分原则都耳熟能详，但是如何在写代码的时候「落地」，就不是特别清楚了，缺练。作者回复：关于迪米特法则的回答，很赞！2020-06-28

面向对象的基本原则第一个就是封装。日常开发中最常用到的封装莫过于函数了，一个函数实现一个最小的功能单元，然后将各个函数与属性组织起来，就成了类。一个类又可视为最小的模块。如何更好暴露接口是编码实践中的技能，时刻要思考着这个接口是否需要暴露以及最小化暴露的接口。最近我也在思考项目需要重构模块，我发现重构是一种软件进化，在杂乱的代码中理清逻辑，重新组织结构。2020-06-26

后续的文章能不能说下取方法名 / 变量的技巧。作者回复: 《代码整洁之道》（Clean Code）第二章讲的都是命名的技巧，你可以去看一下。2020-06-26

好奇老师怎么看待 Lombok，所有字段生成 getter/setter 不是一个好的实践，Java Bean 的概念是不是也不该被提倡？作者回复: Lombok 很好，可以少写很多代码，但必须限制它的使用，像 Data 和 Setter 都是不应该用的。Java Bean 本来也不是应该用在所有情况下的技术，太多误用了。2020-06-28

前段时间修改一个模块，我试图将第三方接口进行 wrap 后产生了新接口以 private 封装该模块内中。在提交给 AR 做 code review 时，他建议去掉从类中去掉新接口，理由也很简单，不属于这个类的行为，给出建议以静态局部函数放在 CPP 里使用。想来 AR 给建议还是很中肯的，类对外的行为要尽可能清晰不变；另外，在后续重构中，这些静态局部函数也可以考虑划分到合适的类中，且进行封装。2020-06-26

我对于老师举的 shutdown 的例子有一个问题，如果按照我的想法，我会把两个 shutdown 方法都暴露出去，caller 自己去组合，所以除非方法的实现需要变更，否则 callee 是不需要去更改的，但是老师说的是把两个方法封装一下，再暴露出一个封装好的方法，那么就好像老师说的，如果这两个方法需要改变顺序，caller 就要改，这怎么理解？作者回复：注意，这里的关键在于，原来的那两个方法变成了私有的。只对外暴露了一个方法，就是 shutdown。2020-06-26

"I made up the term "object-oriented," and I can tell you I did not have C++ in mind." --Alan Kay

"Java and C++ make you think that the new ideas are like the old ones. Java is the most distressing thing to hit computing since MS-DOS." --Alan Kay

## 0304. 面向对象之继承：继承是代码复用的合理方式吗？

今天我们学习了面向对象的第二个特点：继承。继承分为两种，实现继承和接口继承。实现继承是站在子类的视角看问题，接口继承则是站在父类的视角。很多程序员把实现继承当作了一种代码复用的方式，但实际上，实现继承并不是一个好的代码复用的方式，之所以这种方式很常见，很大程度上是受了语言的局限。Ruby 的 mixin 机制，Scala 提供的 trait 以及 C++ 提供的私有继承都是代码复用的方式。即便只使用 Java，也可以通过组合而非继承的方式进行代码复用。

今天我们还讲到这些复用方式背后的编程思想：面向组合编程。它给我们提供了一个不同的视角，但支撑面向组合编程的是分离关注点。将不同的关注点分离出来，每一个关注点成为一个模块，在需要的时候组装起来。面向组合编程，在设计本身上有很多优秀的地方，可以降低程序的复杂度，更是思维上的转变。现在你已经知道了，在继承树上从下往上看，并不是一个好的思考方式，那从上往下看呢？下一讲，我们就来讲讲继承的另外一个方向，接口继承，也就是面向对象的第三个特点：多态。如果今天的内容你只能记住一件事，那请记住：组合优于继承。

首先，你对继承的第一印象是什么呢？说到继承，很多讲面向对象的教材一般会这么讲，给你画一棵树，父类是根节点，而子类是叶子节点，显然，一个父类可以有许多个子类。

父类是干什么用的呢？就是把一些公共代码放进去，之后在实现其他子类时，可以少写一些代码。讲程序库的时候，我们说过，设计的职责之一就是消除重复，代码复用。所以，在很多人的印象中，继承就是一种代码复用的方式。如果我们把继承理解成一种代码复用方式，更多地是站在子类的角度向上看。在客户端代码使用的时候，面对的是子类，这种继承叫实现继承：

```java
Child object = new Child();
```

其实，还有一种看待继承的角度，就是从父类的角度往下看，客户端使用的时候，面对的是父类，这种继承叫接口继承：

```java
Parent object = new Child();
```

不过，接口继承更多是与多态相关，我们暂且放一放，留到下一讲再来讨论。这一讲，我们还是主要来说说实现继承。其实，实现继承并不是一种好的做法。也就是说，把实现继承当作一种代码复用的方式，并不是一种值得鼓励的做法。一方面，继承是很宝贵的，尤其是 Java 这种单继承的程序设计语言。每个类只能有一个父类，一旦继承的位置被实现继承占据了，再想做接口继承就很难了。另一方面，实现继承通常也是一种受程序设计语言局限的思维方式，有很多程序设计语言，即使不使用继承，也有自己的代码复用方式。可能这么说你还不太理解，接下来，我就用一个例子来帮你更好地理解继承。

### 4.1 代码复用

假设，我要做一个产品报表服务，其中有个服务是要查询产品信息，这个查询过程是通用的，别的服务也可以用，所以，我把它放到父类里面。这就是代码复用的做法，代码用 Java 写出来是这样的：

```java
class BaseService {
  // 获取相应的产品信息
  protected List<Product> getProducts(List<String> product) {
    ...
  }
}

// 生成报表服务
class ReportService extends BaseService {
  public void report() {
    List<Product> product = getProduct(...);
    // 生成报表
    ...
  }
}
```

如果采用 Ruby 的 mixin 机制，我们还可以这样实现，先定义一个模块（module）：

```ruby
module ProductFetcher
  # 获取相应的产品信息
  def getProducts(products)
    ...
  end 
end
```

然后，在自己的类定义中，将它包含（include）进来：

```ruby
# 生成报表服务
class ReportService
  include ProductFetcher
  
  def report
    products = getProducts(...)
    # 生成报表
    ..
  end
end
```

在这个例子中，ReportService 并没有继承任何类，获取产品信息的代码也是可以复用的，也就是这里的 ProductFetcher 这个模块。这样一来，如果我需要有一个获取产品信息的地方，它不必非得是一个什么服务，无需继承任何类。这是 Ruby 的做法，类似的语言特性还有 Scala 里的 trait。在 C++ 中，虽然语法并没有严格地区分实现继承，但《Effective C++》这本行业的名著，给出了一个实用的建议：实现继承采用私有继承的方式实现：

```c
class ReportService: private ProductFetcher {
  ...
}
```

请注意，在这个实现里，我的私有继承类名是 ProductFetcher。是的，它并不需要和这个报表服务有什么直接的关系，使用私有继承，就是为了复用它的代码。从前面的分析中，我们也不难看出，获取产品信息和生成报表其实是两件事，只是因为在生成报表的过程中，需要获取产品信息，所以，它有了一个基类。其实，在 Java 里面，我们不用继承的方式也能实现，也许你已经想到了，代码可以写成这样：

```java
class ProductFetcher {
  // 获取相应的产品信息
  public List<Product> getProducts(List<String> product) {
    ...
  }
}

// 生成报表服务
class ReportService {
  private ProductFetcher fetcher;
  
  public void report() {
    List<Product> product = fetcher.getProducts(...);
    // 生成报表
    ...
  }
}
```

这种实现方案叫作组合，也就是说 ReportService 里组合进一个 ProductFetcher。在设计上，有一个通用的原则叫做：组合优于继承。也就是说，如果一个方案既能用组合实现，也能用继承实现，那就选择用组合实现。好，到这里你已经清楚了，代码复用并不是使用继承的好场景。所以，要写继承的代码时，先问自己，这是接口继承，还是实现继承？如果是实现继承，那是不是可以写成组合？

### 4.2 面向组合编程

之所以可以用组合的方式实现，本质的原因是，获取产品信息和生成报表服务本来就是两件事。还记得我们在第 3 讲里讲过的「分离关注点」吗？如果你能看出它们是两件事，就不会把它们放到一起了。我还讲过，分解是设计的第一步，而且分解的粒度越小越好。当你可以分解出来多个关注点，每一个关注点就应该是一个独立的模块。最终的类是由这些一个一个的小模块组合而成，这种编程的方式就是面向组合编程。它相当于换了一个视角：类是由多个小模块组合而成。

还以前面的报表服务为例，如果使用 Java，按照面向组合的思路写出来，大概是下面这样的。其中，为了增加复杂度，我增加了一个报表生成器（ReportGenerator），在获取产品信息之后，还要生成报表：

```java
class ReportService {
  private ProductFetcher fetcher;
  private ReportGenerator generator;
  
  public void report() {
    List<Product> product = fetcher.getProducts(...);
    // 生成报表
    generator.generate(product);
  }
}
```

请注意，我在前面的表述中，故意用了模块这个词，而不是类。因为 ProductFetcher 和 ReportGenerator 只是因为我们用的是 Java，才写成了类；如果用 Ruby，它们的表现形式就会是一个 module；而在 Scala 里，就会成为一个 trait。我们再用 Ruby 示意一下：

```ruby
class ReportService
  include ProductFetcher
  include ReportGenerator
  
  def report
    products = getProducts(...)
    # 生成报表
    generateReport(products)
  end
end
```

而使用 C++ 的话，表现形式则会是私有继承：

```cpp
class ReportService: private ProductFetcher, private ReportGenerator {
  ... 
}
```

C++ 本身支持宏定义，所以，我们可以自定义一些宏，将这些不同的概念区分开来：

```cpp
#define MODULE(module) class module
#define INCLUDE(module) private module
```

上面的类定义就可以变成更有表达性的写法：

```cpp
MODULE(ProductFetcher) {
  ...
}

MODULE(ReportGenerator) {
  ...
}

class ReportService: 
  INCLUDE(ProductFetcher), 
  INCLUDE(ReportGenerator) {
  ...
}
```

我有一个 C++ 的高手朋友，把这种做法称之为「小类大对象」，这里面的小类就是一个一个的模块，而最终的大对象是最终组合出来的类生成的对象。

2-3『[小类，大对象 - 简书](https://www.jianshu.com/p/a830d2261392)，这篇文章整理作为附件「0321小类大对象.md」，并好好消化。』

关于面向对象，有一点我们还没有说，就是面向对象面向的是「对象」，不是类。很多程序员习惯把对象理解成类的附属品，但在 Alan Kay 的理解中，对象本身就是一个独立的个体。所以，有些程序设计语言可以直接支持在对象上进行操作。

3『上面的观点与 JS 中，基于原型的面向对象串起来了。』

还是前面的例子，我想给报表服务增加一个接口，对产品信息做一下处理。用 Ruby 写出来会是这样：

```ruby
module ProductEnhancer
  def enhance
    # 处理一下产品信息
  end
end

service = ReportService.new
# 增加了 ProductEnhancer
service.extend(ProductEnhancer)

# 可以调用 enhance 方法
service.enhance
```

这样的处理只会影响这里的一个对象，而同样是这个 ReportService 的其他实例，则完全不受影响。这样做的好处是，我们不必写那么多类，而是根据需要在程序运行时组合出不同的对象。

在这里，相信你再一次意识到了要学习多种程序设计语言的重要性。Java 只有类这种组织方式，所以，很多有差异的概念只能用类这一个概念表示出来，思维就会受到限制，而不同的语言则提供了不同的表现形式，让概念更加清晰。

前面只是讲了面向组合编程在思考方式的转变，下面我们再来看设计上的差异。举个例子，我们有个字体类（Font），现在的需求是，字体能够加粗（Bold）、能够有下划线（Underline）、还要支持斜体（Italic），而且这些能力之间是任意组合的。

如果采用继承的方式，那就要有 8 个类（原文里有张列表）。而采用组合的方式，我们的字体类（Font）只要有三个独立的维度，也就是是否加粗（Bold）、是否有下划线（Underline）、是否是斜体（Italic）。这还不是终局，如果再来一种其他的要求，由 3 种要求变成 4 种，采用继承的方式，类的数量就会膨胀到 16 个类，而组合的方式只需要再增加一个维度就好。我们把一个 M*N 的问题，通过设计转变成了 M+N 的问题，复杂度的差别一望便知。

虽然我们一直在说，Java 在面向组合编程方面能力比较弱，但 Java 社区也在尝试不同的方式。早期的尝试有 Qi4j，后来 Java 8 加入了 default method，在一定程度上也可以支持面向组合的编程。这里我们只是讲了面向对象社区在组合方面的探索，后面讲函数式编程时，还会讲到函数式编程在这方面的探索。

### 黑板墙

最后，我想请你去了解一下一种叫 DCI （Data，Context 和 Interaction）的编程思想，结合今天的课程，分享一下你对 DCI 的理解。

回答：1）DCI 和小类大对象的理念，在实现手法上很像。2）先说看好的点，DCI 模式在单一职责上能做到更好（ddd 的充血模型很容易肿成上帝对象）。一个 data 在不同的 context 具有不同的 interface 方法，这样的划分，在隔离变化（调用方依赖抽象接口实现功能）和复杂性隔离（只关心当前 context 需要关心的行为）都又不错的效果。3）再说不看好的，DCI 的数据和行为分离不敢苟同。是先有行为再有数据还是先有数据再有行为，这是一个问题。但可以确定的是，行为和数据的关联是密切的，以至于傻傻分不清楚。所以我还是偏向于，抽象模型时，行为和数据应该是一个整体。4）总结，DCI 还是扩展了我的认知。DDD 在封装充血模型时有一个很蛋疼的点，为了复用部分属性和行为，而为充血模型加入了新的属性和行为。多次迭代后，充血模型就很容易肿大，边界模糊（涵盖的面广了也就模糊了）。而 DCI 和小类大对象的思考方式很好的做了补充。大致都是在特定的 context 里，用不同的小类组成特定的领域对象，既能做到复用也能隔离复杂性。5）C++ 有多继承的方式来实现这种组合模式。但 java 语法特性上就不支持。那么无论是小类大对象还是 DCI 都无法用合适的代码结构来描述（我认为，哪怕用回调函数 + 接口实现的写法，也不能很好描述这个语义）。栏主觉得 java 该怎么办？2020-06-29

所谓组合就是类的引用吧，面向对象编程时，如果不是继承关系，那大概率就是引用类来实现功能的组合吧。作者回复：Java 的类引用可以表达很多概念，属性和组合都是通过同样的概念表示出来的。好处就是简单，坏处就不清楚。2020-06-29

老师，我有个概念上的疑惑，分离的关注点是一个个独立的模块，然后由一个个小模块组合出类，这个类就指的是「大对象」吗？上面的一个个小模块，其实也是类，只不过是小类，对于 C++ 就是 class 的实现手法，Ruby 可以是 module 的实现手法，是这样的吗？DCI 关注的是数据在 context 中的交互行为，我的理解大概就是数据在不同的 context，扮演不同的角色，这些角色的属性，是数据内组合上下文需要的特性实现的。作者回复：你的理解是对的，因为在 Java/C++ 这类语言中只有类这一个概念，所以，我们不得不用类表示所有的东西，之所以，要讲不同语言的做法，就是希望大家知道，自己写代码时，这个「类」扮演了什么角色。2020-06-30

组合优于继承，可以使用继承的地方几乎都可以用组合替换的，那是不是说继承这个特性在现代编程语言中没有什么作用了（接口继承实力上就是多态）。作者回复：先看看现代程序设计语言的设计，比如，Go 和 Rust。2020-07-04

继承是面向对象的基本原则之一，但在编码实践中能用组合来实现尽量使用组合。DCI 也是一种编码规范，它是对面向对象编程的一种补充，其实核心思想也是关注点分离。作者回复：很好的理解！2020-06-29

```ruby
MODULE(ProductFetcher) {
  ...
}

MODULE(ReportGenerator) {
  ...
}

class ReportService:
  INCLUDE(ProductFetcher),
  INCLUDE(ReportGenerator) {
  ...
}
```

这段代码，为什么不用组合呢？作者回复：你说的字段的组合方式吧，可以用。但如果有更有语义的表示方式，选择更好的表示方式是一个更好的选择。2020-06-29

## 0305. 面向对象之多态：为什么「稀疏平常」的多态，是软件设计的大杀器？

今天我们讲到了面向对象的第三个特点：多态，它是基于对象和面向对象的分水岭。多态，需要找出不同事物的共同点，建立起抽象，这也是很多程序员更好地运用多态的阻碍。而我们找出共同点，前提是要分离关注点。理解多态，还要理解好接口。它是将变的部分和不变的部分隔离开来，在二者之间建立起一个边界。一个重要的编程原则就是面向接口编程，这是很多设计原则的基础。我们今天还讨论了多态的实现，它通过将一种常见的编程结构升华为语法，降低程序员犯错的几率。最后，我们说了，多态不一定要依赖于继承实现。在面向对象编程中，更重要的是封装和多态。

结构化编程也好，面向对象编程也罢，这些都是大多数程序员都还是比较熟悉的，而下面我们要讲到的编程范式已经成为一股不可忽视的力量。然而，很多人却对它无知无觉，这就是函数式编程。下一讲，我们就来说说函数式编程。如果今天的内容你只能记住一件事，那请记住：建立起恰当的抽象，面向接口编程。


前面两讲，我们讲了面向对象的两个特点：封装和继承，但真正让面向对象华丽蜕变的是它的第三个特点：多态。有一次，我在一个 C++ 的开发团队里做了一个小调查。问题很简单：你用过 virtual 吗？下面坐着几十个 C++ 程序员，只有寥寥数人举起了手。

在 C++ 里，virtual 表示这个函数是在父类中声明的，然后在子类中改写（Override）过。或许你已经发现了，这不就是多态吗？没错，这就是多态。这个调查说明了一件事，很多程序员虽然在用支持面向对象的程序设计语言，但根本没有用过多态。

只使用封装和继承的编程方式，我们称之为基于对象（Object Based）编程，而只有把多态加进来，才能称之为面向对象（Object Oriented）编程。也就是说，多态是一个分水岭，将基于对象与面向对象区分开来，可以说，没写过多态的代码，就是没写过面向对象的代码。

对于面向对象而言，多态至关重要，正是因为多态的存在，软件设计才有了更大的弹性，能够更好地适应未来的变化。我们说，软件设计是一门关注长期变化的学问，只有当你开始理解了多态，你才真正踏入应对长期变化的大门。这一讲，我们就谈谈多态。

### 5.1 理解多态

多态（Polymorphism），顾名思义，一个接口，多种形态。同样是一个绘图（draw）的方法，如果以正方形调用，则绘制出一个正方形；如果以圆形调用，则画出的是圆形：

```java
interface Shape {
  // 绘图接口
  void draw();
}

class Square implements Shape {
  void draw() {
    // 画一个正方形
  }
}

class Circle implements Shape {
  void draw() {
    // 画一个圆形
  }
}
```

上一讲，我们说过，继承有两种，实现继承和接口继承。其中，实现继承尽可能用组合的方式替代继承。而接口继承，主要是给多态用的。这里面的重点在于，这个继承体系的使用者，主要考虑的是父类，而非子类。就像下面这段代码里，我们不必考虑具体的形状是什么，只要调用它的绘图方法即可。

```
Shape shape = new Squre();
shape.draw();
```

1-2『实现继承是站在子类的视角，少用，能用组合实现就别用「实现继承」；多态是站在父类视角的，通过「接口继承」来实现，多用。这就是经常听到的「面向接口编程，而非面向实现编程」。做一张术语卡片。』——已完成

这种做法的好处就在于，一旦有了新的变化，比如，需要将正方形替换成圆形，除了变量初始化，其他的代码并不需要修改。不过，这是任何一本面向对象编程的教科书上都会讲的内容。那么，问题来了。既然多态这么好，为什么很多程序员不能在自己的代码中很好地运用多态呢？因为多态需要构建出一个抽象。

构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分。而遮住程序员们双眼的，往往就是他们眼里的不同之处。在他们眼中，鸡就是鸡，鸭就是鸭。寻找共同点这件事，地基还是在分离关注点上。只有你能看出来，鸡和鸭都有羽毛，都养在家里，你才有机会识别出一个叫做「家禽」的概念。这里，我们又一次强调了分离关注点的重要性。

我们构建出来的抽象会以接口的方式体现出来，强调一点，这里的接口不一定是一个语法，而是一个类型的约束。所以，在这个关于多态的讨论中，接口、抽象类、父类等几个概念都是等价的，为了叙述方便，我这里统一采用接口的说法。在构建抽象上，接口扮演着重要的角色。首先，接口将变的部分和不变的部分隔离开来。不变的部分就是接口的约定，而变的部分就是子类各自的实现。

在软件开发中，对系统影响最大的就是变化。有时候需求一来，你的代码就要跟着改，一个可能的原因就是各种代码混在了一起。比如，一个通信协议的调整需要你改业务逻辑，这明显就是不合理的。对程序员来说，识别出变与不变，是一种很重要的能力。

其次，接口是一个边界。无论是什么样的系统，清晰界定不同模块的职责是很关键的，而模块之间彼此通信最重要的就是通信协议。这种通信协议对应到代码层面上，就是接口。

很多程序员在接口中添加方法显得很随意，因为在他们心目中，并不存在实现者和使用者之间的角色差异。这也就造成了边界意识的欠缺，没有一个清晰的边界，其结果就是模块定义的随意，彼此之间互相影响也就在所难免。后面谈到 Liskov 替换法则的时候，我们还会再谈到这一点。所以，要想理解多态，首先要理解接口的价值，而理解接口，最关键的就是在于谨慎地选择接口中的方法。

至此，你已经对多态和接口有了一个基本的认识。你就能很好地理解一个编程原则了：面向接口编程。面向接口编程的价值就根植于多态，也正是因为有了多态，一些设计原则，比如，开闭原则、接口隔离原则才得以成立，相应地，设计模式才有了立足之本。这些原则你可能都听说过，但在编码的细节上，你可能会有一些忽略的细节，比如，下面这段代码是很多人经常写的：

```java
ArrayList<> list = new ArrayList<String>();
```

这么简单的代码也有问题，是的，因为它没有面向接口编程，一个更好的写法应该是这样：

```java
List<> list = new ArrayList<String>();
```

二者之间的差别就在于变量的类型，是面向一个接口，还是面向一个具体的实现类。相对于封装和继承而言，多态对程序员的要求更高，需要你有长远的眼光，看到未来的变化，而理解好多态，也是程序员进阶的必经之路。

### 5.2 实现多态

还记得我们在编程范式那一讲留下的一个问题吗？面向对象编程，会限制使用函数指针，它是对程序控制权的间接转移施加了约束。理解这一点，就要理解多态是怎么实现的。讲多范式编程时，我举了 Linux 文件系统的例子，它是用 C 实现了面向对象编程，而它的做法就是用了函数指针。再来回顾一下：

```c
struct file_operations {
  loff_t (*llseek) (struct file *, loff_t, int);
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  int (*open) (struct inode *, struct file *);
  int (*flush) (struct file *, fl_owner_t id);
  int (*release) (struct inode *, struct file *);
  ...
}
```

假设你写一个 HelloFS，那你可以这样给它赋值：

```c
const struct file_operations hellofs_file_operations = {
    .read = hellofs_read,
    .write = hellofs_write,
};
```

只要给这个结构体赋上不同的值，就可以实现不同的文件系统。但是，这种做法有一个非常不安全的地方。既然是一个结构体的字段，那我就有可能改写了它，像下面这样：

```c
void silly_operation(struct file_operations* operations) {
  operations.read = sillyfs_read;
}
```

如此一来，本来应该在 hellofs\_read 运行的代码，就跑到了 sillyfs\_read 里，程序很容易就崩溃了。对于 C 这种非常灵活的语言来说，你根本禁止不了这种操作，只能靠人为的规定和代码检查。到了面向对象程序设计语言这里，这种做法由一种编程结构变成了一种语法。给函数指针赋值的操作下沉到了运行时去实现。如果你了解运行时的实现，它就是一个查表的过程，如下图所示：

一个类在编译时，会给其中的函数在虚拟函数表中找到一个位置，把函数指针地址写进去，不同的子类对应不同的虚拟表。当我们用接口去调用对应的函数时，实际上完成的就是在对应的虚拟函数表的一个偏移，不管现在面对的是哪个子类，都可以找到相应的实现函数。

还记得我在开头提的那个问题吗？问 C++ 程序员是否用过 virtual。在 C++ 这种比较注重运行时消耗的语言中，只有 virtual 的函数会出现在虚拟函数表里，而普通函数就是直接的函数调用，以此减少消耗。对于 Java 程序员而言，你可以通过给无需改写的方法添加 final 帮助运行时做优化。当多态成了一种语法，函数指针的使用就得到了限制，犯错误的几率就大大降低了，程序行为的可预期性就大大提高了。

### 5.3 没有继承的多态

回到 Alan Kay 关于面向对象的思考中，他考虑过封装，考虑过多态。至于继承，却不是一个必然的选项。只要能够遵循相同的接口，就可以表现出来多态，所以，多态并不一定要依赖于继承。比如，在动态语言中，有一个常见的说法，叫 Duck Typing，就是说，如果走起来像鸭子，叫起来像鸭子，那它就是鸭子。两个类可以不在同一个继承体系之下，但是，只要有同样的方法接口，就是一种多态。像下面这段代码，Duck 和 FakeDuck 并不在一棵继承树上，但 make\_quack 调用的时候，它们俩都可以传进去。

```ruby
class Duck
  def quack
    # 鸭子叫
  end
end

class FakeDuck
  def quack
    # 模拟鸭子叫
  end
end

def make_quack(quackable)
  quackable.quack
end

make_quack(Duck.new)
make_quack(FakeDuck.new)
```

我们都知道，很多软件都有插件能力，而插件结构本身就是一种多态的表现。比如，著名的开源图形处理软件 GIMP（[GIMP - GNU Image Manipulation Program](https://www.gimp.org/)），它自身是用 C 开发的，为它编写插件就需要按照它规定的结构去编写代码：

```c
struct GimpPlugInInfo
{
  /* GIMP 应用初始启动时调用 */
  GimpInitProc  init_proc;

  /* GIMP 应用退出时调用 */
  GimpQuitProc  quit_proc;

  /* GIMP 查询插件能力时调用 */
  GimpQueryProc query_proc;

  /* 插件安装之后，开始运行时调用*/
  GimpRunProc   run_proc;
};
```

我们所需做的就是按照这个结构声明出 PLUG\_IN\_INFO，这是隐藏的名字，将插件的能力注册给 GIMP 这个应用：

```c
GimpPlugInInfo PLUG_IN_INFO = {
  init,
  quit,
  query,
  run
};
```

你看，这里用到的是 C 语言，一种连面向对象都不支持的语言，但它依然能够很好地表现出多态。现在你应该理解了，多态依赖于继承，这只是某些程序设计语言自身的特点。你也看出来了，在面向对象本身的体系之中，封装和多态才是重中之重，而继承则处于一个很尴尬的位置。

我们花了三讲的篇幅讲了面向对象编程的特点，在这三讲中，我们不仅仅以 Java 为基础讲了传统的面向对象实现的一些方法，也讲到了不同语言在解决同样问题上的不同做法。正如我们在讲程序设计语言时所说，一定要跳出单一语言的局限，这样，才能对各种编程思想有更本质的认识。

在这里，你也看到了面向对象编程的三个特点也有不同的地位：1）封装是面向对象的根基，软件就是靠各种封装好的对象逐步组合出来的；2）继承给了继承体系内的所有对象一个约束，让它们有了统一的行为；3）多态让整个体系能够更好地应对未来的变化。后面我们还会讲到面向对象的设计原则，而这些原则的出发点就是面向对象的这些特点，所以，理解面向对象的这些特点，是我们后面把设计做好的基础。

### 黑板墙

最后，我想请你去了解一下 Go 语言或 Rust 语言是如何支持多态的。

自己理解总结：多态就是接口一样，实现不同。其前提是构建抽象，找出事物的共同点。让程序员更着眼未来的变化。作者回复：这个理解很对。2020-07-01

某系统需要对普通用户增删改查，后来加了超级管理员用户也需要增删改查。把用户的操作抽象成接口方法，让普通用户和管理员用户实现接口方法…… 那么问题来了，这些接口方法的出入参没法完全共用，比如查询用户信息接口，普通用户和超级管理员用户的返回体信息字段不同。所以没法抽象，请问一下老师这种应不应该抽象呢？如果应该做成抽象需要怎么分离变的部分呢。作者回复：应该分，因为管理员和普通用户的关注点是不同的。管理员和普通用户可以分别提供接口，分别提供相应的内容。如果说非要二者共用，可以考虑在服务层共用，在接口层面分开，在接口层去适配不同的接口。2020-07-01

这几讲下来终于体会到多学几门语言的妙处了。对于 Java 和 C++，总是有用树形关系在考虑多态（大概就是继承引导的思维吧），下来看了 Go 和 Rust 对于多态的支持，虽然理解不深，但给我的初步印象就是通过组合接口来实现多态。建立起抽象确实不是件一蹴而就的事情，往往伴随着在某一领域下，对需求认识和理解的不断加深。作者回复：日拱一卒，体会设计之美。2020-07-02

go 就是文中所述的 Duck Typing。只是用来写算法题和小玩意。不是很注意。Duck Typing 的话，能通过 ide 便捷的找到所有实现吗？这是个问题。作者回复：与工具结合起来的时候，太灵活的动态语言，优势就不那么明显了。2020-07-01

react 可以说是，大多数情况下基于组件编程吗？作者回复: React 是基于组件编程的。2020-07-01

使用多态，首先要构建抽象，而抽象就是从不同的对象中找出共同的部分，根本就是要注意分离关注点。然后将抽象出部分使用接口表现出来，所以封装和多态是面向对象最重要的原则。在实际工作上我们的 APP 因为需要支持各种设备和硬件负载，每个设备和负载的数据和 UI 界面也有可能是不大一样的交互，随着业务的发展，需要在一个 APP 中适配和兼容，这给开发和测试带来极大的不便。我的一个想法是利用利用封装将不同设备和负载抽象相同出相同的部分，将不同的部分使用接口分离出来。不知道大佬有没有更好的想法，可以参考？2020-07-01

## 0306. 函数式编程：不用函数式编程语言，怎么写函数式的程序？

这一讲我们讨论了函数式编程这种编程范式，它给我们提供的编程元素是函数。只不过，这个函数不同于传统程序设计语言的函数，它的思想根源是数学中的函数。函数是函数式编程的一等公民（first-class citizen）。一等公民指的是：1）它可以按需创建；2）它可以存储在数据结构中；3）它可以当作实参传给另一个函数；4）它可以当作另一个函数的返回值。如果你使用的程序设计语言不支持函数是一等公民，可以用其他的方式模拟出来，比如，用对象模拟函数。随着函数式编程的兴起，越来越多的程序设计语言加入了自己的函数，比如：Java 和 C++ 增加了 Lambda，可以在一定程度上支持函数式编程。函数式编程就是把函数当做一个个的构造块，然后将这些函数组合起来，构造出一个新的构造块。这样有趣的事情就来了。下一讲，我们来看看这件有趣的事，看函数式编程中是怎么组合函数的。如果今天的内容你只能记住一件事，那请记住：函数式编程的要素是一等公民的函数，如果语言不支持，可以自己模拟。

1『 JS 是函数式语言，函数是一等公民，JS 里函数是一种特殊的对象。』


前面几讲，我们讲了结构化编程和面向对象编程，对于大多数程序员来说，这些内容还是比较熟悉的。接下来，我们要讨论的函数式编程，对一些人来说就要陌生一些。你可能知道，Java 和 C++ 已经引入了 Lambda，目的就是为了支持函数式编程。因为，函数式编程里有很多优秀的元素，比如，组合式编程、不变性等等，都是我们值得在日常设计中借鉴的。即便我们使用的是面向对象编程语言，也可以将这些函数式编程的做法运用到日常工作中，这已经成为大势所趋。

但是，很多人学习函数式编程，刚刚知道了概念，就碰上了函数式编程的起源，遇到许多数学概念，然后，就放弃了。为什么学习函数式编程这么困难呢？主要是因为它有一些不同的思维逻辑，同时人们也缺少一个更好的入门方式。所以，在这一讲中，我打算站在一个更实用的角度，帮你做一个函数式编程的入门。等你有了基础之后，后面两讲，我们再来讨论函数式编程中优秀的设计理念。

### 6.1 不断增加的需求

我们从一个熟悉的场景出发。假设我们有一组学生，其类定义如下：

```java
// 单个学生的定义
class Student {
  // 实体 ID
  private long id;
  // 学生姓名
  private String name;
  // 学号
  private long sno;
  // 年龄
  private long age;
}

// 一组学生的定义
class Students {
  private List<Student> students
}
```

如果我们需要按照姓名找出其中一个，代码可能会这么写：

```java
Student findByName(final String name) {
  for (Student student : students) {
    if (name.equals(student.getName())) {
        return student;
    }
  }


  return null;
}
```

这时候，新需求来了，我们准备按照学号来找人，代码也许就会这么写：

```java
Student findBySno(final long sno) {
  for (Student student : students) {
    if (sno == student.getSno()) {
        return student;
    }
  }

  return null;
}
```

又一个新需求来了，我们这次需要按照 ID 去找人，代码可以如法炮制：

```java
Student findById(final long id) {
  for (Student student : students) {
    if (id == student.getId()) {
        return student;
    }
  }

  return null;
}
```

看完这三段代码，你发现问题了吗？这三段代码，除了查询的条件不一样，剩下的结构几乎一模一样，这就是一种重复。那么，我们要怎么消除这个重复呢？我们可以引入查询条件这个概念，这里只需要返回一个真假值，我们可以这样定义：

```java
interface Predicate<T> {
  boolean test(T t);
}
```

有了查询条件，我们可以改造一下查询方法，把条件作为参数传进去：

```java
Student find(final Predicate<Student> predicate) {
  for (Student student : students) {
    if (predicate.test(student)) {
        return student;
    }
  }

  return null;
}
```

于是，按名字查找就会变成下面这个样子（其他两个类似，就不写了）。为了帮助你更好地理解，我没有采用 Java 8 的 Lambda 写法，而用了你最熟悉的对象：

```java
Student findByName(final String name) {
  return find(new Predicate<Student>() {
    @Override
    public boolean test(final Student student) {
      return name.equals(student.getName();
    }
  });
}
```

这样是很好，但你会发现，每次有一个新的查询，你就要做一层这个封装。为了省去这层封装，我们可以把查询条件做成一个方法：

```java
static Predicate<Student> byName(final String name) {
  return new Predicate<Student>() {
    @Override
    public boolean test(final Student student) {
      return name.equals(student.getName();
    }
  }
}
```

其他几个字段也可以做类似的封装，这样一来，要查询什么就由使用方自己决定了：

```java
find(byName(name));
find(bySno(sno));
find(byId(id));
```

现在我们想用名字和学号同时查询，该怎么办呢？你是不是打算写一个 byNameAndSno 的方法呢？且慢，这样一来，岂不是每种组合你都要写一个？那还受得了吗。我们完全可以用已有的两个方法组合出一个新查询来，像这样：

```java
find(and(byName(name), bySno(sno)));
```

这里面多出一个 and 方法，它要怎么实现呢？其实也不难，按照正常的 and 逻辑写一个就好，像下面这样：

```java
static <T> Predicate<T> and(final Predicate<T>... predicates) {
    return new Predicate<T>() {
        @Override
        public boolean test(final T t) {
            for (Predicate<T> predicate : predicates) {
                if (!predicate.test(t)) {
                    return false;
                }
            }

            return true;
        }
    };
}
```

类似地，你还可以写出 or 和 not 的逻辑，这样，使用方能够使用的查询条件一下子就多了起来，他完全可以按照自己的需要任意组合。这时候，又来了一个新需求，想找出所有指定年龄的人。写一个 byAge 现在已经很简单了。那找到所有人该怎么写呢？有了前面的基础也不难。

```java
Student findAll(final Predicate<Student> predicate) {
    List<Student> foundStudents = new ArrayList<Student>();
    for (Student student : students) {
        if (predicate.test(student)) {
            foundStudents.add(student);
        }
    }

    return new Students(foundStudents);
}
```

如此一来，要做什么动作（查询一个、查询所有等）和用什么条件（名字、学号、ID 和年龄等）就成了两个维度，使用方可以按照自己的需要任意组合。直到现在，我们所用的代码都是常规的 Java 代码，却产生了神奇的效应。这段代码的作者只提供了各种基本元素（动作和条件），而这段代码的用户通过组合这些基本的元素完成真正的需求。这种做法完全不同于常规的面向对象的做法，其背后的思想就源自函数式编程。在上面这个例子里面，让代码产生质变的地方就在于 Predicate 的引入，而它实际上就是一个函数。

这是一个简单的例子，但是我们可以发现，按照「消除重复」这样一个简单的编写代码逻辑，我们不断地调整代码，就是可以写出这种函数式风格的代码。在写代码这件事上，我们常常会有一种殊途同归的感觉。现在，你已经对函数式编程应该有了一个初步的印象，接下来，我们看看函数式编程到底是什么。

### 6.2 函数式编程初步

函数式编程是一种编程范式，它提供给我们的编程元素就是函数。只不过，这个函数是来源于数学的函数，你可以回想一下，高中数学学到的那个 f(x)。同我们习惯的函数相比，它要规避状态和副作用，换言之，同样的输入一定会给出同样的输出。

之所以说函数式编程的函数来自数学，因为它的起源是数学家 Alonzo Church 发明的 Lambda 演算（Lambda calculus，也写作 λ-calculus）。所以，Lambda 这个词在函数式编程中经常出现，你可以简单地把它理解成匿名函数。我们这里不关心 Lambda 演算的数学逻辑，你只要知道，Lambda 演算和图灵机是等价的，都是那个年代对「计算」这件事探索的结果。

我们现在接触的大多数程序设计语言都是从图灵机的模型出发的，但既然二者是等价的，就有人选择从 Lambda 演算出发。比如早期的函数式编程语言 LISP，它在 20 世纪 50 年代就诞生了，是最早期的几门程序设计语言之一。它的影响却是极其深远的，后来的函数式编程语言可以说都直接或间接受着它的影响。

虽然说函数式编程语言早早地就出现了，但函数式编程这个概念却是 John Backus 在其 1977 年图灵奖获奖的演讲上提出来。有趣的是，John Backus 获奖的理由是他在 Fortran 语言上的贡献，而这门语言和函数式编程刚好是两个不同「计算」模型的极端。

了解了函数式编程产生的背景之后，我们就可以正式打开函数式编程的大门了。函数式编程第一个需要了解的概念就是函数。在函数式编程中，函数是一等公民（first-class citizen）。一等公民是什么意思呢？1）它可以按需创建；2）它可以存储在数据结构中；3）它可以当作实参传给另一个函数；4）它可以当作另一个函数的返回值。

2『函数是一等公民，做一张术语卡片。』

对象，是面向对象程序设计语言的一等公民，它就满足所有上面的这些条件。在函数式编程语言里，函数就是一等公民。函数式编程语言有很多，经典的有 LISP、Haskell、Scheme 等，后来也出现了一批与新平台结合紧密的函数式编程语言，比如：Clojure、F#、Scala 等。很多语言虽然不把自己归入函数式编程语言，但它们也提供了函数式编程的支持，比如支持了 Lambda 的，这类的语言像 Ruby、JavaScript 等。

如果你的语言没有这种一等公民的函数支持，完全可以用某种方式模拟出来。在前面的例子里，我们就用对象模拟出了一个函数，也就是 Predicate。在旧版本的 C++ 中，也可以用 functor（函数对象）当作一等公民的函数。在这两个例子中，既然函数是用对象模拟出来的，自然就符合一等公民的定义，可以方便将其传来传去。

在开头，我提到过，随着函数式编程这几年蓬勃的发展，越来越多的「老」程序设计语言已经在新的版本中加入了对函数式编程的支持。所以，如果你用的是新版本，可以不必像我写得那么复杂。比如，在 Java 里，Predicate 本身就是 JDK 自带的，and 方法也不用自己写，加上有 Lambda 语法简化代码的编写，代码可以写成下面这样，省去了构建一个匿名内部类的繁琐：

```java
static Predicate<Student> byName(String name) {
    return student -> student.getName().equals(name);
}

find(byName(name).and(bySno(sno)));
```

如果按照对象的理解方式，Predicate 是一个对象接口，但它可以接受一个 Lambda 为其赋值。有了前面的基础，你可以把它理解成一个简化版的匿名内部类。其实，这里面主要工作都在编译器上，它帮助我们做了类型推演（Type Inference）。

在 Java 里，可以表示一个函数的接口还有几个，比如，Function（一个参数一个返回值）、Supplier（没有参数只有返回值），以及一大堆形式稍有不同的变体。这些「函数」的概念为我们提供了一些基础的构造块，从前面的例子，你可以看出，函数式编程一个有趣的地方就在于这些构造块可以组合起来，这一点和面向对象是类似的，都是由基础的构造块逐步组合出来的。

我们讲模型也好，面向对象也罢，对于这种用小组件逐步叠加构建世界的思路已经很熟悉了，在函数式编程里，我们又一次领略到同样的风采，而这一切的出发点，就是「函数」。

### 黑板墙

今天我们开始了函数式编程的讲解，我想请你谈谈函数式编程给你留下的最深刻印象，无论是哪门函数式编程语言也好，还是某个函数式编程的特性也罢。

基于函数切分逻辑跟基于对象切分逻辑有何异同嘛？作者回复：下一讲会讲函数式编程的组合性，会提到这个问题，简言之，函数式切分的是动词，面向对象切分的是名词。2020-07-03

demo 里面，感觉消除重复不怎么明显（虽然调用侧少了恶心的 if-else，但整体代码量反而变多了）。反而适配的味道很重。将所有 equest 判断适配成统一规格的 Predicate 函数。调用侧基于 Predicate 函数（统一规格的接口）做职责链链式调用。挺复合统一多个类的接口设计的一应用场景。作者回复：这取决于给使用端提供多大的灵活度，灵活度大，这个设计才有意义。2020-07-03

函数式编程给我印象最深的就是「纯函数」的概念。想想看，如果程序是由一个个纯函数组成的，那么在实现每一个函数的时候，不需要关心外界的情况，并且还可以利用缓存提高性能。作者回复：后面我们会讲到纯函数，也会讲到缓存的做法，敬请期待。2020-07-03

尝试用 C++ 模板实现了课程中的例子，咋一看不如常规的 findByxxx 好理解，不过仔细一琢磨，扩展模板的 test 方法，可扩展性是绝对比常规的扩展一个个 findByxxx 方法大太多了，一个新增的查找需求，只需要扩展一个模板实例的 test 方法就完美支持了。2020-07-03

zipper 吧，对 immutable 的递归数据结构进行遍历和修改，很精致的 copy on write。作者回复：很好地分享。2020-07-03

拆成一个个小组件，然后就是随意组合搭积木。面向对象编程的基础组件就是类，而函数式编程就是函数。作者回复：对，是这个意思。2020-07-03

函数式编程范式里，函数是一等公民，有了函数式编程就可以封装复用的逻辑代码，还可以组合这些逻辑代码。语言设计越往后它是不断会进化的，毕竟这个世界里唯一不变的就是变化。作者回复：这个总结是到位的。2020-07-03

java 有空 lambda 之后好，代码精炼了很多，但有些人表示看不懂了，增加了理解难度。作者回复：用好 lambda 的第一条，不要在 lambda 里写太多代码。2020-07-03

在实际开发中，我一般把查询条件放到 sql 里，现在我准备拿到代码里，但是以前的分页插件阻止了我这么做，分页插件是以 sql 为基础的。那么请问郑大，如果改造查询用函数式表示的话，如何评判利弊呢。最近在拯救一个很烂 (完全没有测试) 的项目。2020-07-03

3『附件「0321小类大对象.md」

### 01

一群盲人被带到一头大象面前，让他们摸摸大象像什么。一个瞎子摸到了大象的腿，说大象像一棵树；另一个瞎子摸到了大象的耳朵，说大象像一个扇子；第三个摸着大象的身体，说它像一堵墙；第四个瞎子则拽着大象的尾巴说，它分明像一根绳子......这就是我们熟知的《盲人摸象》的寓言。它主要是用来讽刺：我们不应该只看到一个事物的侧面，就匆忙给出结论，这样我们就与瞎子无异。

### 02

正如万事只要换个坐标系，就可能会得出不同结论一样；回到我们软件设计领域，重新衡量这个问题，会发现盲人摸象的效果恰恰是我们所苦苦追求的。假设我们拥有一头大象。如果现在有人需要一把扇子，我们就让他使用大象的耳朵来扇会儿风；如果有人需要一把长茅，就让他把象牙当作武器；而如果有人需要一根绳子，我们则可以把大象尾巴借他当绳子用会儿……

总而言之，对于不同个体，需要的是更加具体的服务，而不是一头大象，因而他也并不关心为他服务的事物背后是否是一头大象。而大象，是个完整的个体，不可分割（这很重要）。它很大，大到可以为外部提供多种功能的服务。而对于每种不同的服务需要者，它就扮演不同的角色。

1『我去啊，这个大象的思想实在是太 NB 了，完全是从另一个角度（正面）来看盲人摸象，做一张反常识卡片。』——已完成

如果我们将刚才的描述映射到软件的组件技术，就可以用下图来展现：

大象是一个不可分割的完整组件，但对外提供不同的服务。不同类型的客户使用不同的服务，完全无需知道其它服务的存在，也无需知道背后是谁再为自己提供服务。而这种方式，无疑降低了客户与服务提供者之间的耦合：1）一方面，每个服务背后的具体提供者都可以自由替换，而不用担心客户代码受到影响（但要遵从里氏替换原则，即要遵从客户与服务之间的契约）；2）另一方面：作为服务提供者 —— 大象 —— 不会强迫客户依赖它无需依赖的东西，而只依赖自己特定需要的服务接口；3）同时，由于你没有把整只大象呈现在客户面前，这就约束了客户随意使用大象提供的其它接口所带来的不必要的耦合。

如果回到具体程序设计上，一种可能的实现则会如下：

```java
public interface Fan
{
  // Fan related methods.
}

public interface Rope
{
  // Rope related methods.
}

public interface Snake
{
  // Snake related methods.
}

public interface Tree
{
  // Tree related methods.
}

public interface Wall
{
  // Wall related methods.
}

public interface Spear
{
  // Spear related methods
}


class Elephant implements Fan, Rope, Snake, Tree, Wall, Spear
{
  // Implementation of Fan related methods.
  
  // Implementation of Rope related methods.
  
  // Implementation of Snake related methods.
  
  // Implementation of Tree related methods.
  
  // Implementation of Wall related methods.
  
  // Implementation of Spear related methods.
  
  // all Elephant Data.
}

```

在这个 Java 版本的实现方式中，所有接口的具体实现都集中在 Elephant 类里。当接口足够多，实现足够复杂时，这毫无疑问会形成上帝类。不过，这貌似没有太大问题。毕竟，大象本来就是个大块头。

### 03

组件化的设计方式，某种程度也是一种多角色对象设计方式。我们每个人在生活中都扮演不止一个角色：1）在孩子面前，我们是父母；2）在父母面前，我们是子女；3）职场上，在上司面前，我们是下属；4）在下属面前，你是上司...

不同角色，要求履行的职责也不同：1）作为父母：我们要给孩子讲故事，陪他们玩游戏，哄它们睡觉；2）作为子女：我们则要孝敬父母，听取他们的人生建议；3）作为下属：在老板面前，我们需要听从其工作安排；4）作为上司：需要安排下属工作，并进行培养和激励...

所有这些角色，或者有所关联，或者风马牛不相及，但却可以很好的集中于一个人身上。

2『这个隐喻也实在太 NB 了，必须得挖作者更多的文章。（2020-07-13）』

### 04

每一个角色，都有其存在的上下文（Context），或称为环境。比如：你不会回到家里去扮演上司的角色；也不会在公司环境下扮演父母的角色。

对某个人来说，如果一个上下文并不存在，或者已经脱离了某个上下文，那么对他而言，对应的角色也就不会或不再存在。比如，如果一个人还没有孩子，那他就不会扮演父母这个角色；一旦一个人离开职场，那他就无需再承担与职场有关的角色。类似的，一个人也会由于上下文的变化而承担他过去无需承担的责任。比如，当有了孩子之后，他就要开始承担作为父母的责任；而一旦被提拔为管理者，就需要开始承担上司的职责。因而，每个人需要承担的角色，都在随着环境的变化而变化。

对于软件开发而言，环境对应的是 Use Case，对应的是需求。需求的变化，对于很多系统而言是很频繁的。这就意味着我们之前在一个类里实现所有角色相关代码所得到的上帝类，在频繁变化的需求面前，由于角色变更而导致的变化也是很频繁的。

### 05

在频繁的变化面前，上帝类的修改，往往并不是简单的增加或删除某个角色相关代码那么简单。我们已经知道，OO 的主要作用是为了模块化，通过将关联紧密的元素放到一个类中，然后通过封装手段将易于变化的细节隐藏起来，只暴露更为抽象，更为稳定的接口，从而降低模块间耦合。最终达到让软件在变化面前，局部化影响，容易修改的目的。与之相反的是，毫无边界控制的全局数据访问，从而造成大面积无规则的对于实现细节的依赖。这样的做法，在初次实现时，一定是最快速简单的。但同时也是在变化面前最为脆弱的。

而类，在 OOPL 里，是不可再分割的最小模块。而在类的内部，没有边界访问控制，对于类内部的一切实现细节的访问均是自由的。因而，在一个类内部，所有的成员变量都相当于全局变量，所有的函数，都相当于全局函数。而在类内部，没有任何强制手段可以阻止对这些「全局变量」和「全局函数」的自由访问。

如果一个类很小，职责单一，那么内部的高耦合所造成的影响就会很小（所谓高内聚，正是要把关联紧密的事物放在一起，从而将变化带来的影响控制在类内部）。但高内聚的另外一面是：只有关联紧密的事才应该被放在一起。对于一个多重职责的上帝类，内部的各个元素之间的关联紧密程度几乎可以肯定是不一致的。

在这种情况下，没有任何边界访问控制的类内部，就会很容易导致本不该有的高耦合。如果还是觉得难以理解，就不妨想象一下，把整个系统都放到单个类里，这样的设计会导致怎样的耦合度。

### 06

2003 年，伴随着 Eric Evans 出版了《领域驱动设计》，Martin Fowler 很快发表了一篇文章《Anemic Domain Model》(《贫血领域模型》)，对那些只有数据，没有有价值行为的所谓领域对象进行了强烈的批评。这篇文章引起了社区很大的反响。但却并没有阻挡住社区依然在大量使用贫血模型的脚步，Service，而不是 Domain Object，被当作表达业务逻辑的核心场所。

但这也不全是这些团队的错。其根本原因在于，当大家尝试使用充血模型时，发现在易于变化的业务逻辑面前，那些领域类很容易就变成了上帝类，然后随着业务的变化不断修改。完全无法达到局部化影响的效果。大家都是要解决问题的，不能为了充血而充血不是？因而，很多团队在实践 DDD 时，继续纠结的披着面向对象的外衣，行着面向过程之实。

### 07

在单一类里实现所有角色所得到的上帝类，被称作水平上帝类（或横向上帝类）。水平上帝类带来的问题，除了像所有上帝类一样，造成了不必要的高耦合之外，还会导致难以复用的问题。现在我们定义几个不同的 class，用来表现不同类型的人。通过这些 class，可以实例化一个个不同的对象：具体的人。

首先是 A 类型人的实现：

```java
struct TypeAPerson
   : Parent
   , Child
   , Underling
{ 
  // 父母角色相关接口
  void tellStory() {...}
  void playGameWithChild() {...} 
  // ... 

  // 子女角色相关接口
  void getAdviceFromParent() {...}
  // ... 
 
  // 下属角色相关接口 
  void acceptTask() {...}
  void reportStatus() {...}
  // ... 

private:
  // 所有角色所需的数据成员都放置于此 
  // ... 
};
```

下面是 B 类型人的实现：

```java
struct TypeBPerson
   : Parent
   , Boss
   , Underling
{ 
  // 父母角色相关接口
  void tellStory() {...}
  void playGameWithChild() {...} 
  // ... 

  // 老板角色相关接口 
  void assignTask() {...}
  void motivate() {...} 
  // ... 
 
  // 下属角色相关接口 
  void acceptTask() {...}
  void reportStatus() {...}
  // ... 

private:
  // 所有角色所需的数据成员都放置于此 
  // ... 
};
```

对于 TypeAPerson 和 TypeBPerson，他们都扮演了 Parent 和 Underling 的角色，并且这两个角色的实现方式也完全相同。同时，他们也各自扮演了对方不具备的角色：TypeAPerson 扮演了 Child，而 TypeBPerson 则扮演了 Boss。这就造成了这两个类之间是有部分重复代码的。但这的重复根本难不倒我们，将两者重合的角色代码提取到一个基类中即可。

```java
struct BaseTypePerson
   : Parent
   , Underling
{ 
  // 父母角色相关接口
  void tellStory() {...}
  void playGameWithChild() {...} 
  // ... 

  // 下属角色相关接口 
  void acceptTask() {...}
  void reportStatus() {...}
  // ... 
  
private:
  // 其它成员:数据成员和私有函数 
  // ... 
};
```

然后，让两个类都从此它继承:

```java
struct TypeAPerson
  : BaseTypePerson
  , Child 
{
  // 子女角色相关接口
  void getAdviceFromParent() {...}
  // ... 
};

struct TypeBPerson 
  : BaseTypePerson
  , Boss 
{ 
  // 老板角色相关接口 
  void assignTask() {...}
  void motivate() {...}
  // ... 
};
```

到目前为止，一切都好。此时我们再增加一个新的类型，让角色的复用关系更加复杂。如下：

```java
class TypeCPerson
   : Child
   , Boss
{ 
  // 子女角色相关接口
  void getAdviceFromParent() {...}
  // ... 
 
  // 老板角色相关接口 
  void assignTask() {...}
  void motivate() {...} 
  // ... 
 
private:
  // 所有角色所需的数据成员都放置于此 
  // ... 
};
```

此时，再想通过单根继承来解决复用问题，将会变成一个不可能完成的任务。

1『已经接受到作者想要传达的信息了，如果从「继承」实现一步步演变成「组合」实现，哈哈。』

### 08

单根继承的最大问题在于：只能解决单个变化方向的问题，对于多个变化方向无能为力。比如，在下面的关系中，基类 Interface 存在两个抽象函数：f 和 g。这代表两个不同的变化方向。如果 f 和 g 各自存在两种不同的实现方式，则会存在 4 种不同的组合关系。

这种情况下，使用单根继承是无法消除掉所有重复代码的。比如，我们将 f1 和 f2 的重复代码各自提取到不同的中间类 F1 和 F2 中，却依然无法避免 g1 和 g2 的代码重复。

由此可以看出，当存在多个变化方向时，使用单根继承来消除重复，不仅会造成大量的仅仅为消除重复存在的中间类（比如本例子中的 F1 和 F2），却最终依然无法彻底消除重复。因而，为了解决我们之前所述的多角色对象的重复问题，我们必须另辟蹊径。

1『中间类，接着原文中的图看，非常直观，果然一图胜千言。』

### 09

七巧板，是大家熟知的一种其源自中国的古老智力游戏。由这么七块简单的小素材，可以拼出变化无穷的图案。受限的只是你的想象力。这个简单的游戏，蕴含这一种极具价值的设计思想：组合。因而，我们首先将四个角色相关的实现拆解为四个类：

```java
struct ConcreteChild : Child
{ 
  // 子女角色相关接口
  void getAdviceFromParent() {...}
  // ... 

private:
  // 子女角色所需的数据成员
  // ... 
};

struct ConcreteParent : Parent
   
{ 
  // 父母角色相关接口
  void tellStory() {...}
  void playGameWithChild() {...} 
  // ... 

private:
  // 父母角色所需的数据成员
  // ... 
};

struct ConcreteBoss : Boss
{ 
  // 老板角色相关接口 
  public void assignTask() {...}
  public void motivate() {...} 
  // ... 
  
private:
  // 老板角色所需的数据成员 
  // ... 
};

struct ConcreteUnderling : Underling
{ 
  // 下属角色相关接口 
  public void acceptTask() {...}
  public void reportStatus() {...}
  // ... 
  
private:
  // 下属角色所需的数据成员  
  // ... 
};
```

现在我们有了这四个「零件」，下一个问题就是如何把它们组合成我们最终所需的 TypeAPerson，TypeBPerson 和 TypeCPerson。在 C++ 下，对于这类问题，最好的组合方式是多重继承:

```cpp
struct TypeAPerson
  : ConcreteParent
  , ConcreteChild
  , ConcreteUnderling
{
};  

struct TypeBPerson
  : ConcreteParent
  , ConcreteUnderling
  , ConcreteBoss
{
};  

struct TypeCPerson
  : ConcreteChild
  , ConcreteBoss
{
};  
```

一旦转为组合的设计方式，其应对变化的能力将得到极大的增强。比如，TypeAPerson 随后便为管理者，则只需要简单的组合一个新的角色：ConcreteBoss:

```cpp
struct TypeAPerson
  : ConcreteParent
  , ConcreteChild
  , ConcreteUnderling
  , ConcreteBoss      // 新增角色
{
};  
```

而 TypeBPerson 退休，不再从事职场工作，则只需要将职场相关两个角色删除：

```cpp
struct TypeBPerson
  : ConcreteParent
  // , ConcreteUnderling // 删除角色
  // , ConcreteBoss      // 删除角色
{
};  
```

另外，虽然 TypeAPerson 和 TypeBPerson 都扮演了 Parent 的角色，但随后 TypeBPerson 的 Parent 角色的实现方式发生了变化，那么我们只需要增加一个新的 Parent 实现：

```java
struct ConcreteParent2 : Parent
{ 
  // 另一种父母角色相关接口实现
  void tellStory() {...}
  void playGameWithChild() {...} 
};
```

然后把 TypeBPerson 的 Parent 角色替换为新的实现：

```cpp
struct TypeBPerson
  : ConcreteParent2
{
};  
```

这种关系，正如下图所示：

所有那些角色的实现，正如七巧板的那些小组件一样，作为素材库，每一个对象的设计者只需要首先查看素材库，看里面是否有自己所需的角色实现。如果存在，则通过简单的组合方式来复用。如果不存在，则编写自己针对某个角色的特定实现，除了自己使用之外，也变成了素材库的一部分。

1『读到这里，感触到的最核心的是你要有能力进行拆解，有能力拆解出「合适」颗粒度的组件。』

### 10

面向对象方法学，在最初被创造出来时，更多的是希望通过用对象来模拟现实世界的问题域，从而让软件更容易理解。但是，遵从这个思路去使用面向对象，容易得到上帝对象。这种现象的背后，反映了这种方法论的本质缺陷 —— 它没有触及软件设计的真正挑战：软件设计如何才能让软件在需求变化面前容易变更。

我们现在知道，为了让软件能更容易的应对变化，则必须遵从高内聚低耦合原则，以封装和隔离变化。但这样会必然会导致一堆单一职责的小类。而这些类并非一定存在于领域的直接概念上，往往是为了设计的灵活性而由设计师创造出来的。而这些小类最后则实例化为诸多的小对象，而这些小对象，当然也不是能够直接映射到现实问题领域的。而它们的种类事实上要远多于领域概念中的对象数量。所以，这两种哲学的矛盾，一直无法让 OO 发挥其应有的威力：前者更容易理解，但得到的软件更难修改；后者更灵活，却模糊了现实与领域的映射。

之所以产生这种矛盾的原因是：很多人把 class 与 object 看作对等的的东西。class 无非是用来实例化 object 的模版。

但事实上，类与对象是完全两种不同的事物 —— 类的作用，是为了模块化，我们应该遵从高内聚低耦合的原则去划分类，那怕由此产生了远超领域实体概念数量的类，也无妨。让软件容易应对变化，是我们无论采取何种方法论都应该遵从的原则。而对象，是我们运行时承载了数据和行为的实体：它的种类和数量应该与领域的真实概念存在清晰、明确、直接的映射。因而，类应该是小的，对象应该是大的。上帝类是糟糕的，但上帝对象却恰恰是我们所期盼的。

1『哇塞哇塞，太有启发性了。小类大对象，类是为了模块化，在类里做接口，来隔离变化。对象是为了映射真实世界的事物，封装好行为和数据。』

而从类到对象，是一种多对一的关系：最终一个对象模版是由诸多单一职责的小类 —— 它们分别都可以有自己的数据和行为 —— 所构成。而将类映射到对象的过程，在 Ruby 中的 Mixin；在 Scala 中则通过 Traits；而 C++ 则通过多重继承。因而，自 Scala 以来，诸多新设计的语言都开始包含 Trait 这个语法特性。但是其中一些完全没理解 Trait 的真正价值，不允许 Trait 包含数据，因而它们也失去了发挥更强大威力的潜力。

1『在 PHP 里也是通过 Traits 来实现，小类映射到大对象。』

### 11

2011 年，我们在一个电信项目的重构和开发过程中，发现在一个概念上不可分割的领域对象上，其过多的变化方向上导致了大规模重复代码，从而导致代码极难理解和维护。而如果将其切分为很多小对象，可以将重复消除掉，但却会导致对于诸多小对象的管理问题，以及大量的内存浪费，当时那个项目内存优化也是一种重要的目标。

这逼迫我们对 OO 进行了更深入的思考，最终明确了小类，大对象的概念，也开始真正发挥 OO 的威力。由此，在那个项目上，我们得到了两全其美的解决方案：不仅大大增强了系统的可理解性和可维护性，也大幅降低内存占用（内存节省了 70%）。并且作为一种通用方法，在随后的项目中不断发挥其威力。

总而言之，通过将类和对象看作不同事物，现代 OO 方法学漂亮的解决了设计中最重要的两个问题（见《[简单设计 - 简书](https://www.jianshu.com/p/0228d2dd90fe)》）：1）类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；让贫血模型和充血模型不再成为一个两难选择；2）对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域，而这才是领域驱动设计的真正目的和精髓。

自此，已经没有人可以阻挡我们深信 OO 是一种非常有效的分析和设计方法论了。

2『消化吸收作者的文章「简单设计」，并也收录为附件「0322简单设计」。』——已完成

』

3『附件「0322简单设计.md」

简单设计原则，通过对需求、易修改性、可理解性、复杂度，这四个在设计决策中最关键的因素给出了排序，让简单设计不再一个语义模糊的口号，而是对设计决策给出了清晰的 guideline。根据笔者经验，深入理解、并在项目中反复品味和应用它，可以避免掉很多不必要的争议，也会对设计质量产生非常显著的帮助。

我们一直在谈简单设计，但究竟什么是简单设计？更具体的说，对于同一个问题，设计决策 A 和 B，究竟哪一个更符合简单设计的要求？对于这类问题，如果没有一个明确的标尺，那么「简单设计」就不免会成为一句无法评判的空洞口号，让程序设计者无从判断和遵守。

### 01. 简单设计四原则

对此，Kent Beck 给出了清晰的答案：1）通过所有测试（Passes its tests）。2）尽可能消除重复（Minimizes duplication）。3）尽可能清晰表达（Maximizes clarity）。4）更少代码元素（Has fewer elements）。

以上四个原则的重要程度依次降低。这组定义被称做简单设计原则。初看上去，这组原则平淡无奇，似乎是一组耳熟能详的原则的罗列。但只要细细品味，就会发现其精妙绝伦之处。

1、通过所有测试。直观的看，这句话貌似在讲测试：一个项目只有具备完善的自动化测试，才算在做简单设计。但事实上并非如此。这里提到的测试，真正的意思是客户验收。如果你的项目通过了客户的所有验收条件（Acceptance Criteria），那就说明你们已经完成与客户约定的全部需求。至于验收方式是靠人工还是靠自动化测试则无关紧要。所以，这句话强调的是对外部需求 —— 包括功能性需求和非功能性需求 —— 正确的完成。

2、尽可能消除重复。重复，意味着低内聚，高耦合。而消除重复的过程，也就意味着是让软件走向高内聚，低耦合，达到良好正交性的过程。识别和消除重复，对于增强软件应对变化能力的重要程度，怎么强调都不为过。关于这一点，我会另文说明，这里就不再赘述。不过，并不是所有的重复都可以消除：比如，C++ 一个源文件里对外部公开的类，其每个 public 方法原型，除了在源文件里定义时，需要声明一次，还需要在头文件里再次声明。这样的重复，是语言机制的要求，无法消除。因而，这条原则被描述为最小化重复，而不是消除重复。

3、尽可能清晰表达。清晰性，指的是一个设计容易理解的程度。注意：这不仅仅是对整洁代码（Clean Code）及声明式设计（Declarative Design）的强调。关于这一点，有着非常有趣的部分，我们在随后的部分谈到。

4、更少代码元素。这一条是点睛之笔，正是因为它的存在，这组原则才被称做简单设计原则，从而区别于其它设计原则。在这里，常量，变量，函数，类，包 …… 都属于代码元素。代码元素的数量，通常反映了设计的复杂度。因而，这句话强调的是：尽可能降低复杂度，保持简单。

### 02. 重要程度排序

这一句最容易让人忽视，却恰恰最为重要。如果第四条是点睛之笔，那么第五条就是将之前四条贯穿起来的那条龙。正是这一句，让你知道当以上四条发生冲突时，应该如何取舍。我们已经知道，第四条，是简单设计的精髓，但是，它在前四条原则却最不重要。

对于第一条，它强调：简单固然好，但你不能为了简单，而不去实现和客户约定好的需求。（当然，如果需求不合理，你应该在前期通过和客户协商拒绝，或修改。但那是关于需求管理这个话题有关的故事，感兴趣者可以去查阅相关文章和书籍）。

而对于第二条，比如，我们现在有两个类：它们之间有一部分重复代码。为了消除掉这个重复，我们将重复代码提取到一个新的类里。于是两个类变为三个类，增加了一个新的代码元素。这当然让设计变得更复杂了。但这种复杂度产生了更重要的价值（让软件更具备正交性，从而让软件更易于修改），所以，不能为了保持简单，而不去消除这个重复。

对于第三条也是如此，比如下面这句代码中有一个 magic number：

```java
a = 1000;
```

为了让这段代码更容易理解，我们将代码修改为：

```java
const int MAX_NUM_OF_CONNECTIONS = 1000;
a = MAX_NUM_OF_CONNECTIONS;
```

从而增加了一个新的代码元素。因而也稍微增加了设计的复杂度。但由于这个新的代码元素也产生了相对于简单更重要的价值，在简单和表达力之间，我们应该选择后者。

### 03. 反向价值

而简单设计的价值，也可以从相反的角度来看：如果新增的一条代码元素，不能产生上述三个价值，它就不应该存在。

对于第一条，你不应该去实现一个客户还不需要的需求，因为那会增加系统的复杂度。对于第二条，你不应该为还没有出现的重复，或者为尚未出现的变化方向，去增加任何额外的复杂度。比如建立一个抽象接口，却只有一个对应的实现。而第四条对于前两条的约束，就是我们耳熟能祥的 YAGNI（You Aren't Gonna Need It）。它强调，我们要着眼当下，不去为自己猜想出的未来可能性去增加系统的复杂度。总之，当你看到一个代码元素，没有产生之前三条中的任何一条价值，那么它就应该被删除掉。而这正是简单设计能够简单的原因。

### 04. 需求最大

抛开第四条，单看前三条，它们之前的重要程度也是依次降低的。比如，你不应该因为怕产生很难消除、或干脆消除不掉的重复而放弃一个对客户有价值的需求。换句话说，哪怕一个需求会导致重复代码，你也要去实现它。同样的，如果一个需求，会导致你的设计更加晦涩，你却不应该因为它损害了清晰性、可理解性而拒绝它。

对于这两点，绝大多数人都没有太多争议。（也有一派认为，不应该让需求破坏设计的优雅，当两者发生冲突时，选择优雅）。

### 05. 最具争议话题的解决

我们经常能够听到一种争议：一些人认为，放在一起的长篇累牍的大块流程代码，反而更容易理解。因为消除重复而导致的单一职责，会将一大段代码分布到不同的类或者模块，为了理解它，就不得不在类或者模块间跳来跳去，反而不容理解了。

另外一部分人并不认同这种看法。他们认为，由于模块或类的单一职责性，其每块逻辑都更加简单清晰，然后在另外一个层面再去看它们之间的交互，就可以很快理解整个逻辑。这比大坨的面条式代码更容易理解。而对于 SLAP（Single Level of Abstraction Priciple）的遵守，会更进一步的增加可理解性。

由于可理解性属于更加个人、更加主观的事情，因而究竟哪种方式更容易理解，可能永远也不会有统一的答案。而简单设计原则通过第二条和第三条之间的排序，给出了清晰的决策依据：由于消除重复，把一大块代码分隔到了不同的地方，即便团队认为这确实损害了可理解性，但由于重复所导致的恶果更加严重，因而优先选择消除重复。

另外，关于简单设计原则，社区内有多个版本，用词不同，但意思大致相同。关键的差别是第二条和第三条的顺序：即消除重复和提升表达力哪个更重要。有一些人认为表达力比消除重复重要，因而把提升表达力放在第二条。但更多人认同的是本文之前的版本。对于这一点，我个人的观点是，越是主观的东西，就越不具备可验证性或科学性，因而对于工程技术而言，重要程度就越低。

另外，回归到具体项目里，为了避免争议，在不违背前两点原则的情况下，团队可以根据大多数人的审美和认知，决定怎样的设计才更具备可理解性。事实上，在重复已经被消除殆尽的情况下，对于可理解性问题，无论怎样选择，影响都是局部的。因而，对于这个问题，团队觉得舒服最重要。

』



