# 2020016王争的设计模式之美R01

## 记忆时间

2020-08-09

## 目录

0101当谈论面向对象的时候我们到底在谈论什么.md

0102封装抽象继承多态分别可以解决哪些编程问题.md

0103面向对象相比面向过程有哪些优势.md

0104哪些代码设计看似是面向对象实际是面向过程的.md

## 0101当谈论面向对象的时候我们到底在谈论什么.md

1、什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

2、什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

3、如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

4、面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

5、什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

考虑到各个水平层次的同学，并且保证专栏内容的系统性、全面性，我会循序渐进地讲解跟设计模式相关的所有内容。所以，专栏正文的第一个模块，我会讲一些设计原则、设计思想，比如，面向对象设计思想、经典设计原则以及重构相关的知识，为之后学习设计模式做铺垫。

在第一个模块中，我们又首先会讲到面向对象相关的理论知识。提到面向对象，我相信很多人都不陌生，随口都可以说出面向对象的四大特性：封装、抽象、继承、多态。实际上，面向对象这个概念包含的内容还不止这些。所以，今天我打算花一节课的时间，先大概跟你聊一下，当我们谈论面向对象的时候，经常会谈到的一些概念和知识点，为学习后面的几节更加细化的内容做一个铺垫。

特别说明一下，对于今天讲到的概念和知识点，大部分我都是点到为止，并没有展开详细讲解。如果你看了之后，对某个概念和知识点还不是很清楚，那也没有关系。在后面的几节课中，我会花更多的篇幅，对今天讲到的每个概念和知识点，结合具体的例子，一一做详细的讲解。

### 1.1 什么是面向对象编程和面向对象编程语言？

面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。对应地，面向对象编程语言的英文缩写是 OOPL，全称是 Object Oriented Programming Language。面向对象编程中有两个非常重要、非常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在 1960 年，在 Simula 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 Smalltalk 这种编程语言中。Smalltalk 被认为是第一个真正意义上的面向对象编程语言。

1980 年左右，C++ 的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。

以上是面向对象编程的大概发展历史。在刚刚的描述中，我着重提到了两个概念，面向对象编程和面向对象编程语言。那究竟什么是面向对象编程？什么语言才算是面向对象编程语言呢？如果非得给出一个定义的话，我觉得可以用下面两句话来概括。

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲，面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。这里听起来是不是有点绕？不过没关系，我们在后面的第 7 节课中，会详细讲解这个问题。

除此之外，从定义中，我们还可以发现，理解面向对象编程及面向对象编程语言两个概念，其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。不过，关于面向对象编程的特性，也有另外一种说法，那就是只包含三大特性：封装、继承、多态，不包含抽象。为什么会有这种分歧呢？抽象为什么可以排除在面向对象编程特性之外呢？关于这个问题，在下一节课详细讲解这四大特性的时候，我还会再拿出来说一下。不过，话说回来，实际上，我们没必要纠结到底是四大特性还是三大特性，关键还是理解每种特性讲的是什么内容、存在的意义以及能解决什么问题。

而且，在技术圈里，封装、抽象、继承、多态也并不是固定地被叫作「四大特性」（features），也有人称它们为面向对象编程的四大概念（concepts）、四大基石（cornerstones）、四大基础（fundamentals）、四大支柱（pillars）等等。你也发现了吧，叫法挺混乱的。不过，叫什么并不重要。我们只需要知道，这是前人进行面向对象编程过程中总结出来的、能让我们更容易地实现各种设计思路的几个编程套路，这就够了。在之后的课程讲解中，我统一把它们叫作「四大特性」。

### 1.2 如何判定某编程语言是否是面向对象编程语言？

如果你足够细心，你可能已经留意到，在我刚刚的讲解中，我提到，「如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言」。为什么要加上「如果不按照严格的定义」这个前提呢？那是因为，如果按照刚刚我们给出的严格的面向对象编程语言的定义，前面提到的有些编程语言，并不是严格意义上的面向对象编程语言，比如 JavaScript，它不支持封装和继承特性，按照严格的定义，它不算是面向对象编程语言，但在某种意义上，它又可以算得上是一种面向对象编程语言。我为什么这么说呢？到底该如何判断一个编程语言是否是面向对象编程语言呢？

还记得我们前面给出的面向对象编程及面向对象编程语言的定义吗？如果忘记了，你可以先翻到上面回顾一下。不过，我必须坦诚告诉你，那个定义是我自己给出的。实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 1960 年，也就是 60 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。

实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。

比如，我们在面向对象编程的过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了。

实际上，我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。基于此，我们才有了前面的说法，按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。

所以，多说一句，关于这个问题，我们一定不要过于学院派，非要给面向对象编程、面向对象编程语言下个死定义，非得对某种语言是否是面向对象编程语言争个一清二白，这样做意义不大。

### 1.3 什么是面向对象分析和面向对象设计？

前面我们讲了面向对象编程（OOP），实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（OOA）和面向对象设计（OOD）。面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；面向对象设计的英文缩写是 OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。

关于什么是面向对象编程，我们前面已经讲过了。我们现在再来讲一下，什么是面向对象分析和设计。这两个概念相对来说要简单一些。面向对象分析与设计中的「分析」和「设计」这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。不过，你可能会说，那为啥前面还加了个修饰词「面向对象」呢？有什么特殊的意义吗？

之所以在前面加「面向对象」这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。

看到这里，你可能会问，那面向对象分析、设计、编程到底都负责做哪些工作呢？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。今天，我们只是简单介绍一下概念，不展开详细讲解。在后面的面向对象实战环节中，我会用两节课的时间，通过一个实际例子，详细讲解如何进行面向对象分析、设计和编程。

### 1.4 什么是 UML？我们是否需要 UML？

讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 UML（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。

实际上，UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。

要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。

所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。

所以，我这里特别说明一下，专栏中的很多类图我并没有完全遵守 UML 的规范标准。为了兼顾图的表达能力和你的学习成本，我对 UML 类图规范做了简化，并配上了详细的文字解释，力图让你一眼就能看懂，而非适得其反，让图加重你的学习成本。毕竟，我们的专栏并不是一个讲方法论的教程，专栏中的所有类图，本质是让你更清晰地理解设计。

### 黑板墙

今天我们要讨论的话题有两个：1）在文章中，我讲到 UML 的学习成本很高，沟通成本也不低，不推荐在面向对象分析、设计的过程中使用，对此你有何看法？2）有关面向对象的概念和知识点，除了我们今天讲到的，你还能想到其他哪些吗？

在这篇文章中，「面向对象编程」一词多义，不同的场景、语境下，解释不同。文章中没有点到这一点，我这里稍微补充说明一下：1）文章前半部分，面向对象编程指的是一种编程风格或者范式。2）文章后半部分，在讲到面向对象分析、设计、编程的时候，面向对象编程是一种行为。2019-11-11

UML 中定义了类之间的关系：泛化、实现、关联、聚合、组合、依赖，试问下小伙伴们，你们都能搞清楚这几个的区别吗？能否准确的用不同的箭头、图线来画出来吗？即便你能画出来，团队里的小伙伴都能看懂吗？ 不过，关于类之间的关系，我后面会在实战篇中讲到的，但是，我会简化成四种关系，更好理解。2019-11-11

关于 UML 推荐一本书《Java Modeling In Color With UML》和一个神器：[ZenUML - Workspace](https://app.zenuml.com/)。2019-11-11

我理解的是要因场景而异，但是最终的目的都是降低沟通的成本。场景 1：在大多数人对 UML 不是很熟练的情况下，如果采用 UML 来进行沟通，大家在理解上一定会存在 Gap，无形之中会提高学习和沟通的成本，在这种情况下，建议不使用 UML。举个例子，《实现领域驱动》的作者一开始是使用 UML 和领域专家沟通，作者认为 UML 很简单，但是许多领域专家或开发人员并不能很好地理解，最后又出现了 ES（事件风暴）的形式来替代。场景 2：如果需要准确传达设计意图，还是需要 UML 这样的通用设计工具的，目的也是降低沟通的成本。例如，架构师的设计理念想准确传达给工程师，如果使用 UML 工具，可以避免模糊意图，带来额外的沟通成本。敏捷宣言的第一条就是「个体和沟通」高于「流程和工具」。所以要因人而异，因场景而异，在专栏里「很多类图我并没有完全遵守 UML 的规范标准」的策略，我想是一个不错的折中。2019-11-11

对于 UML（统一建模语言），我个人觉得它的作用还是很大的，因为它可以帮助开发人员更好的去分析一个软件的设计过程，通过它的哪些表示的方法吗，会让人的思路更加的清晰，如果是一个软件的负责人，那么使用 UML 来分析问题，我觉得再好不过。软件开发是一个工程问题，就好比盖房子，只有每一步都规划好，分析好，设计好，盖出来的房子才好，总之，我个人觉得值得花时间去学 UML！2019-11-12

确实很多公司使用 UML 的频率比较低，大厂也是这样。另外我自己对 Google 的了解是对代码要求很高，那么代码交付还有文档的要求想必也很高，不知道 Google 公司在文档上面会不会大量使用 UML，如果不用的话，有没有更好的方式或语言来维护高质量的文档。作者回复：好像没有多少人画 uml，文档主要还是聚焦于业务和更上层的架构设计、技术难点说明，实现直接看代码。2019-11-12

我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。曾经面试的时候被问到，领域驱动设计和数据表驱动设计有什么区别，我觉得王老师的这句话总结的很到位。2019-11-11

汇总：1）对 uml，真正掌握确实有难度，很容易忘记，原因可能是自己并没有真正的理解设计这件事，比如说 uml 中是用泛化还是实现不是问题的本质，本质是对于一个特定问题，要如何设计才是尽可能最好的；这中间有两层：将自己的想法转成可表达的设计和将可表达的设计让别人也能理解你的意图，而 uml 就是一种可表达的方式，至于是不是 uml 并不重要；但是 uml 有一套规范，而且知名度高，大家多少都有一些了解，所以就成了一种大家相互沟通的通用语言，所以学 uml 是需要的。我现在是傻傻分不清泛化、实现、关联、聚合、组合、依赖和他们的表达形式。2）想到了编程范式，虽然不是它不是面向对象独有的东西，OO 只是众多范式中的一种。2019-11-11

不是来挑刺的，发现有更好的论述与大家分享。下面内容总结自邵维忠和杨芙清院士的著作《面向对象的系统设计（第 2 版）》，主要看第 20 页，解答了我当年的疑惑：面向对象分析不能简单说是要搞清楚做什么，系统分析！= 需求分析。面向对象分析是指系统分析，它既是对「做什么」问题的进一步明确，也是相当程度上涉及到「怎么做」的问题。重点来了，OOA 产生的系统模型与实现条件无关，OOD 产生的系统模型针对具体的实现平台。2020-05-13

UML 确实很复杂，我认为使用 UML 表达出设计的意思即可，没有必要完全遵从 UML 的规范。比如我目前的工作中，用到的 UML 好像只有类图、时序图、用例图三种。对于类图，也只用到过继承、实现、依赖三种关系。时序图刚刚使用时恨不得将每个类的每个方法的调用关系都画出来，结果不仅使得时序图看上去很复杂，连自己过段时间再看也觉得太复杂了，结果是辛苦半天却事倍功半，后来时序图也是越画越简单，只要能表达出调用关系即可。2020-02-26

## 0102封装抽象继承多态分别可以解决哪些编程问题.md

1、关于封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

2、关于抽象特性。封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

3、关于继承特性。继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。

4、关于多态特性。多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。

这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。

### 2.1 封装（Encapsulation）

首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。

下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用 OOP 的设计思想来详细介绍虚拟钱包的设计实现。

```java
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

从代码中，我们可以发现，Wallet 类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。

```java
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)
```

之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。

1『透明的意思就是不知道细节。』

对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。

封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中「偷偷地」重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。

### 2.2 抽象（Abstraction）

讲完了封装特性，我们再来看抽象特性。封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作「接口类」而不是「接口」。之所以这么做，是因为「接口」这个词太泛化，可以指好多概念，比如 API 接口等，所以，我们用「接口类」特指编程语言提供的接口语法。对于抽象这个特性，我举一个例子来进一步解释一下。

```java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。

之所以这么说，那是因为，类的方法是通过编程语言中的「函数」这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。

除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供「函数」这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的「特异性」，有时候并不被看作面向对象编程的特性之一。

抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？

实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl ()，那即便内部存储方式修改了，我们也不需要修改命名。

### 2.3 继承（Inheritance）

学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 <。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？

继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看「父类、父类的父类……」的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。

所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到「多用组合少用继承」这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。

### 2.4 多态（Polymorphism）

学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。

```java
public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。1）第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。2）第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。3）第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。

1『醍醐灌顶，多态对应于「子类替换父类」，哈哈。（2020-07-30）』

对于多态特性的实现方式，除了利用「继承加方法重写」这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码。

```java
public interface Iterator {
  String hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。

具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。

刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。我们还是先来看一段代码。这是一段 Python 代码。

```py
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。

2『实现多态的 3 个手段，基于继承、基于接口、基于 duck-typing，多使用后两种。做一张术语卡片。』——已完成

多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？

多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator 的例子）。在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print (Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。

### 黑板墙

1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？

争哥对面向对象的总结完美符合 What/How/Why 模型，我按照模型作下梳理。1）封装：隐藏信息，保护数据访问；暴露有限接口和属性，需要编程语言提供访问控制的语法；提高代码可维护性、降低接口复杂度、提高类的易用性。2）抽象：隐藏具体实现，使用者只需关心功能，无需关心实现；通过接口类或者抽象类实现，特殊语法机制非必须。提高代码的扩展性、维护性，降低复杂度，减少细节负担。3）继承：表示 is-a 关系，分为单继承和多继承；需要编程语言提供特殊语法机制。例如 Java 的「extends」，C++ 的「:」；解决代码复用问题。4）多态：子类替换父类，在运行时调用子类的实现；需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing；提高代码扩展性和复用性。3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性、易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。2019-11-14

Java 不支持多重继承的原因。多重继承有副作用：钻石问题（菱形继承）。假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从 JDK1.8 之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。2019-11-13

封装就是让代码遵守开闭原则的重要手段。当调用类，关注过多实施类的细节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处。

再乱想一下，人体，不就是最好的的封装么，给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。

抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。通常借 interface 和 abstract class 来实现抽像这一特性。当 implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。

个人理解：（抽象处理的复杂度是人月神话里描述的本质复杂度（Essential Complexity），也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节）。再瞎想一下，抽像是将很多的知道点给封装起来了（encoding 成为一个模型），归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足 sru）, 然后通过合理的 ood，去调用或运行时 create 具体的子类对象，去实现。拜抽象所赐，一种各有分工，又能有序协同的场景就出来了。其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。（套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）

继续用来表示类之间是 is -a 关系。猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄。有些语言单继续，有些多继承。

意义和解决问题。1）符合认知美感 。2）减少重复 coding。问题：重要隐患，父子类，大量方便藕合。个人理解：继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。再者复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。一但重了，就往往产生大量的不必要的负担。我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。基于职责太重这事，我是很反感用多重继续的。需要啥，再组合一个类多好。多关联一个类，死不了人的。搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的。

1『需要啥，再去组合一个类。』

多态。（个人觉得 oo 中最有趣的一块）多态指子类替代父类。三种语法机制。（父可以）实现多态，除继续外，还有利用接口类语法，duck-typing。个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。于是支持这种把事搞活的套路出来。2019-11-14

c 语言通过结构体来实现封装，只是 c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外 C 中通过 void*+ 结构体 + 函数指针也是可以实现多态的。Linux 内核代码好多都是用了面向对象编程思想。C++ 中引入 public protected private 关键字来进行访问控制权管理。C++ 中没有 Java 中的 interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的 Java 中的接口类的。C++ 是直接支持多继承的，但这个特性也被好多人诟病。2019-11-13

JavaScript 不支持多继承，多继承理论上都存在「菱形问题」，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法 add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时就会出问题，不知道调用哪个方法了。理论上是可以通过 Mixin 的方式来实现多继承。通过一些「合并」算法来「部分」解决「菱形问题」。参考 [JavaScript 中的多继承 - 前端 - 掘金](https://juejin.im/entry/5ac46b6c5188255570063b71)。

3『0121附件JavaScript中的多继承.md

JavaScript 很容易模拟一个「类」，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态。从最初去模拟一个「类」，到 ES5 提供更便捷的原型操控 API，到 ES6 中提供更多「类」相关的关键字，都是在帮我们减小 JavaScript 中面向对象的使用成本。

虽然 JavaScript 中的「继承」并不是真正的继承，「类」也不是真正的「类」，相比 Java 肯定还有很多实现不了的地方，比如 abstract class、Interface 等，只能通过一些 tricky 的办法去模拟。因此 JavaScript 中所谓的「继承」，是为了方便程序员用面向对象的方式来组织代码。

为什么不建议继承。说了那么多，笔者的体会是不要想着继承，不要想着继承，不要想着继承。JavaScript 本身就不是面向对象的语言，干嘛要让它做它不擅长的事情。虽然语法糖已经提供了「类」的支持，那是照顾有面向对象想法的人，但它本质上不同于其他语言中的继承。不要把他人的宽容当作放任的理由，能模拟继承就不错了，就别再惦记「多继承」了。

再回过头来想一想，我们为什么需要继承？继承是一种强耦合关系，到底是否有必要用继承，可以考虑下在应用场景中是否需要用父类型去接收子类型的实例，即子类向父类的向上转型。在 JavaScript 中不会出现这样的需求，应该更多使用组合的方式以代替继承，以及函数式编程也许是更好的方案。

本文从 JavaScript 语言机制出发，回顾了随着语言的进步，「类」与「继承」在 JavaScript 中变得越来越方便。然后讨论了「多继承」时需要考虑的问题，介绍了 Method Resolution Order（MRO）和 C3 算法，并尝试在 JavaScript 中模拟「多继承」。然而，JavaScript 本质上不存在「类」的概念，也不存在真正意义上的继承。这种通过 prototype 模拟出来的「多继承」必然不会太完美，体验上比原生支持继承的语言要差的多。因此不要想着多继承，JavaScript 中也不建议频繁使用继承。

』

JavaScript 支持封装、抽象、继承、多态。封装 ES6 的话，通过 public protected private 等关键字来实现，ES5 的话通过「函数作用域」，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。抽象可以通过 this 指针和原型链的形式来实现。继承通过原型链来实现，或者说基于封装的特性来实现。多态通过原型链的方式，子类覆写父类的方法来实现。2019-11-15

Python 相关：1）抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量、函数、类、模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python 主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。2）封装：Python 不支持严格意义上的封装，没有 private、protected 等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时 Python 里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是 Python 被吐槽的地方吧，大型项目约束力不够。3）继承：Python 支持多重继承，主要是因为它没有类似于 Java 的「接口类」的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。4）多态：Python 的多态就是鸭子类型了，鸭子类型的背后是所谓「协议」，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和 Java 中实现了 Iterator 接口一样。2019-11-13

请问 c++ 的 template 算不算 duck-typing？ 比如定义一个模版，A\<T>，用到函数 T.Load()。然后有类 B 和 C 都有成员函数 Load()。那么都可以通过使用 A\<B> 和 A\<C> 来使用模版，而 B、C 之间不需要继承关系。作者回复：从你的描述来看，有点类似的。2019-11-17

Python 是支持多继承的，对于多继承的二义性问题，有一套 MRO（Method Resolution Order）机制来解决，简单说就是排序。目前是采用 C3 算法，对继承关系建树后，使用拓扑排序得到序列；在 python2.2 之前也有用 DFS 去获取继承序列，但 DFS 会出现继承不到子类对于父类的重写，而后更新为 C3 算法，解决了本地优先级及单调性的问题。2019-11-12

Python 支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python 使用了 C3 算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用 funcitonname.\_\_mro\_\_可以查看调用顺序。对问题二，python 在子类重写方法时，使用 super().methodname() 语句，super 本质上是一个类，内部记录着 MRO 信息，也是用 C3 算法保证一个类只会被搜寻一次。2019-11-15

最近在探索 DDD 的时候有个问题，当涉及 db 或 api 时该怎么设计。比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用 api，那这个 api 需要这个账户类持有么？那每次创建对象还要 set 进去？感觉不是很舒服。作者回复：感觉还是一种数据驱动或者 db 驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db 中数据的读和存只是很小的一部分。2019-11-15

Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: Class B，对多态的支持是子类重写父类的方法。2019-11-14

ava 不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照「接口 -> 抽象类 -> 实现类 -> 拓展实现类」这样的模式，这样设计出来的一组类是与某一个「业务」强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。2019-11-13

## 0103面向对象相比面向过程有哪些优势.md

在上两节课中，我们讲了面向对象这种现在非常流行的编程范式，或者说编程风格。实际上，除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前还没有被广泛接受。在专栏中，我不会对函数式编程做讲解，但我会花两节课的时间，讲一下面向过程这种编程范式。你可能会问，既然面向对象已经成为主流的编程范式，而面向过程已经不那么推荐使用，那为什么又要浪费时间讲它呢？

那是因为在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。

所以，我打算详细对比一下面向过程和面向对象这两种编程范式，带你一块搞清楚下面这几个问题（前三个问题我今天讲解，后三个问题我放到下一节课中讲解）：1）什么是面向过程编程与面向过程编程语言？2）面向对象编程相比面向过程编程有哪些优势？3）为什么说面向对象编程语言比面向过程编程语言更高级？4）有哪些看似是面向对象实际是面向过程风格的代码？5）在面向对象编程中，为什么容易写出面向过程风格的代码？6）面向过程编程和面向过程编程语言就真的无用武之地了吗？

### 3.1 什么是面向过程编程与面向过程编程语言？

如果你是一名比较资深的程序员，最开始学习编程的时候，接触的是 Basic、Pascal、C 等面向过程的编程语言，那你对这两个概念肯定不陌生。但如果你是新生代的程序员，一开始学编程的时候，接触的就是面向对象编程语言，那你对这两个概念可能会比较不熟悉。所以，在对比面向对象与面向过程优劣之前，我们先把面向过程编程和面向过程编程语言这两个概念搞清楚。

实际上，我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。还记得我们之前是如何定义面向对象编程和面向对象编程语言的吗？1）面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。2）面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，我给出下面这样的定义。1）面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。2）面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

不过，这里我必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。

定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&age&gender（比如，小王&28& 男）。我们希望写一个程序，从 users.txt 文件中逐行读取用户信息，然后格式化成 name\tage\tgender（其中，\t 是分隔符）这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted\_users.txt 中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 C 语言这种面向过程的编程语言来编写的。

```c
struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
}
```

然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 Java 这种面向对象的编程语言来编写的。

```java
 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。看完这个例子之后，你可能会说，面向对象编程和面向过程编程，两种风格的区别就这么一点吗？当然不是，对于这两种编程风格的更多区别，我们继续往下看。

1『面向对象，数据和方法绑定在一个类里。』

### 3.2 面向对象编程相比面向过程编程有哪些优势？

刚刚我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？

#### 3.2.1 OOP 更加能够应对大规模复杂程序的开发

看了刚刚举的那个格式化文本文件的例子，你可能会有这样的疑问，两种编程风格实现的代码貌似差不多啊，顶多就是代码的组织方式有点区别，没有感觉到面向对象编程有什么明显的优势呀！你的感觉没错。之所以有这种感觉，主要原因是这个例子程序比较简单、不够复杂。

对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。

面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。

除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

你可能会说，像 C 语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。

实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。

#### 3.2.2 OOP 风格的代码更易复用、易扩展、易维护

在刚刚的那个例子中，因为代码比较简单，所以只用到到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象编程的优势其实并没有发挥出来。

面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？还记得我们在上一节课中讲到的封装、抽象、继承、多态存在的意义吗？我们再来简单回顾一下。

首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。

其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。

最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了「对修改关闭、对扩展开放」的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。

1『几个关键点：1）多态是子类可以替换父类。2）新的功能可以通过增加一个子类覆写掉原来父类里的方法，然后子类替换父类，这样就实现了不在源代码上修改而是通过新增代码实现新功能，也就是「开闭原则」，对修改关闭对扩展开放。终于把「多态 -> 开闭原则」的逻辑链打通了，哈哈。3）利用多态，子类替换父类，可以把不同的类对象传递给相同的方法，从而执行不同的逻辑代码。这应该就是「组合代替 if 句」。2020-08-09』

所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。

#### 3.2.3 OOP 语言更加人性化、更加高级、更加智能

人类最开始跟机器打交道是通过 0、1 这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。

从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！

跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越「远」，离我们人类越「近」，越「智能」。

这里多聊几句，顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加「智能」的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。

### 黑板墙

在文章中我讲到，面向对象编程比面向过程编程，更加容易应对大规模复杂程序的开发。但像 Unix、Linux 这些复杂的系统，也都是基于 C 语言这种面向过程的编程语言开发的，你怎么看待这个现象？这跟我之前的讲解相矛盾吗？

使用任何一个编程语言编写的程序，最终执行上都要落实到 CPU 一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU 看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。

C 语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C 语言用数组 char a[8]，经过编译以后变成了（基地址＋偏移量）的方式。对于 CPU 来说，没有运算比加法更快，它的执行效率的算法复杂度是 O (1) 的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C 语言是极好的选择。

C 语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了 OOP 等更「智能」的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节，占用了更大的内存空间，占用了更多的 CPU 运算。从这个角度看，OOP 这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核 600MHz 为主流，运行 Android 系统点击一个界面需要 2 秒才能响应，那我们现在用的大部分手机程序绝对不是使用 JAVA 开发的，Android 操作系统也不可能建立起这么大的生态。2019-11-16

我们以历史的时间线看看这两种语言的演进过程。1）1969 年贝尔实验室提出 Unix 操作系统。2）1972 年贝尔实验室的 Dennis Ritchie 开发 C 语言。3）1973 年他用 C 语言重写了 Unix。4）1991 年 Linus Torvalds 提出 Linux。另外一条线面向对象语言的发展：1）1972 年第一个面向对象的编程语言是 Simula 发布。2）1996 年，Java1.0 发布，流行的主要原因是 jvm，Write Once, Run Anywhere（编写一次，到处安装 JRE）。

从时间上看，面向对象概念的提出晚于面向过程。C 语言因商业应用成熟要比面相对象的编程语言早。C 语言的流行主要是因为 Unix 和 Linux 操作系统的实现基于 C 语言。类 Unix 系统可以运行在服务器，嵌入式设备，移动设备上。一个东西的好坏要综合考虑：面向过程和面向对象各有各的优缺点。一门编程语言的提出是为了解决某些特定的问题。面向对象和面向过程在应用上各有各的位置。2019-11-15

操作系统虽然是用面向过程的 C 语言实现的 但是其设计逻辑是面向对象的。C 语言没有类和对象的概念，但是用结构体（struct）同样实现了信息的封装，内核源码中也不乏继承和多态思想的体现。面向对象思想，不局限于具体语言。2019-11-15

读过 linux 内核源码和 python 解释器源码的应该都明白，所谓面向过程的 C 语言照样可以实现面向对象的思想，有很多设计都是非常优雅的，付出的代价并不高，我并不认为面向对象编程语言做相同的事情付出的代价会更低。编程思想、设计模式跟语言是没有关系的，编程思想和设计模式是指导我们编程的，而编程语言只是一种实现工具罢了。2019-11-17

操作系统的源码一直没读过，但我认为如此复杂的系统设计，（站在现在的时间点）用面向对象风格（或实现相同目的其他方式）来编写代码是更合适的，而且从 Linux 的模块化分来看，推测有类似的实践。老话说，机器能读懂所有代码，但人不一定。对于机器来说，每一次业务调用流程都是序列化的，机器并不在乎面向对象，但人在乎。正如本文所讲，编程语言离机器越来越远，离人越来越近。为了迁就人，我们使用了执行效率更低的语言，有了更多的中间环节，占用了更大的内存空间，换来的是这个行业的蓬勃发展以及让人类的便捷生活和能力延伸。2019-11-15

老师举的文件那个例子，使用面向对象编程那个，不是封装了函数，用函数对操作过程进行了抽象了吗，为什么老师说没有用到封装、抽象这些特性？C 语言虽然是面相过程语言，但是面向过程语言也可以写面向对象的，另外，C 语言更贴近底层一些，写操作系统的话还是有性能上的优势。作者回复：你指出的这点很好。关于封装，有两种理解，一种是狭义的面向对象特性：封装是一种信息隐藏，需要把数据和方法放到一起，而 c 语言实现的代码，数据和方法是分离的。封装的另一种广义的理解，可以包含你指的封装函数。抽象实际上我们前面章节中也讲到过，比较没有特异性，有的时候不看做面向对象的特性。2019-11-15

我理解 C++ 的出现主要是为了 C 语言中的泛型编程问题。而 Java 的出现是为了抽象对计算机的依赖，更专注于业务。对于计算机底层 C/C++ 可能更适合，而 C 的对于程序员来说自由度是最大的。再看 Linux 的发展，1991 年，林纳斯基于 Unix 的编写的，可能他更善于这个语言，他编写 git 的时候也是用的 C。Unix 选择 C 也是由于自己擅长的原因。2019-11-15

OOP 更能应付复杂流程的程序开发，自己是深有体会。去年做了一个功能，第一版着急上线，就照着流程图翻译，最后就是一组顺序执行的方法集。if 分支特别多。上线后有空，自己重构了一版。这次是翻译了泳道图：data\_provider、rule\_filter\_chain、data\_consumer 和 data\_writer。

data\_provider 提供 3 种类型的数据。每种类型数据有 2 种规则。匹配规则后，会有一些数据处理，如与订单绑定、返佣记录等。最后是将这些数据持久化到数据库。处理过程还使用了多态特性，因此在调用 rule\_filter\_chain、data\_consumer、data\_writer 处的代码都特别精简，都是从 Map 获取处理对象，然后直接调用方法。

现在回看，重构时自己关注最多也是思考最多的是每个阶段的类对象，它的职责是什么。如入参是什么，业务逻辑处理，处理后的出参是什么。实现完这些类后，就真的是像搭积木一样将这些类串起来就可以了。就跟文章说的一样：业务建模、翻译需求为类、类之间交互。重构后的代码逻辑清晰了，也更简洁了。整个业务也更容易理解了。但是有一点，重构之后，类文件也增加了挺多。但是相比一个类几百上千行代码，我更喜欢简短的类。适当的增加一些类文件，也是能接受的。2020-01-09

我的理解不矛盾，理由如下：1）操作系统更多的是和硬件打交道，需要考虑到语言本身翻译成机器语言的成本和执行效率，尤其总要。2）如 linux 内核、总线、文件系统网络等的设计，也是具有面向对象过程的思想，很好的支持了常见的文件系统的挂在、内核的升级和对硬件的热插拔、网络等的处理，常见的服务器多数都是 linux，为啥不用 window，我的理解和设计实现有很大的关系，尤其是网络、安全、权限、标准等等。3）linux 操作系统，本身就是一个大的抽象，属于一个硬件和高级软件连接的桥梁。2019-11-16

go 语言的函数式编程算面向过程吗？作者回复：不算，是一种新的编程范式。2020-01-07

老师没讲函数编程，但我看了一下相关的优点，感觉函数式编程的优点是除了继承 oop 的优点外还有并发和无状态这两个特点，而这种特点和现在云服务切合度很高，但现在问题是对人的要求高。2019-11-17

思考，其实用什么语言来做什么软件，和几个方面有关系。1）软件诞生的时代，在它产生的时候，面向对象编程思想不是主要的趋势；2）发布软件的方式，如以开源的方式发布，它的成熟也要和其他开发者的水准相关，在当时的时代，太过超前的思想，没有很多人的参与，也诞生不了出名的软件；3）适用性，操作系统，更多的还是和计算机打交道，虽然思想上面向对象更适合人的思维，但是操作系统这一层，符合计算机思想的编程语言更适用，面向对象编程语言更适合开发应用软件，符合一般程序员的思维，更多的是跟操作系统打交道，等于中间有一种层级的关系。操作系统更像一个抽象的中间层。2019-11-15

面向过程编程范式是先考虑数据和处理数据的函数，函数和数据是分离的，main 函数开始初始化数据调用 func 处理数数据。面向对象编程范式：先根据需求抽象出类，粒度大的名词是类，粒度小的名称划分到类的属性，类的行为是方法，通过数据访问权限 private 和 public 保护属性的可见性和 get、set 方法保护数据的赋值和输出；先抽象出接口不用想实现就可以写代码，抽象出基类用继承实现代码复用。然后再用类「组合」和「依赖」进行搭积木完成现在业务逻辑。同时可以方便的利用多态实现扩展。范式是完成需求的思考过程和组织代码的方式，跟用什么语言关系不是很大。2020-05-11

在思想上：面向对象最重要的优势，他是以解决描述真实世界的需求为出发点的。而面向过程是以命令计算机如何执行为出发点的。所以，面向对象语言相对而言，比面向过程语言解决真实世界的问题效率更高。（当然，对于计算机则不同）

在技术上：面向对象晚于面向过程诞生，吸收并加强了前者的优秀特性，如抽象，面向过程的抽象是方法，函数的抽象。而面向对象则通过「类」这一特性提供更高纬度的抽象。可以帮助开发人员，先将复杂问题拆解为小的模块问题，在将主要的问题明确后，在专注于业务细节。

面向对象还基于类这一概念，提供了封装特性，将方法和数据绑定，实现了将数据访问权限控制，提高了数据安全性和可维护性。面向对象的继承概念还是要依托于类的概念，可以将多处的相同代码归集到一个类中，在其他要使用的地方通过继承就能获得相同能力。多态，一个函数，可以有多种实现方法。这就像我们生活中，做晚餐这件事，可以做多种做法，煎炒烹炸都行。只有遵照基本的条件就行。2020-05-05

也算是经历了从汇编到 c 到 c++ 再到 java 的过程。确实像作者所说，从偏向机器的思维慢慢过渡到了偏向人类的思维，这似乎也顺应了这个时代的发展潮流。写 c 的时代，我们要非常关注内存的分配，占用，释放，指针是否越界，程序会不会跑飞等问题。现在还记得研究生时候写过一段代码，一运行电脑就自动关机（然而代码的目的不是为了关机！）工作后越来越多的用了 java，有了 jvm，似乎只有在性能调优的时候才会想想堆栈情况，其余时候真的不用再考虑太多，按照业务模块分解功能，专注业务实现就可以了。也因此，程序员越来越高产，门槛也越来越低。然而，知其然而也知其所以然的程序员越来越少了，这样虽然看上去写了不少代码，堆砌了很多新的框架组建，但根基并不牢靠。所以真的需要多一些作者这样的课程，来帮助大家慢下节奏，沉下心多思考。2019-12-23

说白了其实还是要弄清楚 3 点：1）面向对象编程与面向对象编程语言是不是一样的。2）面向过程编程与面向过程编程语言是不是一个东西。3）是不是使用了面向对象语言写出的代码就是面向对象编程 、是不是使用了面向过程语言编程就体现不了面向对象编程的思想。这几点在前几节课讲基础的时候，老师讲的很明白了，在此自己举例子自己总结说明以下：

第一：Java 是一门面向对象的语言，封装、继承、多态、抽象是面向对象语言的特性，当然 Java 在语法上面对这四大特性也很好的支持，但是是不是我们用 Java 写代码了，我们就会面向对象的编程思想了，我感觉不是，在很多 Java 的代码中，完全没有用到这几大特性，因为没用到，所以对开闭、里氏替换、依赖倒置等设计原则没有体现过，反过来讲，我们为什么写代码需要有设计原则，为什么需要有好的设计原则，是因为业务代码的逻辑几乎不会是一成不变的，所以在变化的时候，我们应该变化仅仅需要变化的部分，而不是推倒重来，所以我们需要设计原则来建立基础的模型，需要封装、继承、多态、抽象这些支持设计原则的最基本特性。第二：C 语言是一门面向过程的编程语言，但是使用 C 语言编程的 Unix 系统，我感觉体现了面向对象编程的思想比如 Unix 系统的驱动设计，就是面向对象编程思想的体现。

1『很有感触，一个好的软件必定是随着需求不断在迭代更新的，否者这个软件就没啥价值了。那么就要学会分离关注点，变与不变的东西分割清楚，迭代更新的时候只需要关系「变」的那部分内容，不用全部推倒重新来做。2020-08-09』

最后总结来看：选用什么样的语言来实现产品，来实现业务，跟很多因素有关，个人的能力，接入的快慢，公司的要求等等。境界到了，语言对模型建立的影响应该很小了，这句话不知道说的对不对？因为我还远远没到这个境界，自己认为的。2019-11-16

为什么 Unix、Linux 是使用 C 这种面向过程编程语言开发的？1）历史原因。从二进制指令、汇编语言、面向过程编程语言、面向对象编程语言的发展历程来看，二进制指令和汇编语言由于不具备可移植性，并且不适用于开发大规模复杂程序，而 OOPL 比 POPL 出现得要晚。2）Unix/Linux 具备硬件管理的功能，而硬件运行的特点就是指令化、流程化，这一点与面向过程编程不谋而合。

我对未来编程语言的畅想：更加人性化、更加高级、更加智能，这一定是编程语言的发展方向，现在就已经出现了 AI 助力编程的消息了。对于小争哥所想象的，根据需求规格说明书直接生成代码的编程方式。我觉得有一种方式更容易落地实现。由人类描述代码的设计思路，然后由智能化的编译器生成相应的代码。比如，人类描述 23 种设计模式，然后编译器实现。当然，由于 23 种设计模式只在一些经典问题中才会使用，所以对于一些不需要使用设计模式的编码场景，会需要使用类似的东西进行描述。我把这种编程风格称为面向思路编程。其实，需求规格说明书也是一种表达，但是这种表达太过于接近业务。我不太相信几十年里能够做到。然而，面向思路编程是一种对于具体代码编码的描述，这种描述与业务需求描述无关。2019-11-15

我觉得面向对象是一种思维方式，之前学习 DDD 和 \<Thinking in uml>，吸收到的一点就是拿到业务需求的时候，原来是脑子里面构建出来，并且还要思考业务顺序的前后影响。

```c
if (业务规约 1){
    A do something;
} else if (业务规约 2){
    B do something;
}
```

现在的思维方式是，看到上面的业务描述，拿出本子记录。这个业务里面有 A 对象，有一个功能 say()，哪些数据是归 A 管理的；这个业务里面有 B 对象，有一个功能 hello()，哪些数据是归 B 管理的。所以我觉得面向对象思维，和你用什么语言写是太直接的关系。当然会限制你的实现。比如说虚拟文件系统，我觉得就是面向对象的一种体现，可以支持 ext、fat32 等等，就是一种继承的体现。

有一个问题想问一下老师：目前我接触的项目实体都是贫血模型，虽然分析业务的时候，会努力向面向对象靠近，但是业务代码实现的时候。基本是每个分析的对象，功能包装进一个 service，但是数据还是在贫血实体内。有点类似 DDD 的聚合根（和实际 DDD 思想差的比较远），但是所有实体方法都是以服务的形式提供。但是一下子换成充血模型的话，对团队整体代码和一些跨 n 个实体的业务方法，实现起来又有问题。也没太想明白这个阶段怎么样比较合适。想听听老师是怎么看待这个问题的。2019-11-15

操作系统底层虽然是使用面向过程编程语言开发的，但是面向对象的思想却深入其中。像是 Linux Kernel，它又分成各个子系统，同时又有分离、分层的概念。比如开发一个设备的驱动，只需要分配一个对应的核心层的结构体，对结构体的成员做出该设备特定的设置即可，而设备驱动的很多方法都可以使用核心层的代码；这个过程其实就类似于面向对象编程的继承。可见对于复杂的系统的开发，面向对象的风格还是远胜于面向过程的。操作系统底层为何需要使用 C 语言，我觉得一方面是基于其效率考虑，另一方面则是为了增强在不同体系架构之间的可移植性吧，因为不同的体系架构其汇编指令是不同的，而 C 代码在底层可以很好的和汇编代码结合。2019-11-15

## 0104哪些代码设计看似是面向对象实际是面向过程的.md

你要掌握的重点内容是三种违反面向对象编程风格的典型代码设计。1）滥用 getter、setter 方法。在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。2）Constants 类、Utils 类的设计问题。对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。3）基于贫血模型的开发模式。关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。

上一节课，我们提到，常见的编程范式或者说编程风格有三种，面向过程编程、面向对象编程、函数式编程，而面向对象编程又是这其中最主流的编程范式。现如今，大部分编程语言都是面向对象编程语言，大部分软件都是基于面向对象编程这种编程范式来开发的。不过，在实际的开发工作中，很多同学对面向对象编程都有误解，总以为把所有代码都塞到类里，自然就是在进行面向对象编程了。实际上，这样的认识是不正确的。有时候，从表面上看似是面向对象编程风格的代码，从本质上看却是面向过程编程风格的。

所以，今天，我结合具体的代码实例来讲一讲，有哪些看似是面向对象，实际上是面向过程编程风格的代码，并且分析一下，为什么我们很容易写出这样的代码。最后，我们再一起辩证思考一下，面向过程编程是否就真的无用武之地了呢？是否有必要杜绝在面向对象编程中写面向过程风格的代码呢？

### 4.1 哪些代码设计看似是面向对象，实际是面向过程的？

在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。我也希望你通过对这三个典型例子的学习，能够做到举一反三，在平时的开发中，多留心一下自己编写的代码是否满足面向对象风格。

#### 4.1.1 滥用 getter、setter 方法

在之前参与的项目开发中，我经常看到，有同事定义完类的属性之后，就顺手把这些属性的 getter、setter 方法都定义上。有些同事更加省事，直接用 IDE 或者 Lombok 插件（如果是 Java 项目的话）自动生成所有属性的 getter、setter 方法。当我问起，为什么要给每个属性都定义 getter、setter 方法的时候，他们的理由一般是，为了以后可能会用到，现在事先定义好，类用起来就更加方便，而且即便用不到这些 getter、setter 方法，定义上它们也无伤大雅。

实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话。

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它们的 getter、setter 方法。对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？

我们先来看前两个属性，itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。

而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。

看完了前两个属性，我们再来看 items 这个属性。对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上并不是。

对于 itemsCount 和 totalPrice 这两个属性来说，定义一个 public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：

```java
ShoppingCart cart = new ShoppCart();
...
cart.getItems().clear(); // 清空购物车
```

你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体代码实现如下：

```java
public class ShoppingCart {
  // ...省略其他代码...
  public void clear() {
    items.clear();
    itemsCount = 0;
    totalPrice = 0.0;
  }
}
```

你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart 类不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？

如果你熟悉 Java 语言，那解决这个问题的方法还是挺简单的。我们可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。

```java
public class ShoppingCart {
  // ...省略其他代码...
  public List<ShoppingCartItem> getItems() {
    return Collections.unmodifiableList(this.items);
  }
}

public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                          implements List<E> {
  public boolean add(E e) {
    throw new UnsupportedOperationException();
  }
  public void clear() {
    throw new UnsupportedOperationException();
  }
  // ...省略其他代码...
}

ShoppingCart cart = new ShoppingCart();
List<ShoppingCartItem> items = cart.getItems();
items.clear();//抛出UnsupportedOperationException异常
```

不过，这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。听起来有点绕，看看下面这几行代码你就明白了。

```java
ShoppingCart cart = new ShoppingCart();
cart.add(new ShoppingCartItem(...));
List<ShoppingCartItem> items = cart.getItems();
ShoppingCartItem item = items.get(0);
item.setPrice(19.0); // 这里修改了item的价格属性
```

这个问题该如何解决呢？我今天就不展开来讲了。在后面讲到设计模式的时候，我还会详细地讲到。当然，你也可以在留言区留言或者把问题分享给你的朋友，和他一起讨论解决方案。

getter、setter 问题我们就讲完了，我稍微总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

#### 4.1.2 滥用全局变量和全局方法

我们再来看，另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？如果你是用类似 C 语言这样的面向过程的编程语言来做开发，那对全局变量、全局方法肯定不陌生，甚至可以说，在代码中到处可见。但如果你是用类似 Java 这样的面向对象的编程语言来做开发，全局变量和全局方法就不是很多见了。

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

1『静态变量和静态方法，分离了数据和方法，破坏了封装特性，是典型的面向过程风格。』

在刚刚介绍的这些全局变量和全局方法中，Constants 类和 Utils 类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。我们先来看一下，在我过去参与的项目中，一种常见的 Constants 类的定义方法。

```java
public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
```

在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。

首先，这样的设计会影响代码的可维护性。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。

其次，这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。

最后，这样的设计还会影响代码的复用性。如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。

那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴。第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。

1『赞同作者给的第二种方案。』

讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我想问你这样一个问题，我们为什么需要 Utils 类？Utils 类存在的意义是什么？希望你先思考一下，然后再来看我下面的讲解。

实际上，Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？

我们在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。

既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。

在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个 Utils 类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。

除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。

#### 4.1.3 定义数据和方法分离的类

我们再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁会这么写呢？实际上，如果你是基于 MVC 三层结构做 Web 方面的后端开发，这样的代码你可能天天都在写。

传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。

实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢？关于这个问题，我今天不打算展开讲解。因为它跟我们平时的项目开发结合得非常紧密，所以，更加细致、全面的讲解，我把它安排在面向对象实战环节里了，希望用两节课的时间，把这个问题给你讲透彻。

在面向对象编程中，为什么容易写出面向过程风格的代码？我们在进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？

你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。

除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。

面向过程编程及面向过程编程语言就真的无用武之地了吗？前面我们讲了面向对象编程相比面向过程编程的各种优势，又讲了哪些代码看起来像面向对象风格，而实际上是面向过程编程风格的。那是不是面向过程编程风格就过时了被淘汰了呢？是不是在面向对象编程开发中，我们就要杜绝写面向过程风格的代码呢？

前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？

除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。

不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。

### 黑板墙

今天课堂讨论的话题有两个，你可以选择一个熟悉的来发表观点。1）今天我们讲到，用面向对象编程语言写出来的代码，不一定是面向对象编程风格的，有可能是面向过程编程风格的。相反，用面向过程编程语言照样也可以写出面向对象编程风格的代码。尽管面向过程编程语言可能没有现成的语法来支持面向对象的四大特性，但可以通过其他方式来模拟，比如在 C 语言中，我们可以利用函数指针来模拟多态。如果你熟悉一门面向过程的编程语言，你能聊一聊如何用它来模拟面向对象的四大特性吗？2）看似是面向对象实际上是面向过程编程风格的代码有很多，除了今天我讲到的这三个，在你工作中，你还遇到过哪些其他情况吗？

不想往下看的请看第一句就好：贫血模型流行的原因是，实现简单和上手快。具体解释慢慢看，贫血模型的开发模式为什么会流行？1）实现简单。Object 仅仅作为传递数据的媒介，不用考虑过多的设计方面，将核心业务逻辑放到 service 层，用 Hibernate 之类的框架一套，完美解决任务。2）上手快。使用贫血模式开发的 web 项目，新来的程序员看看代码就能「照猫画虎」干活了，不需要多高的技术水平。所以很多程序员干了几年，仅仅就会写 CURD。3）一些技术鼓励使用贫血模型。例如 J2EE Entity Beans，Hibernate 等。总结：各种模型的好坏讨论一直不断，企业需要的是使用合适的技术把任务完成，从这个角度来说当下管用模型就是好模型。当然我们也要持开放的心态接受新的技术和思想，并结合业务的实际需要选择合适的技术。

概念解释：贫血模型（Anemic Domain Model 由 Matin Fowler 提出）又称为失血模型，是指 domain object 仅有属性的 getter/setter 方法的纯数据类，将所有类的行为放到 service 层。原文他是这么说的「By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring.」他的原文我放上来了，英文好的同学可以看看：[AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)。我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don't know why this anti-pattern is so common）。2019-11-18

1、用 shell 实现自动化脚本做的服务编排，一般都是面向过程，一步一步的。而 k8s 的编排却是面向对象的，因为它为这个顺序流抽象出了很多角色，将原本一步一步的顺序操作转变成了多个角色间的轮转和交互。

2、从接触 ddd 才走出 javaer 举面向对象旗，干面向过程勾当的局面。所谓为什么「充血模型」不流行，我认为不外呼两个。1）规范的领域模型对于底层基础架构来说并不友好（缺少 set、get），所以会导致规范的领域模型与现有基础架构不贴合，切很难开发出完全贴合的基础架构，进而引深出，合理的业务封装却阻碍关于复用通用抽象的矛盾。2）合理的业务封装，需要在战略上对业务先做合理的归类分割和抽象。而这个前置条件很少也不好达成。进而缺少前置设计封装出来的「充血模型」，会有种四不像的味道，反而加剧了业务的复杂性，还不如「贫血模型」来得实用。事实上快节奏下，前置战略设计往往都是不足的，所以想构建优秀的「充血模型」架构，除了要对业务领域和领域设计有足够的认知，在重构手法和重构意愿上还要有一定讲究和追求，这样才能让项目以「充血模型」持续且良性的迭代。

3、「充血模型」相对于「贫血模型」有什么好处？从我的经验来看，可读性其实可能「贫血模型」还好一点，这也可能有思维惯性的原因在里面。但从灵活和扩展性来说「充血模型」会优秀很多，因为好的「充血模型」往往意味着边界清晰（耦合低），功能内敛（高内聚）。这一块老师怎么看？2019-11-18

文中没有举封装或抽象不完全的例子，这里举一个。比如一个实现某种业务需求（如与某种类型设备通讯的应用协议）的 tcp 或 udp 服务器；实例化后还需要自己管理其协议相关的就绪状态（ready 属性）；使你不得不对其再封装一层，并抽象其连接、断开等方法使其自动进行就绪状态的管理；每个继承都这么封装一遍，就会有大量重复的代码，而且其实类的实例化者或继承者并不需要也不应该关心就绪状态的管理，所以没有达到就绪状态管理的封装。这就是一种不完全的封装。2019-11-18

个人觉得，MVC 这种框架模式本质上与面向对象并不冲突。当我们在讨论面向对象的时候，我们究竟应该怎样去定义一个对象，究竟什么才能被我们看成是对象，是不是只有像某种物体，比如说一只鸟或者一只狗我们才能去把他定义为对象？我认为，MVC 里面的三个部分 Model 、Controller 、View 我们都能把他们单独的看成一个对象，比如说 Model，本来它是数据单元，但是如果我们把他看做一个对象的话，里面存储的数据不就是我们对象里的属性么，而对于数据的二次加工处理等等操作不就是对象里的方法么？同理，对于 View 而言，里面小的 view 组件或者是其他的 view 不就是我们对象里面的属性，而对于不同的 view 组件或其他 view 的组合或者其他的处理操作不就是对象里面的方法么？所以说，不必死抠定义，数据就一定要和业务逻辑组成一个类云云。我们最后写出来的代码的目的就是，1）要解决问题；2）代码有可扩展性，可读性；3）代码解耦。作者回复：说的没错，MVC 跟贫血模型没直接关系。我后面在实战篇会讲到的。你的观点我基本都赞同。2019-11-18

先说问题 2：看似面向对象实际面向过程的例子真是数不胜数了，工作语言 C/C++，90% 是 C++, 大体上老师在文中已经提到了，其他的我暂时也没想起来，但是滥用面向对象继承特性的代码我真是看到了太多。问题 1：C 中可以用 struct 来实现 class，只是访问控制权限都是 public。类中的成员函数可以通过指向操作结构体的函数指针来实现，实现封装，需要绑定数据、函数、函数指针。可以创建函数指针表，构造函数设置函数指针指向正确的操作函数，函数指针表作为对象访问函数的接口。操作结构体的这些函数（成员函数）不像 C++ 中能直接访问数据成员，需要显示的传递操作对象给成员函数。1）继承：在派生类中维护一个基类对象的指针。这样派生类可以访问基类对象的数据。2）多态：在基类中维护一个派生类对象的指针。这样基类可以访问派生类对象的数据。C++ 中的多态，有一个对象销毁的问题。基类的析构函数必须是虚函数。在 C 中，这可以通过使基类的删除函数指针指向派生类的删除函数，因为派生类的删除函数清楚派生类的数据和基类的数据。2019-11-18

思考汇总：1）现在因为使用封装好的框架，没有提供 set 方法，类的序列化会成为一个问题。2）从理论上来说，数据和逻辑应该放在一起，但是数据的赋值往往可能依赖其他的 service 提供的数据，如果这样的话数据属性和纯粹依赖的 service 就会导致一个类的成员属性特别的多。3）对于一个具体现实对象而言，不同场景下可能关心的字段稍微有些不一样，对于此又该怎么处理呢？多个小对象，他们之间有无相关关系，有的话如何阐述，还是全部赋值完毕，都完整返回。当然可能具体场景具体分析，那是否有一个稍微通用的指导纲领。2019-11-18

3『作者的微信：wangzheng0822。』

习惯了从前端的参数直接使用 BeanUtils.copyProperties 映射到具体实体类，如果不直接提供 set 方法，有啥好的方法去组装数据呢。作者回复：给类本身提供一个 copy 方法呢。2019-11-21

思考：1）get set 这个很好理解，但是我有很多疑问，比如有的属性理论上来讲不该添加 set 方法，那我怎么对他进行属性拷贝？比如两个 vo 进行拷贝属性值，还有作为接口参数，spring 又怎么给他赋值？2）看完贫血模式那个知识点后，我懵了，我甚至不知道怎么才能写出面向对象的代码了，如果数据和业务不分离的话，那比如我多个业务接口需要同一份数据，难道要定义多份吗？我有点懵了。作者回复：1）并没有说一定不能定义 set 方法，文章中说不要滥定义用不上的 set 方法。2）多个业务接口需要同一份数据？这个怎么理解呢？2019-11-18

添加对象公有方法方法要注意两点：1）避免过多的访问内部数据的方法，只有在确定需要的时候再增加。2）避免返回内部引用（数组，对象，方法等），这些引用会无意间暴露修改内部状态的方法，导致数据不一致，也违反封装原则。这种情况如果数据量不大，返回一个拷贝对象即可。如果有效率考量，就要具体问题具体分析。2019-11-18

对于用 C 来模拟面向对象，曾经看到过一篇非常好的文章[C 语言：春节回家过年，我发现只有我没有对象](https://mp.weixin.qq.com/s/2ivQ9hcRvZnhk89jzAppSg)。2020-02-02

老师这一讲，解我多年困惑。仍有一事困惑：前端传数据到后端，我要是不定义一个开放了所有属性的 POJO，那么数据如何反序列化成类呢？作者回复：前端跟后端交互的那个叫 dto 可以定义为之包含数据的类，后面会讲到。2019-12-02

C 语言可以通过结构体加函数，函数第一个参数为该结构体指针的方式来实现方法和数据结构结合，但无法实现访问权限控制。通过在结构体中包含结构体的方式可以实现继承。通过函数指针实现多态。每个类有一个共同的虚函数表，每个对象都有一个指向虚函数表的指针，通过指向不同的虚函数表来实现多态。

get、set 方法老师以前在讲的时候，也不讲为啥，上来就是直接设置。现在才知道封装的作用。工具类、配置类的细分对后期维护起来方便多了，有时候把控适合细分的度挺重要的，要多些项目经验会把控好这个度。2019-11-18

面向对象是把数据和方法打包，隐藏内部状态，暴露外部需要的方法。这种把数据和方法并列处理的方法也有一个弊端，那就是很多情况下，数据和方法的体量并不对等，例如 String，数据很少，对应的方法却很多，如果把数据和方法放到一个类里，势必方法数目巨大，数据基本淹没在方法中，而且对这么多方法不分类来处理也带来维护负担，这和全局方法过多是一个道理。Kotlin 语言采用的是 extension methods 来处理这种情况，简而言之就是数据被多个方法群调用，然后调用的时候可以根据 import 来分类。请问王老师，还有其他更好的方法来处理这种情况吗。2019-11-18

我是 technical animator 转学 untiy3D C# 编程的，选这门课程作为提高程序设计的能力途径。之前项目里经常用多态做扩展，算是典型面向对象应用。但是采用的 MVC 构建在数据方面又类似贫血模型的面向过程风格。现在 Unity 官方开始革新的 DOTS 技术 ，又开始鼓励大家从面向对象改成面向数据编程，某种程度似乎又回到了面向过程的一些精神。2020-06-20

接手一个项目，分享判断全部写的 if else ，花了一整天改成策略模式了。2020-05-05

数据处理相关的程序，比如数据分析，数据预处理，数据清洗，etl 这些，就是拿到一批数据先干什么，然后再干什么，最后输出数据，这是典型的需要流程化思考模式的需求。面向过程编程和函数式编程更加适合这种场景。为什么是函数式呢，因为所谓的「以算法为主」，就可以把一个个算法操作开发成一个个小函数（称为算子），就可以通过函数式编程把这些算子应用在数据上。2020-03-29

关于滥用 getter、setter 方法，这让我想起了 Spring 中 BeanFactory 类的设计。Spring BeanFactory 只允许查找，不允许修改数据，它提供了一个子类 ConfigurableListableBeanFactory 类则提供了大量的配置方法，如果 setBeanExpressionResolver 等。Spring 中一般提供 BeanFactory 给用户使用，ConfigurableListableBeanFactory 则提供给开发者使用，这样设计避免了滥用 getter、setter 方法，同时也符合单一职能原则。2020-02-26

其实我觉得之所以用面向对象的编程语言写出面向过程的代码主要是对 OOP 理解的不到位，正如文章所说面向过程编程如何人脑的思考方式，也就是第一部干什么第二步干什么自然而然就写成了面向过程的代码，前面提到两者的区别组织方式的不同，其实写代码的时候多考虑一点，我可以怎么分「块」，每块的职责是什么，每块有哪些内容构成（属性和方法，只要职责明确了这两点也就清楚了）块之间是怎么交互的，这些问题思考清楚才算得上面向对象编程。你想想啊，小到工具类的命名、类的命名，大到现在的若干个微服务，不都是一个个「块」么，所以啊，还是想想清楚到底什么才是面向对象编程以及面向对象编程的四大特性才能在实际的开发中运用自如。扩展一下，为什么很多公司那么注重编程规范其中一个原因是代码的易读性会更好，易读性怎么体现不就落实到这一个个「块」中么。比如大一统的 Constants 类为什么不好，最大的问题就是职责不清晰，你让你一个保安去干财务你觉得合适么，你知道他是保安还是财务呢？！2020-02-20

滥用 getter setter 的情况确实挺常见，不过这个问题相对来说是比较容易发现和修正的。购物车那个例子中，数据需要外部访问的情况，作为一个前端工程师，常见的处理思路就是将数据深拷贝，供外部使用，即时恶意修改也不会对原来的逻辑造成影响。不过由于基本没写过服务端的代码，不确定此思路是否适用于服务端，会不会内层占用的问题。面向对象的语言及代码组织形式，却完全写的是面向过程的情况，值得反思。2019-12-31

## 0105接口vs抽象类的区别.md

1、抽象类和接口的语法特性。抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

2、抽象类和接口存在的意义。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

3、抽象类和接口的应用场景区别。什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。

