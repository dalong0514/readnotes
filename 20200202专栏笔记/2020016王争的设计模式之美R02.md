# 2020016王争的设计模式之美R02

## 记忆时间

2020-08-09

## 目录

0108业务开发常用的基于贫血模型的MVC架构违背OOP吗.md

0109如何利用基于充血模型的DDD开发一个虚拟钱包系统.md

0110如何对接口鉴权这样一个功能开发做面向对象分析.md

0111 如何利用面向对象设计和编程开发接口鉴权功能.md

## 0108业务开发常用的基于贫血模型的MVC架构违背OOP吗.md

我们平时做 Web 项目的业务开发，大部分都是基于贫血模型的 MVC 三层架构，在专栏中我把它称为传统的开发模式。之所以称之为「传统」，是相对于新兴的基于充血模型的 DDD 开发模式来说的。基于贫血模型的传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的 DDD 开发模式，是典型的面向对象的编程风格。

不过，DDD 也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的 DDD 开发模式有点大材小用，无法发挥作用。相反，对于业务复杂的系统开发来说，基于充血模型的 DDD 开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以相比基于贫血模型的开发模式，更加有优势。

在前面几节课中，我们学习了面向对象的一些理论知识，比如，面向对象四大特性、接口和抽象类、面向对象和面向过程编程风格、基于接口而非实现编程和多用组合少用继承设计思想等等。接下来，我们再用四节课的时间，通过两个更加贴近实战的项目来进一步学习，如何将这些理论应用到实际的软件开发中。

据我了解，大部分工程师都是做业务开发的，所以，今天我们讲的这个实战项目也是一个典型的业务系统开发案例。我们都知道，很多业务系统都是基于 MVC 三层架构来开发的。实际上，更确切点讲，这是一种基于贫血模型的 MVC 三层架构开发模式。

虽然这种开发模式已经成为标准的 Web 项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为反模式（anti-pattern）。特别是领域驱动设计（Domain Driven Design，简称 DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于充血模型的 DDD 开发模式越来越被人提倡。所以，我打算用两节课的时间，结合一个虚拟钱包系统的开发案例，带你彻底弄清楚这两种开发模式。

考虑到你有可能不太了解我刚刚提到的这几个概念，所以，在正式进入实战项目的讲解之前，我先带你搞清楚下面几个问题：1）什么是贫血模型？什么是充血模型？2）为什么说基于贫血模型的传统开发模式违反 OOP？3）基于贫血模型的传统开发模式既然违反 OOP，那又为什么如此流行？4）什么情况下我们应该考虑使用基于充血模型的 DDD 开发模式？

### 8.1 什么是基于贫血模型的传统开发模式？

我相信，对于大部分的后端开发工程师来说，MVC 三层架构都不会陌生。不过，为了统一我们之间对 MVC 的认识，我还是带你一块来回顾一下，什么是 MVC 三层架构。MVC 三层架构中的 M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整。

比如，现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就将后端项目分为 Repository 层、Service 层、Controller 层。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 Web 项目，基本的分层思路都大差不差。

刚刚我们回顾了 MVC 三层开发架构。现在，我们再来看一下，什么是贫血模型？实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。

```java
////////// Controller+VO(View Object) //////////
public class UserController {
  private UserService userService; //通过构造函数或者IOC框架注入
  
  public UserVo getUserById(Long userId) {
    UserBo userBo = userService.getUserById(userId);
    UserVo userVo = [...convert userBo to userVo...];
    return userVo;
  }
}

public class UserVo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Service+BO(Business Object) //////////
public class UserService {
  private UserRepository userRepository; //通过构造函数或者IOC框架注入
  
  public UserBo getUserById(Long userId) {
    UserEntity userEntity = userRepository.getUserById(userId);
    UserBo userBo = [...convert userEntity to userBo...];
    return userBo;
  }
}

public class UserBo {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}

////////// Repository+Entity //////////
public class UserRepository {
  public UserEntity getUserById(Long userId) { //... }
}

public class UserEntity {//省略其他属性、get/set/construct方法
  private Long id;
  private String name;
  private String cellphone;
}
```

我们平时开发 Web 后端项目的时候，基本上都是这么组织代码的。其中，UserEntity 和 UserRepository 组成了数据访问层，UserBo 和 UserService 组成了业务逻辑层，UserVo 和 UserController 在这里属于接口层。

从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

### 8.2 什么是基于充血模型的 DDD 开发模式？

刚刚我们讲了基于贫血模型的传统的开发模式。现在我们再讲一下，另外一种最近更加被推崇的开发模式：基于充血模型的 DDD 开发模式。

首先，我们先来看一下，什么是充血模型？在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

接下来，我们再来看一下，什么是领域驱动设计？领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，早在 2004 年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是微服务。

我们知道，除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。

不过，我个人觉得，领域驱动设计有点儿类似敏捷开发、SOA、PAAS 等概念，听起来很高大上，但实际上只值「五分钱」。即便你没有听说过领域驱动设计，对这个概念一无所知，只要你是在开发业务系统，也或多或少都在使用它。做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计。所以，不要把领域驱动设计当银弹，不要花太多的时间去过度地研究它。

实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它跟基于贫血模型的传统开发模式的区别主要在 Service 层。

在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。

1『充血模型的 DDD 开发模式，服务层从原来的「Service 类 + BO 类」进化为「Service 类 + Domain 类」，而且业务逻辑和数据都写在 Domain 类里了，Service 类反而变得非常单薄。』

基于充血模型的 DDD 设计模式的概念，今天我们只是简单地介绍了一下。在下一节课中，我会结合具体的项目，通过代码来给你展示，如何基于这种开发模式来开发一个系统。

### 8.3 为什么基于贫血模型的传统开发模式如此受欢迎？

前面我们讲过，基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。

我们前面也讲过，面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？关于这个问题，我总结了下面三点原因。

第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。

第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计。

第三点原因是，思维已固化，转型有成本。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。

### 8.4 什么项目应该考虑使用基于充血模型的 DDD 开发模式？

既然基于贫血模型的开发模式已经成为了一种约定俗成的开发习惯，那什么样的项目应该考虑使用基于充血模型的 DDD 开发模式呢？刚刚我们讲到，基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。

你可能会有一些疑问，这两种开发模式，落实到代码层面，区别不就是一个将业务逻辑放到 Service 类中，一个将业务逻辑放到 Domain 领域模型中吗？为什么基于贫血模型的传统开发模式，就不能应对复杂业务系统的开发？而基于充血模型的 DDD 开发模式就可以呢？

实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是两种不同的开发模式会导致不同的开发流程。基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发的时候更加有优势。为什么这么说呢？我们先来回忆一下，我们平时基于贫血模型的传统的开发模式，都是怎么实现一个功能需求的。

不夸张地讲，我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。

业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致各种长得差不多、区别很小的 SQL 语句满天飞。

所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护。

如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。

我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。

### 黑板墙

今天课堂讨论的话题有两个。1）你做经历的项目中，有哪些是基于贫血模型的传统的开发模式？有哪些是基于充血模型的 DDD 开发模式呢？请简单对比一下两者的优劣。2）对于我们举的例子中，UserEntity、UserBo、UserVo 包含的字段都差不多，是否可以合并为一个类呢？

为什么贫血模型盛行。下面几项自己都中过招：1、环境问题：1）近朱者赤，近墨者黑。2）大多数人都是模仿别人的代码，而别人的代码基本上都是 demo，没有复杂的业务逻辑，基本是贫血模型。3）找不到好的指导与学习对象。4）接触不到复杂业务项目。5）做 web 项目的，很大一部分就是简单的 CURD，贫血模型就能解决。6）公司以任务数来衡量个人价值。2、个人问题：1）不考虑项目质量属性。2）只关心当前业务，没有意识去思考后期该如何维护和响应业务变更。3）求快不求质。4）个人以任务数来自我满足。5）没有 60 分和 100 分的概念。6）需求分析、设计、编码合为一体。

如何理解充血模型。先推荐一本书：整洁架构设计。先说一下充血模型中各组件的角色：1）controller 主要服务于非业务功能，比如说数据验证。2）service 服务于 use case，负责的是业务流程与对应规则。3）Domain 服务于核心业务逻辑和核心业务数据。4）rep 用于与外部交互数据。

额外说一点，业务开发个人倾向于六边形架构，而非传统的三层架构。六边形架构更能体现当下 web 应用的场景。六边形项目结构（根据实际情况自行组织与定义）：1）InboundHandler 代替 controller：a）WebController：处理 web 接口。b）WeChatController：处理微信公众号接口。c）AppController：处理 app 接口。d）MqListener：处理消息。e）RpcController：处理子系统间的调用。2）service 服务于 use case，负责的是业务流程与对应规则。a）CQPS + SRP：读写分离和单一原则将 use case 分散到不同的 service 中，避免一个巨大的 service 类（碰到过 8000 行的 service）。3）Domain 服务于核心业务逻辑和核心业务数据。a）最高层组件，不会依赖底层组件。b）易测试。4）outBoundhandle 代替 rep。a）MqProducer：发布消息。b）Cache：从缓存获取数据。c）sql：从数据库获取数据。d）Rpc：从子系统获取数据。

各层之间的数据模型不要共用，主要是因为稳定性不同，各层数据模型的变更原因和变更速率是不同的，离 IO 设备越近的的稳定性越差，比如说 controller 层的 VO，rep 层的 entity。Domain 层是核心业务逻辑和核心业务数据，稳定性是最高的。

几个不太容易理解的点（我刚开始碰到的时候很费解）：1）use case 和 核心业务逻辑该如何定义与区分？哪些该放到 service 里面，哪些该放到 Domain 中。2）rep 是依赖于 service 的，而不是 service 依赖 rep 层。业务逻辑是最高层组件（最稳定的），rep 层是底层组件。3）接口能反转依赖关系。

一剂良药：所有的中间层都是为了解耦。2019-11-27

我个人认为，充血模型在 web 开发领域不流行的一个根本原因，在于互联网兴起后各种层出不穷的需求变动，以及短命的项目生存周期，充血模型应对复杂业务确实很有优势，但是这是建立在复杂业务本身其实相对稳定上，比如银行的业务，虽然复杂，但是其实很稳定。但是要是换在互联网，今天改需求明天改需求，甚至很多时候根本就是推倒了重来的需求，充血模型面对这种状态，根本是力不从心的。2019-11-27

问题：1）做的 Android 项目更多，Android 开发也是经历了 MVC => MVP（依然是一种 MVC 架构）=> MVVM 的模式演进。类 MVC 模式比较多，在 UI 相关的开发中，只用过贫血模式（之前也尝试过使用充血模式，但考虑到不一致带来的成本就放弃了）；在 UI 无关的复杂服务类开发中，也用过充血模型（虽然我不知道它叫充血模型）。我认为贫血模型的优点是更容易看懂，充血模型的优点是更能应对复杂业务。2）我认为还是不要放在同一个类中，原因是：成本大于收益。成本：一个复杂的类，在被不同的模块调用时充当着不同的角色，甚至，不同的模块调用不同的字段，需要大篇幅的文档来描述这些差异。稍有修改，复杂度的增加非线性。优点：代码重用。

感想：软件开发处理的是工程学问题，解决方案依赖场景，一个新技术的火爆一定是解决了当前主流场景的痛点问题，随着规模和复杂度的变化，场景也随之变化；争论贫血模式更好还是充血模式更好，争论哪个开发语言更好，这样的问题都是伪命题，我们更应该投入精力的是为当前场景选择最合适的解决方案。2019-11-27

个人感觉业务被贫血模型绑架的另一个原因是以前缓存 nosql 这些技术不不成熟，刚毕业那会哪有什么 redis，机器的内存也不多。都是公司堆在角落的旧机器。一些业务如果在 domain 里实现可能会 hold 住数据库中的大部分数据。所以业务上都需要翻译成 sql 的 where 和 join 来减少网络和内存的开销。功能都被 sql 抢了去，想充血也充不起来。现在随便开个项目不带个 redis 老板都会质疑一下。mysql 的访问也都是能少就少，不行再多加几台云服务器。老板也显得更有面儿。2019-11-27

我们公司的 ERP 系统使用的是贫血模型，支付系统由一个 OOP 的忠实践行者设计的，使用的是充血模型。两个系统我都有在维护，先说 ERP。遇到新需求的时候，就像老师说的 SQL 驱动。从后往前返回数据。简单的需求还好，像一些复杂的模块。看着 service 一个方法动辄几百，甚至出现过上千行的。真心感觉改不动。在业务还比较简单的时候贫血模型还够用，但随着业务发展，service 层越来越重。这时还不做封装抽象，系统真心不好维护。很多时候都要依靠老员工的讲解。而支付系统，在开发新功能的时候，因为封装抽象已经做的很好，改动起来还是蛮愉快的。没有那么多的重复性代码。不过，因为封装的太多太深，在刚接手的时候确实不好读。业务逻辑逻辑分散在各处。当然，也可能是本人水平有限。2019-11-28

看到「领域驱动设计有点儿类似敏捷开发、SOA、PAAS 等概念，听起来很高大上，但实际上只值五分钱。」时，不知道引起了多少人的共鸣。做技术的本身就经常会遇到沟通问题，一些人还总喜欢「造概念」，唯恐别人听懂了，争哥这句话无疑说中了我们的心坎儿。当然我这里也不是说 DDD 不好（看后面的争哥也没这个意思），但是每个理论都有自己的局限性和适用性，看很多文章在讲一些理论时，总是恨不得把自己的理论（其实也算不得自己的）吹成银弹，态度上就让人很难接受。

说句实话，我们就没有写过充血模型的代码。我们会把 UserEntity、UserBo 混着用，UserBo 和 UserVo 之间转换时有时还会用 BeanUtils 之类的工具 copy 。对于复杂的逻辑，我们就用复杂 SQL 或者 Service 中的代码解决。不过我在翻一些框架时，比如 Java 的并发包时不可避免的需要梳理 Lock、Condition、Synchronizer 之间的关系。比如看 Spring IOC 时，也会需要梳理围绕着 Context 、 Factory 展开的很多类之间的关系。就好像你要「混某个圈子」时，就不可避免的「拜码头」，认识一堆「七大姑八大姨」，然后你才能理解整个「圈子」里的关系和运转逻辑。

我也经常会有疑问，DDD 和面向对象究竟是什么关系，也会猜想：是不是面向对象主要关注「圈子」内的问题，而 DDD 主要关注「圈子」之间的问题？有没有高手可以回答一下。作者回复：哈哈，多谢认可，我写这篇文字的时候，还害怕搞 DDD 的人会来骂我，看来是我多虑了。隔壁的 DDD 课程可以去学下，管它是不是我写的，看看他咋「吹」的也好。2019-11-27

我觉得代码架构和业务架构一样，只要将关注点分离就可以。简单的系统，困难的不在于领域的拆分，而在于时间成本的控制。从软件工程角度考虑，时间，成本，范围三角理论可以进行分析。我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。DDD 模型其实无异，都是将 Model 层做重。因为业务核心是技术无关的。传统 MVC 用于 C/S 模型，也依然是重 Model 层的。我觉得软件设计的方法没有变化，只是大家看到的视角不同罢了。软件架构有两个含义：1）参与的元素有哪些。2）元素间的关系是什么。从抽象角度来看，非常简单。2019-11-27

基本上经历过的 web 项目都是基于贫血模型开发模式的，entity、bo、vo 不能放在一个类里，每个对象的应用场景不同，entity 是映射数据库字段的，bo、vo 适合业务和展示相关的，而且 entity 相对来讲变化不多，bo、vo 可能会频繁变化，所以不适合放在同一个类里。2019-11-27

第一个还没有太多的感受，还需要时间来练习感受。第二个是否合成一个各有优劣，可能还是和写代码人的功底有关：1）拆分开的优势：各层的防腐隔离，当前层的变化不影响其他层。2）拆分开的劣势：来一个迭代需求，比如需要加一下邮箱等，rd 很有可能在三个类里各加一个字段，从上改到下，完全看不出隔离的优势，就看不到了一层层的类转换。2019-11-27

汇总：1）一直贫血模型，却没有发现。2）充血模型我有点没看懂，我粗糙的理解成把贫血模型的 service 里面的复杂业务逻辑都搬到了 domain，然后 service 简单调用 domain 即可。那 domain 里不也是业务逻辑 + bo 吗？还有复杂的 sql 无法复用问题，我一般写业务都是单表。然后放到 service 层调用多个 dao 去组装最终的数据出来。这样可以解决乱七八糟的 sqlz 吗？希望争哥解答下。3）第二道问题，我觉得不能合并，因为首先 entity 是对应的数据表字段，其次 bo 可能被多个业务方法所使用，返回的字段可能不同，这就需要 vo 来限制具体每个接口需要哪些字段来响应给客户端。2019-11-28

回想起来经历的互联网项目一直都是贫血模型，究其原因：1）互联网项目多采用敏捷开发，需求多变，设计充血模型的性价比低；2）互联网小产品业务场景相对简单，业务难点更多的出现在并发，性能上，在存储，内存成本急剧下降的当下，粗暴的横向扩展成为见效更快的选择。2019-11-28

汇总：1）以前做的项目都是基于贫血模型的，这次的话涉及风控业务，也是基于贫血模型，但是各种问题不断，正在考虑优化，这里刚好看到老师的文章，希望能有所借鉴。2）Entity 是 ORM 中数据库映射的实体类，BO 是业务操作相关实体类，VO 是视图层对应实体类。在简单情况下，这三个类可能是一样的，比方说你填写一个登陆注册的表单，此时前端传给后端接口的数据，一般就是 VO，而通过业务层 Service 操作，加入创建时间，IP 地址等，就转换成了 BO，最后对应到数据层就转换为了 Entity，也许一次注册可能需要写多个库，就会生成多个 Entity。有些复杂业务，还有 DO,DTO，PO 之类的概念，但是个人感觉很模糊，也不是很了解。这里希望老师能指点一下。作者回复：DTO（data transfer object），是一种更抽象的概念，这种数据类型可以是贫血模型的，主要是用在接口之间传递数据。2019-11-27

第二题，不合并有好处。UserEntity 是具体到数据库的，假如有不同版本的 UserEntity，相互之间有少部分不同，抽象出一个 BO 层在 Service 层做 UserEntity 到 BO 的转化，可以方便 Bo 在 Service 层传播，方便不同项目之间复用、统一处理；再往上抽象出的 VO，一般通过接口返回给前端展示，也可以是多种有差异的 BO 转化为同一种 VO 方便前端统一处理。2019-11-27

汇总：1）目前基本都在接触贫血开发模型，充血的可能局部模块设计的时候，会把数据和方法组织到一个类里面去。但是 DB 的操作完全隔离。这里有一个问题：充血模型的话，OOP 的想法，应该是每个人（假设人是类，具体的人就是人这个类的实例化）管理自己的属性，比如我的主管。这个时候有一个需求。批量修改人员的主管。那么充血模型是要遍历委托给每个具体的人自己去修改呢？还是提供一个 service，直接批量操作 DB。2）entity、bo、vo 我的做法是不合并，但是真的有贯穿三层的模型。那么就直接用一个。但是要单独分包。并且组内规范好这个包里面的东西都是有修改风险的。我个人倾向用麻烦换容错。毕竟软件的变化性比较大。作者回复：1）充血模型并不是哪都适用。2）赞成你的看法。2019-11-27

最近在看消息队列的专栏，里面有提到 Pulsar 这个产品采用了存储与计算分离的设计。本质上和文中提到的数据与操作分离应该是一个意思吧？难道也是一种面向过程的设计。作者回复：存储本身有自己的逻辑在那里面，不能单独的看做是数据。2019-11-27

这么说来我所有的项目都是基于贫血模式的；现实的开发中就是把三个 VO 都合成一个的。不知道会有什么问题？作者回复：如果三个 object 需要的字段不是完全一样的，该咋办呢？2019-11-27

MVC 是面向过程编程，是因为它违反了封装的特性，数据和逻辑操作分离开了，在 controller 进行相关数据逻辑操作，而 model 仅仅只是个数据层，没有任何操作。而 MVVM 是面向对象编程，因为它把数据和其相关逻辑操作封装在了 viewModel，只暴露给外部相关方法，controller 想要获取数据直接通过这些方法就行了，不用像 MVC 在 controller 层进行一堆逻辑操作，同时减轻了 controller 的代码，在 viewModel 也方便维护数据逻辑操作。不知道这样的理解对不对？作者回复：可以这么理解。2019-11-27

我经历的所有的项目都是贫血模型，对于充血模型没尝试过，如果说业务数据与业务操作分离，那么在设计接口时如何将繁多的业务属性当成参数传入给接口方法呢？是说将所有属性的 getter 和 setter 直接生成在接口中吗？那么对于接口中使用这些零散的属性是怎样使用的呢？觉得二者确实还得从实际情况出发，看业务复杂度及对代码设计是否有要求，但往往都是为了习惯、速度而忽略了设计初心。

对于三类对象是否合并成一个，我上次的留言就正好说了这个问题，确实很难判别，起初是分开三个对象，但是为了所谓的分层、隔离干净避免耦合，都没有体现，在业务调整方面分开 3 个对象并没体现优势，可能是我参与的项目都比较简单，基本上不涉及到需要解耦来进行代码的扩展性调整，反而是增减改属性比较频繁，这样就涉及到一位同学说的，一下修改 3 个对象而且最好属性值的复制，如果是用委托就不说了，如果不是委托，那么属性值复制多数依赖 BeanUtils 类通过类反射完成，还要保证属性类型的一致性；如果用委托，那么意味着 3 个对象的组合难免又是对分层上的一个污点。所以我觉得两者适用在不同的设计要求、团队人员的一往习惯以及项目的目标，如果公司涉及的项目没有那么复杂、设计要求不高，我更倾向于合并为一个。2019-11-27

说一说我的经历吧，现在就在银行工作。之前做一个新系统，组长说我们用 DDD 模式来开发吧，大家都不熟，摸索着搞了一周，最后项目要在在几号几号上线，根本没有多余的时间让你慢慢设计，一句话，几号能不能正常上线，DDD 花了一周时间难产了，只能老办法贫血模型快速搞定，先上线。若不能正常上线，业务才不管你贫血还是充血呢。所以，有些时候用什么模型真的是跟指标跟任务挂钩的，精心设计需要更多的时间，没有时间，只能粗暴的尽快搞定，后面就是还各种还技术债。2019-11-30

老师，我还是学生，然后学的 web 架构里面我只知道实体类，那个 vo，bo，和 entity 为什么需要定义三个啊，不是用一个实体类就可以了嘛？作者回复：因为是用到不同层的。每一层中的 object 包含的字段可能都不大一样，所以要区分定义。如果一个 object 贯穿所有层，本身有违反封装。2019-11-27

汇总：1）目前经历的项目中，没有基于充血模型来开发的，都是贫血模型，快速开发迭代上线，设计简单，出现重复代码这种事，倒也不是全部贫血模型的锅，有些业务逻辑开发时就是复制粘贴再修改一点东西，所以，代码复用这种事，与哪个模型无关，与开发人员自身有关。2）几个类不能合并为一，每个类都有对应交互使用的地方，虽然看着一样，但在业务中可能会存在些微的差异，而且概念不同，这样分开写逻辑层次更清晰些。2020-06-28

每次开始搭建一个 web 项目的时候，总是想 entity、bo、vo 如何处理的问题。比如最近刚开始做的一个电商项目，我就一个 vo 行天下了（考虑到基本上就是 crud，这几个都长得差不多，如果三层直接都转一次，会非常麻烦与浪费资源）。但是总是觉得带来了很大的耦合，就像 constants、utils 之类的东西到处引用。还有关于 service 同层之间是否可以相互调用、repository 到处引用等等问题，不懂如何做分离封装，深深困扰，有没有朋友给点建议。2020-06-12

## 0109如何利用基于充血模型的DDD开发一个虚拟钱包系统.md

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作。

基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，Controller 层和 Repository 层的代码基本上相同。这是因为，Repository 层的 Entity 生命周期有限，Controller 层的 VO 只是单纯作为一种 DTO。两部分的业务逻辑都不会太复杂。业务逻辑主要集中在 Service 层。所以，Repository 层和 Controller 层继续沿用贫血模型的设计思路是没有问题的。

上一节课，我们做了一些理论知识的铺垫性讲解，讲到了两种开发模式，基于贫血模型的传统开发模式，以及基于充血模型的 DDD 开发模式。今天，我们正式进入实战环节，看如何分别用这两种开发模式，设计实现一个钱包系统。

## 9.1 钱包业务背景介绍

很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作。下图是一张典型的钱包功能界面，你可以直观地感受一下。

一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）。为了方便后续的讲解，我们限定钱包暂时只支持充值、提现、支付、查询余额、查询交易流水这五个核心的功能，其他比如冻结、透支、转赠等不常用的功能，我们暂不考虑。为了让你理解这五个核心功能是如何工作的，接下来，我们来一块儿看下它们的业务实现流程。

1、充值。用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水。

2、支付。用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上。除此之外，我们也需要记录这笔支付的交易流水信息。

3、提现。除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息。

4、查询余额。查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。

5、查询交易流水。查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可。

## 9.2 钱包系统的设计思路

根据刚刚讲的业务实现流程和数据流转图，我们可以把整个钱包系统的业务划分为两部分，其中一部分单纯跟应用内的虚拟钱包账户打交道，另一部分单纯跟银行账户打交道。我们基于这样一个业务划分，给系统解耦，将整个钱包系统拆分为两个子系统：虚拟钱包系统和三方支付系统。

为了能在有限的篇幅内，将今天的内容讲透彻，我们接来下只聚焦于虚拟钱包系统的设计与实现。对于三方支付系统以及整个钱包系统的设计与实现，我们不做讲解。你可以自己思考下。现在我们来看下，如果要支持钱包的这五个核心功能，虚拟钱包系统需要对应实现哪些操作。我画了一张图，列出了这五个功能都会对应虚拟钱包的哪些操作。注意，交易流水的记录和查询，我暂时在图中打了个问号，那是因为这块比较特殊，我们待会再讲。

从图中我们可以看出，虚拟钱包系统要支持的操作非常简单，就是余额的加加减减。其中，充值、提现、查询余额三个功能，只涉及一个账户余额的加减操作，而支付功能涉及两个账户的余额加减操作：一个账户减余额，另一个账户加余额。现在，我们再来看一下图中问号的那部分，也就是交易流水该如何记录和查询？我们先来看一下，交易流水都需要包含哪些信息。我觉得下面这几个信息是必须包含的。

从图中我们可以发现，交易流水的数据格式包含两个钱包账号，一个是入账钱包账号，一个是出账钱包账号。为什么要有两个账号信息呢？这主要是为了兼容支付这种涉及两个账户的交易类型。不过，对于充值、提现这两种交易类型来说，我们只需要记录一个钱包账户信息就够了，所以，这样的交易流水数据格式的设计稍微有点浪费存储空间。

实际上，我们还有另外一种交易流水数据格式的设计思路，可以解决这个问题。我们把「支付」这个交易类型，拆为两个子类型：支付和被支付。支付单纯表示出账，余额扣减，被支付单纯表示入账，余额增加。这样我们在设计交易流水数据格式的时候，只需要记录一个账户信息即可。我画了一张两种交易流水数据格式的对比图，你可以对比着看一下。

那以上两种交易流水数据格式的设计思路，你觉得哪一个更好呢？答案是第一种设计思路更好些。因为交易流水有两个功能：一个是业务功能，比如，提供用户查询交易流水信息；另一个是非业务功能，保证数据的一致性。这里主要是指支付操作数据的一致性。

支付实际上就是一个转账的操作，在一个账户上加上一定的金额，在另一个账户上减去相应的金额。我们需要保证加金额和减金额这两个操作，要么都成功，要么都失败。如果一个成功，一个失败，就会导致数据的不一致，一个账户明明减掉了钱，另一个账户却没有收到钱。

保证数据一致性的方法有很多，比如依赖数据库事务的原子性，将两个操作放在同一个事务中执行。但是，这样的做法不够灵活，因为我们的有可能做了分库分表，支付涉及的两个账户可能存储在不同的库中，无法直接利用数据库本身的事务特性，在一个事务中执行两个账户的操作。当然，我们还有一些支持分布式事务的开源框架，但是，为了保证数据的强一致性，它们的实现逻辑一般都比较复杂、本身的性能也不高，会影响业务的执行时间。所以，更加权衡的一种做法就是，不保证数据的强一致性，只实现数据的最终一致性，也就是我们刚刚提到的交易流水要实现的非业务功能。

对于支付这样的类似转账的操作，我们在操作两个钱包账户余额之前，先记录交易流水，并且标记为「待执行」，当两个钱包的加减金额都完成之后，我们再回过头来，将交易流水标记为「成功」。在给两个钱包加减金额的过程中，如果有任意一个操作失败，我们就将交易记录的状态标记为「失败」。我们通过后台补漏 Job，拉取状态为「失败」或者长时间处于「待执行」状态的交易记录，重新执行或者人工介入处理。

如果选择第二种交易流水的设计思路，使用两条交易流水来记录支付操作，那记录两条交易流水本身又存在数据的一致性问题，有可能入账的交易流水记录成功，出账的交易流水信息记录失败。所以，权衡利弊，我们选择第一种稍微有些冗余的数据格式设计思路。

现在，我们再思考这样一个问题：充值、提现、支付这些业务交易类型，是否应该让虚拟钱包系统感知？换句话说，我们是否应该在虚拟钱包系统的交易流水中记录这三种类型？

答案是否定的。虚拟钱包系统不应该感知具体的业务交易类型。我们前面讲到，虚拟钱包支持的操作，仅仅是余额的加加减减操作，不涉及复杂业务概念，职责单一、功能通用。如果耦合太多业务概念到里面，势必影响系统的通用性，而且还会导致系统越做越复杂。因此，我们不希望将充值、支付、提现这样的业务概念添加到虚拟钱包系统中。

但是，如果我们不在虚拟钱包系统的交易流水中记录交易类型，那在用户查询交易流水的时候，如何显示每条交易流水的交易类型呢？从系统设计的角度，我们不应该在虚拟钱包系统的交易流水中记录交易类型。从产品需求的角度来说，我们又必须记录交易流水的交易类型。听起来比较矛盾，这个问题该如何解决呢？

我们可以通过记录两条交易流水信息的方式来解决。我们前面讲到，整个钱包系统分为两个子系统，上层钱包系统的实现，依赖底层虚拟钱包系统和三方支付系统。对于钱包系统来说，它可以感知充值、支付、提现等业务概念，所以，我们在钱包系统这一层额外再记录一条包含交易类型的交易流水信息，而在底层的虚拟钱包系统中记录不包含交易类型的交易流水信息。为了让你更好地理解刚刚的设计思路，我画了一张图，你可以对比着我的讲解一块儿来看。

我们通过查询上层钱包系统的交易流水信息，去满足用户查询交易流水的功能需求，而虚拟钱包中的交易流水就只是用来解决数据一致性问题。实际上，它的作用还有很多，比如用来对账等。限于篇幅，这里我们就不展开讲了。整个虚拟钱包的设计思路到此讲完了。接下来，我们来看一下，如何分别用基于贫血模型的传统开发模式和基于充血模型的 DDD 开发模式，来实现这样一个虚拟钱包系统？

### 9.3 基于贫血模型的传统开发模式

实际上，如果你有一定 Web 项目的开发经验，并且听明白了我刚刚讲的设计思路，那对你来说，利用基于贫血模型的传统开发模式来实现这样一个系统，应该是一件挺简单的事情。不过，为了对比两种开发模式，我还是带你一块儿来实现一遍。

这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，我省略了具体的代码实现。

```java
public class VirtualWalletController {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletService virtualWalletService;
  
  public BigDecimal getBalance(Long walletId) { ... } //查询余额
  public void debit(Long walletId, BigDecimal amount) { ... } //出账
  public void credit(Long walletId, BigDecimal amount) { ... } //入账
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账
}
```

Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对 amount 是否小于 0、钱包是否存在的校验等等。

```java
public class VirtualWalletBo {//省略getter/setter/constructor方法
  private Long id;
  private Long createTime;
  private BigDecimal balance;
}

public class VirtualWalletService {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletRepository walletRepo;
  private VirtualWalletTransactionRepository transactionRepo;
  
  public VirtualWalletBo getVirtualWallet(Long walletId) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWalletBo walletBo = convert(walletEntity);
    return walletBo;
  }
  
  public BigDecimal getBalance(Long walletId) {
    return walletRepo.getBalance(walletId);
  }
  
  public void debit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    BigDecimal balance = walletEntity.getBalance();
    if (balance.compareTo(amount) < 0) {
      throw new NoSufficientBalanceException(...);
    }
    walletRepo.updateBalance(walletId, balance.subtract(amount));
  }
  
  public void credit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    BigDecimal balance = walletEntity.getBalance();
    walletRepo.updateBalance(walletId, balance.add(amount));
  }
  
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
    VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
    transactionEntity.setAmount(amount);
    transactionEntity.setCreateTime(System.currentTimeMillis());
    transactionEntity.setFromWalletId(fromWalletId);
    transactionEntity.setToWalletId(toWalletId);
    transactionEntity.setStatus(Status.TO_BE_EXECUTED);
    Long transactionId = transactionRepo.saveTransaction(transactionEntity);
    try {
      debit(fromWalletId, amount);
      credit(toWalletId, amount);
    } catch (InsufficientBalanceException e) {
      transactionRepo.updateStatus(transactionId, Status.CLOSED);
      ...rethrow exception e...
    } catch (Exception e) {
      transactionRepo.updateStatus(transactionId, Status.FAILED);
      ...rethrow exception e...
    }
    transactionRepo.updateStatus(transactionId, Status.EXECUTED);
  }
}
```

以上便是利用基于贫血模型的传统开发模式来实现的虚拟钱包系统。尽管我们对代码稍微做了简化，但整体的业务逻辑就是上面这样子。其中大部分代码逻辑都非常简单，最复杂的是 Service 中的 transfer() 转账函数。我们为了保证转账操作的数据一致性，添加了一些跟 transaction 相关的记录和状态更新的代码，理解起来稍微有点难度，你可以对照着之前讲的设计思路，自己多思考一下。

### 9.4 基于充血模型的 DDD 开发模式

刚刚讲了如何利用基于贫血模型的传统开发模式来实现虚拟钱包系统，现在，我们再来看一下，如何利用基于充血模型的 DDD 开发模式来实现这个系统？在上一节课中，我们讲到，基于充血模型的 DDD 开发模式，跟基于贫血模型的传统开发模式的主要区别就在 Service 层，Controller 层和 Repository 层的代码基本上相同。所以，我们重点看一下，Service 层按照基于充血模型的 DDD 开发模式该如何来实现。

在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。具体的代码实现如下所示：

```java
public class VirtualWallet { // Domain领域模型(充血模型)
  private Long id;
  private Long createTime = System.currentTimeMillis();;
  private BigDecimal balance = BigDecimal.ZERO;
  
  public VirtualWallet(Long preAllocatedId) {
    this.id = preAllocatedId;
  }
  
  public BigDecimal balance() {
    return this.balance;
  }
  
  public void debit(BigDecimal amount) {
    if (this.balance.compareTo(amount) < 0) {
      throw new InsufficientBalanceException(...);
    }
    this.balance.subtract(amount);
  }
  
  public void credit(BigDecimal amount) {
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException(...);
    }
    this.balance.add(amount);
  }
}

public class VirtualWalletService {
  // 通过构造函数或者IOC框架注入
  private VirtualWalletRepository walletRepo;
  private VirtualWalletTransactionRepository transactionRepo;
  
  public VirtualWallet getVirtualWallet(Long walletId) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    return wallet;
  }
  
  public BigDecimal getBalance(Long walletId) {
    return walletRepo.getBalance(walletId);
  }
  
  public void debit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    wallet.debit(amount);
    walletRepo.updateBalance(walletId, wallet.balance());
  }
  
  public void credit(Long walletId, BigDecimal amount) {
    VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
    VirtualWallet wallet = convert(walletEntity);
    wallet.credit(amount);
    walletRepo.updateBalance(walletId, wallet.balance());
  }
  
  public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
    //...跟基于贫血模型的传统开发模式的代码一样...
  }
}
```

看了上面的代码，你可能会说，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 VirtualWallet 类的实现代码。

```java
public class VirtualWallet {
  private Long id;
  private Long createTime = System.currentTimeMillis();;
  private BigDecimal balance = BigDecimal.ZERO;
  private boolean isAllowedOverdraft = true;
  private BigDecimal overdraftAmount = BigDecimal.ZERO;
  private BigDecimal frozenAmount = BigDecimal.ZERO;
  
  public VirtualWallet(Long preAllocatedId) {
    this.id = preAllocatedId;
  }
  
  public void freeze(BigDecimal amount) { ... }
  public void unfreeze(BigDecimal amount) { ...}
  public void increaseOverdraftAmount(BigDecimal amount) { ... }
  public void decreaseOverdraftAmount(BigDecimal amount) { ... }
  public void closeOverdraft() { ... }
  public void openOverdraft() { ... }
  
  public BigDecimal balance() {
    return this.balance;
  }
  
  public BigDecimal getAvailableBalance() {
    BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
    if (isAllowedOverdraft) {
      totalAvaliableBalance += this.overdraftAmount;
    }
    return totalAvaliableBalance;
  }
  
  public void debit(BigDecimal amount) {
    BigDecimal totalAvaliableBalance = getAvailableBalance();
    if (totoalAvaliableBalance.compareTo(amount) < 0) {
      throw new InsufficientBalanceException(...);
    }
    this.balance.subtract(amount);
  }
  
  public void credit(BigDecimal amount) {
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException(...);
    }
    this.balance.add(amount);
  }
}
```

领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。

### 9.5 辩证思考与灵活应用

对于虚拟钱包系统的设计与两种开发模式的代码实现，我想你应该有个比较清晰的了解了。不过，我觉得还有两个问题值得讨论一下。

第一个要讨论的问题是：在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？区别于 Domain 的职责，Service 类主要有下面这样几个职责。

1、Service 类负责与 Repository 交流。在我的设计与代码实现中，VirtualWalletService 类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。

这里我再稍微解释一下，之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。

2、Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。

3、Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。

第二个要讨论问题是：在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？

答案是没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。尽管这样的设计是一种面向过程的编程风格，但我们只要控制好面向过程编程风格的副作用，照样可以开发出优秀的软件。那这里的副作用怎么控制呢？

就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

我们再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。

### 黑板墙

这两节课中对于 DDD 的讲解，都是我的个人主观看法，你可能会有不同看法。

我对 DDD 的看法就是，它可以把原来最重的 service 逻辑拆分并且转移一部分逻辑，可以使得代码可读性略微提高，另一个比较重要的点是使得模型充血以后，基于模型的业务抽象在不断的迭代之后会越来越明确，业务的细节会越来越精准，通过阅读模型的充血行为代码，能够极快的了解系统的业务，对于开发来说能说明显的提升开发效率。在维护性上来说，如果项目新进了开发人员，如果是贫血模型的 service 代码，无论代码如何清晰，注释如何完备，代码结构设计得如何优雅，都没有办法第一时间理解系统的核心业务逻辑，但是如果是充血模型，直接阅读充血模型的行为方法，起码能够很快理解 70% 左右的业务逻辑，因为充血模型可以说是业务的精准抽象，我想，这就是领域模型驱动能够达到「驱动」效果的由来吧。2019-11-29

理解 OOP，我们就不难理解 DDD。1）DDD 第一原则：将数据和操作结合。（贫血模型将数据和操作分离，违反 OOP 的原则。）2）DDD 第二原则：界限上下文。这是将「单一指责」应用于我们的领域模型。DDD is nothing more than OOP applied to business models. DDD 其实就是把 OOP 应用于业务模型。实现：1）使用通用语言（Ubiquitous Language）：类、方法、字段的命名，要符合业务。使用业务语言命名，以后在和客户或者其他团队交流时能够更顺畅。2）理解系统业务：例如做一个理财系统，要亲自去和银行卖理财产品的人聊聊或者买个理财产品之后，那些数据库中对你来说毫无意义的字段才变得有血有肉。介绍一篇博客吧：[DDD 101 — The 5-Minute Tour. I like crazy challenges. | by Gérald Croës | The Coding Matrix | Medium](https://medium.com/the-coding-matrix/ddd-101-the-5-minute-tour-7a3037cf53b8)。2019-11-29

看到这里，感觉才真正理解充血模型的作用：真正的业务逻辑都放在充血的领域对象中，与具体使用什么框架（比如 Spring，MyBatis），具体使用什么数据库无关。这样有利于保护领域对象中的数据，比如钱包中的余额，当有入账和出账操作时，余额在领域对象中自动执行加减操作，而不是将余额暴露在 Service 中直接操作（这样很容易出错可能导致帐不平衡，余额应该封装保护起来），当然「余额自动增减」这只是一个简单的业务逻辑例子，业务逻辑越复杂就越应该封装到领域对象中。

1、Service 层只是一个中间层，起到连接和组合作用。用于支持领域模型层和 Repository 层的交互（连接作用），利用各种领域对象执行业务逻辑（组合作用）。比如通过 Repository 查出数据，将数据转换为领域模型对象，利用领域模型对象执行业务逻辑（核心），然后调用 Repository 更新领域模型中的数据。

2、Service 类还负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等。不允许 Service 中的逻辑过于复杂，如果 Service 中的组合的业务逻辑过于复杂，我们就要将这业务逻辑抽取出一个新的领域对象进行封装，通过调用这个领域对象来进行这些复杂的操作。由于 controller 和 Repository 层中本身没有什么业务逻辑，controller 中的 Vo 对象实际上只是传输数据使用（数据从系统传输数据到外部调用方），Repository 中的 Entity 本质上也只是传输数据（数据从数据库中传输数据到系统），所以用贫血模型不会带来副作用，是没有问题的。2019-11-30

这两天一直在思考 ddd，就等课程更新，这样一说就理解了，domain 模型使用充血模型设计，使之具备独立性，而业务无关的 vo，po 就可以使用贫血模型进行设计，因为不涉及具体复杂业务，如果 control 层需要调用多个领域模型，则把相关的领域服务组合在一起，这里有个小问题，就是 do 转为 dto 这个过程，应该是在应用层完成还是领域层完成，如果在应用层完成，好像属于把领域模型暴露出去了，希望老师可以在指点一下。2019-11-29

汇总：1）DDD 真正的价值在于战略设计，对业务模型到领域模型的建模时需要重点关注的有哪些，比如确定核心服务（核心域、通用域、支撑域）、微服务边界（领域、子域）、领域边界（限界上下文），功能归类（聚合）等等。而战略设计最终的目的仍然是说过来说过去的那些，高内聚、低耦合、面向对象设计、职责单一、易扩展、易维护、易拆分、易演进。2）DDD 战术设计是一种实施的方法论，但是因为他是看的见、摸得着（有真正所谓的代码结构可以参考）的，吸引了更多的关注点，如果没有背后的战略设计的思想，生搬硬套，甚至可能会适得其反。3）DDD 最重要的还是设计思想，也就是战略设计，而不是他的模式或者分层方式，也就是战术设计！2019-11-30

看了老师的这篇文章让我对 entity，bo，vo 有了一个更清晰的认识。我是这样理解的，entity 是对数据库的映射，vo 是前端展示的映射，bo 在 DDD 充血模型中我看到了他的用处，看起来他是将 entity 的一些逻辑业务分离了出来做了一个解耦（在我看来貌似没有 bo 或者说 Domain 类似 加余额减余额的逻辑也可以写在 entity 中，只是这样做对于专注于数据库的 entity 来说逻辑更复杂了，维护起来会很困难 ），同时也解决了 entity 暴露过多 getter setter 方法的问题。不知道我这样理解有没有问题，欢迎老师指正。

同时我有如下几个疑问：1）具体上 domain 和 entity 属性和结构上有哪些不同呢？（在我看来好像能写成一样的）2）在贫血模型下 bo 的作用好像没有那么明显了，多写一层 bo 能给我们带来什么好处呢？3）entity bo vo 类属性上好像有很多重合，貌似在实际编写的过程会出现很多重复代码，并且要为每一层编写转换代码，代码量好像又增加了，对于这种情况应该怎么优化和权衡呢？2019-11-29

两个问题：1）Entity 转换成 Domain 的代码应该在哪一层实现？感觉在 Service 层不大合适，因为可能多个 Service 会使用到。2）如果涉及到表单的保存，入参是一个保存全量数据的对象 (比如，创建一个新用户的所有用户数据，但部分属性还是要计算得到的，比如年龄等)。这个对象是属于 VO 吗？这时的 Domain 怎么设计呢？数据模型间的转换怎么处理呢？VO -> BO -> Entity 感觉就是在写各种赋值语句啊，所以我以前在传统开发模式是合并 VO、BO、Entity 的，一个大而全的东西也是很尴尬。2019-11-29

有一个人问题不太懂，数据持久的话，没有 set、get 方法，如何进行持久化？作者回复：如果你用 orm 框架持久化，必须有 get、set，那就要妥协。2019-12-18

总结（直接忽略案例）：1）充血模型把业务逻辑放到 Domain 中处理，满足了 OOP 的规则，数据和行为封装为一体。类似于 CPU 主管计算，而对于数据转换之类的工作不应该交由 Domain 去做。把外围事务交给 Service 管理，比如接口传入的数据封装，底层数据库数据的读写，就好像 CPU 从来不关心 IO 的差异；比如把日志和消息幂等性等工作交给 Service 处理，CPU 也从来不负责监控和容错。2）自己的感受：这种业务相关性和业务无关性的分离，其实就是遵循了高内聚、低耦合，保证了业务和框架的独立性和重用性。3）问题：无论 vo 还是 Entity 在我看来都是 dto ，这么多 dto 会不会导致类爆炸？大概 4、5 年前，我用过两天 aws 的 sdk ，我记得所有的接口都会有对应的 dto ，所以这种类爆炸是必要的类爆炸，还是也是要自己权衡？类似关联查询返回的结果也算是 Entity 吧，Entity 未必和表一一对应吧（额，感觉不应该在这章提问）？2019-12-03

看完自己实现的时候有个疑问，每次实例化 VirtualWallet 时候他的 balance 都会被初始化为 0，我又不想把 balance set 的方法暴露出来，但是如果 Domain 不跟 Repository 层交互的话，就无法获取到当前其中的余额。请问下老师是否只能在构造函数中传入这一种办法？作者回复：可以放到构造函数中。2019-12-02

私以为在实践中 Wallet 调用 Repo 会让代码更简洁，老师担忧的与具体框架耦合的问题，可以让模型依赖仓储的抽象，从设计上并没有对模型产生污染，只是需要在利用切面或其他手段对持久层接口进行实现，这样看来虽然是必须依赖某种框架技术才能将整个模型跑起来，但实践中，只要是大规模系统，IoC/AOP 这种东西都是很基础的吧，总不能一个系统全都用 rt.jar 里的东西来实现，所有代码全都是一层层规规矩矩的对象创建和方法调用吧。service（负责编排 domain） -> domain（负责业务逻辑） -> repo（负责持久化），这样的三层单向调用不是更简洁么？我对 DDD 理解不深，不知道这样的看法对不对。2020-01-12

个人认为充血模型的好处有如下：1）数据与操作结合，而不是隔离，符合 oop 原则，而非数据驱动。2）关注点分离，或者说单一原则。充血模型包含的逻辑就是与该模型紧密相关的。3）领域模型是系统最为稳定的一层，当系统复杂后，也是作为微服务拆分的依据。因此模型的服用度很高。但是充血模型的难点是：业务复杂后，什么样的逻辑最适合放到模型中？一旦不符合规范，那么充血模型就会变成胀血模型，难以维护。还有一种设计方式：充血模型对外提供的是领域服务（充血的领域模型如果是聚合根的话），而文中的 service 实际上是应用服务，串联多个领域服务以及其他组件功能，实现完整业务逻辑。实际上我们可以抽出 biz-service 业务服务，和 core-service 领域服务。将充血模型的大部分逻辑放到 core-service。这样也很清晰，不至于模型内部的逻辑过于复杂。老师怎么看呢？2019-12-10

看完这篇对 DDD 也有了初步的认识了，区别了贫血模式的开发，DDD 应用 OOP 的设计实现提高了封装性，在业务对象类 VirtualWallet 中封装数据和基本的数据处理过程，service 使用业务对象类暴露的方法过程以完成完整的功能。实现上业务对象类具备的封装，单一职责等特性，这样在易用，易维护，易扩展，易读等方面较之贫血模型都会有提高。

另外有两个问题请教下老师：1）贫血模型的 service 中有 VirtualWalletRepository，VirtualWalletTransactionRepository 两个 repository，看字面应该是区分是否带事务，不太明白这样写的好处或用意？因为我现在一般是直接在 service 上直接加事务。2）钱包交易流水和虚拟钱包的交易流水的功能区分还不是特别清楚，示例代码也没有体现。事物一致性的日子记录不能直接用钱包交易流水线吗？作者回复: 1、transaction 能处理分布式事务。2、再看遍文章吧，都有讲到。2019-12-03

看了下项目代码，service 里的方法多数都是获取对象列表，对象入库，删除，很多方法都不是具体某个对象的某个动作，不像余额加减一样，是一个动作，对应某个属性的变化。感觉是不是用不上 DDD 啊。作者回复：简单的业务确实用不上 ddd。2019-12-03

iOS 端是否可以这样理解：MVVM 中 VM 层相当于 Domain，就 V 层中控制器的业务逻辑抽到了 VM 中，M 层负责数据和数据库操作，因为 M 层数据是对外暴露的依然是贫血。V 层中的 View 相当于文中的 Controller 对外展示数据，只做展示功能，所以可以继续贫血，VM 和 V 双向绑定。因为没有 BO 这种，所以更多的是对控制器数据和业务逻辑的抽离到 VM。而 MVP 也 MVVM 也蛮相似。所以我可以理解 MVVM 和 MVP 算是运用到了充血模型吗？2019-12-02

对于前端同学而言、DDD 是不是类似于 MVVM 啊？只是没有数据绑定的业务映射。作者回复：是的。2019-12-02

之前对领域模型有重大误解，把他做成了类似 repository。现在的理解应该是 domain 是 service 层中抽取出来的一些职责单一的点，数据与行为一体的充血领域类。看到阿里编程规范里面的 manager 层应该就是领域模型层了，controller、service 、manager、dao。不知道我现在的理解是否对了，希望老师指点迷津。作者回复：理解的没问题，不过阿里编程规范里的 manager 我不是很清楚是不是就是 domain 层。2020-06-12

DDD 带来的改善还是体现在复杂业务逻辑上，在简单业务逻辑上的程序能带来的提升很小。其中的思想也是「分久必合，合久必分」。service 类应付简单的业务逻辑时，开发效率高，所有业务逻辑放在一起也没多少行，多于业务逻辑的修改也快。当业务逻辑复杂到一定程度，service 类变得巨大且臃肿，这时必然会带来服务细粒度上的难以重用，复杂的耦合交互。此时意识到可以将服务中的一部分功能定义为领域（Domin）属性，固化相关属性至领域模型中，使得 service 类在调用时的粒度放大，业务逻辑变得更加简单，易读性和可维护性增强。2020-04-28

其实 DDD 的核心思想就是，对象要负责自己状态的维护，因为 BO 的状态比较复杂，同时，BO 的状态其实是一组业务逻辑的映射，所以对于 Service 这一层，在业务相对复杂的时候采用充血模型是比较理想的，而 Controller 和 Repository 层只涉及数据的获取和传输（理想状态下，大部分时候，Controller 层可能要做一些适配前端数据结构的工作，而 Repository 可能就是单纯的获取数据和存储数据），所以没有必要在这两层上采用充血模型。2020-03-14

我感觉 service 层的主要作用还是面向接口编程，用于协议约束，遵循这个协议的 domain 可以任意替换，正常的业务都是在修改的过程中发现某一层变的太厚了，维护性越来越差，这个时候就是需要瘦身了，明确责任，不管怎么改，都不会有最佳实践的，都是最满足当下需求的实践。2020-03-10

## 0110如何对接口鉴权这样一个功能开发做面向对象分析.md

针对框架、类库、组件等非业务系统的开发，其中一个比较大的难点就是，需求一般都比较抽象、模糊，需要你自己去挖掘，做合理取舍、权衡、假设，把抽象的问题具象化，最终产生清晰的、可落地的需求定义。需求定义是否清晰、合理，直接影响了后续的设计、编码实现是否顺畅。所以，作为程序员，你一定不要只关心设计与实现，前期的需求分析同等重要。需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP），是面向对象开发的三个主要环节。在前面的章节中，我对三者的讲解比较偏理论、偏概括性，目的是让你先有一个宏观的了解，知道什么是 OOA、OOD、OOP。不过，光知道「是什么」是不够的，我们更重要的还是要知道「如何做」，也就是，如何进行面向对象分析、设计与编程。

在过往的工作中，我发现，很多工程师，特别是初级工程师，本身没有太多的项目经验，或者参与的项目都是基于开发框架填写 CRUD 模板似的代码，导致分析、设计能力比较欠缺。当他们拿到一个比较笼统的开发需求的时候，往往不知道从何入手。

对于「如何做需求分析，如何做职责划分？需要定义哪些类？每个类应该具有哪些属性、方法？类与类之间该如何交互？如何组装类成一个可执行的程序？」等等诸多问题，都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易扩展、易读等优秀特性的代码了。所以，我打算用两节课的时间，结合一个真实的开发案例，从基础的需求分析、职责划分、类的定义、交互、组装运行讲起，将最基础的面向对象分析、设计、编程的套路给你讲清楚，为后面学习设计原则、设计模式打好基础。

### 10.1 案例介绍和难点剖析

假设，你正在参与开发一个微服务。微服务通过 HTTP 协议暴露接口给其他系统调用，说直白点就是，其他系统通过 URL 来调用微服务的接口。有一天，你的 leader 找到你说，「为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。」

leader 丢下这些话就走了。这个时候，你该如何来做呢？有没有脑子里一团浆糊，一时间无从下手的感觉呢？为什么会有这种感觉呢？我个人觉得主要有下面两点原因。

1、需求不明确。leader 给到的需求过于模糊、笼统，不够具体、细化，离落地到设计、编码还有一定的距离。而人的大脑不擅长思考这种过于抽象的问题。这也是真实的软件开发区别于应试教育的地方。应试教育中的考试题目，一般都是一个非常具体的问题，我们去解答就好了。而真实的软件开发中，需求几乎都不是很明确。

我们前面讲过，面向对象分析主要的分析对象是「需求」，因此，面向对象分析可以粗略地看成「需求分析」。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理，搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。

2、缺少锻炼。相比单纯的业务 CRUD 开发，鉴权这个开发任务，要更有难度。鉴权作为一个跟具体业务无关的功能，我们完全可以把它开发成一个独立的框架，集成到很多业务系统中。而作为被很多系统复用的通用框架，比起普通的业务代码，我们对框架的代码质量要求要更高。

开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力，甚至逻辑思维能力的要求，都是比较高的。如果你平时做的都是简单的 CRUD 业务开发，那这方面的锻炼肯定不会很多，所以，一旦遇到这种开发需求，很容易因为缺少锻炼，脑子放空，不知道从何入手，完全没有思路。

### 10.2 对案例进行需求分析

实际上，需求分析的工作很琐碎，也没有太多固定的章法可寻，所以，我不打算很牵强地罗列那些听着有用、实际没用的方法论，而是希望通过鉴权这个例子，来给你展示一下，面对需求分析的时候，我的完整的思考路径是什么样的。希望你能自己去体会，举一反三地类比应用到其他项目的需求分析中。

尽管针对框架、组件、类库等非业务系统的开发，我们一定要有组件化意识、框架意识、抽象意识，开发出来的东西要足够通用，不能局限于单一的某个业务需求，但这并不代表我们就可以脱离具体的应用场景，闷头拍脑袋做需求分析。多跟业务团队聊聊天，甚至自己去参与几个业务系统的开发，只有这样，我们才能真正知道业务系统的痛点，才能分析出最有价值的需求。不过，针对鉴权这一功能的开发，最大的需求方还是我们自己，所以，我们也可以先从满足我们自己系统的需求开始，然后再迭代优化。

现在，我们来看一下，针对鉴权这个功能的开发，我们该如何做需求分析？实际上，这跟做算法题类似，先从最简单的方案想起，然后再优化。所以，我把整个的分析过程分为了循序渐进的四轮。每一轮都是对上一轮的迭代优化，最后形成一个可执行、可落地的需求列表。

1、第一轮基础分析。对于如何做鉴权这样一个问题，最简单的解决方案就是，通过用户名加密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用 ID、AppID）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都携带自己的 AppID 和密码。微服务在接收到接口调用请求之后，会解析出 AppID 和密码，跟存储在微服务端的 AppID 和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则，就拒绝接口调用请求。

2、第二轮分析优化。不过，这样的验证方式，每次都要明文传输密码。密码很容易被截获，是不安全的。那如果我们借助加密算法（比如 SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上，这样也是不安全的，因为加密之后的密码及 AppID，照样可以被未认证系统（或者说黑客）截获，未认证系统可以携带这个加密之后的密码以及对应的 AppID，伪装成已认证系统来访问我们的接口。这就是典型的「重放攻击」。

提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚这个问题，我们可以借助 OAuth 的验证思路来解决。调用方将请求接口的 URL 跟 AppID、密码拼接在一起，然后进行加密，生成一个 token。调用方在进行接口请求的的时候，将这个 token 及 AppID，随 URL 一块传递给微服务端。微服务端接收到这些数据之后，根据 AppID 从数据库中取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token。用这个新生成的 token 跟调用方传递过来的 token 对比。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。

这个方案稍微有点复杂，我画了一张示例图，来帮你理解整个流程。

3、第三轮分析优化。不过，这样的设计仍然存在重放攻击的风险，还是不够安全。每个 URL 拼接上 AppID、密码生成的 token 都是固定的。未认证系统截获 URL、token 和 AppID 之后，还是可以通过重放攻击的方式，伪装成认证系统，调用这个 URL 对应的接口。

为了解决这个问题，我们可以进一步优化 token 生成算法，引入一个随机变量，让每次接口请求生成的 token 都不一样。我们可以选择时间戳作为随机变量。原来的 token 是对 URL、AppID、密码三者进行加密生成的，现在我们将 URL、AppID、密码、时间戳四者进行加密来生成 token。调用方在进行接口请求的时候，将 token、AppID、时间戳，随 URL 一并传递给微服务端。

微服务端在收到这些数据之后，会验证当前时间戳跟传递过来的时间戳，是否在一定的时间窗口内（比如一分钟）。如果超过一分钟，则判定 token 过期，拒绝接口请求。如果没有超过一分钟，则说明 token 没有过期，就再通过同样的 token 生成算法，在服务端生成新的 token，与调用方传递过来的 token 比对，看是否一致。如果一致，则允许接口调用请求；否则，就拒绝接口调用请求。

优化之后的认证流程如下图所示。

4、第四轮分析优化。不过，你可能会说，这样还是不够安全啊。未认证系统还是可以在这一分钟的 token 失效窗口内，通过截获请求、重放请求，来调用我们的接口啊！

你说得没错。不过，攻与防之间，本来就没有绝对的安全。我们能做的就是，尽量提高攻击的成本。这个方案虽然还有漏洞，但是实现起来足够简单，而且不会过度影响接口本身的性能（比如响应时间）。所以，权衡安全性、开发成本、对系统性能的影响，这个方案算是比较折中、比较合理的了。

实际上，还有一个细节我们没有考虑到，那就是，如何在微服务端存储每个授权调用方的 AppID 和密码。当然，这个问题并不难。最容易想到的方案就是存储到数据库里，比如 MySQL。不过，开发像鉴权这样的非业务功能，最好不要与具体的第三方系统有过度的耦合。

针对 AppID 和密码的存储，我们最好能灵活地支持各种不同的存储方式，比如 ZooKeeper、本地配置文件、自研配置中心、MySQL、Redis 等。我们不一定针对每种存储方式都去做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动。

5、最终确定需求。到此，需求已经足够细化和具体了。现在，我们按照鉴权的流程，对需求再重新描述一下。如果你熟悉 UML，也可以用时序图、流程图来描述。不过，用什么描述不是重点，描述清楚才是最重要的。考虑到在接下来的面向对象设计环节中，我会基于文字版本的需求描述，来进行类、属性、方法、交互等的设计，所以，这里我给出的最终需求描述是文字版本的。

最终需求：1）调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。2）微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。3）微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。4）如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配；如果一致，则鉴权成功，允许接口调用，否则就拒绝接口调用。

这就是我们需求分析的整个思考过程，从最粗糙、最模糊的需求开始，通过「提出问题 - 解决问题」的方式，循序渐进地进行优化，最后得到一个足够清晰、可落地的需求描述。

### 黑板墙

除了工作中我们会遇到需求不明确的开发任务，实际上，在面试中，我们也经常遇到一些开放性的设计问题，对于这类问题，你是如何解答的？有哪些好的经验可以分享给大家呢？

工作中遇到非 crud 的需求我就会想尽一切办法让他通用，基本需求分析和需求设计的时间占用百分之五十，开发和重构到自认为最优占用百分之五十。比如最简单的验证码功能，几乎每个项目都有，我就封装一套验证码服务，主要功能有你在配置文件里配置好需要被验证码拦截的路径，这里还要考虑到通配符，空格等等细节和可扩展的点，内置图片验证码，极验证，手机验证以及自定义验证码等等，总之我认为如果有机会遇到非 crud 的需求，一定要好好珍惜，好好把握，把他打造成属于自己的产品，这样会让自己下意识的去想尽一切办法把他做到最优，亲儿子一样的待遇，再也不会无脑 cv，连变量名可能都要认真的重构一两遍。2019-12-02

一句话：使用进化算法的思想，提出一个 MVP（最小可行性产品），逐步迭代改进。拿到这个需求，假设我们不了解接口鉴权，需求又不明确，我会我自己如下问题：1）什么叫接口鉴权？搞清基本概念。2）接口鉴权最佳实践是什么？技术调研。3）appid 和 secret key 从哪里来？用户自己申请还是我们授权？用户申请是以什么方式申请（网页还是邮件？申请的网页有人做了么？）追问下去。4）appid secretkey 存储在什么地方呢？数据存储。5）用户如何使用？需要为用户提供接口鉴权使用手册和文档，及示例代码。写用户手册，文档。6）这个功能如何测试？提前想好如何测试。7）接口鉴权功能何时上线？估计工期。8）鉴权成功或失败返回码和信息定义？约定返回结果。关于防止重放攻击：请求参数中还可以加入 nonce（随机正整数），两次请求的 nonce 不能重复，timestamp 和 nonce 结合进一步防止重放攻击。2019-12-02

OAuth 2.0 + 网关（如 Zuul）+ 认证中心 + AOP 可以实现。极客时间《微服务架构实战 160 讲》里介绍了 OAuth 2.0 企业级的解决方案，小争哥的方案适合快速落地。实际业务中如果安全等级没这么高，直接生成 Token 鉴权就可以。通过业务模型规避风险：1）充值类业务，就算对方篡改接口，最终结果可以通调用证金融机构的接口验证是否有效，不会给公司带来损失。2）如果安全等级非常高，比如提现、转账可以通过发送手机短信，确保是本人操作。3）如果是商品信息查询类接口，防止第三方爬取数据，可以在调用一定次数后加入「人机验证」（输入图片识别码、拼图）。4）根据 IP 限制访问次数。5）服务器间调用可以绑定 mac 地址、IP。6）服务器、客户端通过架设私有 VPN 进行通信，将安全问题转移到 VPN 上，降低业务复杂度的同时还可以避免加解密带来的性能损耗，提升性能。7）调用接口时通过付费方式（如实名认证、银行四要素验证这些调用一次都是要收费的），防止恶意调用。8）通过独立加密硬件（如 U 盾）+ 独立密码验证器（Google 验证器）+ 语音识别 + 面部识别（刷脸支付） + 指纹 + 多人同时输入动态秘钥（核打击时发射程序）。9）安全性会降低系统性能适可而止。极客时间《左耳听风》专栏中介绍了亚马逊在设计开发微服务时，就已经做好了随时对外网开放的准备，由于没有阅读完整个专栏，不知道后面有没有详细介绍。2019-12-03

光拼 url 是不够的，只能覆盖如 HTTP GET 一类参数在 url 中的请求，对于如 POST 和 PUT 一类的请求，因为参数通常在 body 中，就没有参与 token 的生成。又因为这样的方案存在允许重放请求的时间间隔，就可能导致的情况是中间人截获了请求，在允许重放的时间间隔内任意修改 body 中的参数后发送，让接口鉴权形同虚设。

这个需求去年我就做过，给自己系统的对外接口开发一个鉴权的功能。因为之前了解过 oauth2，当时就直接想到了 oauth2 鉴权来实现，就去学习了下，然后选择了「客户端模式」来实现，给各个应用分配 appid 和 appsecrete，客户端拿 appid 和 appsecrete 请求有一定时效的 token，应用拿到 token 后再跟 appid 和 appsecrete 一起来请求接口，服务端鉴权通过后即可调用。老师的例子是客户端定开始时间，我做的是服务端定开始时间。不过当时分析的时候没有意识去一步步分析，就是一下子想起来就去做了，也没有去想着做什么优化，以后在遇到这种问题，应该多去分析，思考，才能让设计更优。2019-12-02

像今天的例子中，如果老板给我这样的需求，我第一反应就是去想怎么实现，用什么技术实现，有什么现成的框架，而不是去先思考「用户名密码登录验证」这最基础的第一步。刚开始脑子就一团浆糊，知道完成也是在便实现便理思路，这样浪费时间而且最后也没有自己完整的思路过程。以后还是要先理清思路，理清需求再去考虑每一小需求实现的技术。2019-12-02

一般遇到这种需求不是特别明确的，先自己理解第一遍需求，有一个大概的思路，然后在和产品经理确认是不是这样。需求确认之前在按照争哥说的需求分析，对需求做任务分解，将需求分解成一个个小的任务点，每个小任务都是很容易执行的。就算开发过程中被打断了，也不要紧。任务分解的尽量小，这样重新回到开发状态也就越容易。2019-12-02

防止重放攻击的方案在老师的基础做进一步的迭代设计：1）要求客户端生成一个唯一的请求 id，如以 uuid 方式。2）客户端在以 sha 等加密哈希方式生成 token 时，也将请求 id 加入其中。3）客户端也要将请求 id 作为参数传递到服务端，如果是 rest api 就是也要将请求 id 拼接到 url 参数中。4）服务端检查服务端的缓存中 (可以是 redis) 是否有客户端传递的请求 id，如果有，则判定为重放攻击，拒绝请求。如果没有，则将请求 id 放到缓存中同时设置在 token 失效的时间窗内缓存的请求 id 自动失效（如 redis key 的 TTL）。

这个实现思路是：在时间窗内的重放攻击，以服务端在时间缓存了在时间窗内的所有请求 id 的形式来防护，而在时间窗外的重放攻击就是老师的方案中检查客户端传过来的时间 (时间戳) 和服务端当前时间 (时间戳) 相减的绝对值不能超过时间窗的长度来实现。另外，时间戳、请求 id 等都 hash 在了 token 中，所有客户端是无法篡改的。

这个实现思路的缺点是：改实现方案要求客户端的时间和服务端的时间之间的差距不能超过时间窗，如果时间窗设置为 1 分钟这种比较小的，则要求客户端时间和服务端时间不能超过 1 分钟，这个有点苛刻，比如客户端如 app 所在的手机的时间不准确了，但就差 1 分钟，将无法访问接口。如果时间窗设置过长，如 30 分钟，则要求服务端缓存中缓存最近 30 分钟的请求 id，如果接口的访问并发挺大的话，缓存占用空间也将很大，需要评估。2019-12-05

我们公司有个重构项目，也是要最客户端鉴权，但是旧客户端没有做 token 之类的鉴权传 token，但现在要做，如何做到兼容旧客户端做鉴权呢？作者回复：后端可以对没有传递 token 的不做校验。2019-12-02

有个问题：通过同样的 token 生成算法，在服务端生成新的 token，与调用方传递过来的 token 比对。这个做法是不是有点多余？ 能把 token 解密难道不能说明 token 没有问题么？作者回复: token 是单向加密算法生成的，无法解密的。2019-12-02

这个鉴权功能需求分析的很好，但是和面向对象分析没有多大关系吧。作者回复：我理解的面向对象分析，就是需求分析。2019-12-04

时间戳要不要拼接在 url 里产生 token 应该都可以吧？服务端反正是按照 url 里解析的时间戳去过滤的。作者回复：放到里面的目的是让每次生成的 token 都不一样。2019-12-02

client 端生成的 token 在时间窗口内，假如用户在操作中停留了 1 分钟（时间窗口），那 token 就过期了吗？作者回复：是要发送请求到服务器的时候才生成 token。2019-12-02

本次以接口鉴权展示乐面向对象编程的一般流程：也就是进行面向对象得需求分析，将模糊的需求细化为可落地的具体的需求，可以按照最小可行性产品思维思考，到底是什么才是该需求要解决问题，需要哪些功能，分别用来做什么的，如果有专业术语也要搞清楚与需求本身的联系，逐步讲抽象的描述具体化流程化。要提醒自己，你理解的需求和 PD 写的需求可能不是同一个东西，一定要多沟通确认清楚，随着业务复杂度的增加，我们需要深入理解业务，业务都理解不清楚妄谈领域驱动设计是毫无意义的，画图是一个很好理解业务的方法，大部分时候我们可能只负责某一个模块，但是如果跳出来主动去看整个业务链路你理解的深度也会加深。2020-02-27

我记得我之前面试一家公司的时候，面试官曾经出过一个问题，如何保证在一台电脑上不同的浏览器，只要有一个浏览器登陆的账号，其他浏览器在登录的时候也可以做到直接登陆呢。针对这种比较笼统的需求的时候，我一开始给出的想法是请求服务端的时候利用请求者的 IP 地址，如果他的 IP 地址在我们的数据库中存储了，那么就直接进行登录，如果发现了异地存储，再利用手机号验证这种方式，将数据库里面的登录 IP 改为新的 IP，但是这样的话，无法防止攻击者伪装他人的 IP 地址进行登录，于是乎我联想一下我能不能在本机上，保存一个文件，然后每次无论什么浏览器去访问的时候都去读取这个文件，并且带的文件上面的信息去直接请求，直白说就是账号密码，后来我想到了 host 文件，因为一般来说 host 的文件都是将网站名和网站的真实 IP 进行相映射的，那么我们可以在用户登录的时候去读取 host 文件，当然再过于具体的实现我没有给出，这只是我的一个思路，后来面试官说这也算是一种实现思路，不过就是比较流氓。也不知道大家有什么更好的实现思路。2020-02-20

## 0111 如何利用面向对象设计和编程开发接口鉴权功能.md

面向对象分析的产出是详细的需求描述。面向对象设计的产出是类。在面向对象设计这一环节中，我们将需求描述转化为具体的类的设计。这个环节的工作可以拆分为下面四个部分。1）划分职责进而识别出有哪些类。根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。2）定义类及其属性和方法。我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。3）定义类与类之间的交互关系。UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。4）将类组装起来并提供执行入口。我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main() 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。

在上一节课中，针对接口鉴权功能的开发，我们讲了如何进行面向对象分析（OOA），也就是需求分析。实际上，需求定义清楚之后，这个问题就已经解决了一大半，这也是为什么我花了那么多篇幅来讲解需求分析。今天，我们再来看一下，针对面向对象分析产出的需求，如何来进行面向对象设计（OOD）和面向对象编程（OOP）。

### 11.1 如何进行面向对象设计？

我们知道，面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。在面向对象设计环节，我们将需求描述转化为具体的类的设计。我们把这一设计环节拆解细化一下，主要包含以下几个部分：1）划分职责进而识别出有哪些类；2）定义类及其属性和方法；3）定义类与类之间的交互关系；4）将类组装起来并提供执行入口。

实话讲，不管是面向对象分析还是面向对象设计，理论的东西都不多，所以我们还是结合鉴权这个例子，在实战中体会如何做面向对象设计。

#### 11.1.1 划分职责进而识别出有哪些类

在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。所以，大多数讲面向对象的书籍中，还会讲到另外一种识别类的方法，那就是把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。对于没有经验的初学者来说，这个方法比较简单、明确，可以直接照着做。

不过，我个人更喜欢另外一种方法，那就是根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。我们来看一下，针对鉴权这个例子，具体该如何来做。

在上一节课中，我们已经给出了详细的需求描述，为了方便你查看，我把它重新贴在了下面。1）调用方进行接口请求的时候，将 URL、AppID、密码、时间戳拼接在一起，通过加密算法生成 token，并且将 token、AppID、时间戳拼接在 URL 中，一并发送到微服务端。2）微服务端在接收到调用方的接口请求之后，从请求中拆解出 token、AppID、时间戳。3）微服务端首先检查传递过来的时间戳跟当前时间，是否在 token 失效时间窗口内。如果已经超过失效时间，那就算接口调用鉴权失败，拒绝接口调用请求。4）如果 token 验证没有过期失效，微服务端再从自己的存储中，取出 AppID 对应的密码，通过同样的 token 生成算法，生成另外一个 token，与调用方传递过来的 token 进行匹配。如果一致，则鉴权成功，允许接口调用；否则就拒绝接口调用。

首先，我们要做的是逐句阅读上面的需求描述，拆解成小的功能点，一条一条罗列下来。注意，拆解出来的每个功能点要尽可能的小。每个功能点只负责做一件很小的事情（专业叫法是「单一职责」，后面章节中我们会讲到）。下面是我逐句拆解上述需求描述之后，得到的功能点列表：1）把 URL、AppID、密码、时间戳拼接为一个字符串；2）对字符串通过加密算法加密生成 token；3）将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；4）解析 URL，得到 token、AppID、时间戳等信息；5）从存储中取出 AppID 和对应的密码；6）根据时间戳判断 token 是否过期失效；7）验证两个 token 是否匹配；

从上面的功能列表中，我们发现，1、2、6、7 都是跟 token 有关，负责 token 的生成、验证；3、4 都是在处理 URL，负责 URL 的拼接、解析；5 是操作 AppID 和密码，负责从存储中读取 AppID 和密码。所以，我们可以粗略地得到三个核心的类：AuthToken、Url、CredentialStorage。AuthToken 负责实现 1、2、6、7 这四个操作；Url 负责 3、4 两个操作；CredentialStorage 负责 5 这个操作。

当然，这是一个初步的类的划分，其他一些不重要的、边边角角的类，我们可能暂时没法一下子想全，但这也没关系，面向对象分析、设计、编程本来就是一个循环迭代、不断优化的过程。根据需求，我们先给出一个粗糙版本的设计方案，然后基于这样一个基础，再去迭代优化，会更加容易一些，思路也会更加清晰一些。

不过，我还要再强调一点，接口调用鉴权这个开发需求比较简单，所以，需求对应的面向对象设计并不复杂，识别出来的类也并不多。但如果我们面对的是更加大型的软件开发、更加复杂的需求开发，涉及的功能点可能会很多，对应的类也会比较多，像刚刚那样根据需求逐句罗列功能点的方法，最后会得到一个长长的列表，就会有点凌乱、没有规律。针对这种复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，应用我们刚刚讲的方法，进行面向对象设计。而模块的划分和识别，跟类的划分和识别，是类似的套路。

### 11.1.2 定义类及其属性和方法

刚刚我们通过分析需求描述，识别出了三个核心的类，它们分别是 AuthToken、Url 和 CredentialStorage。现在我们来看下，每个类都有哪些属性和方法。我们还是从功能点列表中挖掘。

AuthToken 类相关的功能点有四个：1）把 URL、AppID、密码、时间戳拼接为一个字符串；2）对字符串通过加密算法加密生成 token；3）根据时间戳判断 token 是否过期失效；4）验证两个 token 是否匹配。

对于方法的识别，很多面向对象相关的书籍，一般都是这么讲的，识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词，作为候选属性，然后同样进行过滤筛选。我们可以借用这个思路，根据功能点描述，识别出来 AuthToken 类的属性和方法，如下所示：

从上面的类图中，我们可以发现这样三个小细节。

第一个细节：并不是所有出现的名词都被定义为类的属性，比如 URL、AppID、密码、时间戳这几个名词，我们把它作为了方法的参数。

第二个细节：我们还需要挖掘一些没有出现在功能点描述中属性，比如 createTime，expireTimeInterval，它们用在 isExpired() 函数中，用来判定 token 是否过期。

第三个细节：我们还给 AuthToken 类添加了一个功能点描述中没有提到的方法 getToken()。

第一个细节告诉我们，从业务模型上来说，不应该属于这个类的属性和方法，不应该被放到这个类里。比如 URL、AppID 这些信息，从业务模型上来说，不应该属于 AuthToken，所以我们不应该放到这个类中。

第二、第三个细节告诉我们，在设计类具有哪些属性和方法的时候，不能单纯地依赖当下的需求，还要分析这个类从业务模型上来讲，理应具有哪些属性和方法。这样可以一方面保证类定义的完整性，另一方面不仅为当下的需求还为未来的需求做些准备。

Url 类相关的功能点有两个：1）将 token、AppID、时间戳拼接到 URL 中，形成新的 URL；2）解析 URL，得到 token、AppID、时间戳等信息。

虽然需求描述中，我们都是以 URL 来代指接口请求，但是，接口请求并不一定是以 URL 的形式来表达，还有可能是 Dubbo、RPC 等其他形式。为了让这个类更加通用，命名更加贴切，我们接下来把它命名为 ApiRequest。下面是我根据功能点描述设计的 ApiRequest 类。

CredentialStorage 类相关的功能点有一个：从存储中取出 AppID 和对应的密码。

CredentialStorage 类非常简单，类图如下所示。为了做到抽象封装具体的存储方式，我们将 CredentialStorage 设计成了接口，基于接口而非具体的实现编程。

#### 11.1.3 定义类与类之间的交互关系

类与类之间都哪些交互关系呢？UML 统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。关系比较多，而且有些还比较相近，比如聚合和组合，接下来我就逐一讲解一下。

1、泛化（Generalization）可以简单理解为继承关系。具体到 Java 代码就是下面这样：

```java
public class A { ... }
public class B extends A { ... }
```

2、实现（Realization）一般是指接口和实现类之间的关系。具体到 Java 代码就是下面这样：

```java
public interface A {...}
public class B implements A { ... }
```

3、聚合（Aggregation）是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
```

4、组合（Composition）也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：

```java
public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
```

5、关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。具体到 Java 代码就是下面这样：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
或者
public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
```

6、依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。具体到 Java 代码就是下面这样：

```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
或者
public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
或者
public class A {
  public void func(B b) { ... }
}
```

看完了 UML 六种类关系的详细介绍，不知道你有何感受？我个人觉得这样拆分有点太细，增加了学习成本，对于指导编程开发没有太大意义。所以，我从更加贴近编程的角度，对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖，这样你掌握起来会更加容易。

其中，泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。之所以这样重新命名，是为了跟我们前面讲的「多用组合少用继承」设计原则中的「组合」统一含义。只要 B 类对象是 A 类对象的成员变量，那我们就称，A 类跟 B 类是组合关系。

理论的东西讲完了，让我们来看一下，刚刚我们定义的类之间都有哪些关系呢？因为目前只有三个核心的类，所以只用到了实现关系，也即 CredentialStorage 和 MysqlCredentialStorage 之间的关系。接下来讲到组装类的时候，我们还会用到依赖关系、组合关系，但是泛化关系暂时没有用到。

#### 11.1.4 将类组装起来并提供执行入口

类定义好了，类之间必要的交互关系也设计好了，接下来我们要将所有的类组装在一起，提供一个执行入口。这个入口可能是一个 main () 函数，也可能是一组给外部用的 API 接口。通过这个入口，我们能触发整个代码跑起来。

接口鉴权并不是一个独立运行的系统，而是一个集成在系统上运行的组件，所以，我们封装所有的实现细节，设计了一个最顶层的 ApiAuthenticator 接口类，暴露一组给外部调用者使用的 API 接口，作为触发执行鉴权逻辑的入口。具体的类的设计如下所示：

### 11.2 如何进行面向对象编程？

面向对象设计完成之后，我们已经定义清晰了类、属性、方法、类之间的交互，并且将所有的类组装起来，提供了统一的执行入口。接下来，面向对象编程的工作，就是将这些设计思路翻译成代码实现。有了前面的类图，这部分工作相对来说就比较简单了。所以，这里我只给出比较复杂的 ApiAuthenticatorr 的实现。

对于 AuthToken、ApiRequest、CredentialStorage 这三个类，在这里我就不给出具体的代码实现了。给你留一个课后作业，你可以试着把整个鉴权框架自己去实现一遍。

```java

public interface ApiAuthenticator {
  void auth(String url);
  void auth(ApiRequest apiRequest);
}

public class DefaultApiAuthenticatorImpl implements ApiAuthenticator {
  private CredentialStorage credentialStorage;
  
  public DefaultApiAuthenticatorImpl() {
    this.credentialStorage = new MysqlCredentialStorage();
  }
  
  public DefaultApiAuthenticatorImpl(CredentialStorage credentialStorage) {
    this.credentialStorage = credentialStorage;
  }

  @Override
  public void auth(String url) {
    ApiRequest apiRequest = ApiRequest.buildFromUrl(url);
    auth(apiRequest);
  }

  @Override
  public void auth(ApiRequest apiRequest) {
    String appId = apiRequest.getAppId();
    String token = apiRequest.getToken();
    long timestamp = apiRequest.getTimestamp();
    String originalUrl = apiRequest.getOriginalUrl();

    AuthToken clientAuthToken = new AuthToken(token, timestamp);
    if (clientAuthToken.isExpired()) {
      throw new RuntimeException("Token is expired.");
    }

    String password = credentialStorage.getPasswordByAppId(appId);
    AuthToken serverAuthToken = AuthToken.generate(originalUrl, appId, password, timestamp);
    if (!serverAuthToken.match(clientAuthToken)) {
      throw new RuntimeException("Token verfication failed.");
    }
  }
}
```

### 11.3 辩证思考与灵活应用

在之前的讲解中，面向对象分析、设计、实现，每个环节的界限划分都比较清楚。而且，设计和实现基本上是按照功能点的描述，逐句照着翻译过来的。这样做的好处是先做什么、后做什么，非常清晰、明确，有章可循，即便是没有太多设计经验的初级工程师，都可以按部就班地参照着这个流程来做分析、设计和实现。

不过，在平时的工作中，大部分程序员往往都是在脑子里或者草纸上完成面向对象分析和设计，然后就开始写代码了，边写边思考边重构，并不会严格地按照刚刚的流程来执行。而且，说实话，即便我们在写代码之前，花很多时间做分析和设计，绘制出完美的类图、UML 图，也不可能把每个细节、交互都想得很清楚。在落实到代码的时候，我们还是要反复迭代、重构、打破重写。

毕竟，整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程。我们没法严格地按照顺序执行各个步骤。这就类似你去学驾照，驾校教的都是比较正规的流程，先做什么，后做什么，你只要照着做就能顺利倒车入库，但实际上，等你开熟练了，倒车入库很多时候靠的都是经验和感觉。

### 黑板墙

软件设计的自由度很大，这也是软件的复杂之处。不同的人对类的划分、定义、类之间交互的设计，可能都不大一样。那除了我今天给出的设计思路，你还有没有其他设计思路呢？

争哥拆分需求、组织类和方法的思考过程值得我们学习。我想到的实现过程是按照用户发送请求通过鉴权和未通过鉴权的流程写：1）先写接口 auth (String url) ，这里先定义好请求的格式，例如「xxx?AppID=123&Token=aaa&TimeStamp=123123」。2）ApiRequest 类，解析请求。3）AuthToken 类，判断是否过期、token 匹配、校验 token。4）CredentialStorate 类，获取 AppID 对应的 password。具体实现见：[Algorithms4/geekbang/designpattern/u014 at master · gdhucoder/Algorithms4](https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u014)。2019-12-04

前一个项目我也完整的实现了整个鉴权流程，需求分析阶段可以说和小争哥分析的功能点几乎一样，拼接参数，进行加密，验证 token，验证时间。可到了编程阶段，我还是按照面向过程的方式，拆了几个方法，把功能就实现了。今天给我了一个深刻的感悟，面向对象编程，听起来并不复杂，但他真正的难点在于我学了这么多，对于下一个功能，是不是能够用面向对象的方式来把功能实现。如何做到学以致用，是我们学会知识后，接下来要考虑的问题。2019-12-04

设计了一个最顶层的 ApiAuthencator 接口类，为什么要设计出一个顶层的接口，虽然是面向接口编程，但是写成接口，意味着还会有其他的不同实现吗，如果有其他不同的实现，那么接口中的第二个参数的 ApiRequest 也不一定会适用不同的那个实现的传参，不知道说明白没有。作者回复：你说得很好，多谢指出啊，确实没必要搞个接口，ApiRequest 的设计也依赖了具体的 url 实现，所以也不是很通用。2019-12-04

汇总：1）token 加密采用 md5。2）执行测试类即可。上代码：[geek-design: 设计模式之美-学习库](https://gitee.com/MondayLiu/geek-design)。2019-12-05

用这种需求分析需求设计的方式，你告诉我一个方法怎么可能超过五十行？编程规范都说方法单个不超过五十行，八十行的。到头来为什么还是超过？就是因为之前都是面向过程编程，token，url 等操作都放到一个类的一个方法里面，要全面相过程编程。争哥的这种需求分析需求设计的方式值得学习和效仿，真的香！2019-12-04

采用什么方式，要看做的需求有多复杂。1）如果是日常的维护和升级，我目前的开发模式是：拿到需求后先理解需求，包括业务用例、整体交互、通过这俩分析出系统用例：大多数情况是对现有系统的改造和升级，因此还需要考虑对现有功能的影响，依次加入回归用例。拿到用例之后再进行分析和设计，设计的时候最核心的图是时序图、活动图和状态图，类图反而用得不多，看起来自己目前是 TDD 下的过程式编程。2）如果是一个完整的项目，或者说是超过两周的迭代，就会再加一层系统设计、模块设计的环节，然后按照前面的流程细化执行。2019-12-09