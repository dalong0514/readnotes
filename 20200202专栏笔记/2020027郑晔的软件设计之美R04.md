# 2020027郑晔的软件设计之美R04

## 记忆时间

## 0500. 设计方法

1、建立一套业务人员和开发人员共享的通用语言。

2、战略设计，就是将不同的模型进行分组。

3、战术设计，就是按照模板寻找相应的模型。

## 0501. 领域驱动设计：如何从零开始设计一个软件？

我们讲了领域驱动设计，这是目前在软件行业内最符合软件发展趋势的一种设计方法，因为它把软件设计的起始点从技术拉到了业务。学习领域驱动设计，我们要从通用语言和模型驱动设计入手。通用语言是在业务人员和技术人员之间建立一套共有的语言，开发通用语言的一种实践是事件风暴，这是一种工作坊，通过识别领域事件找到引发事件的命令，找出与事件和命令相关的实体或聚合，帮助团队建立通用语言。DDD 的模型设计可以分为战略设计和战术设计。战略设计是高层设计，将系统拆分成领域，战术设计是低层设计，考虑如何组织不同的模型。

1『事件与命令相关的实体和聚合；战略设计将系统拆分成领域、战术设计考虑如何组织不同的模型。』

在前面的内容中，我给你讲了软件设计的各种基本工具。我们学习了程序设计语言，知道怎样把设计更好地落地；学会了各种编程范式，知道了可以用什么样的元素去做设计；我们还学习了设计原则与模式，知道了怎样组合分解出来的各个元素。工具都有了，理论也武装上了，那么我们该如何实践呢？或者说，我要去分解组合的东西是从哪而来的呢？这就需要你对设计方法有一个基本的认知了，也就是说，我们要理解，在真实世界中，解决具体问题是怎样的一个过程。那从这一讲开始，我们就来谈谈设计方法的话题，一起了解一下设计的基本过程。

首先，你知道哪些设计方法呢？我知道的一种做法是，有些人一上来会先设计数据库，因为他们觉得，程序就是数据加函数。数据呢，就要存到数据库里，剩下的就是根据需要对数据库表进行增删改查。但是从我们之前的讲解中，你可以看出，这种思路实际上是一种结构化编程的思路。

后来有人就用面向对象的思路，先来找实体，也就是对象，当然这些实体也要有一些能力。最终，这些对象还是要写到数据库里，同样也是要提供增删改查的能力。你看，这两种做法本质上没什么太大的区别，都是围绕着数据在做文章。在业务需求不复杂的年代，围绕数据做文章的做法还能满足开发的要求，但随着软件日益深入到人们日常工作和生活中，软件变得越来越复杂，这种做法就越发显得笨拙了。

对，软件会越来越复杂的。当软件变得复杂起来，如果我们靠着程序员们本能的做法，就会遇到各种问题，所以，很多人探索了不同的做法。在诸多的探索之中，有一种做法逐渐脱颖而出，它成功地解决业务软件开发中遇到的大部分问题，这就是领域驱动设计。虽然它不是万能药，但对大部分人面对的场景而言，它都能够有效地应对。

### 1.1 领域驱动设计

领域驱动设计（Domain Driven Design，简称 DDD），作为一个新的设计方法正式登上历史舞台，是从 Eric Evans 的著作《领域驱动设计》正式出版开始的。这种设计方法通过使用通用语言，让业务人员加入到设计过程中，拉近了业务人员与开发人员之间的距离，打破了组织的藩篱。同时，还提供了一套标准的建模方法，帮助团队识别业务模型，避免程序员犯下一些低级错误。

按理说，这种设计方法这么好，应该很快流行起来才对。然而真实情况是，很多程序员都不知道 DDD，一个重要的原因就是 Eric 的这本书写得实在不怎么样。要想从中读出味道，你得比较懂 DDD，但是，大多数人并不懂，这就是矛盾的地方。所以，DDD 在很长一段时间都被埋没了。

不过，后来，随着微服务的兴起，人们越发认识到，微服务的难度并不在于将一个系统拆分成若干的服务，而在于如何有效地划分微服务。这个时候，人们发现，DDD 才是最恰当的指引。关于微服务和 DDD 之间的关系，我在《10x 程序员工作法》里已经讲过了，有兴趣的可以去了解一下，这里就不再赘述了。

现在，你已经知道了 DDD 的好，准备学习 DDD 了。但你只要一打开 DDD 的书，一大堆名词就会扑面而来：限界上下文、聚合根、实体、值对象，等等。我该如何下手学习呢？这是摆在每个 DDD 学习者面前最严峻的问题。学习 DDD，就要从理解 DDD 的根基入手：通用语言（Ubiquitous Language）和模型驱动的设计（Model-Driven Design），而领域驱动设计的过程，就是建立起通用语言和识别模型的过程。

### 1.2 通用语言

通用语言，就是在业务人员和开发人员之间建立起的一套共有的语言。要知道，在从前的设计方法中，业务人员总是把问题扔过墙头，让开发人员去解决。可是，业务人员说的都是业务名词，比如：产品、订单等等，而开发人员嘴里全是技术，比如：线程、存储等等，二者除了最基础的几个概念之外，其他的内容基本是没法沟通的。所以，一道人为鸿沟就在开发人员和业务人员之间形成了。

我们在第 1 讲说过，软件设计是要在问题和解决方案架设一座桥梁，好的设计要更接近问题。开发人员对解决方案一端简直再熟悉不过了，但是对业务一端理解则通常不够充分。而通用语言所做的事情，就是把开发人员的思考起点拉到了业务上，也就是从问题出发，这就在一定程度上填平了那道人为的鸿沟。

通用语言是什么呢？就是这个业务中有哪些概念以及哪些操作。比如说，我要做一个电商平台，就要有产品、订单的概念。其中，产品就要有上架、下架、修改产品信息等操作，而订单就会有下单、撤单、修改订单等操作。在业务人员看来，这里说的都是自己擅长的事情，自己就可以有更多的发言权。在开发人员的视角，概念就是一个一个的类，操作就是一个一个的方法，也很好理解。所以，有一套通用语言，双方皆大欢喜。

但是，通用语言是从哪来的呢？也就是说，如何设计通用语言呢？最简单的做法就是让业务人员和开发人员一起，找一块白板，把各种概念都写在上面。然后，双方重新进行分类整理。这里面的重点是，让业务人员和开发人员在一起。如果只让一方出现，结果又会是原来的样子，因为你没法判断，这里面的语言对方是否听得懂。

这种做法很简单，但通常都不够系统，会存在各种遗漏。所以，有人探索出一种更正式的实践：事件风暴（Event Stroming）。事件风暴是一个工作坊，基本做法就是找一面很宽的墙，上面铺上大白纸，然后，用便利贴把识别出来的概念贴在上面。当然，前提依然是让业务人员和技术人员都参与其中。

3『事件风暴学习：[EventStorming](https://www.eventstorming.com/)。』

2『单元里发起一场事件风暴，先把一些概念给大家介绍，然后实操。』

这个实践之所以叫作事件风暴，因为它的关注点在于领域事件。领域事件是用来记录业务过程中发生过的重要事情，比如，作为电商平台的工作人员，你想知道产品是不是已经上架了，这个领域事件就是产品已上架；作为消费者，你会关心我的订单是不是下成功了，这个领域事件就是订单已下。人们做了一个动作，都会关心做过这个动作之后的结果，所以，领域事件用的描述方式都是过去式，比如：OrderPlaced。

1『这里的举的几个领域事件的例子很直观，「产品已上架」和「订单已下」。』

事件风暴这个工作坊主要分成三步：1）第一步就是把领域事件识别出来，这个系统有哪些是人们关心的结果。有了领域事件，下面一个问题是，这些事件是如何产生的，它必然会是某个动作的结果。2）第二步就是找出这些动作，也就是引发领域事件的命令。比如：产品已上架是由产品上架这个动作引发的，而订单已下就是由下单这个命令引发的。3）第三步就是找出与事件和命令相关的实体或聚合，比如，产品上架就需要有个产品（Product），下单就需要有订单（Order）。

至此，我们已经把最核心的内容找出来了。通常，在工作坊过程中，为了增强趣味性和清晰性，不同的概念会用不同的颜色的便利贴标识出来，比如，领域事件用橙色、命令用蓝色、实体 / 聚合用黄色等等。

其实，用不同的颜色建模，事件风暴并不是独一份。Peter Coad 也曾提出过一种四色建模的方法：1）粉色表示时标性对象（moment-interval）；2）黄色表示角色（role）；3）蓝色表示描述（description）；4）绿色表示人、地点、物（party/place/thing）。他还写了一本《彩色 UML 建模》（Java Modeling in Color with UML）介绍这种方法。我在 ThoughtWorks 的前同事徐昊按照自己的理解，对这种方法做了一些更新，有兴趣的话，可以去了解一下。

2『上面的书去下载一下：[彩色UML建模（豆瓣）](https://book.douban.com/subject/3354137/)；上面的文章页消化吸收并作为附件。』

3『[运用四色建模法进行领域分析 - InfoQ](https://www.infoq.cn/article/xh-four-color-modeling)

』

当然，这里的事件风暴，我只是描述了最简单的一个过程。在具体实施的过程中，还会有更多的细节。不过，最重要的还是，让不同角色的参与其中，让知识在所有人的头脑中进行构建，得到一个大家都认同的结果。

### 1.3 模型驱动设计

有了通用语言，接下来就进入模型设计阶段了。虽然有了通用语言，但是业务人员能够帮到开发人员的还是很少，他们只能告诉开发人员哪些模型是符合业务概念的。但这么多的业务模型，该如何组织呢？怎样补全欠缺的模型，使之成为一个可以落地的方案呢？这就是开发人员要想办法解决的事情了。也正是因为在通常情况下，业务模型数量众多，所以在 DDD 的过程中，我们将设计分成了两个阶段：战略设计（Strategic Design）和战术设计（Tactical Design）。

战略设计是高层设计，是指将系统拆分成不同的领域。而领域驱动设计，核心的概念就是领域，也就是说，它给了我们一个拆分系统的新视角：按业务领域拆分。比如，我把一个电商系统拆分成产品域、订单域、支付域、物流域等。拆分成领域之后，我们识别出来的各种业务对象就会归结到各个领域之中。然而，有时候，不同领域的业务对象会进行交互，比如，我要知道自己订单的物流情况。所以，要在不同的领域之间设计一些交互的方式。

而战术设计是低层设计，也就是如何具体地组织不同的业务模型。在这个层次上，DDD 给我们提供了一些标准的做法供我们参考。比如，哪种模型应该设计成实体，哪些应该设计成值对象。我们还要考虑模型之间是什么样的关系，比如，哪些模型要一起使用，可以成为一个聚合。接下来，我们还需要考虑这些模型从哪来、怎样演变，DDD 同样为我们提供了一些标准的设计概念，比如仓库、服务等等。

通过战略设计和战术设计，我们就可以把发现出来的不同业务概念各归其位了。

### 黑板墙

最后，我想请你分享一下，你们在实际工作中是如何与业务人员沟通的？

领域驱动设计可以和传统的面向数据库设计的方式结合吗，比如引入一个 model 模块用来聚合模型。作者回复：先按照一个思路走，否则，你会回到老路上去的。2020-07-29

郑老师说了实话，《领域驱动设计》这本书一般人真是读不下去，应该耽误了不少人学习 DDD。但是说实话，DDD 真是太难学了，能把 DDD 在公司里运用起来，特别是战略设计，几乎就是一个组织变革，需要有同时能够影响业务合作又能引导事件风暴这个高难度的工作坊的人才。虽然像 TW 这样的公司已经在努力推广这种设计方法了，极客时间也开了《DDD 实战课》，但是，很多公司离这个设计方法还是很远的。DDD 之后如何发展，郑老师怎么看？作者回复：DDD 其实不是难，而是概念多，缺乏一个结构理解它。另外，很多人欠缺的不是 DDD，而是设计的基础知识。这就是我在做的尝试，先铺垫设计的基础知识，然后，再讲 DDD，用一个结构化的方式帮你把 DDD 串起来。真正的难点是结合实际工作，把 DDD 完整地走一遍，看到代码就理解了。退一步，可以去看《实现领域驱动设计》的源码。2020-08-01

实体：在时间上有连续性，并且有唯一标识可以来区分的对象，具有生命周期和行为。值对象：用来描述事物的，不区分谁是谁的，不可变的对象，不具有生命周期和行为。2020-07-31

领域事件风暴，使用的是事件，动作，实体，建立基本业务模型，我认为这是时序图、状态图的另外一种表达，战略设计，很像业务架构设计，按照领域职责去划分。建立一个好的平台，需要做好职责划分，配置团队，要不就是无尽的折磨。作者回复：这个理解的角度是在新事物和已有知识建立起连接的角度，很有趣。2020-07-30

数据加函数用了好多年，现在终于想通了为啥 EF 有种 codefirst 编程模式，因为别人早就想通了面向对象编程！！！2020-07-29

各自阐述理解；消除分歧；达成共识。作者回复：总结得好。2020-07-29

## 0502. 战略设计：如何划分系统的模块？

我们主要讲了 DDD 中的战略设计。战略设计中的概念主要是为了做业务的划分和落地成解决方案。首先业务的划分，我们要把识别出来的模型做一个分类，把它们放置到不同的子域中。划分子域的出发点就是不同的关注点，也就是不同的变化来源。划分出来的子域有着不同的重要程度，我们将它们再分为核心域、支撑域和通用域。做出这种区分，主要是为了针对它们各自的特点，决定不同的投入。

3『书籍领域驱动设计精粹「DDDD」里有提到，尽量保证一个限界上下文里就只有一个子域。』

有了不同的领域划分，我们还要把这些领域映射到解决方案上，这就引出了限界上下文。限界上下文限定了模型的使用边界，它可以成为一个独立的系统。如果对应到微服务中，每一个限界上下文可以对应成一个微服务。上下文映射图定义了不同上下文之间的交互方式，如果你只能记住一种交互方式的话，就应该记住防腐层。

1『限界上下文限定了模型的使用边界，其可以作为一个独立的系统，每一个限界上下文对应于一个微服务。』

按照我们之前介绍的了解软件设计的思路，建立起通用语言之后，我们就找到了主要的模型，通过战略设计，我们可以把识别出来的模型放到不同的限界上下文中，就相当于把模型做了分组。然后，我们需要定义出一些接口，让不同的模型之间可以交互，我们也就有了一张上下文映射图。

1『上面这段话，反复去品。（2020-08-03）』

这样一来，我们就把之前学习的知识和新的知识建立起了连接。我们有了模型，有了接口，接下来就该深入到实现中。下一讲，我们就要进一步了解 DDD 的实现：战术设计。如果今天的内容你只能记住一件事，那请记住：战略设计，就是将不同的模型进行分组。

上一讲，我们已经初步认识了 DDD ，知道了支撑 DDD 最核心的就是通用语言和模型驱动设计的方法。我们在上一讲已经讲了建立通用语言的方法，接下来，就该进行模型的设计了。在模型设计中，DDD 又分成了两个阶段，战略设计和战术设计。这一讲，我们先来聊聊战略设计，下一讲再来谈战术设计。

1『原来战略设计和战术设计都是为了「构建模型」的，两者是模型设计的 2 个阶段。醍醐灌顶。（2020-08-03）』

战略设计，这个名字听上去有点高大上。而且，战略设计包含很多的概念，比如，子域、限界上下文和上下文映射图等等。这让很多人有些望而却步。虽然概念看似很多，但只要有一条主线将它们贯穿起来，这些概念也不难理解。

我们可以先把这些概念做一个划分，分为做业务的划分和落地成解决方案两个部分，也就是说，战略设计中的概念，一部分是为了将不同的业务区分开来，也就是要将识别出来的业务概念做一个划分，另一部分则是将划分出来的业务落实到真实的解决方案中。好，我们接下来就先来看看战略设计中的这些概念到底是怎么回事。

1『理解战略设计的一条主线：划分业务和实现解决方案。』

### 2.1 业务概念的划分

我们前面说过，软件开发就是在解决问题，所以，一方面，我们要知道要解决的问题是什么；另一方面，我们要知道怎么去解决问题。

我们要解决的问题就是领域问题，在 DDD 中，有几个概念是与领域相关的，比如，子域、核心域、支撑域、通用域等。其实，它们说的都是一件事，就是如何先把问题从大面上进行分解。

领域驱动设计这个名字里面，排在第一位的是领域（Domain），它就对应着要解决的问题。正如我们一直说的，软件开发是解决问题，而解决问题要分而治之。所谓分而治之，就是要把问题分解了，对应到领域驱动设计中，就是要把一个大领域分解成若干的小领域，而这个分解出来的小领域就是子域（Subdomain）。

1-2『原来「领域」对应于要解决的问题，这里提到的大领域、小领域算法把之前的困惑解答了。领域的概念做一张术语卡片。』

我们在上一讲中说，领域驱动设计首先要建立起一套通用语言，这样一来，我们就拥有了各种各样的词汇，它们对应着模型。接下来，我们就要给这些词汇做个分类，而分类就是要把它们划分到不同的子域中去。这里面的关键就在于，要找出不同的关注点。没错，还是分离关注点。

比如，我要做一个项目管理软件，就需要有用户、有项目、有团队，不同的人还要扮演不同的角色。第一步，我们至少可以先把身份管理和项目管理这两件事分开，因为它们的关注点是不同的。身份管理关注的是用户的身份信息，诸如用户名密码之类的，而项目管理关注的重点是项目和团队之类的。所以，我们这里有了两个子域：身份管理和项目管理。

1『身份管理和项目管理 2 个子域，正好数据流开发的时候可以用到。』

如果直接给你看结果，你可能会觉得很好理解。但是，划分出不同的子域还是比较容易出问题的，因为有一些概念并不容易区分。比如，用户应该怎么划分呢？放在身份管理是合适的，但项目管理也要用到用户。

幸好，我们已经学习了单一职责原则，它给了我们一个重要的思考维度，变化从何而来。不同角色的人会关注不同的变化，所以，我们知道虽然我们用的词都是「用户」，但我们想表达的含义却是不同的，我们最好将这些不同的含义分开，也就是将不同的角色分开。比如，在身份管理中，它是「用户」，而在项目管理中，它就成了「项目成员」。所以，我们划分子域实际上就是在把不同的概念区分开来，让它们各归其位。

对于一个真实项目而言，划分出来的子域可能会有很多，但并非每个子域都一样重要。所以，我们还要把划分出来的子域再做一下区分，分成核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。

核心域是整个系统最重要的部分，是整个业务得以成功的关键。关于核心域，Eric Evans 曾提出过几个问题，帮我们识别核心域：1）为什么这个系统值得写？2）为什么不直接买一个？3）为什么不外包？如果你对这几个问题的回答能够帮你找到这个系统非写不可的理由，那它就是你的核心域。

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域。比如，我们要做一个排行榜功能，可能根据各种信息做排名，这种东西没有人会按照你的需要做出一个，对你来说，又是扩展自己系统的重要一步，它就是一个支撑域。还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行。比如，很多 App 要给用户发通知，这样的功能完全可以买一个服务来做，丝毫不影响你的业务运行。它就是一个通用域。

我们之所以要区分不同的子域，关键的原因就在于，我们可以决定不同的投资策略。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。

### 2.2 业务概念的落地

通过划分子域，区分核心域、支撑域和通用域，我们把 DDD 在问题层面的概念已经说清楚了。接下来，就要进入到解决方案层面了。

我们现在有了切分出来的子域，怎样去落实到代码上呢？首先要解决的就是这些子域如何组织的问题，是写一个程序把所有子域都放在里面呢，还是每个子域做一个独立的应用，抑或是有一些在一起，有一些分开。这就引出了领域驱动设计中的一个重要的概念，限界上下文（Bounded Context）。

限界上下文，顾名思义，它形成了一个边界，一个限定了通用语言自由使用的边界，一旦出界，含义便无法保证。比如，同样是说「订单」，如果不加限制，你很难区分它是用在哪种场景之下。而一旦定义了限界上下文，那交易上下文的「订单」和物流上下文的「订单」肯定是不同的。原因就在于，订单这个说法，在不同的边界内，含义是不一样的。

1『上面的例子又是值得反复品。「订单」这个对象，必须在特定的限界上下文里。反过来看，如果之前划分好的限界上下文里冒出来两个同样名称但观念不同的对象，那么其中一个必定不属于这个限界上下文。』

注意，子域和限界上下文不一定是一一对应的，可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文。

1『哈哈，很有价值的信息。可能在一个限界上下文中包含了多个子域，也可能在一个子域横跨了多个限界上下文。再次强调一下，书籍领域驱动设计精粹「DDDD」里有提到，尽量保证一个限界上下文里就只有一个子域。这两个观点应该是根据不同的上下文场景给出的建议，因开发中没有遇到相应的场景，目前还无法理解透彻。（2020-08-05）』

前面我们说了限界上下文是在解决方案层面的，所以，很自然地，我们就可以把限界上下文看作是一个独立的系统。很多团队做微服务的时候，最纠结的问题就是如何划分服务边界，而限界上下文的出现刚好与微服务的理念契合，每个限界上下文都可以成为一个独立的服务。限界上下文的重点在于，它是完全独立的，不会为了完成一个业务需求要跑到其他服务中去做很多事，而这恰恰是很多微服务出问题的点，比如，一个业务功能要调用很多其他系统的功能。

有了对限界上下文的理解，我们就可以把整个业务分解到不同的限界上下文中，但是，尽管我们拆分了系统，它们终究还是一个系统，免不了彼此之间要有交互。比如，一个用户下了订单，这是在订单上下文中完成的。那接下来，用户要去支付，这是在支付上下文中完成的。我们肯定要通过某种途径让订单上下文的一些信息发送到支付上下文里的。

所以，我们就要有一种描述方式，将不同限界上下文之间交互的方式描述出来，这就是上下文映射图（Context Map）。DDD 给我们提供了一些描述这种交互的方式，比如：1）合作关系（Partnership）；2）共享内核（Shared Kernel）；3）客户 - 供应商（Customer-Supplier）；4）跟随者（Conformist）；5）防腐层（Anticorruption Layer）；6）开放主机服务（Open Host Service）；7）发布语言（Published Language）；8）各行其道（Separate Ways）；9）大泥球（Big Ball of Mud）。

之所以有这么多不同的交互方式，主要是为了让你在头脑中仔细辨认一下，看看限界上下文之间到底在以怎样的方式进行交互。当然这么多交互方式，想一次性记住也是不现实的，有些甚至是你要规避的，比如大泥球。如果说这么多交互方式你必须要记住一个的话，那就是防腐层（Anticorruption Layer）。

防腐层是最具防御性的一种关系，简言之，就是指我们要在外部模型和内部模型之间建立起一个翻译层，将外部模型转化为内部模型。我在第 1 讲给你讲了一个因为没有建立防腐造成的问题。所以，但凡有可能，就要建立防腐层，将外部模型完全隔离开。

当我们知道了不同的限界上下文之间采用哪种交互方式之后，不同的交互方式就可以落地为不同的协议。现在最常用的几种协议有 REST API、RPC 或是消息队列，我们可以根据实际情况进行选择。在我们定义好不同的限界上下文，将它们之间的交互呈现出来之后，我们就得到了一张上下文映射图（Context Map）。上下文映射图是可以，而这往往是很多团队欠缺的。

1『不同限界上下文之间的映射关系落地为不同的协议，几个最常见的协议有：REST API、RPC 或是消息队列。』

### 黑板墙

想听郑老师讲讲更简便一些的模型设计方法，例如，四色建模法，我不知道是不是？作者回复：四色建模并不是简便，从完整性的角度，它不如DDD。想了解四色建模，你可以去看看我推荐的那本书和那篇文章。2020-08-01

有一点不太明白，在不同边界上下文交互过程中，防腐层是封装了具体的远程调用协议和将外部数据进行格式装换？作者回复：交互方式和数据协议，都可以通过防腐层处理掉。2020-07-31

通用语言、战略设计、战术设计，好似一个三部曲，从上层到下层，层层细化和分解。感觉通用语言和战略设计对于接触和使用不久的新人是要不断踩坑的，希望郑老师能分析一些过去很多年的一些详细的实际案例，理论结合实际，更能体会其中的奥妙。作者回复：讲设计，困难的一点就在于背景太多，要想理解一个设计，通常要先理解背景。讲太细了，就会牵扯到很多具体的业务，怕透露太多。选择什么粒度的内容其实我也一直比较纠结。2020-08-03

一套微服务里有一个服务专门负责操作数据库同时又带有业务。其他系统需要发送 RPC 请求调用该系统完成数据库操作。请问老实这样合理吗？作者回复：听上去不太合理，各个服务都应该是一个完整独立的。这种把所有的入库都放在一起的操作，为啥还要做微服务呢？2020-07-31

1『郑烨的思维导图用的 Xmind。』

## 0503. 战术设计：如何像写故事一样找出模型？

今天，我们讲了 DDD 中的战术设计，我们把战术设计当作了一个故事模板。让你先去识别角色，也就是找到实体和值对象。一个简单的区分就是，能通过唯一标识符识别出来的就是实体，只能通过字段组合才能识别出来的是值对象。然后我们应该找到角色之间的关系，也就是聚合。操作聚合关键点在于找到聚合根。当聚合根不存在时，聚合中的对象也就不再有价值了。有了角色及其关系，接下来就是找到各种动词，让故事生动起来。这里，我们讲到了动作，也就是领域服务，以及动作的结果，也就是领域事件，还有创建对象的工厂和保存对象的仓库。这些内容构成了我们最核心的业务逻辑。一些额外的工作，我们可以放到外围来做，这就是应用服务。

通过这几讲关于 DDD 的学习，你知道了如何识别出各种对象。通过前面设计原则、设计模式的讲解，你知道了如何组织这些对象。至此，我已经把设计相关的主要知识给你讲过一遍了，你现在应该知道如何做设计了。那现在我们已经有了这样的基础，我们就可以做自己的设计了。从下一讲开始，我们就来体验一下，如何在真实的项目中做设计。如果今天的内容你只能记住一件事，那请记住：战术设计，就是按照模板寻找相应的模型。

在上一讲中，我们讲了 DDD 中的战略设计，学习如何将识别出来的不同模型放到不同的限界上下文中。那么，接下来，我们就该做更具体的工作了，也就是如何设计模型。在 DDD 中，把具体的模型找出来的做法有一个更响亮的名字：战术设计。

战术设计同样也包含了很多概念，比如，实体、值对象、聚合、领域服务、应用服务等等。有这么多概念，我们该如何区分和理解他们呢？我们同样需要一根主线。其实，我们可以把战术设计理解成写一个故事。你知道怎样去写个故事吗？写故事通常都是有一定套路的。我们要先构建好故事的背景，然后，要设定不同的角色，接下来，创建角色之间的关系，最后，我们要安排人物之间互动起来，形成故事。

1『理解战术设计的主线：写一个故事。』

对于战术设计而言，故事的背景就是我们面对的领域问题，剩下的就是我们在这个故事背景下，要找出不同的角色，找出角色之间的关系，让它们互动起来，这样，我们就有了故事，也完成了战术设计。接下来，我们就来看看，战术设计这个故事模板，我们应该怎么填？

### 3.1 角色：实体、值对象

我们的首要任务就是设计角色，在战术设计中，我们的角色就是各种名词。我们在初学面向对象的时候，课本上的内容就告诉我们要识别出一个一个的模型，其实，就是让我们识别名词。识别名词也是很多人对于面向对象的直觉反应。有一些设计方法会先建立数据库表，这种做法本质上也是从识别名词入手的。我们在战术设计中，要识别的名词包括了实体和值对象。

什么是实体呢？实体（Entity）指的是能够通过唯一标识符标识出来的对象。我们都知道，在业务处理中，有一类对象会有一定的生命周期。我以电商平台上的订单为例，它会在一次交易的过程中存在，而在它的生命周期中，它的一些属性可能会有变化，比如说，订单的状态刚开始是下单完成，然后在支付之后，变成了已支付，在发货之后就变成了已发货。

但是这个订单始终都是这个订单，因为这个订单有唯一的标识符，也就是订单号，订单号作为它的标识符能将它标识出来。你可以通过订单号查询它的状态，可以修改订单的一些信息，比如，配送的地址。像这种通过唯一标识符标识出来的对象，就是实体。其实，大多数程序员对于实体并不陌生，因为在各种设计方法中，都有相应的方法识别实体。你甚至可以简单粗暴地将它理解成数据库里存储的对象，虽然这种理解并不完全正确。

还有一类对象称为值对象，它就表示一个值。比如，订单地址，它是由省、市、区和具体住址组成。它同实体的差别在于，它没有标识符。之所以它叫值对象，是因为它表现得像一个值。值对象可能会有很多属性，而要想判断值对象是否相等，我们就要判断这些属性是否相等。对于两个订单地址来说，只有省、市、区和具体住址等多个属性都相同，我们才认为它们是同一个地址。

实体的属性是可以变的，只要标识符不变，它就还是那个实体。但是，值对象的属性却不能变，一旦变了，它就不再是那个对象，所以，我们会把值对象设置成一个不变的对象。在前面讲函数式编程的不变性时，我给你介绍了不变性的诸多好处，这里也完全适用于值对象。

1『把函数式编程范式里「不变性」有点应用到「值对象」上，再比如在 JS 里用 const 来声明「值对象」。』

那你现在应该懂了，我们为什么要将对象分为实体和值对象？其实主要是为了分出值对象，也就是把变的对象和不变的对象区分开。在传统的做法中，找出实体是你一定会做的一件事，而在不同的模型中，区分出值对象是我们通常欠缺的考虑。

一方面，我们会把一些值对象当作实体，但其实这种对象并不需要一个标识符；另一方面，也是更重要的，就是很多值对象我们并没有识别出来，比如，很多人会用一个字符串表示电话号码，会用一个 double 类型表示价格，而这些东西其实都应该是一个值对象。

之所以说这里缺少了对象，原因就在于，这里用基本类型是没有行为的。在 DDD 的对象设计中，对象应该是有行为的。比如，价格其实要有精度的限制，计算时要有自己的计算规则。如果不用一个类将它封装起来，这种行为就将散落在代码的各处，变得难以维护。

其实，我们在讨论面向对象的封装时就已经说过了，只有数据的对象是封装没做好的结果，一个好的封装应该是基于行为的。在 DDD 的相关讨论中，经常有人批评所谓的「贫血模型」，说的其实就是这种没有行为的对象。你可以回头复习一下第 15 讲，我就不在这里赘述了。

### 3.2 关系：聚合和聚合根

选定了角色之后，接下来，我们就该考虑它们的关系了。在传统的开发中，我们经常会遇到一个难题。比如，如果我有一个订单，它有自己对应的订单项。问题来了，我取订单的时候，该不该把订单项一起取出来呢？取吧，怕一次取出来东西太多；不取吧？要是我用到了，再去一条一条地取，太浪费时间了。这就是典型的一对多问题，只不过，在其他场景中，主角就变成了各种其他的对象。不过，这也是一种用技术解决业务问题的典型思路。我们之所以这么纠结，主要就是因为我们考虑问题的出发点是技术，如果我们把考虑问题的出发点放到业务上呢？

战术设计就给了我们这样一个思考的维度：聚合。聚合（Aggregate）就是多个实体或值对象的组合，这些对象是什么关系呢？你可以理解为它们要同生共死。比如，一个订单里有很多个订单项，如果这个订单作废了，这些订单项也就没用了。所以，我们基本上可以把订单和订单项看成一个单元，订单和订单项就是一个聚合。

学习 DDD 时，有人会告诉你，聚合要保证事务（Transaction）一致性。简言之，就是要更新就一起更新，要删除就一起删除。只要你理解了它们是一个整体，你就不难理解为什么这些对象要一起操作了。不过，一个聚合里可以包含很多个对象，每个对象里还可以继续包含其它的对象，就像一棵大树一层层展开。但重点是，这是一棵树，所以，它只能有一个树根，这个根就是聚合根。

聚合根（Aggregate Root），就是从外部访问这个聚合的起点。我还以上面的订单和订单项为例，在订单和订单项组成的这个聚合里，订单就是聚合根。因为你想访问它们，就要从订单入手，你要通过订单号找到订单，然后，把相关的订单项也一并拿出来。

1『很有感触，那么在数据流开发中，领域对象（模型）：工艺提仪表条件，这个子域的建模过程中，仪表位号应该是聚合根，通过仪表位号关联到设备，通过仪表位号关联到管段号，通过仪表位号关联到工作介质......』

其实，我们可以把所有的对象都看成是一种聚合。只不过，有一些聚合根下还有其他的对象，有一些没有而已。这样一来，你就有了一个统一的视角看待所有的对象了。所以，我们也可以用统一的标准要求聚合，比如，聚合不能设计得太大。你有没有发现，这其实就是单一职责原则在聚合上的应用。

那如果不同的聚合之间有关系怎么办？比如，我要在订单项里知道到底买了哪个产品，这个时候，我在订单项里保存的不是完整的产品信息，而是产品 ID。还记得吗？我们在前面说过，实体是有唯一标识符的。如果需要，我们就可以根据产品 ID 找出产品信息。

1『聚合里只保存另一个聚合里某个实体的唯一标识字段即可。这不就是关系型数据库里各个表的主键么。』

有了对于聚合的理解，做设计的时候，我们就要识别出哪些对象可以组成聚合。所以，我们的一对多问题也就不再是问题了：是聚合的，我们可以一次都拿出来；不是聚合的，我们就靠标识符按需提取。当你纠结于技术时，先想想自己是不是解错了问题。

### 3.3 互动：工厂、仓库、领域服务、应用服务

我们现在有角色了，也确定关系了。接下来，我们就要安排互动了，也就是说，我们要把故事的来龙去脉讲清楚了。还记得第 27 讲的事件风暴吗？我们在其中识别出了事件和动作，而故事的来龙去脉其实就是这些事件和动作。因为有了各种动作，各种角色才能够生动地活跃起来，整个故事才得以展开。

动作的结果会产生出各种事件，也就是领域事件，领域事件相当于记录了业务过程中最重要的事情。相对于 DDD 中的其他概念，领域事件加入 DDD 大家庭是比较晚的，但因为其价值所在，它迅速地就成了 DDD 中不可或缺的一个重要概念。因为领域事件是一条很好的主线，可以帮我们梳理出业务上的变化。同时，在如今这个分布式系统此起彼伏的时代，领域事件可以帮助我们让系统达成最终一致的状态。

那各种动作又是什么呢？拿就是我们在写作中常用到的动词。在战术设计中，领域服务（Domain Service）就是动词。只不过，它操作的目标是领域对象，更准确地说，它操作的是聚合根。动词，是我们在学习面向对象中最为缺少的一个环节，很多教材都会教你如何识别名词。在实际编码中，我们会大量地使用像 Handler、Service 之类的名字，它们其实就是动词。

你可能会问，按照前面的说法，动作不应该在实体或值对象上吗？确实是这样的，能放到这些对象上的动作固然可以，但是，总会有一些动作不适合放在这些对象上面，比如，要在两个账户之间转账，这个操作牵扯到两个账户，肯定不能放到一个实体类中。这样的动作就可以放到领域服务中。

1『不能放到实体类的动作，放到领域服务里。』

还有一类动作也比较特殊，就是创建对象的动作。显然，这个时候还没有对象，所以，这一类的动作也要放在领域服务上。这种动作对应的就是工厂（Factory）。这个工厂其实就是设计模式中常提到的工厂，有了设计模式的基础之后，你理解起来就容易多了。需要注意的是，由于聚合的存在，聚合里的各种子对象都要从聚合根创建出来，以便保证二者之间的关联。比如，订单项的产生应该从订单上的订单项工厂方法创建出来。而聚合根本身的产生，就可以由领域服务来扮演工厂的角色。

1『创建对象的动作（工厂），放到领域服务里。还有一个关键点，聚合里的各种子对象都要从聚合根创建出来。』

对于这些领域对象，无论是创建，还是修改，我们都需要有一个地方把变更的结果保存下来，而承担这个职责的就是仓库（Repository）。你可以简单地把它理解成持久化操作（当然，在不同的项目中，具体的处理还是会有些差别的）。

其实，很多人熟悉的 CRUD，可以对应成一个一个的领域服务。如果我们用战术设计的做法来表示，应该是这样：1）创建（Create），从工厂中创建出一个对象，然后，保存到仓库中；2）查询（Read），通过仓库进行查询；3）修改（Update），通过仓库找到要修改的对象，修改之后，存回到仓库中；4）删除（Delete），通过仓库找到要删除的对象，然后，在仓库中删除。

当然，这种简单的映射并不好，没有体现出业务含义，这里只是为了帮助你把已有知识和新知识之间架设起桥梁。当我们把领域服务构建起来之后，核心的业务逻辑基本就成型了。但要做一个系统，肯定还会有一些杂七杂八的东西，比如，用户要修改一个订单，但首先要保证这个订单是他的。在 DDD 中，承载这些内容的就是应用服务。

应用服务可以扮演协调者的角色，协调不同的领域对象、领域服务等完成客户端所要求的各种业务动作，所以，也有人把它称之为「工作流服务」。一般来说，一些与业务逻辑无关的内容都会放到应用服务中完成，比如，监控、身份认证等等。说到这里，我们已经说出了应用服务和领域服务之间的区别。应用服务和领域服务之间最大的区别就在于，领域服务包含业务逻辑，而应用服务不包含。至于哪些东西算是业务逻辑，就要结合具体的项目来看了。

1『一些与业务逻辑无关的内容都会放到应用服务中完成，比如，监控、身份认证等等。』

至此，我已经把战术设计这个故事模板给你讲了一遍，DDD 也算完整地讲了一遍了。你现在应该对 DDD 的各种基础概念之间是个什么关系、如果要做领域驱动设计，要有怎样一个步骤等有一个基本的认识了。当然，仅凭三讲的篇幅，我们想要完整地理解领域驱动设计几乎是不可能的。但是你现在至少有了一个框架，当你再去学习 DDD 中那些让人眼花缭乱的知识时，你就不会轻易地迷失了。

Vaughn Vernon 写过两本关于 DDD 的书，是现在市面上比较好的 DDD 学习材料。建议你先阅读《领域驱动设计精粹》，这本书可以帮你快速入门；然后你再看《实现领域驱动设计》，这本书很厚，但讲得要更细致一些。当然，想要真正想学会 DDD，还是需要你在实际项目中进行练习。

### 黑板墙

感觉郑老师最厉害的地方就是讲出了 why，而不单是说 how。很多文章会说「实体有唯一标识符」，很正确又无用。只有结合了「是聚合的，我们可以一次都拿出来；不是聚合的，我们就靠标识符按需提取」，我才有了恍然大悟的感觉。2020-08-03

结合张逸老师的《领域驱动设计实践》，完美。作者回复：我和张逸是多年老友，他太能写了。2020-08-10

1『上面的这本书没找到。』

我们平时工作中的那种不怎么复杂的公司内务管理系统可以用 DDD 的思想设计和开发，合适吗？如果没打算微服务的话。作者回复：这种普通的业务系统，用 DDD 是非常合适的。这和微服务没有关系，你可以把所有子域都放在一个限界上下文里。2020-08-05

感觉应用服务才是业务的实现者，领域服务是提供者，老师如何理解上面的。作者回复：从大部分人习惯的角度看，确实是这样的，因为应用服务常常对应着你的 API。但核心是领域服务才是核心，是不可替换的，而应用服务则可能根据实际的情况发生改变。2020-08-03

想到两点，请老师指正。1）订单和订单项的例子中，订单项也是一个实体，而不是值对象吧，因为订单项中的各个属性有可能被修改，比如价格或数量，但它还是这个订单项。无论是存储在 mongodb 的一张 table 中，还是 mysql 里面的两张 table 中。2）结合老师的分析，我又想到了另一个例子，比如当前这边文章（Article）和文章评论（ArticleComment）。从聚合概念上分析，文章是作者创建的，而评论是读者创建的，但如果文章被删除了，那么这些评论也就跟着要删除，所以他们不同生但共死。从识别聚合上分析，获取文章时，也无法一次性把所有评论获取到。作者回复：这个理解没问题，非常棒！2020-08-11

不是聚合的，我们就靠标识符按需提取。用 CQRS 落地 DDD 的话，如果按标识符去查询模型获取数据，有可能获取的不是最新的数据（因为写模型更新了，但查询模型更新是有延迟的），像这种极限情况会有什么问题吗？难道应该去通过命令去查询写的模型？怎么去理解和解决这种情况呢？作者回复：CQRS 的话，你追求的是最终一致性，读这端拿到的你就应该认为它是最新数据。显然，如果你的目标是强一致，就别考虑 CQRS。2020-08-05

## 0600. 巩固篇

1、注意发现身边的小问题，用一个程序库或工具解决它。

2、一个更好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。

3、改进既有设计，从做一个正常的设计开始，小步向前。

## 0601. 程序库的设计：Moco 是如何解决集成问题的？

Moco 的源码：[dreamhead/moco: Easy Setup Stub Server](https://github.com/dreamhead/moco)。

今天我给你讲了 Moco 的设计过程。一个好的软件也好，程序库也罢，都是从实际的问题出发的。阻碍一个程序员写出好的程序库的原因，往往是没有找到一个好问题去解决。程序员不能只当一个问题的解决者，还应该经常抬头看路，做一个问题的发现者。有了问题之后，需要把问题拆解成可以下手解决的需求，让自己有一个更明确的目标。然后，我们才是根据这个需求找到一个适当的解决方案。一个通用的解决方案需要不断地抽丝剥茧，抛开无关的部分，找到核心的部分，这同样根植于分离关注点。

如果最后的解决方案是一个程序库，那么，我们用测试把程序库要表达的内容写出来，就是最直接的。有了测试，就锁定了目标，剩下的就是让测试通过。一个好的设计，应该找到一个最小的核心模型，所有其他的内容都是在这个核心模型上生长出来的，越小的模型越容易理解，相对地，也越容易保持稳定。这一讲，我讲了一个程序库的设计。下一讲，我们再来看看如何设计一个应用。如果今天的内容你只能记住一件事，那请记住：注意发现身边的小问题，用一个程序库或工具解决它。

经过前面内容的讲解，我终于把软件设计的基础知识交付给你了，如果你有一定的经验，相信有很多东西你已经可以借鉴到日常工作中了。但是对于一些同学来说，这些知识恐怕还是有些抽象。那在接下来的几讲中，我会给你讲几个例子，让你看看如何在日常的工作中，运用学到的这些知识，巩固一下前面所学。

我在第 9 讲说过，学习软件设计，可以从写程序库开始。所以，我们的巩固篇就从一个程序库开讲。这是我自己维护的一个开源项目 Moco，它曾经获得 2013 年的 Oracle Duke 选择奖。Moco 是用来做模拟服务器的，你既可以把它当作一个程序库用在自动化测试里，也可以把它单独部署，做一个独立的服务器。我们先来看一个用 Moco 写的测试，感受一下它的简单吧！

```java
public void should_return_expected_response() {
  // 设置模拟服务器的信息
  // 设置服务器访问的端口
  HttpServer server = httpServer(12306);
  // 访问/foo 这个 URI 时，返回 bar
  server.request(by(uri("/foo"))).response("bar"); 
  
  // 开始执行测试
  running(server, new Runnable() {
    // 这里用了 Apache HTTP库访问模拟服务器，实际上，可以使用你的真实项目
    Content content = Request.Get("http://localhost:12306/foo")
      .execute()
      .returnContent();
      
    // 对结果进行断言
    assertThat(content.asString(), is("bar"));
  });
}
```

这一讲，我就来说说它的设计过程，让你看看一个程序库是如何诞生以及成长的。

### 1.1 集成的问题

不知道你有没有发现，阻碍一个人写出一个程序库的，往往是第一步，也就是要实现一个什么样的程序库。因为对于很多人来说，能想到的程序库，别人都写了，再造一个轮子意义并不大。但是，这种思路往往是站在理解结果的角度。其实，程序库和所有的应用一样，都是从一个要解决的问题出发。所以，在日常的繁忙工作中，我们需要偶尔抬头，想想哪些问题正困扰着我们，也许这就是一个程序库或者一个工具的出发点。

曾经有一个问题困扰了我好久，就是集成。还记得在我初入职场时，有一次，我们开发的系统要与第三方厂商的系统进行集成。可是，怎样才能知道我们与第三方集成的效果呢？我们想到的办法就是模拟一个第三方服务。于是，作为当时的新人，我就承担起编写这个模拟服务的任务。那个时候还真是年少无知，居然自己写了一个 HTTP 服务器，然后又继续在上面写了应用协议。那时候的我完全没有编写程序库的意识，只是有人要求我返回什么样的应答，我就改代码，返回一个什么应答。在我的职业生涯中，集成并不少见，只是后来我的经验多了，这种编写模拟服务的事就交到了别人的手上，我就成了那个让别人改来改去的人。

2012 年，我加入到一个海外合作的项目中，这个项目也有一个模拟的 HTTP 服务。开发人员根据自己的需要去改动代码，让这个模拟服务返回不同的应答。之后，他们再打出一个包，部署到一个 Web 服务器上。显然，这比我当年一个人维护模拟服务器要进步很多了，至少它不用考虑 HTTP 协议层面的问题了。

不过，依旧要自己部署模拟服务这一点，让我突然想起当年开发模拟服务时的景象。这么多年过去了，模拟服务却依然如此麻烦，没有得到任何好转，也许我可以做点什么。比起当年做软件开发的懵懂的我，工作了十多年的我，显然已经有了更多的知识储备。

### 1.2 从问题到需求，再到解决方案

那问题有了，我要怎么解决这个问题呢？我需要先把它变成一个可以下手解决的需求。首先，我要考虑的是，我希望这个模拟服务做成什么样子呢？1）它可以支持配置，这样的话，我就不用每次都调整代码了；2）它可以独立部署，因为部署到应用服务器上的方式实在不够轻量级；3）它可以是一个通用的解决方案，因为我已经在多个不同的场景下遇到类似的问题。

除了这些正常的需求之外，我还有一个额外的小需求，就是希望它有一个有表达性的 DSL。因为我当时刚刚翻译完《领域特定语言》，特别想找个机会练练手。以我当时的知识水平来看，配置肯定不是问题，这是任何一个程序员都可以做到的。独立部署，应该也可行，虽然当时还不流行嵌入式的 Web 服务器，但我还知道有 Netty 这样的网络编程框架，我稍微做了一点调研就发现，用它实现一个简单的 Web 服务器并不难。

2『竟然也是 Martin Fowler 的书，以下载书籍「2020159领域特定语言 | 2020159Domain-Specific-Languages」。』

问题就是，我怎样能把它做成一个通用的方案？

在设计中，其实最难的部分就在这里。一个特定的问题总有一个快速的解决方案，而要想做成一个通用方案，它就必须是一个通用的模式。这就需要我们把问题抽丝剥茧，把无关的信息都拿掉，才可能看到最核心的部分。而进行这种分析的的根基，同样是我们在前面说过的分离关注点。

我找到的核心问题就是，模拟服务到底是做什么的呢？其实，它就是按照我预期返回相应的应答。对，一方面，我要表达出预期；另一方面，它要给出返回的结果。当我想明白这一点之后，一段代码浮现在我的脑海中：

```java
server.request("foo").response("bar");
```

对，这就是这个模拟服务器最简单的样子。当请求是「foo」的时候，它就给出对应的应答「bar」，这个结构非常适用于 HTTP 这种请求应答的结构。这段代码简直太合我的胃口了，因为它还是一段内部 DSL，声明出这个模拟服务器的行为，我的额外需求也得到了满足。

如果代码真的可以做成这个样子，那它应该就可以写在单元测试里了。和现在一比，动辄需要启动整个应用，做人工的集成测试，这简直是一个巨大的飞跃。而且，从开发效率上看，这简直就是数量级的提升。不过，上面只是给出了设置服务器的样子，如果我们要把它写到单元测试里，还要考虑到如何去启动和关闭服务器。于是，一段单元测试的代码就浮现了出来：

```java
public void should_return_expected_response() {
  HttpServer server = httpServer(12306);
  server.request("foo").response("bar");
  running(server, new Runnable() {
    Content content = Request.Post("http://localhost:12306")
      .bodyString("foo", ContentType.TEXT_PLAIN)
      .execute()
      .returnContent();
    assertThat(content.asString(), is("foo"));
  });
}
```

这就是 Moco 的第一个测试了。有了测试，我就该考虑如何让测试通过了。同时，测试帮我锁定了具体的目标，我还知道了可用的技术，剩下的就是把它实现出来了。对于程序员而言，实现反而是最简单的。就这样，我花了一个周末的时间，翻着各种文档，让第一个测试通过了。如此一来，Moco 在实现上的技术难度就被突破了。

### 1.3 基础设计的诞生

接下来，我就要考虑 Moco 可以提供怎样的功能了。Moco 首先是一个 HTTP 的模拟服务器，所以，它需要对各种 HTTP 的元素进行支持。HTTP 的元素有哪些呢？其实，无非就是 HTTP 协议中可以看到的 HTTP 协议版本、 URI、HTTP 方法、HTTP 头和 HTTP 内容等等这些东西。

问题来了，如果我们要把 Moco 实现成一个通用的解决方案，我们就需要任意地组合这些元素，我们该如何设计呢？你可能已经想到了，在前面我们讲函数式编程的组合性时，已经提到了要设计可以组合的接口。是的，Moco 就是这么做的。下面是一个例子，如果我们请求 /foo 这个 URI，请求的内容是 foo，那就返回一个 bar，我们还要把这个应答的状态码设置成 200。

```java
server
  .request(and(by("foo"), by(uri("/foo"))))
  .response(and(with(text("bar")), status(200)));
```

在这里，传给 request 和 response 的就不再是一个简简单单的文本，而是一个元素的组合。所以，传给 request 的，我称之为 RequestMatcher，也就是对请求进行匹配，匹配成功则返回 true，反之返回 false。而传给 response 的，我称之为 ResponseHandler，也就是对应答进行处理，在这里面设置应答中的各种元素。这就是 Moco 最核心的两个模型。从 Moco 的第一个版本形成开始，一直没有变过。

```java
interface RequestMatcher {
  boolean match(Request request);
}

interface ResponseHandler {
  void writeToResponse(Response response);
}
```

从这段代码上，你还可以看到用来组合各个元素的 and。学过前面函数式编程的内容，想必你也知道了该如何实现它。除了 and，我还提供了 or 和 not 这样的元素，方便你更好地进行表达。

### 1.4 扩展设计

有了基础设计之后，其实 Moco 已经是一个可用的程序库了。从理论上来说，它已经能够完成 HTTP 模拟服务器所有的需求了。事实上，当我拿出了 Moco 的第一个版本，就有同事在实际的项目中用了起来。如同所有开源项目一样，只要有人用，就会有人给出反馈，你就需要去解决它。Moco 就这样，不经意间开启了自己的生命周期。

我在开篇词就说过，软件设计是一门关注长期变化的学问。长期意味着会有需求源源不断地扑面而来。每当有新问题的到来，软件就要去应对这个新的变化，这也是考验软件设计的时候。

第一个变化就是，有人提出要有一个外部的配置文件。Moco 所要做的调整，就是增加一个配置文件，然后要在配置文件和核心模型之间做一个映射。这个变化其实在核心模型上没有任何的改变。学了前面的课程，你也知道，这就相当于给 Moco 增加了一种外部 DSL，只不过，这个 DSL 的语法我采用了 JSON。

正是因为 JSON 配置文件的出现，Moco 有了一个全新的用法，就是把 Moco 当作了一个独立的模拟服务器。后来的很多人其实更熟悉的反而是这种用法，而把 Moco 用在单元测试的这种场景比例就要低一些。也是因为这个独立模拟服务器的用法，Moco 也不再局限于 Java，不同的程序设计语言编写的应用都可以与之进行交互，Moco 的使用范围得到了扩展。

随后，还有人提出了更多功能性上的需求，让 Moco 的能力也得到了极大的提升：1）有些被模拟的服务不稳定，Moco 支持了一个 proxy 功能，将请求转发给被模拟服务。如果这个服务失效了，就使用本地缓存的信息；2）有些应答里的字段是根据请求的内容来的，Moco 支持了 template 功能，让使用者自己决定怎样使用哪个信息；3）有时还要对请求的内容，进行各种匹配。比如，URI 在同一个根目录下，就进行一样的处理，Moco 支持了 match 功能，让使用者自己可以写正则表达式，对请求进行匹配；4）有人为了方便管理，希望把所有的应答内容放到一个目录下，Moco 支持了 mount 功能，把一个目录挂载在一个 URI ；5）现在的 REST 开发是主流，Moco 支持了 REST 能力，能够定义资源，更方便地将同一资源的内容定义在一起……

所有这些内容都是在基础的模型上扩展出来的，基本上都不需要去改动基础模型。不过，有一个功能的拓展影响了基础模型，就是 template。因为它需要根据请求的内容来决定应答的内容，这让原本各自独立的 request 和 response 开始有了关联。为了适应 template 的需求，我在 ResponseHandler 的接口上增加了 Request，把请求信息带了进来：

```java
class SessionContext {
    private final Request request;
    private final Response response;
    ...
}

interface ResponseHandler {
  void writeToResponse(SessionContext context);
}
```

也是由于这个调整，让 Moco 后来有了可以支持录制回放的能力：

```java
server
  .request(by(uri("/record")))
  .response(record(group("foo")));
  
server
  .request(by(uri("/replay")))
  .response(replay(group("foo")));
```

在这个设置中，我们发给 /record 这个地址的内容就可以记录下来，然后，访问 /replay 这个地址的时候，我们就可以得到刚才记录的内容。由此，Moco 由原来只提供静态设置的模拟服务器，变成了一个能够动态配置的模拟服务器，能力得到了进一步提升。至此，你已经看到了 Moco 是怎么一点一点长大的。与 2012 年刚刚起步时相比，今天的 Moco 的能力已经强大了许多，但它的内核依然很小，代码量也不大。如果你希望研究一个有设计的代码，不妨从 Moco 入手，这个专栏讲到的不少内容都可以在 Moco 中看到影子。

Moco 就是根据请求给出应答，只要理解了这么一个简单的逻辑，你就完全可以理解 Moco 在做的事情，其他的东西都是在这个基础上生长出来的。

### 黑板墙

我想请你抬头看一下路，看看你在开发的过程中，发现过哪些阻碍研发过程的问题呢？

真的很精辟，开发工作是很讲究套路的，从问题，需求，方案，设计，发现问题很关键，太多开发，眼睛里看不到问题，重复开发，功能不复用，不扩展，性能差，开发效率慢，系统质量低，工作中有太多的痛点，痛点即是问题，不追求问题本质，不勤于思考的开发，就是推代码，能跑就行，不管后续维护。如果发现不了问题，更谈不上解决问题，解决方案和设计，就是解决问题，需要积累经验，不断学习，实践，提升解决问题的能力，只有把发现问题和解决问题都做好的开发，才能成为架构师或者 leader，更上一层楼。作者回复：总结得很好！2020-08-05

作为程序猿学习能力应该是自带属性，实际工作中，从解决问题出发，锻炼自身的软件设计和开发能力，这是一个层次。把问题抽象出来提供一个通用的解决方案，并提供程序库出来，这又是一个层次。自己和自己维护的代码一起进化，这应该是每一个开发者所追求的。2020-08-05

记得不错的话，spring mvc test 里面也有相似的概念，如 RequestMatcher，ResponseHandler, 今天才明白原来这是一种函数式编程的 dsl。moco 已 clone, 学习一下。作者回复: RequestMatcher 和 ResponseHandler 是模型，函数式的 DSL 是接口。2020-08-05

在日常工作中，常常因为查 bug 导致阻碍开发进度，其实也是旧项目单元测试没做好，但是有一部分原因是集成测试没做，有些问题需要整个系统和外部系统串起来完整的调用才能定位问题。我想写一个易于集成测试的 DSL，可以将测试人员写好的测试用例的描述内容作为集成测试的逻辑组装。大多数情况下都是测试人员在写自己的测试代码，通过系统的 http 接口调用进行测试。很难覆盖到系统和外部系统之间的调用，往往出问题的也是不同团队间的系统间调用，不同系统间调用老师有什么好的建议吗。2020-08-09

## 0602. 应用的设计：如何设计一个数据采集平台？

今天我通过一个指数系统的应用给你讲了一个应用的设计过程。在这里，你知道了想要做好设计，目标就不能局限于只把功能实现出来，而是我们要去不断发现可能存在的各种问题。简言之，只要你认为会出现重复，它就是一个值得我们去思考解决的问题。我还给你讲了如何衡量应用的设计水平，就是看它符合下面哪个标准：1）没有自动化；2）开发员修改代码实现；3）开发员修改配置实现；4）业务员修改配置实现。

程序员常常给人写代码，实现自动化，却常常忽略了自己工作中可以自动化的部分。作为一个懒惰的程序员，我们需要发现日常工作中繁琐的地方，让自己从低水平的重复中解脱出来。一件事是不是有技术含量往往不取决于事情本身，而取决于我们怎么做它。这两讲我们讲的都是怎么去设计一个新东西，但在实际工作中，有时候，我们还会面对一个既有的系统，这样的系统该如何改进呢？我们下一讲来谈。如果今天的内容你只能记住一件事，那请记住：一个更好的设计从拒绝低水平重复开始，把工作做成有技术含量的事情。

上一讲，我给你讲了 Moco 的设计，这是一个程序库级别的设计。除了开发一个程序库，在日常工作中，还有一种工作是程序员们非常熟悉的，就是开发一个应用。与之对应的设计就是应用设计。也许你会说，应用设计不就是按照之前讲的 DDD 的方法，先通过事件风暴建立通用语言，然后，再找出子域和划分出限界上下文，最后，再按照模板找出各种对象吗？

是的，设计的基本过程确实是这样的。不过，DDD 的方法只能保证我们设计出一个可以接受的方案。如果你想有一个更有扩展性的设计方案，就需要多花一点时间去构建一个更好的模型。这一讲，我就以一个金融指数系统为例，给你讲一下如何更好地设计一个应用。

### 2.1 一个指数系统

在金融系统中，有一个概念叫指数，用来表示金融市场的活动，比如有股票指数、期货指数等等。比较著名的指数有道琼斯指数、标准普尔指数。这个世界上的指数多得数不胜数，每个金融机构都会有自己的指数，而且，它们还会不断推出新的指数。

那指数是怎么算出来的呢？如果以股票为例，就是获取一堆股票的价格，然后根据一个公式算出一个结果。比如，我们有一个公式，A0.2+B0.3+C*0.5，我们把公式里的数据部分称为指标，也就是公式中的 A、B、C，这个公式表示这三种指标分别占比 20%、30% 和 50%。

这个公式就是三个不同的指标按照不同的占比进行求和。假设 A 指标的价格是 5 元、B 指标是 2 元、C 指标是 1 元，按照公式可以算出 520%+230%+1*50%=2.1，这个算出来的 2.1 就是指数的值。价格是实时变化的，而公式是固定的。指数在问世之初，我们需要不断调整这个公式里面各个指标的参数，以便能更好地反映市场的变化。问题来了，我们要怎样设计一个这样的指数系统呢？一个不假思索的设计就是，针对一个具体的指数进行开发。我们就要把指数计算中涉及的各种数据实时取过来，然后根据设置的公式去做计算。

如果我们只有一个指数，这么做也许是可以接受的。但我们要开发的是一个指数系统，这意味着我们会有很多个指数。两个不同的指数可能会用到同样的指标，如果我们按照开发一个指数的方法，不同的指标数据要获取好多遍，从某种意义上来说，这就是一种重复。所以，一个好的做法就是，先做职责划分，把不同职责的部分划分出来。正如我在这个专栏中一直说的，我们不能把各种不同的关注点混在一起，这是很多系统出问题的根源所在。

那从上面的需求描述中，我们可以把指数的计算过程分成两个部分：1）一部分是需要实时获取的数据，比如，前面说到的各种价格；2）一部分是根据公式进行计算出最终的结果，也就是指数最终的值。

这种拆分解决了前面设计中存在的问题，使得指标数据获取和公式计算分开了，同样的数据就可以用在多个公式中，数据的获取和公式的计算就不用同步进行了。而且，把计算过程拆成了两个部分之后，我们就可以针对这两个部分，分别进行细化了：1）对于指标数据获取的部分，我们要解决数据获取可能出现的问题，比如，不同的数据来源如何管理、不同数据源的数据格式是怎样的、如果数据源不可用，我们该怎么办等等；2）对于公式计算的部分，我们关心的问题则是计算要用到哪些指标、每个指标当前可用的值是多少、如果公式中有不可用的指标数据时，系统该怎么处理等等。

既然我们把系统拆分成了两个部分，还有一个问题就是，如何把这两个部分连接起来。其实，指标数据获取部分的输出，就是公式计算部分的输入，那指标数据获取部分的输出是什么呢？我们在前面分析过，指标数据获取要实时获取，无论采用轮询的方式，还是采用数据上报的方式。这种数据的特点就是，它有一个值，还有一个时间。正是因为这种特点，数据会形成一个序列，所以，我们将这种数据称为时序数据。

指标数据获取部分的输出其实就是这种时序数据，只不过，针对每一种指标都会产生一个时序数据序列，而这些不同的时序数据也正是公式计算部分的输入。既然是时序数据，也就有了时间的信息，我们的公式计算部分就可以根据时序数据的时间做一些处理了。比如，怎么判定一个指标不可用呢？如果判断一个指标最新的数据与当前时间的差值过大，我们就可以判断在这次计算中，该指标的数据不可用。

有了对于时序数据的认识，结合前面所说的数据获取和公式计算不再是同步进行的这一点，指标数据获取和公式计算两个部分就完全解耦了，二者之间可以只通过时序数据进行交互。

### 2.2 更上一层楼

现在，我们已经把数据获取和公式计算分成了两个部分，这应该是常规设计中都可以想到的。很多设计者做设计也可能就此打住，开始动手写代码了。但是，有时候我们还可以更进一步。我们可以继续分析一下，看看还有什么可以进一步改进的地方。

我先问你一个问题，公式计算你打算怎么做？你可能会想，这难道不是业务人员给我什么样的公式，我就用写代码的方式把它实现出来吗？这么做肯定是可以把公式实现出来，这一点是毋庸置疑的。但是，正如我前面所说，指数往往要经过一个调整的过程。因为业务人员自己也常常不确定设置的参数是否合理。用写代码的方式实现公式，也就意味着，每次业务人员要调整一个参数，你都需要去改代码。在可以预见的未来，你的工作基本上都会与调整参数相关，而这件事一点技术含量都没有。

对我们程序员而言，一件事是不是有技术含量往往不取决于事情本身，而取决于我们怎么做它。换言之，问题是一样的，但不同的解决方案却会带来不同的效果。业务人员提出的是问题，解决方案是由技术人员给出的，千万别混淆问题和解决方案。

当你可以预见一件事将来会很繁琐、会不断重复，而且会持续相当长的时间，这时候我们就需要重新审视我们的解决方案了。最原始的解决方案是没有自动化的方案，对于任何一个系统而言，我们最好要知道没有自动化的时候，这个问题是如何解决的。这和我们前面说到的，理解一个模型来龙去脉的思路是一致的。

当然，我们现在大多数情况下接触的都是一个已经自动化的方案，但方案之间还是存在着差别。在自动化方案中，最原始的做法是开发人员自己修改代码的方案，这种做法会导致开发人员大量的时间投入，属于严重消耗时间的做法。其次是开发人员修改配置，虽然这种做法只修改配置，但通常还会涉及到重新打包发布的过程，只能说它比修改代码要强一点。比较好的做法是，业务人员修改配置，开发人员完全不参与其中。一方面，业务人员自己最知道自己想要什么；另一方面，没有开发人员的参与，反馈周期就缩短了。

虽然这几种方法在业务的角度是越来越好的，但在设计上，却是要求越来越高的。比起没有自动化的方案，自动化的方案需要投入一些力量去做设计。相比于修改代码，修改配置就意味着要留下扩展的接口。而能够做到让业务人员而不是开发人员修改配置，配置的接口就应该是一个业务的接口，比如，要有一个配置界面。

如果我们用这几个标准评估一下我们现在的方案，显然，我们现在的方案还处于开发人员修改代码的阶段，这说明我们还有向上努力的空间。不过，我们给出的只是一个衡量标准，并不意味着这个台阶要一步一步上，因为我们可以一步就提升到最高标准，一步到位给业务人员提供一个配置的接口。

问题来了，我们要给业务人员提供一个配置接口，它应该长啥样呢？我们知道，这个指数设计的关键就是这个指数的公式。在前面的那个例子里面，它的公式是 A0.2+B0.3+C*0.5。如果我们能够让业务人员在配置接口上这样配置，问题就解决了。

在这里，A、B、C 分别代表一个指标，也就是说，我们只要能够让业务人员指定指标以及指定计算公式，剩下的问题就简单了，就是根据公式计算出相应的结果就好了。说起来很简单，但怎么把 A0.2+B0.3+C*0.5 变成一个可执行的公式，对一些程序员来说，还是有一定难度的。解析文本执行这件事是编译原理的基本功，不过只要你能理解这里需要一点编译原理的知识就很可以了，如果欠缺知识，就去学习相关知识好了。

实际上，公式的解析是编译原理入门的知识，难度系数比设计一门程序设计语言要小多了。而且，现在有编译器前端的工具，比如，Java 世界的 Antlr，它可以直接生成对应的语法树结构，我们只要负责去编写对应的执行部分就好了。

也许你发现了，我们实际上已经构建出了一门 DSL，一门属于指数计算这个特定领域的外部 DSL。前面讲 DSL 的时候，我们就说过，把设计做到极致就可以构建出一门 DSL。在这里，我们也看到了，了解 DSL，实际上也给我们增添了一个可以前进的方向。

把公式构建出来之后，我们仔细分析，还会有一个有趣的发现。你可以想一下，公式计算的结果是什么？因为我们说，它是在利用多个指标的时序数据做计算，所以它得到的结果，其实也是一个时序数据。这样，我们发现了另一个有趣的事，公式计算的得到其实也是一个指标。如此一来，公式计算的结果也可以作为另外一个公式的输入，形成更为复杂的复合公式。显然，由于复合公式的出现，这个系统的处理能力又上了一个台阶。

不知道你是否想起了什么，没错，它和设计模式中的组合模式如出一辙。你看，我们学习到的基础知识在这里都用上了。虽然我们这里讨论的是一个金融中会用到的指数系统，但当我们把模型经过一番整理之后，你会发现它不仅仅局限于指数系统中。比如，如果你在开发的是一个物联网系统，上报上来的数据，往往也要经过一些计算和聚合，那这个模型显然也是适用的。

再比如，你开发了一个 APM（Application Performance Management，应用性能管理）类的应用，采集上来的数据往往也要经过一番计算再展示出来，这个模型同样适用。所以，当我们可以构建出一个好的模型时，它本身就有着更大的适用范围。

### 黑板墙

我想请你回想一下，参照今天的内容，在你现在的工作中，有哪些可以从设计上改进的内容呢？

说的非常好，和我现在做的风控预警系统类似，同样适用于你说的这个通用模型，开发人员一定要有抽象能力，设计模式是一种特定场景的模型，同类应用系统也有通用的模型，采集、计算、分析、监测、预警、报告，如果你做的系统有这样的功能，那么就可以应用通用设计模型。

你说的编码实现，到开发人员配置，到业务人员配置，我们称为配置化，低代码，无代码化，这些目的都是快速响应需求，减少重复，减少开发投入的好方法，也是通用方法，我们同样应用于多个业务系统，我们有一个系统，要投入三分之二人力，支持开发，测试，我们做到了业务自主配置，开发完全解放出来了，因为这些工作就是低级重复，需要大量沟通，配置工作。开发人员要就是为解决问题的，一定避免低级，简单，重复工作，能自动化就不要手工，能自助化，就不要人工协作，对提升水平没有任何帮助，时间还浪费了，随着年龄增长，水平没有进步，本质上其实是在退步！作者回复：非常棒的分享！2020-08-07

分离关注点，把不同的职责划分出来。业务人员提出问题，技术人员提供解决方案，是否有技术含量取决于技术人员怎么去实现解决方案。一个好的设计要从拒绝低水平重复开始。作者回复：总结得不错。2020-08-07

## 0603. 应用的改进：如何改进我们的软件设计？

今天我给你讲了如何改进一个既有软件的设计。一个软件放在时间长河中会有很多东西发生改变，即便是当初还算不错的设计，随着时间的累积，也可能积重难返。改进一个软件的设计，首先，要确定改进的目标。改进的目标就是，重新设计这个软件，它应该设计成什么样子，让设计还原到它应有的本来面貌。寻找改进的起点，一部分可以从需求入手，还有一部分要从梳理接口入手。设计改进的难点在于不要回到老路上，要做正常的设计，尤其是要把分解做好。有了改进目标之后，接下来就是要找到一条改进路径，选择怎样的路径都是有道理的，但有两个关键点是非常重要的，一个是每步改进的动作要小；一个是要让相关利益人达成共识。如果今天的内容你只能记住一件事，那请记住：改进既有设计，从做一个正常的设计开始，小步向前。

前面两讲，我们分别讲了如何从头开始设计一个程序库和应用。但是在实际工作中，有很多时候，我们的工作并不是从头设计一个应用，而是改进一个既有项目的代码。既有项目的代码意味着什么呢？意味着各种问题。

我们一直在说，软件设计是一门关注长期变化的学问。越是在商业上成功的软件，存续的时间往往越长。存续的时间越长，往往就会有更多的麻烦。我们先不说有些项目一开始就没有设计，一路混乱向前。即便是一个最初有着还算不错设计的项目，随着时间的积累、人员的更替、把前人的做法当作惯例等等事情的发生，项目的设计就会逐渐变得不堪重负。

我在前面的课程中也举过一些例子，虽然每人只改了一点点，最后却是积重难返。这就是一个项目缺乏设计守护的结果。好的守护可以使设计更持久，遗憾的是，大多数项目做得并不好。除了上面这几点，还有一点就是，新的技术和框架会不断涌现，旧代码往往是不能有效使用这些新东西的。比如，Java 世界今天开发的主流是 Spring Boot，然而十年前，它还不存在。

虽然那时候已经有了 Spring，但那时候的主流开发方式还是打出一个 WAR 包，再部署到 Tomcat 上。所以，新出现的很多技术会提供更简单的做法，替换掉旧代码中笨拙的部分。所以，到底怎么才能让自己的项目在设计上不断地演进，跟上时代发展的步伐，不断焕发新的活力呢？对于任何一个开发团队而言，这都是一个值得考虑的问题。那么，这一讲，我们就来谈谈如何改进既有项目的设计。

### 3.1 从目标开始

在我的另外一个专栏《10x 程序员工作法》中，我讲过一个类似的主题，如何面对遗留系统。那里面的主要观点就是我们应该找到一个目标，然后小步改进，逐步向这个目标接近。在那一讲中，我讲的重点主要在于改进的过程，而在这里，我打算从设计的角度再来审视一下这个问题。既然都是我的专栏，所以二者在解决问题上的思路一致的，都要先从找到目标开始。

大多数团队一说起改进，一般想的都是功能性方面的目标。比如，我原来的系统能支持 100 万的用户，现在要支持 1000 万的用户。这种改进固然是我们需要考虑的，甚至是迫不得已的。但这种改进解决的是实现，因为不同量级的系统根本就不是一个系统，承载的用户量发生了变化，其实是一种需求的变化。但是，这种改变并不会让你的设计变好。

既然我们已经决定要改进了，就应该好好地把设计改进一下，而不只是把功能重新实现一遍。因为功能实现是你无论如何都必须做的，都是为别人做的，而设计的改进才是你为了自己做的，因为在未来的一段日子里维护这些代码的人是你。如果我们要做设计的改进，设定好改进设计的目标就显得尤为重要。

那设计改进的目标应该是什么呢？你可以先问一下自己这样一个问题，如果有机会从头设计这个系统，它应该是什么样子呢？这个问题可能会让很多程序员一下子愣住，因为他们每天都陷于忙碌的工作中，做的工作都是各种微调、各种打补丁，眼中只有一个具体微观的世界，却不曾有一个整体的思考。

是的，从头来过，它应该是什么样子。这是一个简单的问题，也是一个困难的问题。简单在于，它的字面意思很好理解。困难却在于，很多人一听到这个问题，直觉就要回避：1）我的系统已经这么沉重了，怎么可能重来？2）我有那么多的需求要做，哪有时间重做一遍？3）我的系统那么复杂，重做一遍，出了问题谁来负责？

我承认，这些都是很现实的问题。但是，我的意思并不是让你真的一上来就动手，从零开始把系统重写一遍。这里的重点在于，我们要找到改进的目标，也就是一个系统本来应有的面貌。这就是为什么我们前面要学习那么多设计一个系统的知识，否则，我们没有一个设计知识的沉淀，所谓的「重新设计」，弄不好我们就会回到原来的老路上去。

这时候，或许你突然想到一个严重的问题了，开启一次系统改进，如何处理人们的共识好像也是一件困难的事情，但这根本不是一个设计问题。想要真正地开启一次改进，就要让人们意识到，设计一个系统和实施一次系统改进是两个完全不同的问题，可以分阶段地进行。

我们只有把系统设计成它应有的样子，才算是确定了我们的目标。有了目标之后，接下来，我们才能制定改进路径，而把现有的系统一点一点从旧有的样子改动成新的样子，这是实施的过程。好！我假设你已经搞定了周边人的共识，准备着手进行改进了。

### 3.2 改进的过程

现在你要重新设计这个系统了，或许你会想，这有什么难的？不就是照着原来的需求，重新来一遍吗？如果你真的还有原来的需求，能让你照着设计一遍。我真的只能说，你太幸运了。在大部分真实的项目中，一个既有系统的情况是，没有人能够说出它到底承载了哪些需求。当然，主干部分是人人都知道的，但主干常常是九牛一毛，而更多的细节隐藏在代码中了。一个长期存在的系统，开发者可能已经换了好几拨。了解当年那些需求的人可能早已不知所踪了，导致的结果就是，每一个工作在这个项目上的人都是只见树木不见森林。

在这种情况下，我们该怎么办呢？我给你一个入手的起点，就是接口。在第 4 讲学习怎样理解一个系统的设计时，我们曾经说过，想要理解一个系统的设计，可以按照模型、接口和实现的这个框架去理解，其中，接口是模型能力的体现。

对于一个系统而言，接口也是使系统内部状态发生改变的原因，系统中的所有变化必然都是从某个接口开始的。既然没有人能够清楚地说明系统的现状，那么，我们从接口入手，了解系统的现状是一个非常现实的做法。毕竟，接口是不会骗人的。

不过，这里的接口不仅包括我们传统意义上的接口，也包括各种后台服务。前面我们讲了很多构建模型的内容，有了这个基础，我们再看后台服务，就会发现，后台服务只不过是按照某种规则触发模型的接口。比如，定时服务，就是定时地去调用模型的接口。所以，我们也要把这种接口梳理出来。有了对于这些接口的了解，我们就对这个系统呈现哪些能力有一个认识了，就相当于获得了一份需求描述。基于这个认识，我们来构建我们新的设计。

接下来，我们就要重新设计了，这个改进设计的难点就是不要回到老路上。我们需要按照一个正常设计的思路去走，该分离关注点的分离关注点，该重新组合的要重新组合。之所以我要提示这一点，就是因为思维的惯性实在是太大了。比如说，在原有的系统内有一个叫订单的概念，我们就会习惯性地使用订单，而不是把商品订单、支付订单等概念分开。

一般而言，既有项目的设计有一个很大的问题就是各种信息混在一起，而能够把不同的信息拆分开来，对于设计而言，就是一个巨大的进步。做好了新的设计，也就为我们后续的行动找到了新的方向。接下来，我们要做的是，对比新旧设计，找到一条改进路径。永远不要指望一个真实的项目停下来，一步到位地进行改进。我们能够做的，唯有小心翼翼，一步一步向着目标前进。对于不同的项目，选择的路径可能是不同的，有人会选择关键路径上的关键模块进行改进，也有人会选择影响较小的模块先进行探索，无论是哪种方案都是可以的。一个关键点就在于，动作要小。

学习过我的两个专栏的同学可能已经充分理解了我对小步前行的喜爱了。任何一个大动作，往往都意味着很长时间无法完成。在这个过程中，所有人都会提心吊胆。如果不能看到成果，很多人的信心都会随时间流失。所以，在软件设计的改进过程中，积小胜为大胜才是一个合理的选项。

还有一个关键点，要让所有相关利益人有一个共识。我又一次说到了共识，软件开发虽然是一个技术活，但归根结底还是一项团队活动，是一项人的活动。既然涉及到诸多参与者，就一定要让大家形成一个共识。所以，系统改进，尤其是一个规模比较大的系统改进，一定要让所有人有共识。无论是开会也好，宣讲也罢，让大家对于改进的原因和改进的计划有个共同的预期是至关重要的。更加具体的改进过程，我在《10x 程序员工作法》中有更细节的讨论，有兴趣的话，可以去参考一下。

虽然我在这里讲的是一个系统的改进过程，其实，同样的思路也可以运用在更小的模块中。只不过，更小模块意味着更少的接口、更低的复杂度以及更少的相关利益人。事实上，我反而鼓励你从小模块入手，一步到位去改进整个系统，难度系数是更大的，而小模块可以帮助你积累更多改进的经验，无论是设计，还是与人打交道。

### 黑板墙

我想请你回想一下，你的系统在设计上存在着哪些问题，你打算怎么改进它呢？

我们正在重构一个 40 多万行的应用，这个应用的开发，产品，业务都走光了，现在团队有的开发要重写，有的开发的意见是不动老代码，两种意见，我都是反对的，全部重写不现实，一个跑了 5 年的系统，需求根本没人弄的清楚，就算弄清楚需求，重写代码，就能做的更好？设计水平达到了吗？另外，不动老代码不现实，很多新需求，虽然是新需求，正因为设计的不好，不得不动老代码。面对这样的困境，我们还是采用小幅重构的办法，我们做了重构方案，目标清晰可落地，效果可检视。我们对重构进行分类。

1、瘦身，瘦身就是把系统的各种接口，页面接口，服务接口，job，通过监控统计已经下线的功能，把代码删除掉，最近一年没有访问的请求，把代码删除掉。另外，通过表，sql 反向梳理，就是表里没有新数据，sql 最近一年没有执行过，把这样的代码都删除掉。

2、重构，精准重构，1 个是性能，梳理接口，统计超过一定阀值的接口，根据成本收益原则，确定优先级，分布实施，1 个是功能复杂度，统计最近 1 年每个源代码文件提交的次数，我们的依据是开放封闭原则，一个类被频繁修改，就说明设计存在问题了。

3、新需求，新应用，对于业务领域是个全新的子域，我们坚决开发新应用解决，另外我们计划做服务标准化，对于新接口和服务，通过一个新应用实现。同样的遵守开放封闭原则。

我们已经重构了半年，下半年还要重构，我认为明年也要重构，重构得到领导的大力支持，我相信也是提升团队设计，开发水平的机会，加油吧！作者回复：非常棒的分享，感谢你让大家看到实践者前行的足迹！2020-08-10

我非常赞同从改进一个小的模块设计开始，不断地小步前行的做法。我最近也是在重构项目，虽然是 APP 项目，但这个项目很大，安装包已经有 200M。因为需求复杂，经历人员也比较多，结构设计也没有统一，有使用 rxjava，dagger，MVP 等等框架，交互层和业务层的逻辑交织在一起，改一个 bug 相当得耗时间。现在第一步做法是梳理模块，统一每个模块对外的接口，这个改动目前来说是最小的，也是更进一步改造的基础。曾多次问自己如果重新开始我会怎么设计这样的问题。其实回答这个问题可以帮你更好的理解现有系统的业务逻辑，也是你重构的目标，重新设计它是一个理想状态，不可能一下子就达到，但是可以不断地逼近目标。作者回复：感谢分享！2020-08-10

个人补充：项目质量的好坏，与公司发展情况，项目价值息息相关。在业绩不好的条件下，举债前行就是合理的。所以我们讨论项目质量，谈设计和重构，都是建立在价值和公司业务发展需要的前提条件下的。（反之，逆势而为有违天和，事倍功半）课后题：1）问题：最大的问题就是缺少共同设计。2）解决思路：开发与产品间的沟通应该基于统一、公开的业务建模。3）问题描述：产品和开发之间沟通都是基于一个个零散发散的功能点。在系统和业务间没有做一定的模型抽象。导致开发不了解业务全貌，产品不理解系统现状。进而在知识传承的成本就很大。往往新产品出的功能很难兼容现有系统（复用已有能力和兼容其他已有功能）; 新的开发也很难看清系统的全貌。（进而问题就多，问题多团队氛围就比较差，就容易扯皮）4）价值：产品需要开发通过模型勾勒出系统的现状，屏蔽掉实现的复杂度。开发需要产品通过模型屏蔽掉无关的业务复杂性，串联整体业务脉络，快速准确的理解业务全貌。如此也有利于新人介入，知识传承。5）外在问题：因为不是一个人的事，所以天时地利很重要，同样的时间也可以做很多事情，没必要吃力不讨好不是。作者回复：能够理解我写的内容都是吃过亏的人。2020-08-10

公司以前业务是 2C，后来钱烧完了，开发人员走的差不多，现在做 2B。但把各个服务拆的非常细，几十个微服务，几个人维护，现在也不敢做的大的改动。想了想问题：1）微服务拆分的太多，各种服务之间 RPC 调用经常超时。2）各个服务报错之后，没有事务和补偿机制，存在数据不一致问题。3）微服务相关调用，一个服务挂了，好多功能停摆，无法用。4）监控体系没有做，各种服务的状态和接口的调用情况不清晰。5）服务熔断、链路追踪等没有。有时候，我在想，2B 业务量不大，不如保持现在各个微服务的样子，只是不再一个个部署了，合并到一个进程里面跑算了（相当于模块化开发，把 RPC 调用禁掉）。只是有点回到老路的样子，大家有些不甘心。作者回复：微服务应该是结果，而不应该成为目标。2020-08-10

10 年 + 复杂系统改善坑：1）需要同步修改的点无法确定，如：上层接口变化导致下游未同步、数据源变化（分析人员方了）；2）面条逻辑，数据库、后台服务、前台、网关均有逻辑。3）神一般坏味道，if 能在屏幕左侧写到右两屏的那种。4）红线需求层出不穷。5）替换了依赖组件版本、修改底层一行代码，平台直接起不来。然后，我们的解决方案大致如下。

止损：1）建立规范，防止代码分层不明确、代码风格迥异。2）防止平台出现大变动。3）更新底层、尽量以新的能力承载，然后慢慢迁移到新的实现方式。4）外部基础组件版本不允许变化。

搭建安全网：1）建立后台服务接口监控。2）建立核心业务流程自动化测试流程，防止挂的太离谱。3）建立验收环境，上线版本必须在该环境进行验收测试。

落地实施：1）先拆基础服务，文件、消息等。2）新业务关联性不强，另起炉灶。3）将代码中的阈值一律移入配置管理，不允许写代码中。4）业务侧发起，哪些功能不要的，直接砍、删——做好长期战斗准备。5）建立核心业务平台标准接口 (业务上做调整)，外部平台陆续迁移新接口。6）数据库中单表超 20 个业务含义字段的都是危险分子，分析职责权属。7）让资深业务、测试、开发周期性来培训团队系统都有撒撒撒，他们重点关注的撒撒撒。

重构项目需要有愚公移山的精神，然后每次就来一点点。作者回复：非常赞的分享！2020-08-17

微服务应该是结果，而不应该成为目标。怎么理解这个呢？作者回复：不要为了微服务而去微服务，如果拆分的结果是微服务，那就微服务了。2020-08-20