# 2020027郑晔的软件设计之美R01

## 0100. 了解一个软件的设计

1、了解设计，先模型，再接口，最后是实现。

2、理解模型，要了解模型设计的来龙去脉。

3、理解一个项目的接口，先找主线，再看风格。

4、理解实现，带着自己的问题，了解软件的结构和关键的技术。

## 0101. 三步走：如何了解一个软件的设计？

今天，我们学习了如何了解一个软件设计，可以从三个部分入手：模型、接口和实现。1）模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。2）接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。3）实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。

了解设计的顺序应该是，先模型，再接口，最后是实现。了解设计，需要一层一层地展开，在每个层次都按照模型、接口和实现进行理解，在头脑中形成一棵设计树。现在你已经有了一个了解设计的基本方法，接下来几讲，我会用几个开源项目带你再进一步，去看看如何去了解模型、接口和实现。如果今天的内容你只能记住一件事，那请记住：了解设计，先模型，再接口，最后是实现。

经过了前面几讲的铺垫，我们已经对软件设计是什么，以及要考虑哪些因素有了一个初步的了解。热身之后，就该开启正式的旅程了。作为一个程序员，我们在职业生涯中免不了要接手新项目，承担维护该项目的职责。如果一个新项目摆在面前，你会怎么去研究它呢？

很多人的第一反应就是去看源代码。但是，一头扎入代码中，很快你就会迷失其中，最初那股子探索精神，也会逐渐被迷茫所代替。回想一下，有多少次你满怀希望地打开一个开源项目，结果多半都是坚持不了多久就放弃了。你有没有想过，问题出在哪里呢？你的迷茫在于缺少对这个软件整体的了解，这就如同不带地图指南针闯入密林一般，迷路只是早晚的事。所以，虽然阅读源码是必经的一步，却不应该是你的第一步。我们应该先从了解软件的设计开始。那我们该如何了解一个软件的设计呢？

### 1.1 模型、接口和实现

了解一个软件的设计可以从三个部分着手：模型、接口和实现。这三者的关系就好比你去看代码，你会先去看有哪些类以及它们之间的关系，这就是看模型；然后你会打开一个具体的类，看它提供了哪些方法，这就相当于看接口；最后，你再来打开一个具体的方法，去看它的代码是怎么写的，这就是看实现。

好，接下来，我们具体地分析一下每一个部分。首先是模型，它是一个软件的核心部分。在其它的材料里，也有人称之为抽象，为了统一，我这里就都叫模型了。我们在前面的课程里也说过，设计最关键的就是构建出模型。而理解一个设计中的模型，可以帮助我们建立起对这个软件整体的认知。

比如，你在编写分布式计算代码时，需要考虑怎样在不同的节点上调度计算；而使用 MapReduce 时，只要考虑如何把计算分开（Map）最后再汇总（Reduce）；而到了 Spark，注意力就集中在要做怎样的计算上。它们在解决同样的问题，只是抽象层次逐步提高了，越来越接近要解决的问题，越来越少地考虑计算在不同的机器上是如何执行的，由此，降低了理解的门槛。当你知道了模型的重要性，目光甚至可以不局限在某一个软件上。如果把同一个领域不同阶段的多个模型联系起来看，你还能看到软件发展的趋势。

其次是接口，它决定了软件通过怎样的方式，将模型提供的能力暴露出去。它是我们与这个软件交互的入口。如何理解这句话呢？我给你举几个具体的例子。1）一个程序库的接口就是它的 API，但对于同样的模型，每个人会设计出不同的 API，而不同的 API 有着不同的表达能力。比如：Google 的 Guava 对 JDK 的一些 API 重新做了封装，其目的就是简化开发，而很多优秀的做法后来又被 JDK 学了回去。2）一个工具软件一般会提供命令行接口，比如，每个程序员必备的基本技能 ——Unix 命令行工具就是典型的命令行接口。3）一个业务系统的接口，就是对外暴露的各种接口，比如，它提供的各种 REST API，也可能是提供了 RPC 给其它系统的调用……如果你想深入源码，去了解一个软件，接口是一个很好的指向标。你可以从一个接口进入到软件中，看它是怎样完成各种基本功能的。

最后是实现，就是指软件提供的模型和接口在内部是如何实现的，这是软件能力得以发挥的根基。这么说可能比较抽象，我再来举些例子。1）一个业务系统收到一个请求之后，是把信息写到数据库，还是转发给另外的系统。2）一个算法的实现，是选择调用与别人已有的程序库，还是需要自己实现一个特定的算法。3）一个系统中的功能，哪些应该做成分布式的，哪些应该由一个中央节点统一处理。4）一段业务处理，是应该做成单线程，还是多线程的。5）当资源有竞争，是每个节点自己处理，还是交由一个中间件统一处理。6）不同系统之间的连接，该采用哪种协议，是自己实现，还是找一个中间件……

讲到这，相信你一定发现了，「实现」里面的内容很多。所以，做每一个技术决策都应该结合自己所开发应用的特点，并不存在一个通用的解决方案。在实际的工作中，我发现许多人以为的设计其实是这里所讲的实现。

我也知道，「实现」很重要，但是，它必须建立在模型和接口的基础之上。因为在一个系统的设计中，模型是最核心的部分。如果模型变了，这个软件便不再是这个软件了，而接口通常反映的就是模型。所以，模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整。

举个例子，很多人都知道 Redis 这个键值对存储性能非常好，他们学习 Redis 时，对其单线程模型印象深刻，因为它简单高效。但随着人们使用 Redis 的增多，对 Redis 有了进一步的需求。所以，从 6.0 开始，它开始支持多线程版本，以便于更好地满足人们的需求。但即便 Redis 改成了多线程，它还是那个 Redis，它的模型和接口还是一如既往，只是实现变了而已。

### 1.2 了解设计三步走

之所以要把模型、接口和实现区分开来，是因为这三者的关注点是不同的，而很多人在讨论所谓的「设计」时，经常会把它们混在一起。如果你在讨论的时候连「讨论的内容到底是什么」都没弄清楚，就很难得出一个清晰的结果。我参与过很多类似的讨论，经常有一种很混乱的感觉。我思考了很长时间才发现，问题就在于他们把不同层面的内容混在了一起。

所以正确的做法是什么呢？就是你在讨论设计时应该遵循一个顺序，先模型，再接口，最后是实现，同理，了解一个设计也应该遵循这样的顺序。

如果模型都还没有弄清楚，就贸然进入细节的讨论，你很难分清哪些东西是核心，是必须保留的，哪些东西是可以替换的。如果你清楚了解了模型，也就知道哪些内容在系统中是广泛适用的，哪些内容必须要隔离。简单地说，分清模型会帮助你限制实现的使用范围。

下面是一张简化过的架构图，在这幅图里，订单模块完成处理之后，通过一个 Kafka 队列把消息发给支付模块，支付模块处理之后，再通过一个 Kafka 队列把消息发给物流模块。很多人都应该在自己的项目中见过类似的，但是更复杂的架构图。你能看出这张图的问题在哪吗？

这张架构图的问题就在于，它把模型和实现混淆在一起了。图中的订单、支付和物流，说的都是模型层面的东西，但 Kafka 的出现，就把实现层面的东西拉了进来。Kafka 只是实现这个功能时的一个技术选型，这也就意味着，如果随着业务的发展，它不能很好地扮演它的角色，你就可以替换掉它，而整个设计是不用变的。所以，实现这段代码的时候，必须把 Kafka 相关的代码进行封装，不能在系统各处随意地调用，因为它属于实现，是可能被替换的。

1『这个例子很赞，上面的信息结合原文的图去看。领域模型间交互的限界上下文映射（这个例子是 Kafka），不能直接体现在架构里，它跟领域模型不是同一个 level，要把它封装成一个「映射」模型，Kafka 只是这个映射模型的一个「实现」而已。』

我还要强调一点，在了解设计时，要按层次去了解，因为设计常常是分层的。每当我们打开一个层次，需要了解它的内部时，我们还要按照模型、接口和实现的顺序解读这个层次。

我用大家比较熟悉的操作系统来举个例子，如果你去了解它的内部，就知道它有内存管理、进程调度、文件系统等模块。我们可以按照模型、接口和实现去理解每个模块，就以进程管理为例：1）进程管理的核心模型就包括进程模型和调度算法；2）它的接口就包括，进程的创建、销毁以及调度算法的触发等；3）不同调度算法就是一个个具体的实现。

操作系统课程难以学习，很大程度上就在于，很多人没有搞清楚其中各个概念之间的关系。即便层层展开到最后，到了一个具体类，甚至是一个具体的数据结构，我们依然可以按照模型、接口和实现这个结构来理解，比如很多 Java 面试题常问到的 HashMap：1）它的模型就是我们在数据结构中学习的 HashMap；2）它定义了一些接口，比如，get、put 等；3）它的实现原来是用标准的 HashMap 实现，后来则借鉴了红黑树。

实际上，当你能够一层一层地去理解设计，就像一棵知识树逐渐展开一样，每一个知识节点在展开的时候，都会有下面一级更具体的内容。当你的头脑中有了这样一棵设计树，你也就掌握了整个系统的地图，再有新需求到来时，你就不会再盲目地去改代码了。

### 黑板墙

现在的开源项目越来越多，每个开源项目都会提供一些不同的特点，请你找一些自己感兴趣的开源项目，看看它们分别提供了什么，是新的模型、是新的接口，还是新的实现？

模型，通常包含两类要素，一是基本元素，二是这些元素之间的关系。比如常见的 CRM，基本元素就包括项目、客户、合同和回款，相互之间的主要关系通常是客户报备，进入立项环节（评估投入产出），再签约，最后进入回款环节。这是基本模型。这个模型（系统）的接口，就是要为 BD 提供从客户报备到签约、回款的整个流程管理。实现就是要考虑如何用消息在这些模块之间传递数据，状态控制、数据查重锁定等等。作者回复：赞，这个思路很清晰！2020-06-01

1-3『看到上面的信息后，模型对应于系统论中的系统，系统三大核心概念：系统中的元素、各个元素间的关系、延迟。（2020-09-01）』

当使用一个新的库或者框架的时候，首先看的是接口，看对外提供的功能的是否满足自己的要求，然后才是具体的实现。对于模型，想学习开源软件的架构的时候在去关注的。2020-06-01

思考：1）模型：圈定了数据，明确了边界。在我的数据范围内的业务才是我的业务。模型是业务的抽象定义。2）接口：定义了功能，明确了提供什么服务和这个服务的规格。接口是业务的功能口径。3）实现：选择技术，明确了功能的性能，满足接口的规格，实现业务的逻辑。实现与业务无关，只考虑接口规格和技术选型。2020-06-01

看 rocketmq 的文档，可以先从 [rocketmq/concept.md at master · apache/rocketmq](https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md) 了解模型开始。作者回复：很好的补充！2020-06-02

这个分析思路比较好，好多一上来就深入源码细节（实现）容易懵，特别是集成关系比较重的时候，最后都不知道调用到哪地方去了，这样就需要单步跟踪才能了解其脉络。若是先分析了类的层次关系，有个一定的理解，后面的调用脉络就有一定的清晰认识。模型这部分比较难理解，要想到作者为什么会这样定义模型，这样的设计用途是什么，可能刚开始不了解，到实现部分有种豁然开朗的感觉。2020-06-01

看了文章，知道自己以前为什么读不懂源码了，因为我每次都是从「实现」入手，想要自顶向上的去了解整个软件的架构，也许这条路也能走通，但是难度太大。之前看过《代码阅读方法与实践》（和大多数书一样没能看完），这本书其实就是从细节开始讲起的，书是好书，但是我的打开方式似乎有点问题。进程管理的模型包括调度算法，这个稍微有一点不好理解，我之前以为模型都是一些比较「实」的东西。不过如果从模型是「名词」/ 概念，接口是「动词」/ 命令，实现是动作 / 技术细节这个角度就更清楚一些。翻回到专栏的第一篇，老师举例说在交易系统中，有交易原语：下单、成交和撤单，交易动作：冻结、解冻、出金、入金，当时解释说这是模型上的分层。那么我的问题是，这些原语和动作都当做模型来看待么？如果让我来分析，那么交易系统的模型可能是：用户、商品、订单、支付、物流；接口是：下单、成交、撤单……作者回复：模型只有名词是一个误区，模型里会包含动词的，比如，Service 从角色上讲，就是一种动词。后面你还会看到相关的讨论。2020-06-01

模型是否可以这样理解：它可以包括，软件中有哪些类，类与类之间是如何组织的；软件中用了哪些框架（是 MVC，还是 DDD，TTD；也可以是业务模块之间的关系。总之，它是软件最基础，最核心的，也是最不可变的内容，最有别于其他软件的部分。作者回复：你可以把模型理解成一个个的类，但是，到了框架，就和实现相关了。MVC 是一种设计模式，DDD 是一种设计方法，TDD 是一种实践。2020-06-09

模型：需求，接口：可以提供哪些功能，实现：实现模型和接口的办法，语言，框架等技术。2020-06-06

以前一直以为 react 的接口设计很有前瞻性，以至于它们的内部架构改了几次对于使用者来说都没什么影响。读了这个课程之后才发现，它们只是严格遵循了软件设计的原则罢了。以前一直苦于不知如何改进现有项目的腐败点以及文档的产出，在这里我找到了切入点了。作者回复：好的设计都是类似的。2020-06-06

分析框架的流程应当从子模型往上建模，若从 mvc 入手，开始分析其内部的子模型是怎么实现，感觉虽然明显看到顶层模型的交互但是会很含糊。认为应当自底向上的进行分析，从框架运行的流程（生命周期）进行模型分析再上升为组件模型，最后总结 mvc 模型 / 其他模型，这种分析的方式，虽然相反，但是感觉更容易懂。2020-06-01

使用一个软件，就是通过其接口进行的。接口分为 api 和 ui。要想正确使用一个东西，就要知道一点内部的原理。模型是对内部原理的简化，可以让人快速上手。如果想玩一些高级的玩法，或者想要改造软件，就少不了研究实现了。接口和模型组合起来，就相当于一个「ADT」。作者回复：很好的补充，但 ADT 的说法，容易让人误解成实现。2020-06-01

理解软件开发中的设计可以通过三步走套路：模型 -> 接口 -> 实现，这个也就是了解软件设计的「模型」。1）模型其实是一个软件设计中的抽象，通过与其它软件设计中的进行对比学习，理解它们的异同，突出自身的核心抽象结构；2）接口是软件交互的入口，是一个软件系统的能力提现，它是一种规范，它与模型共同组成了软件系统的稳定性因素；3）实现是软件设计中对模型和接口的具体的逻辑实现，这个很好理解。2020-06-01

例如在 C++ 的一个小系统中，模型可以理解为定义的类么？接口类似于类里面的函数，接口类似于函数的调用？作者回复：后面你会看到不同的模块组织方式，本质上，C++ 的组织方式只有一个「类」的概念，幸好有宏定义，可以定义出不同的概念。2020-06-04

## 0102. Spring DI 容器：如何分析一个软件的模型？

今天，我们学习了如何了解设计的第一部分：看模型。理解模型，要知道项目提供了哪些模型，这些模型都提供了怎样的能力。但还有更重要的一步就是，要了解模型设计的来龙去脉。这样，一方面，可以增进了我们对它的了解，但另一方面，也会减少我们对模型的破坏或滥用。

我以 Spring 的 DI 容器为例给你讲解了如何理解模型。DI 容器的引入有效地解决了对象的创建和组装的问题，让程序员们拥有了一个新的编程模型。按照这个编程模型去写代码，整体的质量会得到大幅度的提升，也会规避掉之前的许多问题。这也是一个好的模型对项目起到的促进作用。像 DI 这种设计得非常好的模型，你甚至不觉得自己在用一个特定的模型在编程。有了对模型的了解，我们已经迈出了理解设计的第一步，下一讲，我们来看看怎样理解接口。如果今天的内容你只能记住一件事，那请记住：理解模型，要了解模型设计的来龙去脉。

今天这一讲，我们就先来谈谈了解设计的第一步：模型。如果拿到一个项目，我们怎么去理解它的模型呢？我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。这是所有人都知道的事情，我并不准备深入地去探讨。但如果只知道这些，你只是在了解别人设计的结果，这种程度并不足以支撑你后期对模型的维护。

在一个项目中，常常会出现新人随意向模型中添加内容，修改实现，让模型变得难以维护的情况。造成这一现象的原因就在于他们对于模型的理解不到位。我们都知道，任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。也就是说，理解一个模型的关键在于，要了解这个模型设计的来龙去脉，知道它是如何解决相应的问题。今天我们以 Spring 的 DI 容器为例，来看看怎样理解软件的模型。

1『每个模型都是为了解决某个特定问题而生的，去调研没有这个模型之前，该问题是如何处理的。』

### 2.1 耦合的依赖

Spring 在 Java 世界里绝对是大名鼎鼎，如果你今天在做 Java 开发而不用 Spring，那么你大概率会被认为是个另类。今天很多程序员都把 Spring 当成一个成熟的框架，很少去仔细分析 Spring 的设计。但作为一个从 0.8 版本就开始接触 Spring 的程序员，我刚好有幸经历了 Spring 从渺小到壮大的过程，得以体会到 Spring 给行业带来的巨大思维转变。

如果说 Spring 这棵参天大树有一个稳健的根基，那其根基就应该是 Spring 的 DI 容器。DI 是 Dependency Injection 的缩写，也就是「依赖注入」。Spring 的各个项目都是这个根基上长出的枝芽。那么，DI 容器要解决的问题是什么呢？它解决的是组件创建和组装的问题，但是为什么这是一个需要解决的问题呢？这就需要我们了解一下组件的创建和组装。

1『 DI 要解决的问题是，组件的创建和组装。』

在前面的课程中，我讲过，软件设计需要有一个分解的过程，所以，它必然还要面对一个组装的过程，也就是把分解出来的各个组件组装到一起，完成所需要的功能。为了叙述方便，我采用 Java 语言来进行后续的描述。

我们从程序员最熟悉的一个查询场景开始。假设我们有一个文章服务（ArticleService）提供根据标题查询文章的功能。当然，数据是需要持久化的，所以，这里还有一个 ArticleRepository，用来与持久化数据打交道。熟悉 DDD 的同学可能发现了，这个仓库（Repository）的概念来自于 DDD。如果你不熟悉也没关系，它就是与持久化数据打交道的一层，和一些人习惯的 Mapper 或者 DAO（Data Access Object）类似，你可以简单地把它理解成访问数据库的代码。

```java
class ArticleService {
  //提供根据标题查询文章的服务
  Article findByTitle(final String title) {
    ...
  }
}

interface ArticleRepository {
  //在持久化存储中，根据标题查询文章
  Article findByTitle(final String title)；
}
```

在 ArticleService 处理业务的过程中，需要用到 ArticleRepository 辅助它完成功能，也就是说，ArticleService 要依赖于 ArticleRepository。这时你该怎么做呢？一个直接的做法就是在 ArticleService 中增加一个字段表示 ArticleRepository。

```java
class ArticleService {
  private ArticleRepository repository;
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

目前看起来一切都还好，但是接下来，问题就来了，这个字段怎么初始化呢？程序员一般最直接的反应就是直接创建这个对象。这里选用了一个数据库版本的实现（DBArticleRepository）。

```java
class ArticleService {
  private ArticleRepository repository = new DBArticleRepository();
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

看上去很好，但实际上 DBArticleRepository 并不能这样初始化。正如这个实现类的名字所表示的那样，我们这里要用到数据库。但在真实的项目中，由于资源所限，我们一般不会在应用中任意打开数据库连接，而是会选择共享数据库连接。所以，DBArticleRepository 需要一个数据库连接（Connection）的参数。在这里，你决定在构造函数里把这个参数传进来。

```java
class ArticlService {
  private ArticleRepository repository;
  
  public ArticlService(final Connection connection) {
    this.repository = new DBArticleRepository(connection);
  }
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

好，代码写完了，它看上去一切正常。如果你的开发习惯仅仅到此为止，可能你会觉得这还不错。但我们并不打算做一个只写代码的程序员，所以，我们要进入下一个阶段：测试。

一旦开始准备测试，你就会发现，要让 ArticleService 跑起来，那就得让 ArticleRepository 也跑起来；要让 ArticleRepository 跑起来，那就得准备数据库连接。是不是觉得太麻烦，想放弃测试。但有职业素养的你，决定坚持一下，去准备数据库连接信息。然后，真正开始写测试时，你才发现，要测试，你还要在数据库里准备各种数据。比如，要测查询，你就得插入一些数据，看查出来的结果和插入的数据是否一致；要测更新，你就得先插入数据，测试跑完，再看数据更新是否正确。

不过，你还是没有放弃，咬着牙准备了一堆数据之后，你突然困惑了：我在干什么？我不是要测试服务吗？做数据准备不是测试仓库的时候应该做的事吗？那么，问题出在哪儿呢？其实就在你创建对象的那一刻，问题就出现了。

### 2.2 分离的依赖

为什么说从创建对象开始就出问题了呢？因为当我们创建一个对象时，就必须要有一个具体的实现类，对应到我们这里，就是那个 DBArticleRepository。虽然我们的 ArticleService 写得很干净，其他部分根本不依赖于 DBArticleRepository，只在构造函数里依赖了，但依赖就是依赖。

与此同时，由于要构造 DBArticleRepository 的缘故，我们这里还引入了 Connection 这个类，这个类只与 DBArticleRepository 的构造有关系，与我们这个 ArticleService 的业务逻辑一点关系都没有。所以，你看到了，只是因为引入了一个具体的实现，我们就需要把它周边配套的东西全部引入进来，而这一切与这个类本身的业务逻辑没有任何关系。

1『问题点出来了，在这个构造函数里，不能把创建数据库模型的具有实现放进来，因为创建数据模型要依赖很多「非业务」的东西，耦合了。（2020-09-01）』

这就好像，你原本打算买一套家具，现在却让你必须了解树是怎么种的、怎么伐的、怎么加工的，以及家具是怎么设计、怎么组装的，而你想要的只是一套能够使用的家具而已。

这还只是最简单的场景，在真实的项目中，构建一个对象可能还会牵扯到更多的内容：1）根据不同的参数，创建不同的实现类对象，你可能需要用到工厂模式。2）为了了解方法的执行时间，需要给被依赖的对象加上监控。3）依赖的对象来自于某个框架，你自己都不知道具体的实现类是什么……所以，即便是最简单的对象创建和组装，也不像看起来那么简单。

既然直接构造存在这么多的问题，那么最简单的办法就是把创建的过程拿出去，只留下与字段关联的过程：

```java
class ArticleService {
  private ArticleRepository repository;
  
  public ArticleService(final ArticleRepository repository) {
    this.repository = repository;
  }
  
  public Article findByTitle(final String title) {
    // 做参数校验
    return this.repository.findByTitle(title);
  }
}
```

1『对头，不要在 ArticleService 里 new 任何 ArticleRepository 对象，直接传进来一个 ArticleRepository 对象。』

这时候，ArticleService 就只依赖 ArticleRepository。而测试 ArticleService 也很简单，只要用一个对象将 ArticleRepository 的行为模拟出来就可以了。通常这种模拟对象行为的工作用一个现成的程序库就可以完成，这就是那些 Mock 框架能够帮助你完成的工作。

或许你想问，在之前的代码里，如果我用 Mock 框架模拟 Connection 类是不是也可以呢？理论上，的确可以。但是想要让 ArticleService 的测试通过，就必须打开 DBArticleRepository 的实现，只有配合着其中的实现，才可能让 ArticleService 跑起来。显然，你跑远了。

现在，对象的创建已经分离了出去，但还是要要有一个地方完成这个工作，最简单的解决方案自然是，把所有的对象创建和组装在一个地方完成：

```java
...
ArticleRepository repository = new DBArticleRepository(connection);
AriticleService service = new ArticleService(repository);
...
```

相比于业务逻辑，组装过程并没有什么复杂的部分。一般而言，纯粹是一个又一个对象的创建以及传参的过程，这部分的代码看上去会非常的无聊。虽然很无聊，但这一部分代码很重要，最好的解决方案就是有一个框架把它解决掉。在 Java 世界里，这种组装一堆对象的东西一般被称为「容器」，我们也用这个名字。

```java
Container container = new Container();
container.bind(Connection.class).to(connection);
container.bind(ArticleReposistory.class).to(DBArticleRepository.class);
container.bind(ArticleService.class).to(ArticleService.class)

ArticleService service = container.getInstance(ArticleService.class);
```

至此，一个容器就此诞生。因为它解决的是依赖的问题，把被依赖的对象像药水一样，注入到了目标对象中，所以，它得名「依赖注入」（Dependency Injection，简称 DI）。这个容器也就被称为 DI 容器了。至此，我简单地给你介绍了 DI 容器的来龙去脉。虽然上面这段和 Spring DI 容器长得并不一样，但其原理是一致的，只是接口的差异而已。

事实上，这种创建和组装对象的方式在当年引发了很大的讨论，直到最后 Martin Fowler 写了一篇《反转控制容器和依赖注入模式》的文章，才算把大家的讨论做了一个总结，行业里总算是有了一个共识。

2『 [Inversion of Control Containers and the Dependency Injection pattern](https://www.martinfowler.com/articles/injection.html)

去消化吸收 Martin Fowler 的这篇文章。——未完成
』

那段时间，DI 容器也得到了蓬勃的发展，很多开源项目都打造了自己的 DI 容器，Spring 是其中最有名的一个。只不过，Spring 并没有就此止步，而是在这样一个小内核上面发展出了更多的东西，这才有了我们今天看到的庞大的 Spring 王国。

讲到这里，你会想，那这和我们要讨论的「模型」有什么关系呢？正如我前面所说，很多人习惯性把对象的创建和组装写到了一个类里面，这样造成的结果就是，代码出现了大量的耦合。时至今日，很多项目依然在犯同样的错误。很多项目测试难做，原因就在于此。这也从另外一个侧面佐证了可测试性的作用，我们曾在第 3 讲中说过：可测试性是衡量设计优劣的一个重要标准。由此可见，在没有 DI 容器之前，那是怎样的一个蛮荒时代啊！

有了 DI 容器之后呢？你的代码就只剩下关联的代码，对象的创建和组装都由 DI 容器完成了。甚至在不经意间，你有了一个还算不错的设计：至少你做到了面向接口编程，它的实现是可以替换的，它还是可测试的。与之前相比，这是一种截然不同的思考方式，而这恰恰就是 DI 容器这个模型带给我们的。

而且，一旦有了容器的概念，它还可以不断增强。比如，我们想给所有与数据库相关的代码加上时间监控，只要在容器构造对象时添加处理即可。你可能已经发现了，这就是 AOP（Aspect Oriented Programming，面向切面编程）的处理手法。而这些改动，你的业务代码并无感知。

Spring 的流行，对于提升 Java 世界整体编程的质量是大有助益的。因为它引导的设计方向是一个好的方向，一个普通的 Java 程序员写出来的程序只要符合 Spring 引导的方向，那么它的基本质量就是有保障的，远超那个随意写程序的年代。不过，如果你不能认识到 DI 容器引导的方向，我们还是无法充分利用它的优势，更糟糕的是，我们也不能太低估一些程序员的破坏力。我还是见过很多程序员即便在用了 Spring 之后，依然是自己构造对象，静态方法满天飞，把原本一个还可以的设计，打得七零八落。

你看，通过上面的分析，我们知道了，只有理解了模型设计的来龙去脉，清楚认识到它在解决的问题，才能更好地运用这个模型去解决后面遇到的问题。如果你是这个项目的维护者，你才能更好地扩展这个模型，以便适应未来的需求。

### 黑板墙

最后，我想请你思考一个问题，DI 容器看上去如此地合情合理，为什么在其他编程语言的开发中，它并没有流行起来呢？

汇总：1）斟酌再三，虽说直接说 spring di 容器好像也没啥毛病，但个人觉得这描述并不是很准确，故阐述下自己的认知。2）我认为 spring 提供的这个编程模型应该叫 ioc（控制反转和响应式编程有点像）而不是 di。因为最开始被提出来的是 ioc（好莱坞原则），而且最早的实现也不是 spring，jdk 和 ejb 都有对 ioc 的实现，spring 才是后来者。但是 di 确实好像是在 spring 上被流行起来，且长期主流的（spring di 容器没毛病的原因）。不过 spring 对 ioc 的实现，除了 di 还有依赖查找，在我眼里 ioc 是模型，依赖查找和依赖注入是功能，所以我认为应该是 spring 提供了 ioc 的编程模型，利用 ioc 容器 + di 的功能简化了开发。3）依赖注入相对于依赖查找，透明度更好，调用方对 ioc 容器的 api 和具体接口实现的查表获取被隐藏了（技术与业务的解耦最终都该透明无感）。但依赖查找在需要动态选择策略时依旧有其用武之地。4）回答课后题： 对于 py 和 go 这类函数式编程语言，函数是一等公民，是可以作为参数传递的。那么直接改变所传的函数就可以实现 mock 和函数替换（使用和创建天然解耦）。为什么 java 会流行？我认为有个原因，是因为 java 是单分派的语言，编译期方法和参数类型是绑定死的（强类型），运行期走哪个 bean 的方法是动态决定的。如此就引出了面向接口编程的多态实现方案，才会有后面 ioc 的诉求。2020-06-03

我觉得最根本原因是大多数开发不写测试，所以不会考虑依赖问题，大多数方法都是面向实现而不是接口，使用 DI 容器反而增加了工作量。目前所在小组偏向于外包，代码只有一层，不是单列，就是静态方法；为了达到快速交付，基本没有设计，不管怎么说这都是不合理的。是前人挖，后人跳。作者回复：唉，你说的现状，我非常理解。所谓的「快」，只是从当前一个时点上看，放在长期，就是越跑越慢。2020-06-03

```java
container.bind(Connection.class).to(connection);
container.bind(ArticleReposistory.class).to(DBArticleRepository.class);
container.bind(ArticleService.class).to(ArticleService.class)
```

请问这 3 行代码的具体含义是啥？作者回复：1）将 Connection 这个类绑定在 connection 这个对象上，当需要一个 Connection 对象时，返回 connection 这个对象。2）将 ArticleReposistory 这个接口绑定在 DBArticleRepository 这个类上，当需要一个 ArticleReposistory 对象时，返回 DBArticleRepository 这个类的一个对象。3）将 ArticleService 这个类就绑定在其自身，当需要一个 ArticleService 对象时，返回这个类的一个对象。2020-06-03

理解软件设计中模型首先要理解模型解决的核心问题是什么，然后抽丝剥茧了解模型的来龙去脉，深入理解模型解决问题的过程。spring 中的 di 模型是为了解决对象的创建和组装的问题。那为什么创建对象和组装要用 di 来解决？一个重要的原因是为了解耦。分离接口与实现的强依赖，也就是软件设计第一步分离关注点。而这个恰恰就是为了可测试性，当一个代码是可测的，其实就是说明它是比较灵活的，修改起来不会牵一发而动全身，提高开发的体验，减少因修改引入的额外问题。2020-06-03

放下历史长河之中去看问题，比如现在去看几年前甚至 10 年前的代码，才知道这样做的好处，分离关注点，可测试性是多么需要，不然真的改不动。作者回复：这是我在开篇词里的立论，软件设计是一门关注长期变化的学问。2020-06-04

为什么不建议使用静态方法？如果只是简单的模型转换，用静态方法不是更好吗？作者回复：静态方法，没法去模拟它的行为，所以，要做测试的话，遇到静态方法，你必须关注它的实现，而不是它的接口。总的来说，静态方法是写着爽，但测着不方便。2020-06-04

1『也解答了自己之前的一个疑问，静态方法没法去模型它的行为，但为什么没法模型行为还是不理解。（2020-09-01）』

一个框架的流行根本原因不是它简化了开发，而是导致了问题的简化的那个开发模型。像 spring 提供的 di 模型，你甚至感受不到它的存在。它更像是一种理念，而这是一个模型的最高级形态。在 di 的核心模型之上，又出现了 starter、auto configuration 等理念，这就是 spring boot 的模型创新。在 springboot 之上，又有 springcloud.....Spring 这个框架，真的是牛逼（找不到合适的词了）。作者回复：没错，简化开发是结果，模型才是动因。Spring Boot 是在 Spring 出现好多年之后才出现的。2020-06-03

文中说「静态方法满天飞」是为了在实例方法中调用别的方法所以改为静态方法，是这样的意思吗？作者回复：为了方便，定义静态方法，到处调用，然后，没法 mock，不好测试。2020-06-03

接触 spring 七八年，一直在学习 BeanFactory 和 ApplicationContext 上打转，今天才算对容器这个概念有一个直觉性的认识！作者回复：学习一个软件，要从基础模型开始。2020-06-03

回答作业：1）Java 有反射，其他语言不一定有；2）Java 生态比较完善，大神比较多，有模版可以学；3）前端开发集中在 UI 界面和数据解析，需求变更快，用 DI 容器去做有点吃力；（UI 大多是包含的方式，很难把子控件拎出来初始化）4）DI 容器的 AOP 可能更适合后端，突如其来的统计、归档之类的需求。而前端的应用生命周期和页面生命周期都由 UI 框架提供了，AOP 自然用的少。总结：我觉得 AOP 可能才是开发者爱用 DI 的主要原因，加上 Java 生态的繁荣最终流行起来。（个人看法）作者回复：AOP 早在 DI 之前就有了，它并没有那么大的推动作用，DI 兴起之后，它才有了更多的用武之地。2020-06-03

DI 是模型？我理解的 DI 是一种实现，IoC 是模型。作者回复：当年，IoC、DIP 和 DI 几个名字争论了好久，最后决定叫了 DI，这个几个词确实有很多类似的地方。其实，它们都是设计原则。后面讲设计原则的时候，还会提到 DIP 的。2020-06-03

多半因为 Java 在企业级应用里独占鳌头，所以 Java 的 DI 更为人所知，也因为更早地出现了容器级的 DI，Java 才这么流行。作者回复：DI 没有成为主流时，Java 也已经很流行了，比如，J2EE。2020-06-03

跳出软件设计领域，像家具装潢（比如买沙发）等传统行业是可以找到对应概念的，但是相比软件设计复杂多；客户期望只关注产品功能（对应模型），然而企业销售产品时往往揉入了很多客户并不想了解的产品实现细节比如加工工艺、材料源头等（杂糅模型和实现）；这也算是造就了程序员的单纯吧。作者回复：打开盖子，才能看到细节。2020-06-22

我是一个两年的前端程序媛，不太了解 java。面向对象编程时，你只想要一颗树，却得到整个森林，于是有些人就觉得面向对象编程是不好的，所以认为函数式编程的方式更好，不过文章提到的组件创建和组合放入到一个容器中，也就是说将所有依赖都放入都一个地方，提供业务需要的接口，而不写到业务中，那么为啥没有在前端火起来呢？函数式编程是不是就是面向接口编程的一种呢？作者回复：后面会讲到函数式编程，简单来说，面向对象提供了组织类的能力，函数式编程提供了组织动作的能力，二者可以混合使用。2020-06-07

2『面向对象编程范式提供了组织类的能力，函数式编程范式提供了组织动作的能力。做一张金句卡片。』——已完成

我觉得是因为 Java 面向对象，更多的是使用组合解决问题，使用组合那就避免不了对象的依赖，加上接口实现分离，就更加依赖于 DI，而像其他的语言，像面向过程全程使用函数来解决问题，貌似有点用不到对象的组合和创建。我的一点小理解，也不知道有没有问题。作者回复：面向对象和面向过程只是用到了不同的设计元素，其实，使用程序设计语言完全可以兼顾二者，稍后，我会在编程方范式部分进一步讲解。2020-06-04

其实很早就听说过 Inversion of Control 和 Dependency Injection，但是似乎一直没有搞明白其中的概念，也没有机会有意识的去使用 DI（也许是用了，但是没有意识到）。重读了 Martin Fowler 的长（旧）文，有一个疑惑，专栏里面的 Spring DI 是属于哪一种类型的 IoC，看上去比较像 type 1，Constructor Injection。但是在 Martin Fowler 的文章里面说道 Spring 的开发者更推荐使用 Setter Injection（Spring 框架应该是同时支持这两种依赖注入方式的），不知道是因为框架的进展，改用了 Constructor Injection，或者只是局限于作者的这个例子。结合专栏的内容，简单的了解了一下 Spring 中的 DI。1）在 Ruby 中可以使用 dry-rb 实现依赖倒置：[Introduction to dependency injection in Ruby | by Christian Paling | Medium](https://medium.com/@Bakku1505/introduction-to-dependency-injection-in-ruby-dc238655a278)。2）但是 DHH 也说过：[Dependency injection is not a virtue in Ruby (DHH)](https://dhh.dk/2012/dependency-injection-is-not-a-virtue.html)。2020-06-03

2『 loC 做一张术语卡片。』——已完成

我的理解，IoC 是一种思想，就像 OOP、AOP 一样都是思想。而 DI 是技术实现，是 IoC 的最常见以及最合理的实现方式。按照老马（Martin Fowler）的意思，可以使用 DI 代替掉 IoC。因为 DI 就基本能够体现出 IoC 的意思了。省得搞混淆了。另外对于静态方法，在日常开发中，老师的建议是什么呀？推荐使用吗？在什么场景下可以推荐使用？作者回复: IoC、DI、DIP 其实这几个名字在早先的讨论里是类似的，容易混淆的，其重点都是把依赖通过接口隔离开。最后 DI 容器这里选了 DI，后面我们会讲到 DIP，可以再来看。IoC 远远到不了 OO 的级别，只是一种设计原则。静态方法能不用就不用，大多数情况下都可以用普通方法代替。只有少数程序库适合写成 static 的。2020-06-18

我觉得可能是用的太浅吧，或者把发挥的空间就留给了一小部分人，所谓的上手快，形成的优质案例不多影响也不大。编程思想是跨语言层面的，比如说 java 实现的用其它高级语言也能实现，要我说都是用的人的问题。人的因素很大，比如 C++ 也可以不写成多继承啊，不能因为语言层面没有禁止就说是语言设计的不好是吧。作者回复：对，只有脑子里面有一个该怎么做的主线，才不会被各种语言带偏了。2020-06-03

## 0103. Ruby on Rails：如何分析一个软件的接口？

今天我们学习如何了解设计的第二部分：看接口。看接口的一个方法是找主线，看风格。先找到一条功能主线，对项目建立起结构性的了解。有了主线之后，再沿着主线把相关接口梳理出来。查看接口，关键要看接口的风格，也就是项目作者引导人们怎样使用接口。在一个项目里，统一接口风格也是很重要的一个方面，所以，熟悉现有的接口风格，保持统一也是非常重要的。我还介绍了一个曾经火爆的 Web 开发框架：Ruby on Rails。借着它的起步走文档，我给你介绍了它的一些接口，包括：1）Web 应用对外暴露的接口：REST API；2）程序员写程序时用到的接口：API；3）程序员在开发过程中用到的接口：命令行。从 Rails 的接口设计中，我们可以看到，一个好的接口设计，无论是最佳实践的引入，抑或是 API 设计风格的引导，都可以帮助我们建立起良好的开发习惯。当我们理解了模型和接口，接下来就该看实现了，这就是我们下一讲要讲的内容。如果今天的内容你只能记住一件事，那请记住：理解一个项目的接口，先找主线，再看风格。

在上一讲中，我以 Spring 的 DI 容器为例，给你讲解了如何理解一个项目的模型。在模型之后，下一步就该是接口了。

在任何一个项目中，接口的数量都不是一个小数目。仅仅一个普通的程序库，里面的接口少则几十个，多则成百上千。难道我们理解接口，就是要一个一个地读这些接口吗？显然，你不太可能把所有的接口细节都记住。我写 Java 程序差不多 20 年了，但很多 JDK 里的类我都不了解。甚至有时候，还没有等我去了解这个类，它就过时了。那么，如何才能从纷繁复杂的接口中，披荆斩棘而出呢？我给你个方法：找主线，看风格。

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。你对细节部分的了解会随着你对项目的深入而逐渐增加。而有了主线后，你就有了着力点，就可以不断深入了。但是，我们要学习的不只是这些接口的用法，要想从项目的接口设计上学到更多，这就需要你关注它所引导的风格，换句话说，就是它希望你怎样使用它，或是怎样在上面继续开发。

从一个项目的接口风格中，我们不难看出设计者的品位。我们常把编程视为一种艺术，而在接口的设计上就能窥见一二。这些内容是我们在学习软件设计时，应该慢慢品味的。为什么要看风格，还有一个很重要的原因，就是你要维护项目的一致性，必须有一个统一的风格。有不少项目，里面会共存多种不同风格的接口，就是每个人都在设计自己习惯的接口，那势必会造成混乱。

这一讲，我们就来一起来学习怎样看接口，我选择的项目是 Ruby on Rails，因为它的接口设计风格是带给我最多震撼的，无论是编程接口的优雅，还是开发过程接口的顺畅。不过，正如我在第 4 讲所说，看设计要先看模型。所以，我们还是先快速地了解一下 Ruby on Rails 的模型。

### 3.1 Ruby on Rails 模型

如果你是一个比较年轻的程序员，Ruby on Rails 这个名字可能会让你有一些陌生。但是在十多年前，它初出茅庐之际，可是给行业带来了极大的冲击。只是后来时运不济，编程模型发生了大的改变，使它失去了行业领导者的地位。这个故事还是要从你最熟悉的 Web 开发说起。

自从互联网兴起，人们对于 Web 开发的探索就从未停止过。最早期的 Web 开发只是静态页面的开发，那时候，你只要熟悉 HTML，就可以说自己懂 Web 开发了。后来，人们不再满足于静态页面，开始尝试编写有动态效果的页面。一方面，浏览器开始支持 JavaScript，让页面本身有了动态效果；另一方面，有人开始制作后台服务，在页面之间切换的时候，也可以有动态的效果。那个时候出现了像 CGI（Common Gateway Interface）这样的编程规范。

当 Java 世界里出现了 Servlet、JSP 这些规范，Web 开发也逐渐由小打小闹变成了企业开发的主力，越来越多的公司开始正视 Web 开发。因为这些规范很沉重，一些号称要简化 Web 开发的框架开始出现，比如：Struts、Webwork 以及 Spring MVC 等等。

这些框架的出现，让 Web 开发摆脱了 Servlet 的初级阶段，使 MVC 模式成为了 Web 开发的主流。但即便如此，那个时候的 Java Web 开发依然是沉重的，比如写一个 Web 应用，光是配置文件就足以把人逼疯。Ruby on Rails 正是在这样的背景下横空出世的。为了叙述方便，后面我就把 Ruby on Rails 简称 Rails 了。

从模型上讲，Rails 是标准的基于 MVC 模型进行开发的 Web 框架。在这一点上，它没有什么特殊的，它给行业带来巨大冲击的是它的接口设计。Rails 一个重要的设计理念就是约定优于配置，无需配置，按照缺省的风格就可以完成基本的功能，这样的理念贯穿在 Rails 各个接口的设计中。接下来，我们就来看 Rails 的接口。

1『约定优于配置 Laravel 框架就是借鉴 Rails 的。』

前面我提到过理解接口应该先找主线，找到项目主线的一个方法就是从起步走文档开始，因为它会把项目最基本的用法展现给你，你可以轻松地找到主线。Rails 的起步走文档做得就非常好，主线可以说是一目了然。它用了一个 Web 项目帮你介绍了 Rails 开发的基本过程，通过这个过程，你就对 Rails 有了初步的印象。

有了主线之后，我们就要开始从中了解接口的风格。Rails 给我们提供的三种接口，分别是：1）Web 应用对外暴露的接口：REST API；2）程序员写程序时用到的接口：API；3）程序员在开发过程中用到的接口：命令行。接下来，我们就一个个地深入其中，了解它们的风格，以及它们给行业带来的不同思考。

### 3.2 REST 接口

先说应用对外暴露的接口：REST API。REST 如今已经成为很多人耳熟能详的名词，它把 Web 的各种信息当作资源。既然是资源，它就可以对这些 Web 信息做各种操作，这些操作对应着 HTTP 的各种动词（GET、POST、PUT、DELETE 等）。

REST 当年的问世是 Roy Fielding 博士为了纠正大家对 HTTP 的误用。REST 刚出来的时候，开发者普遍觉得这是一个好的想法，但怎么落地呢？没有几个人想得清楚。Rails 恰逢其时地出现了。Rails 对 REST 的使用方式做了一个约定。只要你遵循 Rails 的惯用写法，写出来的结果基本上就是符合 REST 结构的，也就是说，Rails 把 REST 这个模型用一种更实用的方式落地了。

```c
Rails.application.routes.draw do
  ...
  resources :articles
  ...
end
```

在用 Rails 写程序的时候，你只要添加一个 resource 进去，它就会替你规划好这个资源应该如何去写、怎么设计 URL、用哪些 HTTP 动词，以及它们对应到哪些方法。

```ruby
$ bin/rails routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index
```

看了 Rails 给你的这个映射关系后，你就知道自己该怎么写代码了。这就是一种约定，不需要你费心思考，因为这是人家总结出来的行业中的最佳实践。只要按照这个规范写，你写的就是一个符合 REST 规范的代码，这就是 Rails 引导的外部接口风格。

### 3.3 API 接口

我们再来看 API 接口。当年我接触 Rails 时，最让我感到震惊的是它的数据库查询方式，与传统开发的风格截然不同，就这么简单的一句：

```ruby
Article.find_by_title("foo")
```

要知道，那个时候用 Java 写程序，即便是想做一个最简单的查询，写的代码也是相当多的。我们不仅要创建一个对象，还要写对应的 SQL 语句，还要把查询出来的结果，按照一定的规则组装起来。而 Rails 用一句轻描淡写 find\_by 就解决了所有的问题，而且，这个 find\_by\_title 方法还不是我实现的，Rails 会替你自动实现。当我们需要有更多的查询条件时，只要一个一个附加上去就可以了。

```ruby
Article.find_by_title_and_author("foo", "bar")
```

同样的事，如果放到 Java 里去做，还需要把前面说的事再做一遍，差别只是查询语句不一样。虽然我说的是当年的场景，但时至今日，在这些简单问题上，很多使用 Java 的团队所付出的工作量并不比当年少。从功能的角度说，这样的查询在功能上是完全一样的，但显然 Rails 程序员和 Java 程序员的工作量是天差地别的。这其中的差异就是不同的编程接口所造成的。

所以你看，一个好的接口设计会节省很多工作量，会减少犯错的几率。因为它会在背后帮你实现那些细节。而设计不好的接口，则会把其中的细节暴露出来，让使用者参与其中。写程序库和写应用虽然都是写代码，但二者的要求确实相差极大。把细节暴露给所有人，显然是一个增加犯错几率的事情。

Rails 的 API 接口给行业带来的另一个影响是，它让人们开始关注 API 的表达性。比如，每篇文章可以有多个评论，用 Rails 的方式写出来是这样的：

```ruby
class Article < ApplicationRecord
  has_many :comments
  ...
end
```

而如果用传统 Java 风格，你写出来的代码，可能是这个样子的：

```java
class Article {
  private List<Comment> comments;
  ...
}
```

很明显，「有多个」这种表示关系的语义用 has\_many 表示更为直白，如果用 List ，你是无法辨别它是一个属性，还是一个关系的。Rails 里面类似的代码有很多，包括我们前面提到的 find\_by。所以，如果你去读 Rails 写成的应用，会觉得代码的可读性要好得多。

由于 Rails 的蓬勃发展，人们也开始注意到好接口的重要性。Java 后期的一些开源项目也开始向 Rails 学习。比如，使用 Spring Data JPA 的项目后，我们也可以写出类似 Rails 的代码。声明一对多的关系，可以这样写：

```java
class Article {
  @OneToMany
  private List<Comment> comments;
  ...
}
```

而查询要定义一个接口，代码可以这样写：

```java
interface ArticleRepository extends JpaRepository<Article, Long> {
  Article findByTitle(String title);
  Article findByTitleAndAuthor(String title, String author);
}
```

当你需要使用的时候，只要在服务里调用对应的接口即可。

```java
class ArticleService {
  private ArticleRepository repository;
  ...
  public Article findByTitle(final String title) {
    return repository.findByTitile(title);
  }
}
```

显然，Java 无法像 Rails 那样不声明方法就去调用，因为这是由 Ruby 的动态语言特性支持的，而 Java 这种编译型语言是做不到的。不过比起从前自己写 SQL、做对象映射，已经减少了很多的工作量。顺便说一下，Spring Data JPA 之所以能够只声明接口，一个重要的原因就是它利用了 Spring 提供的基础设施，也就是上一讲提到的依赖注入。它帮你动态生成了一个类，不用你自己手工编写。简单，表达性好，这就是 Rails API 的风格。

### 3.4 命令行接口

作为程序员，我们都知道自动化的重要性，但 Rails 在「把命令行的接口和整个工程配套得浑然一体」这个方面做到了极致。Rails 的自动化不仅会帮你做一些事情，更重要的是，它还把当前软件工程方面的最佳实践融合进去，这就是 Rails 的命令行风格。如果要创建一个新项目，你会怎么做呢？使用 Rails，这就是一个命令：

```
$ rails new article-app
```

这个命令执行的结果生成的不仅仅是源码，还有一些鼓励你去做的最佳实践，比如：1）它选择了 Rake 作为自动化管理的工具，生成了对应的 Rakefile；2）它选择了 RubyGem 作为包管理的工具，生成了对应的 Gemfile；3）为防止在不同的人在机器上执行命令的时间不同，导致对应的软件包有变动，生成了对应的 Gemfile.lock，锁定了软件包的版本；3）把对数据库的改动变成了代码……

而这仅仅是一个刚刚生成的工程，我们一行代码都没有写，它却已经可以运行了。

```
$ bin/rails server
```

这就启动了一个服务器，访问 http://localhost:3000/ 这个 URL，你就可以访问到一个页面。如果你打算开始编写代码，你也可以让它帮你生成代码骨架。执行下面的命令，它会帮你生成一个 controller 类，生成对应的页面，甚至包括了对应的测试，这同样是一个鼓励测试的最佳实践。

```
$ bin/rails generate controller Welcome index
```

1『对应于 Laravel 里「php artisan XX」的各种命令，原来这个术语命令行接口。（2020-09-01）』

在 Rails 蓬勃发展的那个时代，人们努力探索着 Web 开发中各种优秀的做法，而在这个方面走在最前沿的就是 Rails。所以，那个时候，我们经常会关注 Rails 的版本更新，看看又有哪些好的做法被融入其中。Rails 中那些优秀的实践逐步地被各种语言的框架学习着。语言编写者们在设计各种语言框架时，也都逐步借鉴了 Rails 中的那些优秀实践。比如，今天做 Java 开发，我们也会用到数据库迁移的工具，比如 Flyway。当然，另一个方面，即便到了今天，大部分项目的自动化整合程度也远远达不到 Rails 的高度，可能各方面的工具都有，但是如此浑然一体的开发体验，依然是 Rails 做得最好。

最后，你可能会问，Rails 这么优秀，为什么今天却落伍了呢？在 Web 开发领域，Rails 可谓成也 MVC，败也 MVC。MVC 是那个时代 Web 开发的主流，页面主要在服务端进行渲染。然而，后来风云突变，拜 JavaScript 虚拟机 V8 所赐，JavaScript 能力越来越强，Node.js 兴起，人们重新认识了 JavaScirpt。它从边缘站到了舞台中心，各种组件层出不穷，前端页面的表现力大幅度增强。Web 开发的模式由原来的 MVC，逐渐变成了前端提供页面，后端提供接口的方式。Java 的一些框架和服务也逐步发展了起来，Spring 系列也越来越强大，重新夺回了 Web 后端开发的关注。

### 黑板墙

最后，我想请你来分享一下，你在哪个项目的设计中学到了一些好的开发习惯呢？

汇总：1）最早自学的就是 ruby，要不是因为找不到工作，可能就做不成 javaer 了。论快速搭建一个 web 项目，至今依旧是 ruby on rails。一个多小时从无到有搭建一个博客系统的时候，信心爆棚。2）本篇，明天得再看看。get 不到点。只能理解风格应该是说设计偏好。至于主线，从 ruby 这个 demo 里没能 get 到。3）spring。兼容（老版本以及各种场景），开放（提供规范和基础工具，方便各种「实现」自己写插件接入 spring），与时俱进（springboot 的推出，算得上破而后立），追求卓越（在迭代中改变接口命名，只为让原本达意的命名更达意）。作者回复：Ruby 成于 Rails，也败于 Rails。2020-06-05

在 Spring 的源码中，接口 -> 抽象类 -> 实现类，如 BeanDefinition -> AbstractBeanDefinition -> RootBeanDefinition。这样的设计风格。顶层接口规定定义，抽象类提供部分实现。用户需要扩展，可以选择从抽象类进行扩展，或从接口扩展。作者回复：上一讲是 Spring，这一讲是 Ruby on Rails，这个评论让我有一种走错片场的感觉。2020-06-05

找主线，看风格。找主线看文章，看风格看接口。从上到下，从整体到局部。不过这也是正常读源码的一个步骤。作者回复：太喜欢你这个评论了，这就应该是正常的步骤啊，可是很多人不知道。2020-06-07

Ruby on Rails 这个设计在当时感觉很超前，也不知道现在的 SpringBoot 是不是借鉴了，感觉从 SpringBoot 上能看倒 Ruby on Rails 的身影，SpringBoot 的约定大于配置，还 SpringBoot 把命简洁的页面，勾选之后就可以创建一个简单的 SpringBoot 项目等等，Ruby on Rails 的设计在现在看来可能确实没什么，但在当时感觉这个设计就太超前了。作者回复：你说得很对，Rails 超前是全方位的，今天看来，很多东西都影响了全行业。2020-06-06

理解软件中的接口设计，要抓住主线，可以从文档开始入手，了解软件设计者的风格品味，看看作者希望我们是如何使用这些接口的。我没用过 Ruby，但是通过分析之后，其实它的接口设计中，整合了许多极佳的工程实践，提高编码效率，解放生产力，这些思想在软件设计的时候是可以学习和参考的。作者回复：能够把开发效率提高，也是一大推动力。2020-06-05

好的设计要多从使用者角度考虑，是否有助于释放程序员精力，是否易用，是否有良好的可读性和可扩展性。自己先用，并在开始时就设定好边界，即使先只在一点上有所突破也比全面开花哪哪不灵要好。作者回复：这个我完全同意！你说的单点突破实际上就是 MVP 的思路。2020-06-07

最早接触 BDD 是 cucumber，当时觉得简直是 magic。整个 RoR 框架也到处给人 magic 的感觉。但是软件开发不应该有 magic，否则容易失控。RoR 式微部分原因可能也是 Ruby 过于灵活了，印象中 RoR 有些严重的安全漏洞就是由此引发。此外 Ruby 的执行效率也逐渐落后于时代了。近年来有 Crystal 语言借由 llvm 复兴 Ruby，加入了很多现代语言的特性，希望能有好结果。作者回复：这是两个方面，使用者和开发者。使用者的角度，那是简单的，开发者的角度，需要理解那些 Magic。Ruby 有些问题其实动态语言的问题，在开发大型应用上，没有类型是一个很伤的地方。执行效率其实与使用程度是相关的，只要有更多的人在用，就会有更多的人来优化，如果没有人用，优化的动力自然就不强了。2020-06-05

「优雅的编程接口，顺畅的开发过程」，虽然我也非常的喜欢 Ruby on Rails，却没有办法像老师这样精辟的总结提升。给我的感觉，RoR 在设计的时候非常的体贴程序员，并且采用了一大堆优秀的设计范式。看了文中对于 Rails 接口的分析，感觉更喜欢 Rails 了，可惜的确如同留言里面 @Jxin 说的那样，工作不好找，另外薪水不高。如果按照开发模式的变迁，那么现在是不是应该学习 Deno ? 请老师推荐一个比较有潜力的语言或者框架，Go 或者 TypeScript ？作者回复：很快就轮到讲程序设计语言了，简言之，多学点。2020-06-05

接触的第一个框架就是 rails，用起来确实很爽，今天看到此篇文章，让我对它更有敬意，而不会因为现在不就行，或者性能不够好，就看不起它，没有东西是绝对的好，或者绝对不好，今天全是对这个道理有更深层的理解了。我之后学习了 JavaScript，转了前端，学习 Vue 框架，它使用虚拟 dom 将组件高度抽象化，使页面组件可以多端运行，比如 node 端，如此可以前后端同构，解决单页面应用的劣势，而保留其优势。模块如何拆解然后又如何组装，逻辑清晰。提供了很多全局组件和生命周期函数，以及其他方法，这些就是给程序员提供的接口，可以让我们在特定的场景让你更加关注功能需求的实现，而不是代码的实现细节，会自动帮你做好很多事情。并且使用了很多高阶函数，化繁为简，最终返回一个干净的只有核心逻辑的函数。即大量使用了函数式编程。学习的过程就是写一段简单的，特定场景代码，然后进行断点测试，看看源码中主要会走那些流程。然后大概就有了一条小主线。好的框架理解起来应该是容易的，清晰的。而那些不假思索写出来的面向过程的代码，如果不一行一行去看的话，就不知道问题出在哪里，甚至以后回过来看，都不知道自己是怎么写出这种代码的，就像写正则表达式一样，写完之后，自己都看不懂了。作者回复：感谢你的分享，丰富了更多的内容。2020-06-08

问个问题，如果说 rails 落伍的原因是因为 Javascript，为什么没有演变成 javascript + rails 后端服务这样的组合呢？作者回复：在加餐里讲了 JavaScript 的兴起，实际上，Node.js 并没有真正意义上成为后端开发的主力，却促进了前端的发展，让前后端分离了，结果，后端借此兴起的是 Java。Rails 归根结底是有硬伤的，性能差。在没有了 MVC 的加持之后，Java 就重新回来了。2020-06-28

那 python 的 Django 是不是也有 rails 的问题？那 flask 呢？java 的 spring boot 是更好的实践吗？另外 rails 应该也可以使用前后端分离吗？老师是否还可以再分享下，spring 具体是如何越来越强大，使得 rails 落伍？spring 和 node 如何联手超越 rails 的？作者回复：从工程实践的角度看，Rails 是最好的，很多后来者抄袭了 Rails，比如，Django。Spring Boot 最近这些年进步很大，但依然不如 Rails。Spring Boot 其实就是把 Spring 这么多年积累的组件合到了一起，再加上嵌入式服务器的发展，大幅度地降低了开发难度。编程模型从 MVC 转向了 REST 服务，是一个重大的契机。Rails 自身的执行效率本来就是一个硬伤。Spring Boot 可以说抓住了新一波的浪潮，让 Java 重新回到了巅峰上。之所以 MVC 转向了 REST，要拜 Node.js 所赐，让前端有了大发展，这段分析在程序设计语言的加餐中。2020-06-19

关于接口想请教一下老师，我们平时在公司内部的二方库，是不是应该拆分成两个 jar 包，分为 api 模型包和一个实现包。对于大多数开发业务我们只关心一个系统的模型以及提供什么样的功能接口。拆分成不同包可以根据需要引入不同的实现包，而 api 和模型是共用的。比如最近有个项目需要把查数据湖的报表改成差数据库，如果封装的足够好应该只要替换实现就可以不改一行代码达到目标。作者回复：这其实是打包原则的事。从理论上说，分成两个是最好，只是实际情况很多人分不了那么干净。2020-06-11

## 0104. Kafka：如何分析一个软件的实现？

今天是了解设计的第三部分：看实现。理解一个实现，是以对模型和接口的理解为前提的。每个系统的实现都有非常多的细节，我们不可能一上来就把所有的细节吃透。如果想了解一个系统的实现，应该从软件结构和关键技术两个方面着手。无论是软件结构，还是关键技术，我们都需要带着自己的问题入手，而问题的出发点就是我们对模型和接口的理解。了解软件的结构，其实，就是把分层的模型展开，看下一层的模型。一方面，你要知道这个层次给你提供了怎样的模型，另一方面，你要带着自己的问题去了解这些模型为什么要这么设计。最后，我借着 Kafka 的关键技术还给你讲了软硬结合的思路，在系统优化之路上寻求突破时，可以增加你选择的道路。不过，实现都是有约束的，比如，Kafka 的实现主要是针对机械硬盘做的优化，现在的 SSD 硬盘越来越多，成本越来越低，这个立意的出发点已经不像以前那样稳固了。

至此，了解设计的三步我们已经全部走完了。接下来，我们就要开始自己的设计历程了。首先，我们需要掌握一些关于设计的基础知识。下一讲，我们就从最基础的部分入手，我们来谈谈程序设计语言。如果今天的内容你只能记住一件事，那请记住：理解实现，带着自己的问题，了解软件的结构和关键的技术。

上一讲，我们学习了如何看接口，今天我们进入第三个部分 —— 看实现。在一个系统中，模型和接口是相对稳定的部分。但是，同样的模型和接口，如果采用不同的实现，稳定性、可扩展性和性能等诸多方面相差极大。而且，只有了解实现，你才有改动代码的基础。但是，不得不说，「看实现」是一个很大的挑战，因为有无数的细节在那里等着你。所以，在很多团队里，一个新人甚至会用长达几个月的时间去熟悉代码中的这些细节。

面对这种情况，我们该怎么办呢？首先，你要记住一件事，你不太可能记住真实项目的所有细节，甚至到你离开项目的那一天，你依然会有很多细节不知道，可这并不妨碍你的工作。但是，如果你心中没有一份关于项目实现的地图，你就一定会迷失。

像我前面所说的新人，他们用几个月的时间熟悉代码，就是在通过代码一点点展开地图，但是，这不仅极其浪费时间，也很难形成一个整体认知。所以我建议，你应该直接把地图展开。怎么展开呢？你需要找到两个关键点：软件的结构和关键的技术。

可能你还不太理解我的意思，下面我就以开源软件 Kafka 为例，给你讲一下如何把地图展开，去看一个软件的实现。按照我们之前讲过的思路，了解一个软件设计的步骤是「先模型，再接口，最后看实现」。所以，我们要先了解 Kafka 的模型和接口。

### 4.1 消息队列的模型与接口

Kafka 是这么自我介绍的：Kafka 是一个分布式流平台。这是它现在的发展方向，但在更多人的心目中，Kafka 的角色是一个消息队列。可以说，消息队列是 Kafka 这个软件的核心模型，而流平台显然是这个核心模型存在之后的扩展。所以，我们要先把焦点放在 Kafka 的核心模型 —— 消息队列上。简单地说，消息队列（Messaging Queue）是一种进程间通信的方式，发消息的一方（也就是生产者）将消息发给消息队列，收消息的一方（也就是消费者）将队列中的消息取出并进行处理。

站在看模型的角度上，消息队列是很简单的，无非是生产者发消息，消费者消费消息。而且消息队列通常还会有一个 topic 的概念，用以区分发给不同目标的消息。消息队列的基本接口也很简单。以 Kafka 为例，生产者是这样发消息的：

```java
producer.send(new KafkaRecord<>("topic", new Message()));
```

而消费者收消息是这样的：

```java
ConsumerRecords<String, Message> records = consumer.poll(1000);
```

有了对模型和接口的基本了解，我们会发现，消息队列本身并不难。但我们都知道，消息队列的实现有很多，Kafka 只是其中一种，还有诸如 ActiveMQ、RabbitMQ 等的实现。为什么会有这么多不同的消息队列实现呢？因为每个消息队列的实现都会有所侧重，不同的消息队列有其适用的场景。

消息队列还有一个最常见的特性是，它会提供一定的消息存储能力。这样的话，当生产者发消息的速度快于消费者处理消息的速度时，消息队列可以起到一定的缓冲作用。所以，有一些系统会利用消息队列的这个特性做「削峰填谷」，也就是在消息量特别大时，先把消息收下来，慢慢处理，以减小系统的压力。Kafka 之所以能从一众消息队列实现中脱颖而出，一个重要的原因就是，它针对消息写入做了优化，它的生产者写入速度特别快。从整体的表现上看，就是吞吐能力特别强。

好，我们已经对 Kafka 的能力有了一个初步的认识。显然，介绍接口和模型不足以将它与其他消息队列实现区分开来。所以，我们必须拉开大幕，开始去了解它的实现。

### 4.2 软件的结构

前面我提到，当我们想去看一个软件的实现时，有两件事特别重要：软件的结构和关键的技术。

我们先来看软件的结构。软件的结构其实也是软件的模型，只不过，它不是整体上的模型，而是展开实现细节之后的模型。我在第 1 讲也说过，模型是分层的。对于每个软件来说，当你从整体的角度去了解它的时候，它是完整的一块。但当你打开它的时候，它就变成了多个模块的组合，这也是所谓「分层」的意义所在。而上一层只要使用下一层提供给它的接口就好。所以，当我们打开了一个层次，了解它的实现时，也要先从大处着手。最好的办法就是我们能够找到一张结构图，准确地了解它的结构。

如果你能够找到这样一张图，你还是很幸运的。因为在真实的项目中，你可能会碰到各种可能性：1）结构图混乱：你找到一张图，上面包含了各种内容。比如，有的是模块设计，有的是具体实现，更有甚者，还包括了一些流程；2）结构图复杂：一个比较成熟的项目，图上画了太多的内容。确实，随着项目的发展，软件解决的问题越来越多，它必然包含了更多的模块。但对于初次接触这个项目的我们而言，它就过于复杂了；3）无结构图：这是最糟糕的情况，你最好先想办法画出一张图来。

无论遇到上述的哪种情况，你了解项目都不会很顺利。所以，你还是要先了解模型和接口，因为它们永远是你的主线，可以帮你从混乱的局面中走出来。那么，假设现在你有了一张结构图，在我们继续前进之前，我想先问一个问题：现在你有了一张结构图，你打算做什么？你可能会问，难道不是了解它的结构吗？是，但不够。我们不仅要知道一个设计的结果，最好还要推断出设计的动因。

所以，一种更好的做法是，带着问题上路。我们不妨假设自己就是这个软件的设计者，问问自己要怎么做。然后再去对比别人的设计，你就会发现，自己的想法和别人想法的相同或不同之处。对于理解 Kafka 而言，第一个问题就是如果你来设计一个消息队列，你会怎么做呢？

如果在网上搜索 Kafka 的架构图，你会搜到各种各样的图，上面包含了不同的信息。有的告诉你分区（Partition）的概念，有的告诉你 Zookeeper。根据前面对模型的介绍，我特意挑了一张看上去最简单的架构图，因为它最贴近消息队列的基础模型：

那么，从这个图中，你能看到什么呢？你能看到，Kafka 的生产者一端将消息发送给 Kafka 集群，然后，消费者一端将消息取出来进行处理。这样的结构和你想的是不是一样的呢？如果让你负责进一步设计，你会怎么做呢？1）生产者端封装出一个 SDK，负责消息的发送；2）消费者端封装出一个 SDK，负责消息的接收；3）设计一个集群系统，作为生产者和消费者之间的连接。

然后，你就可以问自己更多的问题：1）生产端如果出现网络抖动，消息没有成功发送，它要怎么重试呢？2）消费端处理完的消息，怎样才能保证集群不会重复发送呢？3）为什么要设计一个集群呢？要防止出现单点的故障，而一旦有了集群，就会牵扯到下一个问题，集群内的节点如何保证消息的同步呢？4）消息在集群里是怎么存储的？5）生产端也好，消费端也罢，如果一个节点彻底掉线，集群该怎么处理呢？……

你有了更多的问题之后，你就会在代码里进行更深入地探索。你可以根据需要，打开对应模块，进一步了解里面的实现。比如，消息重发的问题，你就可以看看生产端是怎么解决这些问题的。当问题细化到具体实现时，我们就可以打开对应的源码，去里面寻找答案。

从结构上来说，Kafka 不是一个特别复杂的系统。所以，如果你的项目更复杂，层次更多，我建议你把各个层次逐一展开，先把整体结构放在心中，再去做细节的探索。

### 4.3 关键的技术

我们再来看看理解实现的另一个重要方面：关键技术。

什么算是关键技术呢？就是能够让这个软件的「实现」与众不同的地方。了解关键技术可以保证一点，就是我们对代码的调整不会使项目出现明显的劣化。幸运的是，大多数项目都会愿意把自己的关键技术讲出来，所以，找到这些信息并不难。以 Kafka 为例，前面说过，它针对写入做了优化，使得它的整体吞吐能力特别强。那它是怎么做到的呢？

消息队列实现消息存储的方式通常是把它写入到磁盘中，而 Kafka 的不同之处在于，它利用了磁盘顺序读写的特性。对于普通的机械硬盘而言，如果是随机写，需要按照机械硬盘的方式去寻址，然后磁头做机械运动，写入速度就会慢得多。但顺序写的话，会大幅度减少磁头的运动，效率自然就得到了大幅度的提高。

之所以可以这样实现，是充分利用了消息队列本身的特性：有序。它是技术实现与需求完美结合的产物。有了这个基础，就可以有进一步的优化。比如，利用内存映射文件减少用户空间到内核空间复制的开销。如果站在了解实现的角度，你会觉得非常地自然。但要想从设计的角度学到更多，我们还是应该带着问题上路，多问自己一个问题，为什么其他的消息队列之前不这么做呢？这是一个值得深思的问题。Kafka 这个实现到底是哪里不容易想到呢？答案是软硬结合。

之前的消息队列实现也会把消息写入到文件里，但文件对它们来说，只是一个通用的接口。开发者并没有想过利用硬件的特性做开发。而 Kafka 的开发者突破了这个限制，把硬件特性利用了起来，从而取得了更好的结果。一旦理解了这一点，我们再来看其他的一些设计，就能学到更多的东西。比如，有一个著名的开源项目 LMAX Disruptor，它号称是最强劲的线程通信库。它有一段非常奇怪的代码，类似这样：

```java
protected long p1, p2, p3, p4, p5, p6, p7;
```

以正常程序员的标准，这简直是无厘头的低劣代码。而想要理解这段代码，你必须理解 CPU 缓存行的机制，这也是一种软硬结合的思路。

对于习惯写「软」件的程序员而言，在软件上投入的努力到达极限时，软硬结合是一种思路上的突破。当然，这种突破的前提是要对硬件的机制有所了解，这往往是很多程序员在基本功上欠缺的，可以学习一下计算机组成原理之类的课程。如果你有时间去学习，《深入理解计算机系统》一书值得一读。

### 黑板墙

最后，我想请你来思考一下，在项目上学习的哪些东西对你个人在实现思路上有了一个极大的突破。

旁外话：我的能力只能做到描述自己的理解。我描述自己的理解是希望能从栏主和其他学员处获得反馈，从而调整个人认知。我的身边缺少在软件设计上有追求的队友，很感谢有这个平台可以让我试错，交流，调整。

1、我认为软件的结构和核心技术应该是分开的。kafka 之所以是消息队列，看的是对消息队列这个模型的实现。kafka 之所以是 kafka 看的是其消息存储这一核心技术的实现。所以，如果我是想通过看 kafka 了解消息队列，那么就没必要也不该去看存储实现，我该看的是，路由信息管理，消息生产，消息消费这 3 块核心业务的骨干，以及其旁支功能的选择（限制消息大小，故障节点延后，延迟消费）；如果我想知道 kafka 为什么在 mq 中间件中如此突出，那么我就得了解其核心技术的实现，也就这里所说的「软硬结合的存储设计」。

2、谈谈对模型的理解。模型是一个抽象的概念，被抽象的对象可以是某个聚合实体（订单中心中的订单），也可以是某个流程或功能（java 内存模型中的主存与缓存同步的规则）。分层对模型来说是实现层面的东西，是一种水平方向的拆分，是一个实现上的规范；模型的细粒度拆分（父模型，子模型），应该是一种垂直维度的拆分，子模型的功能要高内聚，其复杂性不该发散到外部。

3、protected long p1, p2, p3, p4, p5, p6, p7; 这个玩意是 Disruptor 的缓存行填充中的填充字段。Disruptor 中的一个元素是一个 volatile 的 long 类型，占用 8 字节。一但一个元素被修改，则与其出于同个缓存行的所有元素的缓存都会失效。这就导致变更索引位 1 的元素，会导致索引位 0 的元素缓存也失效（操作时需要重新从主内存加载）。故而 Disruptor 做了一个缓存行填充的优化，在目标元素的前后都加了 7 个类型字段，两边都占据掉 56 个字节。故而保证每个元素都独占缓存行。是一种用空间换时间的优化。

4、04 讲说过要拿个开源项目来分析，刚好我拿的也是 mq，就借当前这个篇幅补充下。我看的是 RocketMq，目前看完了路由信息管理中心，消息生产端和消息存储的逻辑。拿路由信息管理中心 NameServer 来说。被抽象的模型对象是路由信息管理中心，既包含路由信息也包含路由信息的管理。路由信息由 QueueData，Broker，TopicRouteData 三个实体承载，路由信息管理由 BrokerLiveInfo 和 RouteInfoManager 负责。提供了路由注册，路由发现和路由删除三个接口。1）路由注册的接口触发是以 Nameserver 处理 Broker 的心跳包的方式接入的，具体代码见 RouteInfoManager#registerBroker。2）路由发现的接口触发 Nameserver 不管，由客户端定时请求获取路由信息，具体看 DefaultRequestProcessor#getRouteInfoByTopic。3）路由删除接口的触发是由 Nameserver 定时 10S 扫一遍 brokerLiveTable。将超时 120s 的 broker 信息全部剔除。或者 broker 正常关闭会来调用。具体见 RouteInfoManager#scanNotActiveBroker 和 unregisterBroker。

评价：作为路由信息中心，功能相对简单，所以技术设计上就没太多好说的。比较突出的就是 NameServer 节点间不做信息同步，每个 NameServer 都单独接收 broker 的心跳维护路由信息。这样的设计无疑极大降低了 NameServer 实现的复杂度，毕竟集群内消息同步一直是个头疼的事情。但是这样的方式，在 NameServer 节点过多和 broker 节点过多的场景下感觉都会有性能瓶颈（单位时间心跳的次数增多和需要心跳通知的节点增多）。可是这样的设计依旧抗住了大规模集群的场景，用实践案例打了我理论感观的脸。

但作为一个 apache 开源项目，其代码实现风格实在令人难受。违反单一职责原则，NamesrvController 做了外放接口，存储数据，启动定时等等一系列事情。且因为涵盖数据容器的职责，所以还需要再其他类中传递。违反依赖倒置原则，接口都找不到，就不用提啥基于接口而非实现编程了。如果要说这个项目的风格或者说代码设计偏好，那么就是没有原则，甚至都看不到阿里巴巴编程规范的影子。而这个问题不仅是在 NameServer 一个子模块中，而是在整个 rocketMq 模块都普遍存在。于此带来的就是，这个项目的新老交接，持续迭代，成本都会比较高。

限于篇幅，其他部分就不表了。rocketMq 是个很优秀很成功的产品，但也因为它的光辉，目前其背后的代码实现才越显得格格不入。作者回复：感谢你的分享，其他人可以从中学习到新的知识。2020-06-08

1『上面读者的信息目前还没能力消化吸收。（2020-09-01）』

看一个项目的实现，主要是去看软件结构和关键技术。类似于 Kafka 这样的「网红」开源项目，可以找到的结构图和相关资料不少，特别是官方资料还是比较权威的，比平时工作中接触到的那些陈旧代码要好很多。文中对于 Kafka 的生产者消费者模型的初步提问，并不难以想到，生产者、消费者、集群连接；而后续问出更多的问题 —— 网络抖动、集群…… 这个就比较需要功力了。Kafka 的关键技术在于利用了磁盘顺序读写的特性，这个和 Disruptor 利用缓存填充技术颇有异曲同工之妙。而我前两天刚好在「数据结构和算法之美」的打卡活动里面，看过 Disruptor，印象颇深。顺路去看了「深入浅出计算机组成原理」中关于 Kafka 的章节，还试读了两篇「Kafka 核心技术与实战」，确实应该认真的学习一下 Kafka，这个号称薪资排名比较靠前的技能。我也好奇，面对 SSD 硬盘，Kafka 怎么办？作者回复：其实也不需要怎么办，享受硬件升级带来的好处就好了，性能自然就提升了。2020-06-08

相同的功能可能要不同的软件产品。他们的接口与模型都是差不多的，不同之处就在于实现。所以理解这些产品族以及他们的差异就该从实现入手。就像 LinkedList 和 ArrayList 都可以提供 List 的功能，但是实现的不同决定了他们各自不同的特性。使用时的选型还是要根据业务场景的需求来的。作者回复：这取决于你的模型是什么，如果是 List，LinkedList 和 ArrayList 就是实现。如果是具体类，它们就是各自的模型了。2020-06-08

先后看了 php 的源代码和 laravel，CI，Tp 等框架的源码。从从组件到接口，从组件到模型，最后从模型到实现，走完一整个生命周期，学习到了很多优雅的设计，以及扩展如何接入，不过并不真的为什么会这么设计，设计的时候会解决什么样的问题，以及应用场景，当时还是在大学，所以实战经验不是特别丰富，于是自己想动手实现一下框架，看看为什么框架可以引用于不同的架构，逐步扩展，发现思想虽然相同，但是实现的优雅程度还是不可比拟。作者回复：还有一个原因，你没有面对那个问题。所有的代码只是设计的结果，一些东西变复杂通常都是有原因的。2020-06-10

1『很有感触，一些东西变得复杂是有原因的。（2020-09-01）』

## 0200. 设计一个软件——程序设计语言

1、每年至少学习一门能够提供新编程模型的程序设计语言。

2、提升软件设计能力，可以从编写程序库入手。

3、把运行时当作自己设计的地基，不受限于语言。

4、好的设计要迈向 DSL，我们可以从编写有表达性的代码起步。

## 0201语言的模型如何打破单一语言局限让设计更好地落地.md

我们谈到了程序设计语言。学习不同的程序设计语言可以帮助我们更好地落地设计，也可以让我们向不同的语言借鉴优秀的方面。我们简要地了解了程序设计语言的发展历史，从最开始的对机器模型的封装，到今天不断降低的开发门槛，程序设计语言的演化从未停止。我们也看到各种不同的编程风格在经历了最初各自独立的发展之后，开始慢慢融合。对程序设计语言发展的了解，可以帮助我们理解一件事：一切语法都是语法糖。新的语法通常是在既有的结构上不断添加出来的，为的是简化代码的编写。《程序员修炼之道》鼓励程序员们每年至少学习一门新语言，主要是为了让我们去学习新的编程模型，而不提供新编程模型的语言不值得刻意去学习。不过，这就需要你对程序设计语言有着更深的理解。下一讲，我们来看程序设计语言的接口，看看更具体的语言演化是如何发生的。如果今天的内容你只能记住一件事，那请记住：每年至少学习一门能够提供新编程模型的程序设计语言。

经过前面几讲，我们已经学习了如何去了解一个现有软件的设计。从这一讲开始，我们就进入到新的模块，讨论如何设计一个软件。做设计之前，我们要先知道手边有哪些工具。所以在这个模块开启之初，我们先来讨论程序设计语言。

或许你会觉得，程序设计语言有啥好讨论的？哪个程序员没有一门看家的程序设计语言呢？不知道你是否遇到过这样的问题：1）面向对象用来组织程序是好，但我用的是 C 语言；2）我用的是 C++，函数式编程的好，跟我有什么关系；3）动态语言那些特性很好，可惜我用的是 Java……

如果你这么想，说明你被自己的看家本事给局限住了，这种思维方式会让你即便学到了更多的好东西，也只能无可奈何。其实，程序设计语言之间没有那么泾渭分明的界限，程序员唯有多学习几门语言，才能打破语言的局限，让设计更好地落地。你可以根据项目特点选择合适的语言，也可以将其它语言一些优秀的地方借鉴过来。Andrew Hunt 和 David Thomas 在《程序员修炼之道》（The Pragmatic Programmer）中给程序员们提了一项重要的建议：每年至少学习一门新语言。

可是，语言那么多，我要一个一个都学过去吗？学语言到底在学什么呢？其实，程序设计语言本身也是一个软件，它也包含模型、接口和实现。而我们学习程序设计语言主要是为了学习程序设计语言提供的编程模型，比如：不同的程序组织方式，不同的控制结构等等。因为不同的编程模型会带给你不同的思考方式。既然要学习编程模型，我们就要先知道编程模型设计的来龙去脉，所以，今天我先带你领略一下程序设计语言的发展历程。

### 1.1 程序设计语言发展简史

我们今天接触到的程序设计语言都是图灵完备的。这里的「图灵完备」指的是语言指定的数据操作规则能够实现图灵机的全部功能（图灵机的概念是由阿兰·图灵提出的，图灵机为计算机能够解决的问题划定了一个边界）。所以，图灵机是所有程序设计语言最底层的模型，程序设计语言都是在这个基础上生长出来的，包括众所周知的计算机基础：用 0 和 1 编码。

我们今天的计算机能够识别的都是 0 和 1，但真正用 0 和 1 直接写代码的人少之又少，因为实在太麻烦了。所以，早在计算机诞生之初，就产生了汇编语言，它可以将那些 0101 的操作符变成更容易记住的 ADD、MOV 之类的指令。相比于 01 串，汇编虽然进步了一些，但人们很快就发现，用汇编写程序也是非常痛苦的事情，因为只有对计算机了如指掌，才能写好汇编。更可怕的是，即便你熟练掌握了一种计算机的汇编语言，换成另外一种计算机，你也必须从头学过。

这时，就轮到高级程序设计语言登场了。第一门被广泛使用的高级程序设计语言是 Fortran，它为程序设计语言的发展奠定了基础。比如，一些基本控制结构出现了，数据开始拥有了类型（类型就是一种对内存数据的解释方式）。虽然这些东西在今天看来非常简单，但和那个年代使用的汇编相比，简直是一个巨大的飞跃。Fortran 对于计算机的发展起到了巨大的推动作用，人们也逐渐认识到高级程序设计语言对于开发效率的提高。接下来，人们开发了各种高级程序设计语言，不断地探索怎样写好程序。

早期程序设计语言探索的集大成者就是 C 语言，它提供了对于计算机而言最为恰当的抽象，屏蔽了计算机硬件的诸多细节。时至今日，C 语言依然受众广泛。随着高级程序设计语言的发展，门槛逐步降低，人们可以开发的程序规模也逐渐膨胀。这时候，如何组织程序成了新的挑战。有一种语言搭着 C 语言的便车将面向对象的程序设计风格带入了主流视野，这就是 C++。很长一段时间内，C++ 成为了行业中最主流的选项，既兼容 C 语言，又提供了很好的程序组织方式。

虽然各种高级程序设计语言已经屏蔽了很多细节，但有一个问题始终没有得到很好的解决，也由此引发了更多的问题，这就是内存管理。其实，人们早就在尝试各种屏蔽内存管理的方式，但因为早期计算机硬件性能有限，所以没有任何一种方式能够成为行业主流。

后来，计算机硬件的能力得到了大幅度提升，这让那些在故纸堆里的技术又焕发了新的活力。这个阶段的胜利者是 Java，一方面，它支持面向对象编程；另一方面，它还有垃圾回收机制 —— 一种内存管理的方式。

Java 的路其实也很坎坷，因为它早期在个人电脑上的尝试并不算成功。后来选择了企业级开发的赛道，才有机会展现自己的优势。因为企业级服务器本身性能优于个人电脑，对 Java 有更高的容忍度，它才得到了机会，不断进行自身的优化。当硬件不再是程序设计语言的发展障碍之后，程序设计语言又该如何发展呢？

从前面的历程不难看出，程序设计语言的发展就是一个「逐步远离计算机硬件，向着待解决的问题靠近」的过程。所以，程序设计语言接下来的发展方向就是探索怎么更好地解决问题了。前面说的这些只是程序设计语言发展的主流路径，其实还有一条不那么主流的路径也一直在发展，就是函数式编程的程序设计语言，这方面的代表就是 LISP。

在这条路上，刚开始，很多人都是偏学术风格的，他们更关心的是解决方案是否优雅，也就是说，如何解决问题，如何一层层构建抽象。他们也探索更多的可能，垃圾回收机制就是从这里来的。但同样受限于当时硬件的性能，这条路上的探索在很长一段时间之内都只是一个小众游戏。

当硬件的性能不再成为阻碍，如何解决问题开始变得越来越重要时，函数式编程终于和程序设计语言发展的主流汇合了。促进函数式编程引起广泛重视也还有一个硬件因素：多核。多核的出现，本身是 IT 行业应对 CPU 发展进入瓶颈期的一个解决方案，但它却打破了很多程序员只习惯于利用一个 CPU 写程序的传统方式。

为了利用多核的优势，人们探索了各种方案，今天看到的各种并发模型、异步模型等解决方案都从那时开始得到了蓬勃的发展。函数式编程在这个方面的探索就是利用自己声明式的表达方式屏蔽了硬件差异。让人们注意到函数式编程的价值的就是著名的 MapReduce。

函数式编程的兴起，让那些在函数式编程社区的探索随之兴起，比如，声明式编程、DSL、元编程等等。一些后出现的程序设计语言开始将面向对象和函数式编程二者融合起来，比如 Scala。而像 Java 和 C++ 这些「老战士」则逐渐地将函数式编程的支持加入到语言之中。

相比于这些「正规军」，还有一股力量也逐渐从边缘走上了舞台，这就是动态语言，代表语言有 Perl、Python、Ruby、PHP 等等。以前，人们更喜欢用「脚本语言」称呼这类程序设计语言，这个名字表明，它就是为了简单地解决一些特定的问题而出现的。所以，在人们心目中，它们显得并不那么正式。但它们简单、轻巧的特性有效地降低了入门的门槛，也赢得了一大批拥趸。

语言的发展就是一个互相学习和借鉴的过程。以前，动态语言的弱项在于不适用于规模比较大的工程，而近些年来，随着动态语言用户的增多，配套的工具也逐渐多了起来，动态语言项目的规模也逐渐增大。而在主航道的程序设计语言，也纷纷向动态语言学习，努力地简化代码编写的难度，比如，Java 和 C++ 都开始支持类型推演（Type Inference），目的就是让程序员少敲几个字符。

至此，我简单地带你回顾了一下程序设计语言的发展历程，梳理了程序设计语言的发展脉络。从中不难看出，如果把程序设计语言当作一个软件，它的发展历程就是一个逐渐添加新模型的过程，而其发展的结果就是如今的开发门槛越来越低，能够开发的程序规模越来越大。

### 1.2 一切语法都是语法糖

现在，你已经能更好地理解我们在前面提出的说法，学习程序设计语言其实就是要学习语言提供的编程模型。

以我学过的一些程序设计语言为例：1）C 语言提供了对汇编指令直接的封装。2）C++ 先是提供了面向对象，后来又提供了泛型编程。3）Java 把内存管理从开发者面前去掉了，后来引入的 Annotation 可以进行声明式编程。4）Ruby 提供了动态类型，以及由 Ruby on Rails 引导出的 DSL 风格。5）Scala 和 Clojure 提供了函数式编程。6）Rust 提供了新的内存管理方式，而 Libra 提供的 Move 语言则把它进一步抽象成了资源的概念。

2『各个语言的特性，做一张任意卡片。』——已完成

既然学习新的程序设计语言是为了学习新的编程模型，反过来也可以说，不提供新编程模型的语言是不值得刻意学习的。如果你已经学会了一两门程序设计语言，学习一门新的语言其实并不困难，因为每种语言提供的新模型是有限的，基本的元素是类似的，无非是用了不同的关键字。所以，学习新语言，只是在做增量的学习，思维负担并没有那么沉重。一旦对于程序设计语言的模型有了新的认识，你就能理解一件事：一切语法都是语法糖。

语法糖（Syntactic sugar）是英国计算机科学家彼得·兰丁发明的一个术语，指的是那些为了方便程序员使用的语法，它对语言的功能没有影响。

懂得了语法糖的道理，要想更好地理解程序设计语言，一种好的做法就是打开语法糖，了解一下语法是怎么实现的：1）类型是一种对内存的解释方式。2）class/struct 是把有相关性的数据存放到一起的一种数据组织方式。3）Groovy、Scala、Kotlin、Clojure 等 JVM 上的新语言，提供了一种不同于 Java 的封装 JVM 的方式……

3『在耗子哥的专栏里看到一个金句：数据类型是对内存的抽象。』

通过前面的介绍，你也看到了，语言的发展并非一蹴而就，而是一个渐进式的发展历程。一些新的尝试总会在一些不起眼的地方冒出来，而且语言之间也在相互借鉴。如果你能每年学习一门新语言，起初，你可以了解不同的编程模型。当你的积累足够多了，学习语言就是在跟踪程序设计语言的最新发展了。当你手里有了足够多的「武器」时，你就可以打开思路，运用不同的方式解决问题了，甚至把其它语言的好东西，借鉴到自己使用的语言中。

### 黑板墙

你最近打算学习哪门新的程序设计语言呢？为什么？

操作系统等各种软件有模型，编程语言也有模型，计算机世界里模型真是无处不在啊。模型就是一种看待世界的方式，一种模型的提出的最大的动力是为了解决某个问题。编程语言的发展就是各种编程模型的演化。从图灵机模型到冯诺依曼的存储程序模型，机器语言，汇编，一直到千姿百态的高级语言。每种语言都提供了一个编程模型，这个模型越来越高级，越人性化，越贴近人的思维。拿自己熟悉的 java 语言举例。尽管 java 是用 c++ 语言写成的，但 Java 提供了不同于 c++ 的内存与线程模型（Java 的六种线程状态并不与 os 的各种线程状态一一对应，内存的划分也是如此），大大简化了开发。每年学一门新语言，也就是每年学一个新的编程模型。作者回复：很好的补充，我这里只说了语言的演变，你补充的线程信息很好！2020-06-10

两本《七周七语言》里包含的语言：1）Clojure, Haskell, Io, Prolog, Scala, Erlang, and Ruby。2）Lua, Factor, Elixir, Elm, Julia, MiniKanren, and Idris。几年前因为感到规模化的 js 工程需要类型，调研过 Elm、BuckleScript 和 TypeScript，今天看来赢家不言而喻。作者回复：能被记住的就是赢家。2020-06-11

参考书是《深入理解计算机系统》，我看不懂，所以我又找了《计算机是怎样跑起来的》、《程序是怎样跑起来的》、《网络是怎样连接的》，《图解 HTTP》、《图解 TCP/IP》。下个月开始死磕《深入理解计算机系统》。作者回复：嗯，C 语言是弄懂计算机结构的好入口。《深入理解计算机系统》是非常好的书，不过，确实不容易读。2020-06-10

汇总：1）最早了解到 LISP，应该是在 Paul Graham 的 Hacker News 和 Arc 语言（为了证明 Arc 写了 Hacker News，Arc 没火 Hacker News 却火了）。2）Paul Graham 提出了著名的 Blub 论断，这个论断讨论这样一个问题：「不同的编程语言到底有什么不一样？是不是一种编程语言比另外一种编程语言更高级？」3）为了表达观点，他引入了一个叫作 Blub 的语言。这个语言比机器上的二进制语言要高级一点，但是比市面上的任何高级语言都要低级。为什么从一个使用 Blub 语言的程序员的角度去看，机器上的二进制语言是一个更加低级的编程语言？因为它缺乏了 Blub 拥有的语言特性。但是从一个使用二进制编程语言的人的角度来看，其实两者没什么差别，因为即便有多余的特性，二进制语言编程者也不会去用那些东西，而只会用属于二进制语言的那个子集。

4）结论就是：使用更高级语言的人知道低级语言缺乏了一些高级语言的特性，所以低级语言显得更原始，而低级语言的开发者却无法发现高级语言里面蕴含的额外的语言特性。5）我的认知：个人不喜欢高低之分，毕竟存在即合理，每款现存的语言都会有它高的地方和低的地方。但是 Paul Graham 的论断其实也反应了一些问题。就是人们往往会陷于自己的已有认知 (毕竟阻力最小)。做为一个 java 程序员，无论是写 py 还是写 go 多多少少都有点用 py 和 go 语法写 java 代码的味道 (也因为我在 py 和 go 的水平不够)。所以栏主所说的，学习语言是增量学习这个是对的，但已有认知也会是陷阱，这就导致我可以很快学会一门语言的语法，但很难接受其背后的编程模型。已有认知带来的偏向性会让人对新的编程模型带有抵触的情绪。外在表现就是，喜欢在其他语言中找不足来满足自己内心的偏向心理。6）我们这次专栏是软件设计之美，重在设计。深入语言这种，感觉背景比设计理论都要重。ruby 和这章感觉要理解栏主表达的意思都显得比较吃力。

作者回复：感谢你做出这么棒的分享！在内容中说了，之所以要讲语言就是为了打破语言局限，在后面的内容中，你就会看到，有用 C 语言实现面向对象的，有用 Java 实现函数式编程的。做设计，拥有各种设计思想固然重要，但更重要的是，能够把它实现出来。2020-06-10

项目经验比较少，所以反而不太受语言的限制，C#、Java、Ruby 都能写一些，Python、JavaScript 也都接触过，不过缺点就是每一门语言都不是很精通。看过《程序员修炼之道》，对于每年学一门新语言也很向往，之前还考虑过挑战一下《七周七语言》。但是确实没有仔细考虑过为什么要学，以及如何学得更有效率。发现文章在描述语言发展史的时候没有提到 C#、JavaScript 和 Go，当然还有一些其他的语言。C# 应该和 Java 比较类似，JavaScript 接近动态语言，但是因为 V8 引擎，又有些不太一样，Go 语言我就不知道该如何定位了，好像是结余 C 语言和 Java 之间。

之前并不喜欢 Java（其实是因为我没有看到 Java 最近几年的发展），但是发现在工作市场上，Java 的机会远多于 C# 和 Ruby。每一种语言（或者框架）的出现，其实都是试图解决某种问题，如果能丰富一下自己的「兵器库」，当然会带来软件设计功力的提升。那么问题来了，感觉一年时间（工作之余）其实不足以掌握一门编程语言，因为还要需要学习一些周边的框架和工具等等，这个问题怎么破？后面如果有时间，想要学习一下 Go 语言。2020-06-10

我是做前端开发的，有往全栈方向发展的打算，文中说的一种新语言的编程模型，那我选择最近学习 typescript 算是一种新语言么？作者回复：如果你只用过 JavaScript，那 TypeScript 值得一学，它提供了更好的程序组织方式。2020-06-10

作为一个老程序猿使用的编程语言有 Java、Python、golang、kotlin。每种编程语言都有自己编程模型，一个编程语言都是为了解决现有的问题而出现的。从汇编语言到高级语言，从过程编程到面向对象编程，从线程模型到协程模型…都是一个不断进化发展的过程，也是编程思维的升级。建议程序猿每年学习一门新语言其实也为了理解编程语言的模型思维，从而更好的理解软件设计。2020-06-10

打算学习 julia，因为性能强大语法也简单。作者回复：Julia 有一个不错的目标，希望它也能够快速成长。2020-06-25

## 0202语言的接口语法和程序库软件设计的发力点.md

我们的学习主题是程序库，程序库最初只是为了消除重复。后来，逐渐有了标准库，然后有了大量的第三方库，进而发展出包管理器。如果通用性足够好，一些经过大量实践验证过的程序库甚至会变成语言的语法，而一些语法解决得不够好的地方，又会出现新的程序库去探索新的解决方案。所以，语言设计就是程序库设计，程序库设计就是语言设计。二者相互促进，不断发展。当你开始学习如何编写程序库，你对软件设计的理解就会踏上一个新的台阶。我们说过，学习不同程序设计语言一个重要的原因是为了相互借鉴。理解了模型和接口，你就知道该借鉴什么，但具体如何借鉴呢？我们还需要了解这些模型是如何实现的，所以下一讲，我们就来谈谈程序设计语言的实现。如果今天的内容你只能记住一件事，那请记住：提升软件设计能力，可以从编写程序库入手。

在上一讲中，我们学习了程序设计语言模型的演变过程。学习不同的程序设计语言，实质上就是学习不同的编程模型。谈完了模型，接下来，就该说说接口了。这一讲，我们就来谈谈程序设计语言的接口，一说起程序设计语言的接口，你的直观印象肯定是程序设计语言的语法，那是一个你已经很熟悉的话题了，但程序设计语言还有一个你可能都不曾留意的接口：程序库。

如果你已经能够完成基本功能的开发，想让自己在编程水平上再进一步，成为一个更好的程序员，你就可以从封装程序库开始练习。因为想封装出一个好的程序库所需的能力，就是软件设计所需的能力。封装程序库，可以成为你软件设计进阶的发力点。

### 2.1 消除重复的程序库

我们写程序的时候，只要规模稍微大一点，你就会发现同样的模式经常出现，差别无非是几个地方的参数不一样，这就是重复。最开始的重复是指令级别的重复，程序员们会把同样的指令序列放到一起，通过传入不同的参数进行识别。你发现了吗？我说的就是函数。函数已经成了今天的主流编程方式，是几乎所有的程序设计语言都有的基础设施，人们甚至忘了它的由来。

写程序的一项主要日常工作就是定义各种函数。一旦你定义了大量的函数，就会发现有很多函数不仅仅在某个项目中是适用的，而且在很多项目中都是适用的。这时，作为一个「懒惰」的程序员，我们就会把这些在多个项目中使用的部分抽取出来，组成一个模块，这就是程序库的来源。所以，程序库就是为了消除重复而出现的。而消除重复，也是软件设计的初衷。

程序库（Library）是程序员最熟悉的一项内容。学习一门新语言，首先是学习语法（Syntax），然后学习程序库（Library），之后再学习运行时（Runtime），这样，你就具备一门语言的基础了。再往后，你需要了解的就是各种惯用法（Idiom），以及如何运用到实际的工作中。

有一些程序库实在是太常用了，它们就会随着语言一起发布，成为标准库。比如，程序员熟知的第一个程序「Hello, world」的做法来自《C 程序设计语言》，其中用到的 printf 就是来自 C 的标准库。再比如，Java 程序员无人不知的 JDK，里面包含了大量的程序库，一个 Java 程序员如果不能说出几个容器，简直就不好意思和人打招呼。

当然，如果在实际工作中只使用标准库，有些代码写起来还是非常麻烦的。因为标准库提供的能力通常是很基础的。这时，我们就需要利用更多的第三方程序库，它们给提供了更丰富的选项，去完善标准库做得不够的地方。也就是说，它们会在标准库的基础上，再做一次封装，提供一个新的编程模型，或是新的接口，甚至修正一些标准库的 bug，让开发变得更简单。只要是人气足够的语言，在这个方面做得都非常好，它们会提供大量的第三方库。

正是因为第三方库的兴起，怎样管理第三方库就成了一个问题。今天，这已经成了一个标准的问题，也有了标准的解决方案，那就是包管理器。很多语言都有了自己的包管理器，像 Java 的 Maven、Node 的 NPM、Ruby 的 RubyGems 等等，而像 Rust 这样年轻的语言，包管理器甚至变成了随语言的发行包一起发布的一项内容。

### 2.2 语言设计就是程序库设计

```java
new
```

虽然程序库受限于特定的程序语言，但其表达的思想却不受语言限制。我给你举个例子，在软件开发中，我们最常做的一个操作就是初始化。如果采用 C 这样比较早期的语言，通常的做法就是，分配一块内存，然后给这块内存赋值，如下图所示：

类似的代码会反复出现，成为一个固定的模式。而一些新的语言索性就将二者合二为一，成了一个固定的语法，这就是很多人熟悉的 new。无论是 C++ 程序员，还是 Java 程序员，对 new 一定不陌生。

当我们调用 new 时会发生什么呢？首先，它会申请一块内存，然后调用对应类的构造函数。类也好，构造函数也罢，这些内容都是 C 语言没有的，但这个初始化的模式与 C 语言是如出一辙的。只不过，在 C 语言里面，这个操作通常是通过程序库实现的，而到了 C++ 和 Java 中，它成了语法。一旦变成了语法，它就成了语言的一部分，成为了一个特定的模型。对于使用者而言，这个模型就是一个接口，只要接口的行为不变，我的代码就不用变。

但对于接口另一面的实现者而言，它就可以做一些特定的工作了。比如，插入不同的内存分配算法，这就是 C++ 的 allocator 所做的事情；再比如，把内存完全管控起来，这就是 Java 做的事情。没错，Java 之所以能够让程序员忽略内存管理，new 功不可没。

一个经过验证的模式最终变成了语言的一部分，而它的起点只是一个常见的用法：一个程序库。

```java
synchronized
```

我再用 Java 中的 synchronized 给你举个例子。我们都知道，并发编程是程序员的一门必修课。学习并发编程，一方面要学习各种概念，比如「锁」；另一方面还要学习不同语言相应的程序库。因为这些概念太常用了。所以，Java 干脆把它变成了一个语法，也就是 synchronized。

成为语法固然是一个巨大的进步，但是在一些场景下，语法反而会显得僵化。这时候，又轮到程序库登场了。我还以前面所说的 new 和 synchronized 为例给你讲解一下。

### 2.3 程序库设计就是语言设计

```java
new
```

new 虽然帮我们解决了一些问题，但与 new 配合使用的构造函数往往有一个致命伤，那就是它只有一个名字，也就是类的名字。当我们需要表达多种不同的构造逻辑时，各村就出现了各村的高招。我曾经见过有人利用重载（overload）来解决问题的，不同的构造逻辑用不同类型的参数。比如，一个用 HashMap，一个用 TreeMap。作为一个新加入项目的程序员，你很难想到这是两种不同的构造逻辑，它们与这里不同类型的数据结构其实一点关系都没有。

一个更好的解决方案是利用工厂模式解决这个问题，也就是说，用一个名字更能表意的函数，代替构造函数作为构造入口。还是以 Java 为例，ArrayList 是 Java 程序员很熟悉的一个数据结构。如果我要创建一个包含两个元素的 ArrayList，同时，还要创建一个初始容量为 10 的 ArrayList。用 JDK 原生的做法，我可以这么做：

```java
// 创建有两个元素的数组
ArrayList<String> listWithElements = new ArrayList();
listWithElements.add("foo");
listWithElements.add("bar");

// 创建一个初始容量为10的数组。
ArrayList<String> listWithCapacity = new ArrayList(10);
```

这种做法可行，但代码表意并不清晰。那有没有更好的做法呢？Google 的 Guava 程序库，对于同样的场景，给出了一个不同的做法：

```java
ArrayList<String> listWithElements = newArrayList("foo", "bar");
ArrayList<String> listWithCapacity = newArrayListWithCapacity(10);
```

显然，从语义上来说，这种做法更清晰。Java 领域的行业名著《Effective Java》（第三版）的第一个条款是「用静态工厂方法代替构造函数」，讨论的就是这种做法。

```java
synchronized
```

再来看 synchronized。它虽然解决了一部分并发的问题，但是，这个解决问题的方式粒度太大了。程序员只要稍微深入一些，就会感到 synchronized 的掣肘。于是，Java 的开发者在 Java 5 中开始了新一轮的编程模型探索，这次探索的成果就是后来的并发编程库。这也为面试官们提供了新的素材。你看到了吧，解决同一个问题，它可以用一个语法，也可以用一个程序库，二者之间是等价的。

Andrew Koenig 和 Barbara Moo 写过一本书《C++ 沉思录》，书里记录了 C++ 早期开发者在设计各种 C++ 特性时的思考，这是一本编程思想之作。当年读这本书时，有两章的标题让我陷入了沉思，分别是「语言设计就是程序库设计」和「程序库设计就是语言设计」。

通过今天的学习，这两句话对你来说就不难理解了。因为语法和程序库是在解决同一个问题，二者之间是相互促进的关系。通常是先有程序库，再有语法；如果语法不够好，新的程序库就会出现，新一轮的编程模型就开始孵化。

一切有生命力的语言都会不断改善自己的语法，某些好用的程序库就可以转正成为语法。比如，Java 引入 Lambda，支持函数式编程；C++ 引入类型推演，简化了代码编写。

同样地，程序库的发展也在推动着语言的不断进步，有一部分语法就是为了让程序库表现得更好而存在的。比如说：1）C 里面的宏，虽然很多人用它来定义常量，但只有编写程序库才能让它更好地发挥出自身的价值；2）Java 中的 Annotation，很多人都在用，但用它做过设计的人却很少，因为它的使用场景是以程序库居多；3）Scala 中的隐式转换，如果你没有设计过 DSL，很可能根本就不知道它有什么具体的作用。

至此，你已经能够理解程序设计语言的接口不只包含语法，还有程序库。而且，学习一种程序设计语言提供的模型时，不仅仅要看语法本身有什么，还要了解有语言特性的一些程序库。所以，对于程序员而言，想要自己的编程水平上一个台阶，学习编写程序库是一个很好的路径。一方面，我们可以锻炼自己从日常工作中寻找重复；另一方面，我们可以更好地理解程序设计语言提供的能力。

### 黑板墙

今天我们讲到了程序库和语法之间的互相促进，最后，我想请你分享一下，你还能找出哪些语法和程序库互相促进的例子呢？

想到两个观点：1）「设计模式是缺失的语言特性」。比如在函数是一等公民的语言中，至少有半打的设计模式是不需要的。2）「所有非平凡的抽象（abstraction）在某种程度上都是有漏洞的（leaky）」。封装的程序库只能工作在某个抽象层次上，总会遇到无法在该抽象层次上解决的问题，此时只能绕过这层抽象从更低的抽象层次上解决。作者回复：非常好的补充，后面讲到设计模式，我也会提到类似的观点。2020-06-13

汇总：1）《Effective Java》是本好书，需要尽早一读。2）今天记住的是这句话。语言设计就是程序库设计，程序库设计就是语言设计。眼前一亮的感觉。3）程序库和语言都属于加法容易，减法难的范畴。除了抽象去重外，其实更重要的是识别什么不该做，以及如何设计向后兼容，易扩展的代码结构。4）事实上，很多程序库，为了保证灵活，性能，向后兼容，功能全面。内部代码量会比较大。如果提高设计能力，起步就是程序库，感觉会比较吃力。（写过公共工具包，为此看了 hutool 和 guava 等的源码，前者散乱后者优雅，但都不好啃）。在有一定认知后，才能看出一些端倪。5）所以，起步的话，把《重构 - 既有代码改善》看了，内容简单易懂。然后在项目中持续重构自己的代码，跟自己较真，多思考。每次重构都是在重审自己对设计的理解，循序渐进。作者回复：可能是我的偏见，国人的开源项目代码质量高的不多，除非这个项目有大量的老外参与，或者作者之前在外企工作。2020-06-12

我看到文中这句话时：「它们会在标准库的基础上，再做一次封装，提供一个新的编程模型。」第一反映想到了这篇博客：[SpringMVC 深度探险 1—— SpringMVC 前传](https://www.iteye.com/blog/downpour-1330537)，其中也提到「编程模型」这个词汇。做过 java 开发的同学，建议看看，非常有助于理解老师的这节课。我的理解：在标准库 jdk 的基础上，struct 和 springmvc 再做了封装，提供了 2 种新的编程模型，最后 springmvc 的编程模型胜出。作者回复：SpringMVC 从模型上确实简单一些，但它胜出依赖的是 Spring，或者说作者的整体品味。2020-06-13

一言不合就开车，一码不便就撸库。确实在语言发展历程上，每门好的语言都有其精华，目的还是在用不同的编程哲学适应不同的应用场景。用 golang 的伙伴会得意于编译出的程序内存占用少，goroutin 如何方便，函数支持多返回值是多么的优雅，而用 java 的伙伴则乐于能用到泛型、重载、多态等特性，能用到 spring 等等功能异常强大的框架。编程知识大爆炸的年代，语言小巧够用感觉更环保些ʘᴗʘ作者回复：非常好的补充！2020-06-15

程序语言的接口是程序库。我们可以通过学习和开发程序库来提高自己的程序设计能力。程序库的开发是为了消除重复。经常遇到的编程模型和重复的功能逻辑都封装成程序库，可以提升编码效率和体验。除了使用语言提供的标准程序库还需要理解其它常用的第三方程序库，这些库也是解决某种问题而存在，也是对标准库以及其它三方库的封装。很多语言使用包管理器工具管理这些常用库（这也是一个解决问题的模型）。语言设计和程序设计是相互促进、相互影响的。好的编程模型会被整合进语法糖成为语言设计的一部分，而好的语言接口也影响程序设计的模型。作者回复：很好的总结！2020-06-12

js 里的 promise，最早是社区弄出来的，最后却成了 js 语言的一部分。作者回复：异步处理的发展也经过了一个很有趣的发展过程，从最开始的写进程线程，到后面的 promise / future，到现在的响应式编程。演化还还有结束，还有很多的东西正在进行中。2020-06-18

如果按照语法、程序库、运行时的节奏，我对于几个语言（Java，C#，Ruby）的理解大部分停留在了程序库这一步，而且运用的不怎么熟练。「语言设计就是程序可设计，程序库设计就是语言设计」，专栏中提到说二者是为了解决同样的问题，那么这个问题是什么，是为了消除重复？学习编写程序库对我来说有点无从下手，不过我觉的可以看一些优秀的开源程序库代码，也许是个不错的选择。我有一个感觉，各种不同的语言和程序库之间其实是相互促进的关系，Java 其实也是在不断的演化，再加上 Guava 等程序库的加持（当然还有 Spring 系列的框架），焕发新春。作者回复：设计主要都是消除重复，只不过，有的人是通过设计新模型消除重复，有的人是通过把代码块抽到一起消除重复。阅读优秀程序库的源码是一个人自我提升的一种途径，这是值得鼓励的。2020-06-17

这篇文章大大提升了我对程序设计语言的认知高度，以前还真没有从语法，程序库，第三方库以及他们之间的关系方面去理解一门语言。更没有意识到程序设计语言的「接口」。这些知识老师说透了之后感觉并不难，但是我们的难点在于靠自己摸索的话似乎永远看不透。2020-06-12

类库是块砖，哪里需要哪里般。框架是混凝土，将类库与代码以一致的形式风格粘合在一起。作者回复：这个比喻很有意思。2020-07-11

## 0203语言的实现运行时软件设计的地基.md

今天我们讨论了程序设计语言的实现：运行时。对于运行时的理解，我们甚至可以做出语言本身不支持的设计。所以，做设计真正的地基，并不是程序设计语言，而是运行时。理解运行时，可以将「程序如何运行」作为主线，将相关的知识贯穿起来。我们从了解可执行文件的结构开始，然后了解程序加载机制，知道加载器的运作和内存布局。然后，程序开始运行，我们要知道程序的运行机制，了解字节码，形成一个整体认识。最后，还可以根据需要展开各种细节，做深入的了解。

有一些语言的运行时还提供了一些语言层面的编程接口，程序员们可以与运行时进行交互，甚至拥有超过语言本身的能力。这些接口有的是以程序库的方式提供，有的则是以规范的方式提供。如果你是一个程序库的开发者，这些接口可以帮助你写出更优雅的程序。关于程序设计语言的介绍，我用了三讲分别从模型、接口和实现等不同的角度给你做了介绍。目的无非就是一个，想做好设计，不仅仅要有设计的理念，更要有实际落地的方式。下一讲，我们来讲一个你可以在项目中自己设计的语言：DSL。如果今天的内容你只能记住一件事，那请记住：把运行时当作自己设计的地基，不受限于语言。

### 3.1 程序如何运行

首先，我们要澄清一点，对于大部分普通程序员来说，学习运行时并不是为了成为运行时的开发者，我们只是为了更好地理解自己写的程序是如何运行的。运行时的相关知识很多，而「程序如何运行」本身就是一条主线，将各种知识贯穿起来。程序能够运行，前提条件是，它是一个可执行的文件，我们就从这里开始。

一般来说，可执行的程序都是有一个可执行文件的结构，对应到 JVM 上，就是类文件的结构。然后，可执行程序想要执行，需要有一个加载器将它加载到内存里，这就是 JVM 类加载器的工作。

加载是一个过程，那么加载的结果是什么呢？就是按照程序运行的需求，将加载过来的程序放到对应的位置上，这就需要了解 JVM 的内存布局，比如，程序动态申请的内存都在堆上，为了支持方法调用要有栈，还要有区域存放我们加载过来的程序，诸如方法区等等。

到这里，程序完成了加载，做好了运行的准备，但这只是静态的内容。接下来，你就需要了解程序在运行过程中的表现。一般来说，执行过程就是设置好程序计数器（Program Counter，PC），然后开始按照指令一条一条地开始执行。所以，重点是要知道这些指令到底做了什么。

在 Java 中，我们都知道，程序会编译成字节码，对于 Java 来说，字节码就相当于汇编，其中的指令就是 Java 程序执行的基础。所以，突破口就在于了解指令是如何执行的。其实，大部分 JVM 指令理解起来都很简单，尤其在你了解内存布局之后。比如，加法指令就是在栈上取出两个数，相加之后，再放回栈里面。

我要提一个看上去很简单的指令，它是一根拴着牛的绳子，这就是 new，没错，就是创建对象的指令。那头牛就是内存管理机制，也就是很多人熟悉的 GC，这是一个很大的主题，如果展开来看的话，也是一个庞杂的知识体系。

有了对指令的理解，就对 Java 程序执行有了基本的理解。剩下的就可以根据自己的需要，打开一些被语法和程序库隐藏起来的细节。比如，synchronized 是怎样实现的，顺着这条线，我们可以走到内存模型（Java Memory Model，JMM）。当然，这里的内容并不是为了与你详细讨论 JVM 的实现，无论是哪个知识点真正展开后，实际上都还会有很多的细节。

这里只是以 JVM 为例进行讲解，学习其他语言的运行时也是类似的，带着「程序如何运行」这个问题去理解就好了。只不过，每种语言的执行模型是不同的，需要了解的内容也是有所差异的。比如，理解 C 的运行时，你需要知道更多计算机硬件本身的特性，而理解一些动态语言的运行时，则需要我们对语法树的结构有一定认识。

有了对运行时的理解，我们就可以把一些好的语言模型借鉴到自己的语言中，比如，使用 C 语言编程时，我们可以实现多态，做法就是自己实现一个虚拟表，这就是面向对象语言实现多态的一种方案。

### 3.2 运行时的编程接口

我们前面说过，做软件设计的地基是运行时，那怎样把我们的设计构建在运行时之上呢？这就要依赖于运行时给我们提供的接口了。所以，我们学习运行时，除了要理解运行时本身的机制之外，还要掌握运行时提供的编程接口。

在 Java 中，最简单的运行时接口就是运行时类型识别的能力，也就是很多人熟悉的 getClass。通过这个接口，我们可以获取到类的信息，一些程序库的实现就会利用类自身声明的信息。比如，之前说过，有些程序库会利用 Annotation 进行声明式编程，这样的程序库往往会在运行的过程中，以 getClass 为入口进行一系列操作将 Annotation 取出来，然后做相应的处理。

当然，这样的接口还有很多，一部分是以标准库的方式提供的，比如，动态代理。通过阅读 JDK 的文档，我们很容易学会怎么去运用这些能力。还有一部分接口是以规范的方式提供的，需要你对 JVM 有着更好的理解才能运用自如，比如，字节码。前面我们说了，通过了解指令的执行方式，可以帮助我们更好地理解运行时的机制。有了这些理解，再来看字节码，理解的门槛就大幅度地降低了。

如果站在字节码的角度思考问题，我们甚至可以创造出一些 Java 语言层面没有提供的能力，比如，有的程序库给 Java 语言扩展 AOP（Aspect-oriented programming，面向切面编程）的能力。这样一来，你写程序的极限就不再是语言本身了，而是变成了字节码的能力极限。

给你举个例子，比如，Java 7 发布的时候，字节码定义了 InvokeDynamic 这个新指令，当时语言层面上并没有提供任何的语法。如果你需要，就可以自己编写字节码使用这个新指令，像 JRuby、Jython、Groovy 等一些基于 JVM 的语言，开发者就可以利用这个指令改善自己的运行时实现。当然 InvokeDynamic 的诞生，本身就是为了在 JVM 上更好地支持动态语言。

好消息是，操控字节码这件事的门槛也在逐渐降低。最开始，操作字节码是一件非常神秘的事情，在许多程序员看来，那是只有 SUN 工程师才能做的事情（那时候，Java 还属于 SUN）。

后来，出现了一个叫 ASM 的程序库（[ASM](https://asm.ow2.io/)），把字节码拉入了凡间，越来越多的程序员开始拥有操作字节码的能力。不过，使用 ASM，依然要对类文件的结构有所理解，用起来还是比较麻烦。后来又出现了各种基于 ASM 的改进，现在我个人用得比较多的是 ByteBuddy（[Byte Buddy - runtime code generation for the Java virtual machine](https://bytebuddy.net/#/)）。

有了对于字节码的了解，在 Java 这种静态的语言上，就可以做出动态语言的一些效果。比如，Java 语言的一些 Mock 框架，为什么可以只声明接口就能够执行，因为背后常常是动态生成了一个类。

一些动态语言为了支持自己的动态特性，也提供了一些运行时的接口给开发者。比如，Ruby 里面很著名的 method_missing，很多框架用它实现了一些效果，即便你未定义方法也能够执行的。你也许想到了，我们提到过的 Ruby on Rails 中各种 find_by 方法就可以用它来实现。

method_missing 其实就是一个回调方法，当运行时在进行方法查找时，如果找不到对应方法时就调用语言层面的这个方法。所以，你看出来了，这就是运行时和语言互相配合的产物。如果你能够对于方法查找的机制有更具体的了解，使用起来就可以更加地得心应手，就能实现出一些非常好的设计。

### 黑板墙

我想请你分享一下，你知道哪些程序库的哪些特性是利用运行时交互的接口实现的？

我们自己的分布式日志收集系统就使用了运行时字节码生成技术，这样既对业务应用没有任何影响（性能上微乎其微），又能根据抓取的日志分析服务调用链、异常等有用的信息。作者回复：你做的事情与 APM 有相似的地方。2020-06-15

汇总：1）在 web flux 出来之前，java 的 web 开发大多都是基于 servlet 的。可以认为 servlet 容器是 java web 项目的运行时环境。servlet 3.0 的「ServletContext」（通过编程方式配置 servlet、filter，listener 而不依赖 web.xml）和「运行时插拔」两大特性（两个特性前后关联），相当于以编程库的方式提供了运行时容器的服务增减的能力。这也是 spring 3.X 后 spring web 自动装配的实现基础。2）spring 基本是 java 后端开发的实时标准，如果以 spring 为运行时环境（ioc 容器 + 依赖注入以及其他功能），那么其以约定和编码库提供的运行时编程的接口就实在挺多了。3）按本篇自己的理解，运行时不限于语言级别。固有以上推断。作者回复：你这个理解的角度很有趣，非常好的补充！2020-06-15

运行时是程序语言设计中的地基。理解运行时可以深入理解程序语言是如何加载，执行的，这能让我们对语言添加一些原本不支持的功能。对于 JAVA 语言就是要了解 jvm 执行的机制，它包括加载字节码，解析，内存管理，线程调度等等方面。这些跟操作系统的很多知识其实是相通的，因此需要把各种知识在头脑建立连接，达到知识的迁移的效果，提高学习的效率。作者回复：很好的总结！2020-06-15

学习一门语言，从模型开始。设计一门语言，以运行时为地基。按照时间顺序的发展是：高手把运行时抽象为简化的模型，供小白入门。小白想进阶的话，还是要深入到运行时的实现细节中去。作者回复：想深入，就要到细节中去。2020-07-11

C 和 C++ 不是直接编译成操作系统可执行文件吗？没有运行时这一说吧。不是太理解文中提及的 C 语言运行时。作者回复：首先，推荐去读一本书《程序员的自我修养》，这是一本好书，只是名字起得不太好。C 和 C++ 都有运行时支持，不然，C++ 的虚拟函数是怎么实现的。不同的是，C/C++ 的运行时是以库的形式存在，最终与你的代码生成到一个可执行文件中，而不像 Java 是以一个可执行的 JVM 形式存在。2020-07-08

## 0204DSL你也可以设计一门自己的语言.md

我们讨论了领域特定语言，这是针对某个特定领域的程序设计语言。DSL 在软件开发领域中得到了广泛的应用。要实现一个 DSL，首先要构建好模型。常见的 DSL 主要是外部 DSL 和内部 DSL。二者的主要区别在于，DSL 采用的是不是宿主语言。相对于外部 DSL，内部 DSL 的开发成本更低，与我们的日常工作结合得更加紧密。内部 DSL 体现更多的是表达能力，相对于传统的代码编写方法而言，这种做法很好地将作者的意图体现了出来。即便我们不去设计一个内部 DSL，这种写代码的方式也会对我们代码质量的提高大有助益。关于语言，已经讲了四讲，我们先告一段落。下一讲，我们要来讨论编程范式，也就是做设计的时候，我们可以利用的元素有哪些。如果今天的内容你只能记住一件事，那请记住：好的设计要迈向 DSL，我们可以从编写有表达性的代码起步。

在前面，我们花了三讲的篇幅探讨程序设计语言，一方面是为了增进我们对程序设计语言的理解，另一方面，也希望从中学习到软件设计方面做得好的地方。除了借鉴一些语言特性之外，我们还能怎样应用程序语言，来帮我们做设计呢？

讲到程序设计语言模型时，我说过，程序设计语言的发展趋势，就是离计算机本身越来越远，而离要解决的问题越来越近。但通用程序设计语言无论怎样逼近要解决的问题，它都不可能走得离问题特别近，因为通用程序设计语言不可能知道具体的问题是什么。

这给具体的问题留下了一个空间，如果我们能把设计做到极致，它就能成为一门语言，填补这个空间。注意，我这里用的并不是比喻，而是真的成为一门语言，一门解决一个特定问题的语言。这种语言就是领域特定语言（Domain Specific Language，简称 DSL），它是一种用于某个特定领域的程序设计语言。这种特定于某个领域是相对于通用语言而言的，通用语言可以横跨各个领域，我们熟悉的大多数程序设计语言都是通用语言。

我在第 8 讲说过，它们都是图灵完备的，但 DSL 不必做到图灵完备，它只要做到满足特定领域的业务需求，就足以缩短问题和解决方案之间的距离，降低理解的门槛。虽然大多数程序员并不会真正地实现一个通用程序设计语言，但实现一个 DSL，我们还是有机会的。这一讲我们就来谈谈 DSL，看看我们可以怎样设计自己的语言。

### 4.1 领域特定语言

不过，一说起设计一门语言，很多人直觉上会有畏惧心理。但实际上，你可能已经在各种场合接触过一些不同的 DSL 了。程序员最熟悉的一种 DSL 就是正则表达式了，没错，也许已经习惯使用正则表达式的你都不知道，但它确实就是一种 DSL，一种用于文本处理这个特定领域的 DSL。

如果你觉得正则表达式有点复杂，还有一种更简单的 DSL，就是配置文件。你可能真的不把配置文件当作一种 DSL，但它确实是在实现某个特定领域的需求，而且可以根据你的需求对软件的行为进行定制。一个典型的例子是 Ngnix。无论你是用它单独做 Web 服务器也好，做反向代理也罢，抑或是做负载均衡，只要通过 Ngnix 的配置文件，你都能实现。配合 OpenResty，你甚至可以完成一些业务功能。这么一说，你是不是觉得 DSL 的门槛不像听上去那么高了。

经过前面几讲的学习，你应该知道了，语法只是一种接口。很多人说到设计 DSL，脑子里实际想的也只是设计一种语法。所以，从软件设计的角度看，DSL 最终呈现出来的语法只是一种接口，但最重要的是它包裹的模型。

Martin Fowler 在他的《领域特定语言》这本书中，将这个模型称为语义模型（Semantic Model）。不过，在我看来，Martin Fowler 起这个名字是站在语言开发的角度，毕竟语义这个词，只有学过编译原理的人才好理解。所以，这里真正的重点是模型。

想要实现一个 DSL，可以这么说，DSL 的语法本身都是次要的，模型才是第一位的。当你有了模型之后，所谓的构建 DSL，就相当于设计一个接口，将模型的能力暴露出来。当把 DSL 理解成接口，我们接受 DSL 的心理负担就小了很多。你可以想一想，它和你熟悉的 REST API 其实没有什么本质的不同。

既然是接口，形式就可以有很多种，我们经常能接触到的 DSL 主要有两种：外部 DSL 和内部 DSL。Martin Fowler 在他的书中还提到了语言工作台（Language Workbench），不过，这种做法在实际工作中用到的不多，我们暂且忽略。

外部 DSL 和内部 DSL 的区别就在于，DSL 采用的是不是宿主语言（Host Language）。你可以这么理解，假设你的模型主要是用 Java 写的，如果 DSL 用的就是 Java 语言，它就是内部 DSL，如果 DSL 用的不是 Java，比如，你自己设计了一种语法，那它就是外部 DSL。

把概念说清楚了，一些问题便迎刃而解了。这也可以解释为什么 DSL 让有些人畏惧了，原因就是说起 DSL，这些人想到的就是自己设计语法的外部的 DSL。其实，即便是外部 DSL，也不一定要设计一门语法，我们甚至可以借助已有的语法来完成。比如，很多程序员熟悉的一种语法：XML。

如果你是一个 Java 程序员，XML 就再熟悉不过了。从 Ant 到 Maven，从 Servlet 到 Spring，曾经的 XML 几乎是无处不在的。如果你有兴趣，可以去找一些使用 Ant 做构建工具的项目，项目规模稍微大一点，其 XML 配置文件的复杂程度就不亚于普通的源代码。

因为它本质上就是一种用于构建领域的 DSL，只不过，它的语法是 XML 而已。正是因为这种 DSL 越来越复杂，后来，一种新的趋势渐渐兴起，就是用全功能语言（也就是真正的程序设计语言）做 DSL，这是后来像 Gradle 这种构建工具逐渐流行的原因，它们只是用内部 DSL 替换了外部 DSL。

从复杂度而言，自己设计一种外部 DSL 语法，大于利用一种现有语法做外部 DSL，二者之间的差别在于谁来开发解析器。而外部 DSL 的复杂度要大于内部 DSL，因为内部 DSL 连解析的过程都省略了。从实用性的角度，更好地挖掘内部 DSL 的潜力对我们的实际工作助益更多。

### 4.2 代码的表达性

你或许会有一个疑问，内部 DSL 听上去就是一个程序库啊！你这个理解是没错的。我们前面说过，语言设计就是程序库设计，程序库设计就是语言设计。当一个程序库只能用在某个特定领域时，它就是一个内部 DSL，这个内部 DSL 的语法就是这个程序库的用法。我先用一个例子让你感受一下内部 DSL，它来自 Martin Fowler 的《领域特定语言》。我们要创建一个 Computer 的实例，如果用普通风格的代码写出来，应该是这个样子：

```java
Processor p = new Processor(2, 2500, Processor.Type.i386); Disk d1 = new Disk(150, Disk.UNKNOWN_SPEED, null);
Disk d2 = new Disk(75, 7200, Disk.Interface.SATA);
return new Computer(p, d1, d2);
```

而用内部 DSL 写出来，则是这种风格：

```java
computer() 
  .processor()
    .cores(2) 
    .speed(2500) 
    .i386()
  .disk()
    .size(150)
  .disk()
   .size(75)
   .speed(7200) 
   .sata()
.end();
```

如果这是一段普通的 Java 代码，我们看到一连串的方法调用，一定会说，这段代码糟糕至极！但在这个场景下，和前面的代码相比，这段代码省去了好多变量，反而是清晰了。这其中的差别在哪里呢？之所以我们会觉得这种一连串的方法调用可以接受，一个重要的原因是，这段代码并不是在做动作，而是在进行声明。做动作是在说明怎么做（How），而声明的代码则是在说做什么（What）。

二者的抽象级别是不同的，「怎么做」是一种实现，而「做什么」则体现着意图。将意图与实现分离开来，是内部 DSL 与普通的程序代码一个重要的区别，同样，这也是一个好设计的考虑因素。

Martin Fowler 在讨论 DSL 定义时，提到了 DSL 的 4 个关键元素：1）计算机程序设计语言（Computer programming language）；2）语言性（Language nature）；3）受限的表达性（Limited expressiveness）；4）针对领域（Domain focus）。

其中，语言性强调的就是 DSL 要有连贯的表达能力。也就是说，你设计自己的 DSL 时，重点是要体现出意图。抛开是否要实现一个 DSL 不说，的确，程序员在写代码时应该关注代码的表达能力，而这也恰恰是很多程序员忽略的，同时也是优秀程序员与普通程序员拉开差距的地方。普通程序员的关注点只在于功能如何实现，而优秀的程序员会懂得将不同层次的代码分离开来，将意图和实现分离开来，而实现可以替换。

说到这里，你就不难理解学习内部 DSL 的价值了，退一步说，你不一定真的要自己设计一个内部 DSL，但学会将意图与实现分离开，这件事对日常写代码也是有极大价值的。有了这个意识，你就可以很好地理解程序设计语言的一个重要发展趋势：声明式编程。现在一些程序设计语言的语法就是为了方便进行声明式编程，典型的例子就是 Java 的 Annotation。正是它的出现，Spring 原来基于 XML 的外部 DSL 就逐步转向了今天常用的内部 DSL 了，也就是很多人熟悉的 Java Config。

你会发现，虽然我在这说的是写代码，但分离意图和实现其实也是一个重要的设计原则，是的，想写好代码，一定要懂得设计。

### 黑板墙

我想请你分享一下，你还能举出哪些 DSL 的例子呢？

SQL 也是一种 DSL，他屏蔽了计算机存储的底层实现，提供了易于操作数据的接口。一些 ORM 框架对 SQL 这些 DSL 进行了进一步的封装提供了声明式注解，相当于构建在 DSL 之上的 DSL 翻译器。面向对象编程将面向关系的 DSL 进行更高层次的封装，使得在编程这个特定领域更加易于使用。作者回复：很好的分享！2020-06-17

我觉得 markdown 应该算一个。作者回复：嗯，好有趣的角度！2020-06-17

汇总：1）k8s 和 docker-compose 的 yml 文件，就是声明试编程。算是外部 dsl。2）本章疑问： dsl 和接口有何异同点？首先 dsl 和接口都做了一件事，就是意图和实现的分离。但是 dsl 的语义（意图）是可以灵活组织的，而接口的语义基本靠接口命名和方法命名来阐述，在灵活性上明显是不足的。如何去实现 dsl？第一感觉就是建造者模式。这里实现就有分支。第一种是将要执行的业务逻辑（实现）写在 dsl 实体 bean 内部。在所有业务功能都由实体内部属性决定时，这是可行的（领域模型的行为）；第二种是将执行的业务功能注入要创建的 dsl 实体，然后回调。毕竟复杂业务流程的组织不该是单个实体能够囊括的，而且我们的功能代码大部分还是面向过程的（java 就是一个 service 注入一个 service，然后嵌套调用）；第三种就是将 dsl 实体作为入参传入接口方法，然后通过其属性调整业务流向，控制代码逻辑。这种方式我认为是开发维护成本最低的（面向过程不好，但他简单呀，不需要什么设计知识背书，懂语法就能看懂），但是我在某本书看到过，「程序的逻辑不该由入参去控制」。是定制多个接口方法。还是提供统一方法由入参调度逻辑，真的不好说孰好孰劣。作者回复：后面我们就来谈结构化编程和面向对象编程。2020-06-17

drone.io 用的.drone.yml，jenkins 用的 pipefile 都算是轻量级的 dsl。uml 算不算是一种重量级的 dsl 呢？作者回复: UML 可能不算，因为它不能执行。2020-06-17

DSL 是为了解决某个特定领域的程序设计语言。作为一个客户端 APP 开发者，最常用到的莫过于 gradle。现在 JAVA 后端程序主要是通过 pom 配置构建，它其实就是通过 xml 来实现 DSL，我觉得后端程序通过 gradle 构建也将会成为主流。它比 xml 更加灵活，表达性更强要设计一个 DSL 就要构建一个模型，通过接口将能力暴露出来。如何暴露接口就可以分为内部 DSL 和外部 DSL，内部 DSL 使用编程语言如 JAVA 来实现，外部则使用类似 xml 语言来实现，或者自己设计语法实现内部 DSL 要将意图与实现区分开，这在程序设计中一个重要的原则。作者回复：非常好的总结！2020-06-17

我还没有到「设计一个 DSL」的高度，而且可能日常工作中遇到的问题也没有需要一门新的 DSL 来解决。正则表达式、配置文件和 SQL 都可以算作 DSL，这些都是受众比较广泛的，如果是自己设计一个，使用的人没有那么多，还有意义么？看了内部 DSL 的 Computer 的例子，感觉 DSL 不那么可怕了；顺便理解了为什么这「一连串的方法调用」可以被接受 —— 因为这是一段声明 What。反之，如果是一连串的动作，就应该避免了。虽然短时间内估计不会有设计 DSL 的机会，不过「编写有表达性的代码」，「分离意图和实现」是我可以追求的目标。看到留言里面有同学说可以把 Markdown 也当做一种 DSL，那么其针对的领域是什么呢，排版？作者回复: Markdown 并不能执行。2020-06-18

lambda，网络协议描述算不算是 dsl 呢？作者回复: DSL 首先是一门语言，能够执行的那种。单独的 Lambda 和协议都是不可执行的。2020-06-17

普通程序员的关注点只在于功能如何实现，而优秀的程序员会懂得将不同层次的代码分离开来，将意图和实现分离开来，而实现可以替换。意图和实现具体指什么还是不太明白，作者回复：意图，做什么，实现，怎么做。意图可以理解成方法命名，实现可以理解成方法里的每行代码。意图可以理解成接口定义，实现可以理解成实现类。2020-06-28

汇总：1）redis 的指令应该不算是 dsl，而只是接口吧。2）linux 的 awk 应该算是一种 dsl。作者回复：AWK 已经是一门正经的语言了。2020-06-22

全文读完就感觉 DSL 其实就是个间接层，为什么要有这个间接层，为了就是能更简单的更快捷的解决问题。作者回复：是的，接口也很重要。2020-06-19

如果这么说，移动端开发常用的 Cocoapods 也是一种 DSL。作者回复：嗯，也算。2020-06-17

Quartz 等调度框架常用的 Cron 表达式也是一种 DSL 吧。作者回复：嗯，还真是。2020-07-01

ansible-playbooks 的 yml 文件应该也能看成 dsl。作者回复：某种程度上，算。2020-06-23

## 0205再八卦几门语言.md

每个程序员除了学习当下要用到的知识之外，一般都会对自己的未来做一些技术储备，其中，判断技术趋势就是我们在投资未来时的一个重要参考。如何才能更好地判断未来技术发展趋势呢？就是去知道一些技术的发展历史。

### 5.1 C#

当年 Java 开始起势的时候，微软还处于自己的巅峰，它当然不想错过 Java 这么有前景的东西。但是，微软从来就不会老老实实按照标准做事，所以，你会看到微软手中的 Basic 已经很不像 Basic 了，微软的 C++ 也有着自己的扩展。于是，微软也想做出一个自己的 Java，J++ 就出现了。但是，这不是一个正常的 Java，引发了 SUN 的不满，将微软告上法庭。最终，双方庭外和解，微软不再祸害 Java，J++ 停止更新。

但有一点不得不承认，微软在 Windows 上的 JVM 性能是当时最好的，因为操刀 J++ 的是 Anders Hejlsberg，他是全世界最顶级的程序员。微软为了不与 Java 开启的受控（Managed）代码浪潮擦肩而过，于是，转身又推出了 C# 和.NET。

C# 的初版本简直和 Java 一模一样，一个 Java 程序员几乎不用培训就可以成为一个 C# 程序员。所以，从语言的角度来说，最初的 C# 并没有对行业做出什么贡献。不过，既然有 Anders Hejlsberg 在背后，事情当然不会就这么简单收尾。C# 在语言特性上开始一路狂奔，一个更强大的 C# 崭露头角。像 Lambda、类型推演这些特性早早就落户 C# 了。然而，C# 时运不济，它的上升期遇到了微软的下降期。越来越多的公司选择了 Java，越来越多的程序员拥抱了 Java，而语言模型上表现优秀的 C# 则遭遇了冷落。

当年 Java 号称「一个语言，多个平台」，而 .NET 则是「一个平台，多个语言」。结果呢，.NET 的「一个平台」并不足以吸引更多的公司和程序员的投入，除了微软自己，其他在上面开发语言的尝试通常都是浅尝辄止。而 JVM 虽然目标不是为了多语言，但丝毫不妨碍很多人在上面开发新语言，比如，Groovy、Scala、Clojure 等等。

最终，JVM 成了「多个语言，多个平台」。随着微软的逐步开放，.NET 也开始迈向了多平台，C# 也成了一门跨平台的语言，遗憾的是，为时已晚，Java 已经成就了一番霸业。

如果出于学习的目的，C# 绝对是值得一学的程序设计语言，毕竟微软在语言设计上还是很有一套的。Java 语言的进化是非常缓慢的，尤其是 SUN 的衰退又耽误了很多年。所以，从语言特性上来看，说 C# 领先 Java 十年并不夸张。

### 5.2 JavaScript

JavaScript 从诞生之日起就扮演着一个不受待见的角色，Brendan Eich 发明 JavaScript 完全是为了应付工作，因为他当时供职的 Netscape 需要让网页上的元素动起来。

雷锋和雷锋塔有什么关系？Java 和 JavaScript 有什么关系？这是一个经常被人提起的段子，但实际上，JavaScript 和 Java 真的有关系，关系就是蹭热度。当时的 Java 给世界描绘了一个美好的未来，让无数人心潮澎湃，JavaScript 就想借一下 Java 的东风。

JavaScript 仅仅用 10 天就设计出来，所以，在它的实现中，包含了各种奇怪的问题。不过，它还是体现出了 BrendanEich 的功底，比如，JavaScript 提供了对各种编程范式的支持。其实，他真正想做的是一门函数式编程的语言，但向现实妥协的结果就是，借助了 C 风格的语法，函数式编程的底子却留在了 JavaScript 里。

虽然在今天看来，在浏览器上 JavaScript 一枝独秀，但当年它也是有竞争对手的，那个年代无处不在的微软，出手做了一个 VBScript。但是，如同微软错过了互联网时代一样，与 Windows 结合更加紧密的 VBScript 也在这场竞争中败下阵来。

当年，与 JavaScript 联系在一起的，更多的是像走马灯之类的页面特效。让 JavaScript 真正第一次得到重视是 Ajax 这门技术。Ajax 的出现，让页面的元素可以与远程的服务器进行交互，JavaScript 开始由一个小玩具变成了一门值得研究的技术，前端的表现力得到了大幅度的提升。但很长一段时间里，JavaScript 一直都不是一门正式的语言，对于很多人来说，它只是要做前端时顺便学习的语言。这种现象一直持续到 Node.js 的诞生。

Node.js 其实是一个集成商，它之所以能有良好的表现要归功于 V8 这个 JavaScript 引擎。而 V8 的出现则要归因于 Google 对于网络应用前景的格局。想当年的浏览器大战，Netscape 和 IE 拼得你死我活，最终 IE 凭借 Windows 的优势成了赢家，Netscape 也退出了历史舞台。然而，胜利后的微软认为天下已平，竟然解散了 IE 的团队，导致了程序员们要在很长时间内忍受 IE 这个既不标准又慢的浏览器。

这就给后来居上者留下了空间。最有名的两个后来者，一个是 Netscape 的转世 Firefox，另外一个就是 Google 出品的 Chrome。

Chrome 认为未来的页面一定要有更强的表现力，所以，一个高效强大的浏览器是必需的。既然慢是个大问题，Chrome 就着力解决慢这个问题，甚至不惜开发了一个新的 JavaScript 引擎，也就是 V8，它的重点就是解决 JavaScript 执行慢的问题。可等微软看懂 Google 的操作，幡然悔悟，重新投入浏览器的开发之时，大势已去。Chrome 成了新的霸主。

Chrome 有一点做得很好，V8 一开始就是一个独立的 JavaScript 引擎。所以 Node.js 才可以很方便地把它借鉴过去。除了 V8 的性能优势，Node.js 还引入了异步 IO 的模型，这刚好与 JavaScript 事件驱动的特点相吻合。

Node.js 刚一登场便赢得了满堂喝彩。因为，人们认识到，JavaScript 原来不只能在浏览器中运行，也可以跑在服务器端。很快，NPM 这个包管理器登场，降低了众多开发者参与的门槛，JavaScript 迎来了属于自己的爆发，各种各样的程序库让人眼花缭乱。

前端开发也由少数人的爱好，成为了一个专属的职位，像 React、Angular、Vue 等框架的出现，更是让前端开发有了工程的味道，而不再是小打小闹了。一旦 JavaScript 突破了浏览器的限制，给人们的想象空间就大了许多。除了服务器端，有人想把 JavaScript 用在嵌入式开发中，有人想把它用在手机开发中。JavaScript 成了一门全平台覆盖的语言，大有一统天下的架势。

不过，JavaScript 作为一门语言，其问题之多也是由来已久的。虽然 JavaScript 本身也在不断进化，但沉重的历史包袱让很多人都想开发出新的语言去替代它。所以，在 JavaScript 社区中，很多人把它看成了一种 Web 上的汇编语言，把新的语言编译成 JavaScript，这样，就可以在浏览器上运行了。从早先的 CoffeeScript 到现在的 TypeScript，甚至新一代的 JavaScript 标准都是以这种方式进行开发的。

当然还有人有更高的追求，他们认为仅仅在语言层面屏蔽 JavaScript 是不够的。WebAssembly 就是想成为 Web 上真正的汇编，真正取 JavaScript 而代之，事实上，它也得到了很多人的支持。不过，这种努力至今仍在继续中，还有很长的路要走。

JavaScript 就是这样，从一出生就不受待见，到今天，很多人仍想把它干掉。但这并不妨碍它在软件开发的历史中写下浓墨重彩的一笔。

### 5.3 Go 和 Rust

在系统编程方面，C 语言是当之无愧的霸主，然而，C 语言已经快 50 岁了。在计算机这个快速变化的行业里，50 年长得令人发指。在这 50 年中，C 从被人质疑发展到如日中天，再到应用开发的地位逐步被取代。如今，它只在系统编程有着无可替代的作用。事实上，人们也一直想着替代它。

C 的强项是对于计算机模型的适度抽象，弱项却是在程序的组织上。因为在 C 诞生那个年代，程序的规模还不算太大。然而 C 的成功却让程序的规模越来越大，大到超出了 C 语言的能力范畴。于是，有人想着把面向对象加到 C 语言里，扩大程序的组织规模。这方面的尝试，我们都熟悉的是 C++。

不过，C++ 只风光了一段时间，就被 Java 盖了过去。C++ 本身有一段时间变成了语言特性的试验田，泛型编程，尤其是模板元编程的出现，一度让人怀疑人生。它成了高手极度喜爱，普通人一脸懵硬着头皮写的程序语言。

但更重要的是，C++ 背负了 C 语言所有的历史负担。所以，很多 C 的问题在 C++ 里面依然存在，比如，内存管理。虽然 C++ 有各种补丁方案，但你必须对 C++ 极其了解，才能写好 C++，然而，这个要求对于一个工程化的语言来说，实在是太高了。所以，无论是 C 还是 C++，都是在执行性能上无可挑剔，在代码编写上一地鸡毛，人们还是需要一门更有开发效率的系统编程语言。

时间来到新千年，又有人出手想代替 C 语言，这回出手的人物背景强大，他就是 Ken Thompson，C 语言的亲爹。2009 年，如日中天的 Google 推出了 Go 语言，再加上 Ken Thompson 和 Rob Pike 这样早期的 Unix 先驱站在它背后，Go 语言的前景给人无限的遐想。

Go 语言的语法设计是简单的，基本上，你花一个晚上就可以把 Go 语言完整地学习一遍。它在接口设计和并发上的处理方式都给人眼前一亮的感觉。人们热切地期盼着它成为下一个系统编程语言的霸主。

但事实并没有像人们想象地那样发生，除了初生之时引起了一片欢呼，Go 语言很长一段时间都在低位徘徊。比较有趣的是，中国有很多开发者对于 Go 的喜爱程度极高，一度让 Go 语言在中国的热度远远超过了全球的平均水平。之所以 Go 没有很快赢得人们的关注，因为它关注的系统编程领域并没有太多的机会留给它，人们嘴上喊着热爱，手里还依然用 C 写着代码。

不过，机会总是留给做好准备的人，语言也不例外。随着 Docker 这套虚拟化软件登上历史舞台，Go 语言终于有了用武之地。人们开始意识到，原来云计算领域还有一些基础设施要写，用 C 的话，不好维护；用 Java 的话，浪费资源；Go 恰如其分地解决了大部分问题。

一批新生代的基础设施纷纷出炉，除了 Docker 之外，还有帮助人们实现容器部署的 Kubernetes，也就是 k8s，还有辅助 Service Mesh 的 istio 等等。虽然在云计算基础设施中，Go 赢得了一席之地，这属于开辟了一片蓝海。在传统系统编程的红海中，Go 语言其实并没有做出什么特别的成绩，对于实时性和性能要求极高的领域，Go 语言有一个拿不出手的弱项，也就是它的 GC。

自动的内存管理固然是简化程序员工作的一项重要手段，但对于系统编程这个领域而言，GC 显然还没有表现得能够赢得大家的信任，而且，在可见的未来，也不会有明显的起色。所以，在系统编程领域替代 C 的征程上，大家都还有机会。这条赛道上目前最有力的竞争者是 Rust。

Rust 出自 Mozilla，这是浏览器 Firefox 背后的公司，它原本是 Mozilla 员工 Graydon Hoare 的个人项目，后来得到了公司赞助，由一个练手的项目成为了一个正式的项目。Rust 对初学者并不友好，对于习惯「少废话、先动手」的程序员而言，Rust 的初体验可能一点都不好，按照习惯方式写出来的代码很可能是无法编译的。比如，Rust 的「变」量缺省是不变的，再有，想写好 Rust 程序，先要了解所有权的概念。不过，也恰恰是因为这些限制，让 Rust 写出来的程序犯下低级错误的概率大大降低了。

如果你理解系统编程面临的问题，以及现代软件开发的趋势，你会发现，Rust 提供的选项很好地规避了许多问题。比如，之所以要用不变性，是因为它可以规避掉很多因为「变」带来的问题，这是函数式编程给软件开发贡献的一个重要思路。再比如，所有权的概念也是为了防止一块内存不同的人去改，造成各种问题，同时，也给内存管理提供了新的思路。

内存不能让程序员管，这已经成了共识，但主流的 GC 方案又不能满足系统编程的需要，Rust 则给出了第三种方案，把内存当作一种资源，申请下来就初始化好，出了生命周期就销毁掉。之所以能够做到这点，还是要拜 Rust 强大的编译器所赐，因为所有权的存在，编译器可以很好地分析出内存到底该什么时候释放。

Rust 成为系统编程语言的有力竞争者还有一个原因，它背靠着 LLVM。LLVM 是一套编译器的基础设施，它的出现是因为传统的工具链 GCC 太过沉重。LLVM 把编译器的前端和后端分离开来，语言开发者只要关注前端，设计好各种语言特性，就可以利用 LLVM 的后端进步的优势，比如，不断优化带来的性能提升。对系统编程语言来说，一个重点就是可移植性。

系统编程一个重要的战场就是各种嵌入式设备，而绝大多数设备都只支持 C/C++ 语言。一个重要的原因就是谁来移植编译器，C/C++ 的后端常常是厂商提供支持的，而其他语言则多半无人理睬。现在有了 LLVM 的基础设施，一个芯片厂商只要支持了 LLVM 的后端，用 LLVM 前端开发出的语言也就都得到了支持。这对于新兴语言来说，绝对是一个巨大的好消息。

Rust 在语言层面表现出来的安全特性，帮它赢得了像微软、亚马逊这样大厂的注意；占用资源少的内存管理方式，让一些人开始尝试使用它编写 Linux 驱动；更多的移植可能，也让它成为了嵌入式开发的一种考虑。在这场 C 语言替代者的竞争中，Rust 值得期待！

### 黑板墙

我想请你分享一下，你看好哪门语言未来的发展？为什么？

语言的流行通常需要一个杀手级的应用，比如 RoR 之于 Ruby，Docker 之于 Go，Spring 之于 Java。作者回复：是这样的，杀手级应用助力语言爆发。2020-06-19

python 应该会因为 AI 继续焕发第二春下去。作者回复：这点还真是，Python 找到了 AI 这个增长点。2020-06-21

从语言本身来说，我还是比较喜欢 C# 的，多年以前也写过 ASP.NET 的程序。不过 C# 确实「时运不济」，而且替技术人员背了不少黑锅，比如「ASP.NET 就是慢」之类的。我还是挺喜欢 C# 后来的泛型、Lamda 表达式、LINQ 之类的「语法糖」。

从就业市场的角度讲，C# 的程序员的平均薪水一直不怎么高（可能是因为上手比较容易），岗位也不多。现在有了 .NET Core，不知道会不会好一点。学过一点 JavaScript 和 Node.JS，相比较而言，我还是更把时间投入到 Go 或者是 C# 上面。听了一次前端的直播（Vue.js），我就从入门到放弃了。之前是打算去学一下 Go 语言的，不过看了专栏的介绍，觉得 Rust 也是一个好机会。作者回复：每种流行的语言都有它流行的原因，值得探索一下。2020-06-23

个人以为语言应差异化竞争，百花齐放，多出些最佳实践和案例相互成就。我比较看好微软的 .NET 5.0，立足实际又不乏野心，公司本身也具备做好的条件和能力。不要太在意短期吸粉与排名，做好自我完善和迭代也许就水到渠成了。作者回复：.NET 本身的能力只是一方面，还要看微软怎么让它摆脱单一平台的刻板印象。2020-06-19

由于自己的行业相对比较传统，没有接触特别前沿的领域和技术，不好判定语言的走势。就程序设计语言，又让我回想起那句：语言即是程序库，程序库即是语言。语言的出现是伴随着工程问题的出现，通过新的语言特性更好地解决现有的工程问题。前段时间阅读了《c++ 的程序设计与演化》，较直观地看到语言的前世今生，了解语言的历史对写好一门语言也是挺重要的。作者回复：一个程序员，保持对技术趋势的关注很重要。2020-06-20

Wasm 最初的规范中不支持 GC，所以 Rust 和 C/C++ 天生都可以「直出」Wasm，Go 和 Java 等就不行。但要让前端开发去掌握系统编程语言还是要求高了点且没必要（其他的选择像是 AssemblyScript 虽然门槛低一些但还不完整；Yew 可以重用一些 Elm 的经验，但 Elm 本身也太小众了）。有 GC 的话虽然影响性能，但确实可以降低语言的门槛。作者回复：感谢你的补充信息！2020-06-20

看好 JavaScript，感觉它的出生起，就奠定了它以无声胜有声，无意胜有意的大道。我走我的路，让别的语言说去吧。作者回复：等着看未来的发展吧！2020-06-19

每种语言都有自己解决问题的范畴。哪个语言更好其实没有很强的可比性，因为每个语言解决的问题不一样。从发展潜力上看，个人还是比较看好 golang 和 rust，虽然我自己使用的语言主要是 JAVA，kotlin 等 jvm 语言。作者回复：找出每种语言解决的问题和方案，可以帮助我们更好地理解程序设计语言。2020-06-19

汇总：1）微软早期本就是屡战屡败，屡败屡战顽强存活下来的......失利和失败在那个时候也算是家常便饭了。2）很遗憾，语言这个话题不敢乱说。虽然也会几门语言，但也就看得懂语法，能写点玩具的程度。也就 java 熟悉点。只能说，无论以后各种语言多么璀璨。java 都挺难退出历史舞台，毕竟在普及程度或则说体量上 java 占比很高，这算得上已有市场优势。而且 java 的社区的积累殷实。新语言哪怕只是翻译，一个一个组件改写成自己的程序库也要挺久。所以 kt、grovy、scala 这些可以基于 java 程序库开发其实挺好的。能改善 java 比较死板的语言特性，还能用其丰富的程序库。更何况 java 还有 jvm 这个玩意，这玩意可是实现了多语言的虚拟机（jit 编译器 graal）。（一门语言除了前端编译器（文法解析），是否还应包含后端编译器呢？这是个问题）作者回复：Java 在可见的未来都会长期存在，它的生态太庞大了。2020-06-19

一度认为能前后端通吃的语言吧，比如 Javascript，更多新潮需要特性支持的 Swift。作者回复：JS 能力上没问题，语言拖后腿了。2020-06-19

中国有很多开发者对于 Go 的喜爱程度极高，一度让 Go 语言在中国的热度远远超过了全球的平均水平。还真是的，七牛最近甚至还搞了个 Go+ 出来。作者回复：嗯，这个消息我也看到了，让它先飞一会儿。2020-07-29