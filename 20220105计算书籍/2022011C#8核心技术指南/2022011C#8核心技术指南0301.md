## 0301. 在 C# 中创建类型

本章将深入讨论类型和类型的成员。

### 3.1 类

类是一种最常见的引用类型，最简单的类的声明如下：

```cs
class YourClassName
{
}
```

而复杂的类可能包含如下内容：

1、在 class 关键字之前：类特性（Attribute）和类修饰符。非嵌套的类修饰符有：public、internal、abstract、sealed、static、unsafe 和 partial。

2、紧接 YourClassName：泛型参数、唯一基类与多个接口。

3、在花括号内：类成员（方法、属性、索引器、事件、字段、构造器、重载运算符、嵌套类型和终结器）。

本章涵盖了除类特性、运算符函数以及 unsafe 关键字外的上述所有内容。本章未涵盖部分将在第 4 章介绍。以下将逐一介绍各个类成员。

#### 3.1.1 字段

字段（field）是类或结构体中的变量成员。例如：

```cs
class Octopus 
{ 
    string name;
    public int Age = 10;
}
```

字段可用以下修饰符进行修饰：

静态修饰符：static

访问权限修饰符：public internal private protected

继承修饰符：new

不安全代码修饰符：unsafe

只读修饰符：readonly

线程访问修饰符：volatile

readonly 修饰符

readonly 修饰符防止字段在构造后进行变更。只读字段只能在声明时或在其所属的类型构造器中赋值。

字段初始化

字段不一定要初始化。没有初始化的字段均为默认值（0、\0、null、false）。字段初始化逻辑在构造器之前运行：

```cs
public int Age = 10;
```

字段初始化器可以包含表达式或调用其他方法：

```cs
static readonly string TempFolder = System.IO.Path.GetTempPath();
```

同时声明多个字段

为了简便，可以用逗号分隔的列表声明一组相同类型的字段。这是声明具有共同特性和修饰符的一组字段的简便写法：

```cs
static readonly int legs = 8,
                            eyes = 2;
```

#### 3.1.2 常量

常量是一种值永远不会改变的静态字段。常量会在编译时静态赋值，编译器会在常量使用点上直接替换该值（类似于 C++ 的宏）。常量可以是内置的数据类型：bool、char、string 或者枚举类型。

常量用关键字 const 声明，并且必须用值初始化。例如：

```cs
public class Test 
{
    public const string Message = "Hello World";
}
```

常量和 static readonly 字段的功能相似，但它在使用时有着更多的限制，不仅能够使用的类型有限，而且初始化字段的语句含义也不同。其他与 static readonly 字段的不同之处还有：

常量是在编译时进行赋值的。例如：

```cs
public static double Circumference (double radius) 
{
    return 2 * System.Math.PI * radius; 
}
```

将编译为：

```cs
public static double Circumference (double radius)
{ 
    return 6.2831853071795862 * radius;
}
```

将 PI 作为常量是合理的。它的值将在编译期确定。相反，static readonly 字段的值在程序运行时可以取不同的值。

```cs
static readonly DateTime StartupTime = DateTime.Now;
```

static readonly 字段的好处还在于当提供给其他程序集时，可以在后续版本中更新其数值。例如，假设程序集 X 提供了一个如下的常量：

```cs
public const decimal ProgramVersion = 2.3;
```

如果程序集 Y 引用程序集 X 并使用了这个常量，那么值 2.3 将在编译时固定在程序集 Y 中。这意味着如果 X 后来重新编译将其值更改为 2.4，那么 Y 仍将使用旧值 2.3 直至 Y 重新编译。而 static readonly 字段则不存在这个问题。

从另一个角度看，未来可能发生变化的任何值从定义上都不是常量，因此不应当表示为常量。

常量也可以在方法内声明：

```cs
static void Main() 
{
    const double twoPI = 2 * System.Math.PI;
    ... 
}
```

非局部常量可以使用以下的修饰符：

访问权限修饰符：public internal private protected

继承修饰符：new

#### 3.1.3 方法

方法用一组语句实现某个行为。方法从调用者指定的参数中获得输入数据，并通过指定的输出类型将输出数据返回给调用者。方法可以返回 void 类型，表明它不会向调用者返回任何值。此外，方法还可以通过 ref/out 参数向调用者返回输出数据。

方法的签名在这个类型的签名中必须是唯一的。方法的签名由它的名字和一定顺序的参数类型（但不包含参数名和返回值类型）组成。

方法可以用以下修饰符修饰：

静态修饰符：static

访问权限修饰符：public internal private protected

继承修饰符：new virtual abstract override sealed

分部方法修饰符：partial

非托管代码修饰符：unsafe extern

异步代码修饰符：async

表达式体方法

以下仅由一个表达式构成的方法：

```cs
int Foo (int x) { return x * 2; }
```

可以用表达式体方法简洁地表示，用胖箭头来取代花括号和 return 关键字：

```cs
int Foo (int x) => x * 2;
```

1『想不到 C# 竟然也有箭头函数，学 JS 时认识到的。（2022-04-08）』

表达式体函数也可以用 void 作为返回类型：

```cs
void Foo (int x) => Console.WriteLine (x);
```

重载方法

只要确保方法签名不同，可以在类型中重载方法（多个方法共用一个名称）。例如，以下的一组方法可以同时出现在同一个类型中：

```cs
void Foo (int x) {...} 
void Foo (double x) {...} 
void Foo (int x, float y) {...} 
void Foo (float x, int y) {...}
```

但是，下面的两对方法则不能同时出现在一个类型中，因为方法的返回值类型和 params 修饰符不属于方法签名的一部分：

```cs
void Foo (int x) {...} 
float Foo (int x) {...}

// Compile-time error

void Goo (int[] x) {...} 
void Goo (params int[] x) {...}

// Compile-time error
```

按值传递和按引用传递

参数按值传递还是按引用传递也是方法签名的一部分。例如，Foo (int) 和 Foo (ref int) 或 Foo (out int) 可以同时出现在一个类中。但 Foo (ref int) 和 Foo (out int) 不能同时出现在一个类中：

```cs
void Foo (int x) {...} 
void Foo (ref int x) {...}  // OK so far
void Foo (out int x) {...}   // Compile-time error
```

局部方法

我们可以在一个方法中定义另一个方法。

```cs
void WriteCubes() 
{
    Console.WriteLine (Cube (3)); 
    Console.WriteLine (Cube (4)); 
    Console.WriteLine (Cube (5));
    int Cube (int value) => value * value * value;
}
```

局部方法（如上述例子中的 Cube 方法）仅仅在包含它的方法（如上例中的 WriteCubes 方法）范围内可见。这不仅简化了父类型还可以让阅读代码的人一眼看出 Cube 不会在其他地方使用。另外一个优势是局部方法可以访问父方法中的局部变量和参数，这可以导致很多后果（将在 4.3.2 节详细介绍）。

局部方法还可以出现在其他类型的函数中，例如属性访问器和构造器等。甚至可以将局部方法放在其他的局部方法中，放在使用语句块的 Lambda 表达式中（见第 4 章）。同时，局部方法可以是迭代的（见第 4 章）和异步的（见第 14 章）方法。

局部方法不能用 static 修饰。如果父方法是静态的，那么局部方法也是隐式静态的。

静态局部方法（C# 8）

为局部方法添加 static 修饰符将令其无法使用其父级方法的局部变量和参数。这既可以避免耦合，也可以随心所欲地在局部方法中定义变量而无须担心和父级方法中定义的变量冲突。

#### 3.1.4 实例构造器

构造器执行类或结构体的初始化代码。构造器的定义和方法的定义类似，区别仅在于构造器名和返回值只能和封装它的类型相同：

```cs
public class Panda 
{
    string name; 
    public Panda (string n) 
    {
        // Define field 
        // Define constructor
        name = n;
        // Initialization code (set up field)
    }
} 
...

Panda p = new Panda ("Petey");
// Call constructor
```

实例构造器支持以下的修饰符：

访问权限修饰符：public internal private protected

非托管代码修饰符：unsafe extern

仅包含一个语句的构造器也可以使用表达式体成员的写法。例如：

```cs
public Panda (string n) => name = n;
```

重载构造器

类或者结构体可以重载构造器。为了避免重复代码，构造器可以用 this 关键字调用另一个构造器：

```cs
using System;

public class Wine 
{ 
public decimal Price; 
public int Year; 
public Wine (decimal price) { Price = price; } 
public Wine (decimal price, int year) : this (price) { Year = year; } 
}
```

当构造器调用另一个构造器时，被调用的构造器先执行。

还可以向另一个构造器传递表达式：

```cs
public Wine (decimal price, DateTime year) : this (price, year.Year) { }
```

表达式内不能使用 this 引用，例如，不能调用实例方法（这是强制性的。由于这个对象当前还没有通过构造器初始化完毕，因此调用任何方法都有可能失败）。但是表达式可以调用静态方法。

隐式无参数构造器

C# 编译器会自动为没有显式定义构造器的类生成无参数公有构造器。但是，一旦显式定义了至少一个构造器，系统就不再自动生成无参数的构造器了。

构造器和字段的初始化顺序之前提到，字段可以在声明时初始化为其默认值：

```cs
class Player 
{
    int shields = 50;
    int health = 100; 
}
```

字段的初始化按声明的先后顺序，在构造器之前执行。

非公有构造器

构造器不一定都是公有的。通常，定义非公有的构造器的原因是为了通过一个静态方法调用来控制类实例的创建。静态方法可以从一个池中返回对象，而不必每次创建一个新对象的实例。静态方法还可以根据不同的输入参数返回不同的子类对象：

```cs
public class Class1 
{ 
    Class1() {} 
    public static Class1 Create (...)
    // Private constructor
    { 
    // Perform custom logic here to return an instance of Class1 
    ...
    } 
}
```

解构器

解构器（或称之为解构方法）就像构造器的反过程：构造器使用若干值作为参数，并且将它们赋值给字段；而解构器则相反将字段反向赋值给若干变量。

解构方法的名字必须为 Deconstruct，并且拥有一个或多个 out 参数，例如：

```cs
class Rectangle 
{ 
    public readonly float Width, Height;
    public Rectangle (float width, float height)
    {
        Width = width; 
        Height = height;
    }
    
    public void Deconstruct (out float width, out float height) 
    {
        width = Width;
        height = Height; 
    }
}
```

若要调用解构器，则需使用如下的特殊语法：

```cs
var rect = new Rectangle (3, 4); 
(float width, float height) = rect; 
Console.WriteLine (width + " " + height);
// Deconstruction 
// 3 4
```

第二行是解构调用。它创建了两个局部变量并调用 Deconstruct 方法。上述解构调用等价于：

```cs
float width, height; 
rect.Deconstruct (out width, out height);
```

或者

```cs
rect.Deconstruct (out var width, out var height);
```

解构调用允许隐式类型推断，因此可以将其简写为：

```cs
(var width, var height) = rect;
```

或者 

```cs
var (width, height) = rect;
```

在解构过程中，如果并非对所有的变量都感兴趣，则可以使用丢弃符号（_）来忽略它们：

```cs
var (_, height) = rect;
```

以上写法比起定义一个不会使用的变量更能够体现出程序的本意。

如果解构中的变量已经定义过了，那么可以忽略类型声明：

```cs
float width, height;(width, height) = rect;
```

上述操作也称为解构赋值。我们可以通过解构赋值来简化类的构造器：

```cs
public Rectangle (float width, float height) =>
    (Width, Height) = (width, height);
```

我们还可以通过重载 Deconstruct 方法向调用者提供一系列解构方案。

Deconstruct 方法可以是扩展方法（请参见 4.9 节）。这种做法可方便地对第三方作者的类型进行解构。

#### 3.1.5 对象初始化器

为了简化对象的初始化，可以在调用构造器之后直接通过对象初始化器设置对象的可访问字段或属性。例如下面的类：

```cs
public class Bunny 
{
public string Name; 
public bool LikesCarrots; 
public bool LikesHumans;

public Bunny () {} 
public Bunny (string n) { Name = n; }
}
```

就可以用对象初始化器对 Bunny 对象进行实例化：

```cs
// Note parameterless constructors can omit empty parentheses 
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false }; 
Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };
```

构造 b1 和 b2 的代码等价于：

```cs
Bunny temp1 = new Bunny(); 
temp1.Name = "Bo"; 
temp1.LikesCarrots = true; 
temp1.LikesHumans = false; 
Bunny b1 = temp1;
// temp1 is a compiler-generated name
Bunny temp2 = new Bunny ("Bo"); 
temp2.LikesCarrots = true; 
temp2.LikesHumans = false; 
Bunny b2 = temp2;
```

使用临时变量是为了确保在初始化过程中如果抛出异常，也不会得到一个部分初始化的对象。

对象初始化器是在 C# 3.0 中引入的。

使用对象初始化器还是使用可选参数

除了使用对象初始化器，还可以令 Bunny 的构造器接收可选参数：

```cs
public Bunny (string name, bool likesCarrots = false, bool likesHumans = false) 
{
    Name = name;
    LikesCarrots = likesCarrots;
    LikesHumans = likesHumans; 
}
```

我们可以使用如下的语句构造 Bunny 对象：

```cs
Bunny b1 = new Bunny (name: "Bo", likesCarrots: true);
```

这样做的优点是可以将 Bunny 的字段（或属性，之后会讲解）设置为只读。如果在对象的生命周期内不需要改变字段值或属性值，则将其设置为只读是非常有用的。

缺点是，所有的可选参数都需要由调用者处理。换句话说，C# 会将构造器调用翻译为：

```cs
Bunny b1 = new Bunny ("Bo", true, false);
```

如果另一个程序集实例化 Bunny，则当 Bunny 类再次添加一个可选参数（如 likesCats）的时候就会出错。除非引用该类的程序集也重新编译，否则它还将继续调用三个参数的构造器（现在已经不存在了）而造成运行时错误（还有一种难以发现的错误是，如果我们修改了某个可选参数的默认值，另一个程序集的调用者在重新编译之前，还会继续使用旧的可选值）。

因此，如果希望程序在不同版本的程序集中保持二进制兼容，最好避免在公有方法中使用可选参数。

#### 3.1.6 this 引用

this 引用指代实例本身。下面的例子中，Marry 方法将 partner 的 mate 字段设定为 this：






public class Panda

{ public Panda Mat

e;

public void Marr

y

(Panda partner) {  Mate = partner

;  partner.Mate =

t

his; }}

this

引用可避免字段、局部变量或属性之间发生混淆。例如：

public class Test

{ string name; public Test (st

ri

ng name) { this

.name = name; }}

this

引用仅在类或结构体的非静态成员中有效。

#### 3.1.7 属性

从外表看来，属性（Property）和字段很类似，但是属性内部像方法一样含有逻辑。例如，从以下代码不能判断出 CurrentPrice

到底是字段还是属性。

Stock msft = new Stock();

msft.CurrentPrice = 30;msft.CurrentPrice -= 3;Console.WriteLine (msft.C

urrentPrice);

属性的声明和字段的声明很类似，但是属性比字段多出了 get

/set

代码块。下面是 CurrentPrice

作为属性的实现方法：

public class Stock

{ decimal currentP

ri

ce;      // The private "backing" field public decimal C

ur

rentPrice   // The public property {  get { return c

ur

rentPrice; }  set { currentP

ri

ce = value; } }}

get

和 set

是属性的访问器。读属性时会运行 get

访问器，它必须返回属性类型的值。给属性赋值时运行 set

访问器。它有一个名为 value

的隐含参数，其类型和属性的类型相同，它的值一般来说会赋值给一个私有字段（上例中为 currentPrice

）。

尽管访问属性和字段的方式是相同的，但不同之处在于，属性在获取和设置值的时候给实现者提供了完全的控制能力。这种控制能力使实现者可以选择任意的内部表示形式，而无须将属性的内部细节暴露给用户。上例中，set

方法可以在 value

超出有效范围时抛出异常。

本书中广泛使用公有字段以免干扰读者的注意力。但是在实际应用中，为了提高封装性可能会更倾向于使用公有属性。

属性支持以下的修饰符：

静态修饰符：static

访问权限修饰符：public internal private protected

继承修饰符：new virtual abstract override sealed

非托管代码修饰符：unsafe extern

只读属性和计算属性

如果只定义了 get

访问器，属性就是只读的。如果只定义了 set

访问器，那么它就是只写的。一般很少使用只写属性。

通常属性会用一个专门的支持字段来存储其所代表的数据，但属性也可以从其他数据计算得来：

decimal currentPrice, sharesOwned;

public decimal Worth{ get { return currentPrice * shar

e

sOwned; }}

表达式体属性

只读属性（就像之前的例子中那样的属性）可简写为表达式体属性。它使用胖箭头替换了花括号、get

访问器和 return

关键字。

public decimal Worth => currentPrice * sharesOwned;

只需添加少许代码，还可以进一步将 set

访问器改为表达式体：

public decimal Worth{ get => currentPrice * sharesOwned;

set => sharesOwned = value / currentPrice;

}

自动属性

属性最常见的实现方式是使用 get

访问器和 set

访问器读写私有字段（该字段与属性类型相同）。因而编译器会将自动属性声明自动转换为这种实现方式。因此我们可以将本节的第一个例子重新定义为：

public class Stock

{ ... public decimal C

ur

rentPr

ice { get; set; }}

编译器会自动生成一个后台私有字段，该字段的名称由编译器生成且无法引用。如果希望属性对其他类型暴露为只读属性，则可以将 set

访问器标记为 private

或 protected

。自动属性是在 C# 3.0 中引入的。

属性初始化器

我们可以为自动属性添加属性初始化器。其写法就像初始化字段一样：

public decimal CurrentPrice { get; set; } = 123;

上述写法将 CurrentPrice

的值初始化为 123

。拥有初始化器的属性可以为只读属性：

public int Maximum { get; } = 999;

就像只读字段那样，只读自动属性只可以在类型的构造器中赋值。这个功能适于创建不可变（只读）的对象。

get

和 set

的可访问性

get

和 set

访问器可以有不同的访问级别。典型的用例是将 public

属性中的 set

访问器设置成 internal

或 private

的：

public class Foo{ private decimal x; public decimal X {  get     { return x; }  private

set { x = Math.Round (value, 2); }

}}

注意，属性本身应当声明具有较高的访问级别（本例中为 public

），然后在需要较低级别的访问器上添加相应的访问权限修饰符。

CLR 属性的实现

C# 属性访问器在内部会编译为名为 get_

XXX

和 set_

XXX

的方法：

public decimal get_CurrentPrice {...}

public void set_CurrentPrice (decimal

value) {...}

简单的非虚属性访问器会被 JIT（即时）编译器内联编译，消除了属性和字段访问间的性能差距。内联是一种优化方法，它用方法的函数体替代方法调用。

Windows Runtime 库中的属性则会被编译器转换为 put_

XXX

作为属性命名约定而非 set_

X

XX

。

#### 3.1.8 索引器

索引器为访问类或者结构体中封装的列表或字典型数据元素提供了自然的访问接口。索引器和属性很相似，但索引器通过索引值而非属性名称访问数据元素。例如 string

类具有索引器，可以通过 int

索引访问其中每一个 char

的值。

string s = "hello";

Console.WriteLine (

s[0]); // 'h'Console.WriteLine (

s[3]); // 'l'

使用索引器的语法就像使用数组一样，不同之处在于索引参数可以是任意类型。

索引器具有和属性相同的修饰符（请参见 3.1.8 节），并且可以在方括号前插入「?

」以使用 null

条件运算（请参见 2.10 节）：

string s = null;

Console.WriteLin

e (s?[0]); // Writes nothing; no error.

索引器的实现

编写索引器首先要定义一个名为 this

的属性，并将参数定义放在一对方括号中。例如：

class Sentence{ string[] words = "The quick brown fox".Split(); public string this [int wordNum]   // indexer

{

get { return words [wordNum]; }

set { words [wordNum] = value; }

}

}

以下展示了索引器的使用方式：

Sentence s = new Sentence();

Console.WriteLine (s[3]);

// foxs[3] = "kangaroo";Console.WriteLine (s[3]);

// kangaroo

一个类型可以定义多个参数类型不同的索引器，一个索引器也可以包含多个参数：

public string this [int arg1, string arg2]

{ get { ... } set { ... }}

如果省略 set

访问器，则索引器就是只读的。同时，索引器也可以使用表达式体的语法简化其定义。

public string this [int wordNum] => words [wordNum];

CLR 索引器的实现

索引器在内部会编译为名为 get_Item

和 set_Item

的方法，如下所示：

public string get_Item (int wordNum) {...}

public void set_Item (int wordNum, string

value) {...}

在索引器中使用索引和范围（C#）

在自定义类中，可以在索引器参数中使用 Index

和 Range

类型来支持索引和范围操作（请参见第 2.7.2 节）。例如，我们可以扩展前面的例子，在 Sentence

类中加入以下的索引器：

public string this [Index index] => words [index];

public string[] this [Range range] => words [range

];

并进行如下的调用：

Sentence s = new Sentence();

Console.WriteLine (s [^1]);

// foxstring[] firstTwoWords = s [

..2];  // (The, quick)

#### 3.1.9 静态构造器

每个类型的静态构造器只会执行一次，并不是每个实例执行一次。一个类型只能定义一个静态构造器，名称必须和类型同名，且没有参数：

class Test

{ static T

es

t() { Console.WriteLine ("Type Initialized"); }}

运行时将在类型使用之前调用静态构造器，以下两种行为可以触发静态构造器执行：

实例化类型

访问类型的静态成员

静态构造器只支持两个修饰符：unsafe

和 extern

。

如果静态构造器抛出了未处理的异常（见第 4 章），则该类型在整个应用程序生命周期内都是不可用的。

静态构造器和字段初始化顺序

静态字段初始化器会在调用静态构造器前运行。如果类型没有静态构造器，字段会在类型被使用之前或者在运行时中更早的时间进行初始化。

静态字段初始化器按照字段声明的先后顺序运行。下面的例子中 X

初始化为 0

而 Y

初始化为 3

。

class Foo

{ public

st

atic int X = Y;  // 0 public

st

atic int Y = 3;  // 3}

如果我们交换两个字段初始化顺序，两个字段都将初始化为 3

。以下示例会先打印 0

后打印 3

，因为字段初始化器在 X

初始化为 3

之前创建了 Foo

的实例：

class Program{ static void Main() { Console.WriteLine (Foo.X); }  // 3}class Foo{ public static Foo Instance = new Foo();

public static int X = 3;



Foo() { Console.WriteLine (X); }  // 0}

如果交换上面代码中加粗的两行，则两个字段上下两次都输出 3

。

#### 3.1.10 静态类

类可以标记为 static

，表明它必须只能够由 static

成员组成，并且不能派生子类。System.Console

和 System.Math

类就是静态类的最好示例。

#### 3.1.11 终结器

终结器是只能够在类中使用的方法。该方法在垃圾回收器回收未引用对象占用的内存前调用。终结器的语法是类的名称加上～

前缀。

class Class1

{ ~Class1() {  ... }}

事实上，这是 C# 语言重写 Object

类的 Finalize

方法的语法。编译器会将其扩展为如下的声明：

protected override void Finalize()

{ ... base.Finalize();}

第 12 章将详细讨论垃圾回收和终结器。

终结器允许使用以下的修饰符：

非托管代码修饰符：unsafe

仅仅包含一个语句的终结器可以写为表达式体语法：

~Class1() => Console.WriteLine ("Finalizing");

#### 3.1.12 分部类型和方法

分部类型（partial type）允许一个类型分开进行定义，典型的做法是分开在多个文件中。分部类型使用的常见场景是从其他源文件自动生成分部类（例如从 Visual Studio 模板或设计器），而这些类仍然需要额外手动编写方法。例如：

// PaymentFormGen.cs - auto-generated

partial class PaymentForm { ... }// PaymentForm.cs - hand-authoredpartial class PaymentForm { ... }

每一个部分必须包含 partial

声明。因此以下的写法是不合法的：

partial class PaymentForm {}

class PaymentForm {}

分部类型的各个组成部分不能包含冲突的成员，例如具有相同参数的构造器。分部类型完全由编译器处理，因此各部分在编译时必须可用，并且必须编译在同一个程序集中。

可以在多个分部类声明中指定基类，只要基类是同一个基类即可。此外，每一个分部类型组成部分可以独立指定实现的接口。我们将在 3.2 节和 3.6 节详细讨论基类和接口。

编译器并不保证分部类型声明中各个组成部分之间的字段初始化顺序。

分部方法

分部类型可以包含分部方法（partial method）。这些方法能够令自动生成的分部类型为手动编写的代码提供自定义钩子（hook）。例如：

partial class PaymentForm  // In auto-generated file

{ ... partial void ValidatePayment (decimal amount);}partial class PaymentForm  // In hand-authored file{ ... partial void ValidatePayment (decimal amount) {  if (amount > 100)   ... }}

分部方法由两部分组成：定义和实现。定义一般需要代码生成器生成，而实现一般需要手动编写。如果没有提供方法的实现，分部方法的定义会被编译器清除（调用它的代码部分也一样）。这样，自动生成的代码既可以提供钩子又不必担心代码过于臃肿。分部方法返回值类型必须是 void

，且该方法是隐式的 private

方法。

#### 3.1.13 nameof 运算符 

nameof 运算符返回任意符号的字符串名称（类型、成员、变量等）。

```cs
int count = 123;
string name = nameof(count);    // name is "count"
```

相对于直接指定一个字符串，这样做的优点体现在静态类型检查中，可以令像 Visual Studio 这样的工具理解你引用的符号。当符号重命名时，所有引用之处都会随之重新命名。

当指定一个类型的成员（例如属性和字段）名称时，请务必引用其类型名称。这对静态和实例成员都有效：

```cs
string name = nameof (StringBuilder.Length);
```

上述代码将结果解析为 Length，如果希望得到 StringBuilder.Length，则可以这样做：

```cs
nameof (StringBuilder) + "." + nameof (StringBuilder.Length);
```

### 3.2 继承

类可以通过继承另一个类来对自身进行扩展或定制。继承类可以使用被继承类的所有功能而无须重新构建。类只能继承自唯一的类，但是可以被多个类继承，从而形成了类的层次。本例中定义了一个名为 Asset

的类：

public class Asset

{ public string Na

me

;}

接下来我们定义两个类 Stock

和 House

。它们都继承了 Asset

类，具有 Asset

类的所有特征，而各自又有自身新增的成员定义：

public class Stock : Asset

// inherits from Asset{ public long SharesOwned;}public class House : Asset

// inherits from Asset

{ public decimal Mortgage

;}

下面是两个类的使用方法：

Stock msft = new Stock { Name="MSFT",

SharesOwned=

1000 };Console.WriteLine (msft.Name);

// MSFTConsole.WriteLine (msft.SharesOwned);

// 1000House mansion = new House { Name="Man

sion",              Mortgage=

250000 };Console.WriteLine (mansion.Name);

// MansionConsole.WriteLine (mansion.Mortgage);

// 250000

派生类 Stock

和 House

都从基类 Asset

中继承了 Name

属性。

派生类也称为子类；基类也称为超类。

3.2.1　多态

引用是多态的。意味着 x

类型的变量可以指向 x

子类的对象。例如，考虑如下的方法：

public static void Display (Asset asset)

{ System.Console.WriteLine (asset.Name);

}

这个方法可以用来显示 Stock

和 House

的实例，因为这两个类都继承自 Asset

：

Stock msft  = new Stock ... ;

House mansion = new House ... ;

Display (msft);Display (mansion);

多态之所以能够实现，是因为子类（Stock

和 House

）具有基类（Asset

）的全部特征，反过来则不正确。如果 Display

转而接受 House

对象，则不能把 Asset

对象传递给它。

static void Main() { Display (new Asset()); }  // Compile-time error

public static void Display (House house)     // Will not accept As

s

et{ System.Console.WriteLine (house.Mortgage);}

3.2.2　类型转换和引用转换

对象引用可以：

隐式向上转换为基类的引用。

显式向下转换为子类的引用。

各个兼容类型的引用之间向上或向下类型转换仅执行引用转换：（逻辑上）生成一个新的引用指向同一个对象。向上转换总是能够成功，而向下转换只有在对象的类型符合要求时才能成功。

向上类型转换

向上类型转换即从一个子类引用创建一个基类的引用。例如：

Stock msft = new Stock();Asset a = msft;       // Upcast

向上转换之后，变量 a

仍然是 msft

指向的 Stock

对象。被引用的对象本身不会被替换或者改变：

Console.WriteLine (a == msft);    // True

虽然 a

与 msft

均引用同一对象，但 a

在该对象上的视图更加严格：

Console.WriteLine (a.Name);      // OK

Console.WriteLine (a.SharesOwned);  // Co

mpile-time error

上例中的最后一行会产生一个编译时错误，因为虽然变量 a

实际引用了 Stock

类型的对象，但它的（声明）类型仍为 Asset

。因而若要访问 SharesOwned

字段，必须将 Asset

向下转换为 Stock

。

向下类型转换

向下转换则是从基类引用创建一个子类引用。例如：

Stock msft = new Stock();Asset a = msft;           // UpcastStock s = (Stock)a;         // Downcast

Console.WriteLine (s.SharesOwned);  // <No error>Console.WriteLine (s == a);     // TrueConsole.WriteLine (s == msft);    // True

向上转换仅仅影响引用，而不会影响被引用的对象。而向下转换必须是显式转换，因为它有可能导致运行时错误：

House h = new House();Asset a = h;        // Upcast always succeedsStock s = (Stock)a;    // Downcast fails: a

is not a Stock

如果向下转换失败，会抛出 InvalidCastException

。这是一个运行时类型检查的例子（后面还会在 3.3.2 节详细介绍这个概念）。

as

运算符

as

运算符在向下类型转换出错时返回 null

（而不是抛出异常）：

Asset a = new Asset();

Stock s = a as Stock;

// s is null; no exception thrown

这个操作相当有用，接下来只需判断结果是否为 null

。

if (s != null)

Console.WriteLine (s.SharesOwned);

如果不用判断结果是否为 null

，那么更推荐使用类型转换。因为如果发生错误，类型转换会抛出描述更清晰的异常。我们可以通过比较下面两行代码看出：

int shares = ((Stock)a).SharesOwned;  // Approach #1

int shares = (a as Stock).SharesOwned; // Approach #2

如果 a

不是 Stock

类型，则第一行代码会抛出 InvalidCastException

，很清晰地描述了错误。而第二行代码会抛出 NullReferenceException

，这就比较模糊。因为不容易区分 a

不是 Stock

类型和 a

是 null

这两种不同的情况。

从另一个角度看，使用类型转换运算符即告诉编译器：「我确定这个值的类型，如果判断错误，那说明代码有缺陷，请抛出一个异常！」而如果使用 as

运算符，则表示不确定其类型，需要根据运行时输出结果来确定执行的分支。

as

运算符不能执行自定义转换（请参见 4.16 节），也不能用于数值的转换：

long x = 3 as long;  // Compile-time error

as

和类型转换运算符也可以用来实现向上类型转换，但是不常用。因为隐式转换就已经足够了。

is 运算符

is

运算符用于检测变量是否满足特定的模式。C# 支持若干模式，其中最重要的模式是类型模式。在这种模式下，is

运算符后跟类型的名称。

在类型模式上下文下，is

运算符检查引用的转换是否能够成功，即对象是否从某个特定的类派生（或是实现某个接口）。该运算符常在向下类型转换前使用：

if (a is Stock

)



Console.WriteLine (((Stock)a).SharesOwned);

如果拆箱转换（unboxing conversion）成功执行，则 is

运算符会返回 true

（参见 3.3 节），但它不能用于自定义类型转换和数值转换。

除类型模式外，is

运算符还支持 C# 7 和 C# 8 引入的多种其他模式（虽然这些模式不如类型模式这么为人熟知）。完整的介绍请参见 4.12 节。

引入模式变量

在使用 is

运算符时可以引入一个变量：

if (a is Stock s

)



Console.WriteLine (s.SharesOwned);

上述代码等价于：

Stock s;

if (a is

Stock){ s = (S

tock) a; Consol

e.WriteLine (s.S

ha

resOwned);}

引入的变量可以「立即」使用，因此以下代码是合法的：

if (a is Stock s

&& s.

SharesOwned > 100000)

Console.WriteLine (

"Wealthy");

同时，引入的变量即使在 is

表达式之外仍然在作用域内。例如：

if (a is Stock s && s.SharesOwned > 100000) Console.WriteLine ("Wealthy");Else s = new Stock();  // s is in scope

Console.WriteLine (s.SharesOwned); // Still in scope

3.2.3　虚函数成员

子类可以重写标识为 virtual

的函数以提供特定的实现。方法、属性、索引器和事件都可以声明为 virtual

：

public class Asset{ public string Name; public virtual

decimal Liability => 0;  // Expression-bodied property

}

Liability => 0

是 {get { return 0;} }

的简写。更多关于该语法的介绍请参见 3.1.8 节。

子类通过应用 override

修饰符重写虚方法：

public class Stock : Asset{ public long SharesOwned;}public class House : Asset{ public decimal Mortgage; public override

decimal Liability => Mortgage;

}

默认的情况下，Asset

类型的 Liability

属性为 0

，Stock

类不用限定这一行为，而 House

类则令 Liability

属性返回 Mortgage

的值。

House mansion = new House { Name="McMansion", Mortgage=250000 };

Asset a = mansion;Console.WriteLine (mansion.Liability); // 250000Console.WriteLine (a.Liability);    // 250000

虚方法和重写的方法的签名、返回值以及可访问性必须完全一致。重写方法可以通过 base

关键字调用其基类的实现（将在 3.2.7 节介绍）。

从构造器调用虚方法有潜在的危险性，因为编写子类的人在重写方法的时候未必知道现在正在操作一个未完全实例化的对象。换言之，重写的方法很可能最终会访问到一些方法或属性，而这些方法或属性依赖的字段还未被构造器初始化。

3.2.4　抽象类和抽象成员

声明为抽象（abstract）的类不能实例化，只有抽象类的具体实现子类才能实例化。

抽象类中可以定义抽象成员，抽象成员和虚成员相似，只不过抽象成员不提供默认的实现。除非子类也声明为抽象类，否则其实现必须由子类提供：

public abstract

class Asset{ // Note empty implementation public abstract

decimal NetValue { get; }}public class Stock : Asset{ public long SharesOwned; public decimal CurrentPrice; // Override like a virtual method. public override

decimal NetValue => CurrentPrice * SharesOwned;

}

3.2.5　隐藏继承成员

基类和子类可能定义相同的成员，例如：

public class A   { public int Counter = 1; }

public class B : A { public int Counter = 2; }

类 B

中的 Counter

字段隐藏了类 A

中的 Counter

字段。通常，这种情况是在定义了子类成员之后又意外地将其添加到了基类中而造成的。因此，编译器会产生一个警告，并采用下面的方法避免这种二义性：

A

的引用（在编译时）绑定到 A.Counter

。

B

的引用（在编译时）绑定到 B.Counter

。

有时需要故意隐藏一个成员。此时可以在子类的成员中使用 new

修饰符。new

修饰符仅用于阻止编译器发出警告，写法如下：

public class A   { public   int Counter = 1; }public class B : A { public new

int Counter = 2; }

new

修饰符可以明确将你的意图告知编译器和其他开发者：重复的成员是有意义的。

C# 在不同上下文中的 new

关键字拥有完全不同的含义。特别注意 new

运算符和 new

修饰符是不同的。

new

和重写

请观察以下的类层次：

public class BaseClass{ public virtual void Foo() { Console.WriteLine ("BaseClass.Foo"); }}public class Overrider : BaseClass{ public override

void Foo() { Console.WriteLine ("Overrider.Foo"); }}public class Hider : BaseClass{ public new

void Foo()   { Console.WriteLine ("Hider.Foo"); }

}

以下代码展示了 Overrider

和 Hider

的不同行为：

Overrider over = new Overrider();BaseClass b1 = over;over.Foo();             // Overrider.Foob1.Foo();              // Overrider.FooHider h = new Hider();BaseClass b2 = h;h.Foo();              // Hider.Foob2.Foo();             // BaseClass.Foo

3.2.6　密封函数和类

重写的函数成员可以使用 sealed

关键字密封其实现，防止其他的子类再次重写。在前面的虚函数成员示例中，我们可以密封 House

类的 Liability

实现，防止继承了 House

的子类重写 Liability

属性：

public sealed

override decimal Liability { get { return Mortgage; } }

也可以在类上使用 sealed

修饰符来密封整个类，这会隐式地密封类中所有的虚函数。密封类比密封函数成员更常见。

虽然密封可以防止重写，但是它却无法阻止成员被隐藏。

3.2.7　base

关键字

base

关键字和 this

关键字很相似。它有两个重要目的：

从子类访问重写的基类函数成员。

调用基类的构造器（见下节）。

下例中，House

类用关键字 base

访问 Asset

类对 Liability

的实现：

public class House : Asset{ ... public override decimal Liability => base.

Liability + Mortgage;

}

使用 base

关键字将以非虚的方式访问 Asset

的 Liability

属性。这意味着不管实例的运行时类型如何，都将访问 Asset

类的相应属性。

如果 Liability

是隐藏属性而非重写的属性，该方法也同样有效（也可以在调用相应函数前，将其转换为基类来访问隐藏的成员）。

3.2.8　构造器和继承

子类必须声明自己的构造器。派生类可以访问基类的构造器，但是并非自动继承。例如，如果定义了如下的 Baseclass

和 Subclass

：

public class Baseclass

{ public int X; public Baseclass ()

{

} public Baseclass (in

t

x) { this.X = x;

}}public class Subclass

:

Baseclass { }

则下面的语句是非法的：

Subclass s = new Subclass (123);

Subclass

必须重新定义它希望对外公开的任何构造器。不过，它可以使用 base

关键字调用基类的任何一个构造器：

public class Subclass : Baseclass{ public Subclass (int x) : base (x)

{ }

}

base

关键字和 this

关键字很像，但 base

关键字调用的是基类的构造器。

基类的构造器总是先执行，这保证了基类的初始化发生在子类特定的初始化之前。

隐式调用基类的无参数构造器

如果子类的构造器省略 base

关键字，那么基类的无参数构造器将被隐式调用：

public class BaseClass

{ public int X; public BaseClass() {

X

= 1; }}public class Subclass

:

BaseClass{ public Subclass() {

Co

nsole.WriteLine

(X); } // 1}

如果基类没有可访问的无参数构造器，子类的构造器中就必须使用 base

关键字。

构造器和字段初始化的顺序

当对象实例化时，初始化按照以下的顺序进行：

1. 从子类到基类

a. 初始化字段

b. 计算被调用的基类构造器中的参数

2. 从基类到子类

a. 构造器方法体的执行

以下代码演示了构造器的字段初始化顺序：

public class B{ int x = 1;     // Executes 3rd public B (int x) {  ...       // Executes 4th }}public class D : B{ int y = 1;     // Executes 1st public D (int x)  : base (x + 1

)  // Executes 2nd

{   ...

//

Executes 5th }}

3.2.9　重载和解析

继承对方法的重载有着特殊的影响。请考虑以下两个重载：

static void Foo (Asset a) { }

static void Foo (House h) { }

当重载被调用时，类型最明确的优先匹配：

House h = new House (...);

Foo(h);

// Calls Foo(House)

具体调用哪个重载是在编译器静态决定的而非运行时决定。下面的代码调用 Foo (Asset)

，尽管 a

在运行时是 House

类型的：

Asset a = new House (...);

Foo(a);

// Calls Foo(Asset)

如果把 Asset

类转换为 dynamic

（见第 4 章），则会在运行时决定调用哪个重载。这样就会基于对象的实际类型进行选择：

Asset a = new House (...);

Foo ((dynamic)a);  // Cal

ls Foo(House)

3.3　object

类型

object

类型（System.Object

）是所有类型的最终基类。任何类型都可以向上转换为 object

类型。

为了说明这个类型的重要性，首先介绍通用栈。栈是一种遵循 LIFO（Last-In First-Out，后进先出）的数据结构。栈有两种操作：将对象压入（push）栈，以及将对象从栈中弹出（pop）。以下是一个可以容纳 10 个对象的栈的简单实现：

public class Stack{ int position; object

[] data = new object[10]; public void Push (object

obj)  { data[position++] = obj; } public object

Pop()       { return data[--position]; }

}

由于 Stack

类操作的对象是 object

，所以可以实现 Push

或 Pop

任意类型实例的操作：

Stack stack = new Stack();

stack.Push ("sausage");string s = (string) stack.

Pop();  // Downcast, so

explicit cast is neededConsole.WriteLine (s);

// sausage

object

是引用类型，承载了类的优点。尽管如此，int

等值类型也可以和 object

类型相互转换并加入栈中。C# 这种特性称为类型一致化。以下是一个例子：

stack.Push (3);

int three = (in

t) stack.Pop();

当值类型和 object

类型相互转换时，公共语言运行时（CLR）必须进行一些特定的工作来对接值类型和引用类型在语义上的差异。这个过程称为装箱（boxing）和拆箱（unboxing）。

3.9 节将会介绍如何改进 Stack

类，使之能更好地处理同类型元素。

3.3.1　装箱和拆箱

装箱是将值类型实例转换为引用类型实例的行为。引用类型可以是 object

类或接口（本章后面将介绍接口）。本例中，我们将 int

类型装箱成一个 object

对象：

int x = 9;

object obj

= x;      // Box the int

拆箱操作刚好相反，它把 object

类型转换成原始的值类型：

int y = (int)obj;     // Unbox the int

拆箱需要显式类型转换。运行时将检查提供的值类型和真正的对象类型是否匹配，并在检查出错的时候抛出 InvalidCastException

。例如，下面的例子将抛出异常，因为 long

类型和 int

类型并不匹配：

object obj = 9;      // 9 is inferred to be of type int

long x = (long) obj;   // InvalidCastException

下面的语句是正确的：

object obj = 9;

long x = (int)

obj;

以下的语句也是正确的：

object obj = 3.5;       // 3.5 is inferred to be of type double

int x = (int) (double) obj;  // x is now 3

在上例子中，(double)

是拆箱操作而 (int)

是数值转换操作。

装箱转换对系统提供一致性的数据类型至关重要。但这个体系并不是完美的：在 3.9 节中会介绍数组和泛型的变量只能支持引用转换，不能支持装箱转换：

object[] a1 = new string

[3];  // Legalobject[] a2 = new int

[3];   // Error

装箱拆箱中的复制语义

装箱是把值类型的实例复制到新对象中，而拆箱是把对象的内容复制回值类型的实例中。下面的示例修改了 i

的值，但并不会改变它先前装箱时复制的值：

int i = 3;

object box

ed = i;i = 5;Console.Wr

iteLine (boxed);

// 3

3.3.2　静态和运行时类型检查

C# 程序在静态（编译时）和运行时（CLR）都会执行类型检查。

静态类型检查使编译器能够在程序没有运行的情况下检查程序的正确性。例如，因为编译器会强制进行静态类型检查，因而以下代码会出错：

int x = "5";

在使用引用类型转换或者拆箱操作进行向下类型转换时，CLR 会执行运行时类型检查。例如：

object y = "5";

int z = (int) y

;     // Runtime error, downcast failed

运行时可以进行类型检查是因为堆上的每一个对象都在内部存储了类型标识，这个标识可以通过调用 object

类的 GetType

方法得到。

3.3.3　GetType

方法和 typeof

运算符

C# 中的所有类型在运行时都会表示为 System.Type

类的实例。有两个基本方法可以获得 System.Type

对象：

在类型实例上调用 GetType

方法。

在类型名称上使用 typeof

运算符。

GetType

在运行时计算，而 typeof

在编译时静态计算（如果是用泛型类型参数，那么它将由即时编译器解析）。

System.Type

拥有诸多属性，例如类型的名称、程序集、基类型等属性。例如：

using System;

public class

P

oint { public int X, Y; }class Test{ static void



Main() {  Point p =



new Point();  Console.W

r

iteLine (p.GetType().Name);

/

/ Point  Console.W

r

iteLine (typeof (Point).Name);

/

/ Point  Console.W

r

iteLine (p.GetType() == typeof(Point));

/

/ True  Console.W

r

iteLine (p.X.GetType().Name);

/

/ Int32  Console.W

r

iteLine (p.Y.GetType().FullName);

/

/ System.In

t3

2 }}

System.Type

同时还是运行时反射模型的访问入口。我们将在第 19 章介绍该内容。

3.3.4　ToString

方法

ToString

方法返回类型实例的默认文本描述。所有内置类型都重写了该方法。下面是对 int

类使用 ToString

方法的示例：

int x = 1;

string s =

x.ToString();   // s is "1"

可以用下面的方式在自定义的类中重写 ToString

方法：

public class Panda

{ public string Na

me

; public override

st

ring ToString() => Nam

e;}...Panda p = new Pand

a

{ Name = "Petey" };Console.WriteLine

(p

);  // Petey

如果不重写 ToString

方法，那么它会返回类型的名称。

当直接在值类型对象上调用 ToString

这样的 object

成员时，若该成员是重写的，则不会发生装箱。只有进行类型转换时才会执行装箱操作：

int x = 1;

string s1

= x.ToString();  // Calling on nonboxed valueobject box

= x;string s2

= box.ToString(); // Calling on boxed value

3.3.5　object

的成员列表

以下列出了 object

的所有成员：

public class Object

{ public Object(); public extern Typ

e

GetType(); public virtual bo

ol

Equals (object obj

)

; public static boo

l

Equals (object obj

A

, object objB); public static boo

l

ReferenceEquals (ob

j

ect objA, object objB); public virtual in

t

GetHashCode(); public virtual st

ri

ng ToString(); protected virtual

v

oid Finalize(); protected extern

ob

ject MemberwiseClon

e

();}

6.11 节将介绍 Equals

、ReferenceEquals

和 GetHashCode

方法。

3.4　结构体

结构体和类相似，不同之处在于：

结构体是值类型，而类是引用类型。

结构体不支持继承（除了隐式派生自 object

类型，或更精确地说，是派生自 System.ValueType

）。

除了以下内容，结构体可以包含类的所有成员：

无参数的构造器

字段初始化器

终结器

虚成员或 protected

成员

当表示一个值类型语义时，使用结构体更加理想。数值类型就是一个很好的例子。对于数值来说，在赋值时对值进行复制而不是对引用进行复制是很自然的。由于结构体是值类型，因此其实例不需要在堆上实例化，创建一个类型的多个实例就更加高效了。例如，创建一个值类型的数组只需要进行一次堆空间的分配。

结构体是值类型，因而其实例不能为 null

。结构体对象的默认值是一个空值实例，即其所有的字段均为空值（均为其默认值）。

3.4.1　结构体的构造语义

结构体的构造语义如下：

结构体隐式包含一个无法重写的无参数构造器，将字段按位置取 0（即将其设置为默认值）。

定义结构体的构造器时，必须显式为每一个字段赋值。

需要指出的是结构体不支持字段初始化器。以下是一个声明并调用结构体构造器的示例：

public struct Point

{ int x, y; public Point (int

x

, int y) { t

his.x = x; this.y = y; }}...Point p1 = new Poin

t

();    //

p1.x and p1.y will be 0Point p2 = new Poin

t

(1, 1);  //

p2.x and p2.y will be 1

在构造结构体时使用 default

关键字的效果和调用隐式的无参数构造器的效果是一样的：

Point p1 = default;

上述方式也可以简化调用某些方法的形式：

void Foo (Point p) { ... }...Foo (default

);  // Equivalent to Foo (new Point());

以下示例包含三个编译时错误：

public struct Point

{ int x = 1;



// Illegal: field initializer int y; public Point() {}



// Illegal: parameterless constructor public Point (int

x

) {this.x = x;} // Illegal: must assign field y}

如果把 struct

替换为 class

，则以上写法都合法。

3.4.2　只读结构体与只读函数

从 C# 7.2 开始，我们可以在结构体上应用 readonly

修饰符来确保所有的字段都是 readonly

的。这不但可以帮助我们表达只读的本意还能给予编译器更多的优化空间：

readonly

struct Point

{ public read

on

ly int X, Y;  // X and Y must be readonly}

如果需要更细粒度地应用 readonly

的特性，可以利用 C# 8 提供的新功能，即将 readonly

修饰符应用在结构体的函数中。这确保了如果该函数试图更改任何字段的值都会产生一个编译期错误：

struct Point{ public int X, Y; public readonly

void ResetX() => X = 0; // Error!

}

如果 readonly

函数调用非 readonly

函数，则编译器会生成一个警告（并同时保护性地创建一个结构体对象的副本以避免潜在的更改字段的风险）。

3.4.3　ref

结构体

ref

结构体是在 C# 7.2 中适时引进的功能。该功能的引入主要是为第 24 章介绍的 Span<T>

和 ReadOnlySpan<T>

提供支持（除此之外还有第 11 章中介绍的高度优化的 Utf8JsonReader

）。这些结构体可以通过一些微小的优化来降低内存分配。

和引用类型不同（引用类型实例是分配在堆上的），值类型对象是存储在声明处的（即变量在哪里声明就存储在哪里）。如果值类型声明为参数或者局部变量，则该对象会存储在栈上：

struct

Point { public int X, Y; }

...void SomeMethod(){ Point p;  // p will resi

de o

n the stack}

但是如果值类型声明为类中的字段，则它将存储在堆上：

class MyClass

{ Point p;

//

Lives on heap, because MyClass instances live on the heap}

类似地，结构体数组是存储在堆上的，同样，装箱的结构体也会转存在堆上。

从 C# 7.2 开始，结构体在声明时支持 ref

修饰符，它确保该结构体只可能存储在栈上。任何可能令 ref

结构体存储在堆上的做法都会产生编译期错误：

ref

struct Point { public int X, Y; }class MyClass  { Point P;

}  // Error: will not compile!

...var points = new Point [100];

// E

rror: will not compile!

ref

结构体的引入主要是为了支持 Span<T>

和 ReadOnlySpan<T>

这两个结构体。由于 Span<T>

和 ReadOnlySpan<T>

实例只能够存储在栈上，因此它们能够安全地包装栈上分配的内存。

ref

结构体无法和任何可能直接或者间接导致堆存储的功能结合使用。包括将在第 4 章中介绍的一些高级 C# 特性，例如 Lambda 表达式、迭代器、异步函数（因为这些特性会创建对外不可见的包含字段的类）。此外，ref

结构体也不能出现在非 ref

结构体中，并且它们也无法实现任何接口（因为这可能会导致装箱操作）。

3.5　访问权限修饰符

为了提高封装性，类型或类型成员可以在声明中添加以下六个访问权限修饰符之一来限定其他类型和其他程序集对它的访问。

public

：完全访问权限。枚举类型成员或接口成员隐含的可访问性。

internal

：仅可以在程序集内访问，或供友元程序集访问。这是非嵌套类型的默认可访问性。

private

：仅可以在包含类型中访问。这是类或者结构体成员的默认可访问性。

protected

：仅可以在包含类型或子类中访问。

protected internal

：protected

和 internal

可访问性的并集。protected internal

修饰的成员在任意一种修饰符限定下都能够访问。

private protected

：从 C# 7.2 开始支持，protected

和 internal

可访问性的交集。若一个成员是 private protected

的，那么该成员只能够在其类型中或被其相同程序集中的子类型访问（它的可访问性比 protected

和 internal

都低）。

3.5.1　示例

Class2

可以从本程序集外访问，而 Class1

不可以：

class Class1 {}         // Class1 is internal (default)public

class Class2 {}

ClassB

的字段 x

可以被本程序集的其他类型访问，而 ClassA

的则不可以：

class ClassA { int x;     } // x is private (default)class ClassB { internal

int x; }

Subclass

Bar

Foo

class BaseClass{ void Foo()      {}    // Foo is private (default) protected

void Bar() {}

}class Subclass

:



BaseClass{ void Test1()

{



Foo(); }    // Error - c

an

not access Foo void Test2()

{



Bar(); }    // OK}

3.5.2　友元程序集

在一些高级的场景中，添加 System.Runtime.CompilerServices.InternalsVisibleTo

程序集特性就可以将 internal

成员提供给其他的友元程序集访问。可以用如下方法指定友元程序集：

[assembly: InternalsVisibleTo ("Friend")]

如果友元程序集有强名称（见第 18 章），必须指定其完整的 160 字节公钥：

[assembly: InternalsVisibleTo ("StrongFriend, PublicKey=0024f000048c...")]

可以使用 LINQ 查询的方式从强命名的程序集中提取完整的公钥值（关于 LINQ 的介绍请参见第 8 章）：

string key = string.Join ("",

Assembly.GetExecutingAssemb

ly().GetName().GetPublicKey()  .Select (b => b.ToString

("x2")));

LINQPad 中有一个例子和本例类似。它可以选择指定程序集，而后将其完整公钥复制到剪贴板上。

3.5.3　可访问性上限

类型的可访问性是它内部声明成员可访问性的上限。关于可访问性上限，最常用的示例是 internal

类型中的 public

成员。例如：

class C { public void Foo() {} }

C

的（默认）可访问性是 internal

，它作为 Foo

的最高访问权限，使 Foo

成为 internal

的。而将 Foo

指定为 public

一般是为了将来将 C

的权限改成 public

时方便重构。

3.5.4　访问权限修饰符的限制

当重写基类的函数时，重写函数的可访问性必须一致。例如：

class BaseClass       { protected virtual void Foo() {} }class Subclass1 : BaseClass { protected override void Foo() {} } // OKclass Subclass2 : BaseClass { public

override void Foo() {} } // Error

若在另外一个程序集中重写 protected internal

方法，则重写方法必须为 protected

。这是上述规则中的一个例外情况。

编译器会阻止任何不一致的访问权限修饰符。例如，子类可以比基类的访问权限低，但不能比基类的访问权限高：

internal class A {}

public class B : A

{}     // Error

3.6　接口

接口和类相似，但接口只提供行为定义而不会持有任何状态（数据），因此：

接口只能定义函数而不能定义字段。

接口的成员都是隐式抽象的（虽然 C# 8 支持在接口中声明非抽象函数，但这应当视为一种特殊情况。我们将在 3.6.6 节中详细介绍该特性）。

一个类（或者结构体）可以实现多个接口。而一个类只能够继承一个类，结构体则完全不支持继承（只能从 System.ValueType

派生）。

接口声明和类声明很相似。但接口不提供成员的实现，因为它的所有成员都是隐式抽象的。这些成员将由实现接口的类或结构体实现。接口只能包含函数：即方法、属性、事件、索引器（而这些正是类中可以定义为抽象的成员类型）。

以下是 System.Collections

命名空间下的 IEnumerator

接口的定义：

public interface

IEnumerator

{ bool MoveN

ex

t(); object Cur

re

nt { get; } void Reset

()

;}

接口成员总是隐式 public

的，并且不能用访问权限修饰符声明。实现接口意味着它将为所有的成员提供 public

实现：

internal class Countdown : IEnumerator

{ int count = 11; public bool MoveNext() => count-- >

0;

public object Current => count; public void Reset() { throw new NotS

up

portedException();

}}

可以把对象隐式转换为它实现的任意一个接口：

IEnumerator e = new Countdown();

while (e.MoveNext()) Console.Write (e.Current);

// 109876543210

尽管 CountDown

是 internal

权限的类，通过把 CountDown

实例转换为 IEnumerator

，其内部实现 IEnumerator

接口的成员就可以作为 public

成员访问。例如，如果同程序集中的一个公有类型定义了如下的方法：

public static class Util

{ public static object G

et

CountDown() => new CountDown();}

另一个程序集的调用者可以执行：

IEnumerator e = (IEnumerator) Util.GetCountDown();

e.MoveNext();

如果 IEnumerator

定义为 internal

，那么以上方法就不能使用了。

3.6.1　扩展接口

接口可以从其他接口派生，例如：

public interface IUndoable       { void Undo(); }

public interface IRedoable : IUndoable { void Redo(); }

IRedoable

「继承」了 IUndoable

接口的所有成员。换言之，实现 IRedoable

的类型也必须实现 IUndoable

的成员。

3.6.2　显式接口实现

当实现多个接口时，有时会出现成员签名的冲突。显式实现（explicitly implementing）接口成员可以解决冲突。请看下面的例子：

interface I1 { void Foo(); }interface I2 { int Foo(); }public class Widget : I1, I2{ public void Foo() {  Console.WriteLine ("Widget's implementation of I1.Foo"); } int I2.Foo

()



{

Co

nsole.WriteLine ("Widget's implementation of I2.Foo");

re

turn 42;

}}

I1

和 I2

都有相同签名的 Foo

成员。Widget

显式实现了 I2

的 Foo

方法，使得同一个类中同时存在两个同名的方法。调用显式实现成员的唯一方式是先将其转换为对应的接口：

Widget w = new Widget();

w.Foo();

// Widget's implementation of I1.Foo((I1)w).Foo();

// Widget's implementation of I1.Foo((I2)w).Foo();

// Widget's implementation of I2.Foo

另一个使用显式实现接口成员的原因是隐藏那些高度定制化的或对类的正常使用干扰很大的接口成员。例如，实现了 ISerializable

接口的类通常会选择隐藏 ISerializable

成员，除非显式转换成这个接口。

3.6.3　实现接口的虚成员

默认情况下，隐式实现的接口成员是密封的。为了重写，必须在基类中将其标识为 virtual

或者 abstract

：

public interface IUndoable { void Undo(); }public class TextBox : IUndoable{ public virtual

void Undo() => Console.WriteLine ("TextBox.Undo");}public class RichTextBox : TextBox{ public override

void Undo() => Console.WriteLine ("RichTextBox.Undo");

}

不管从基类还是接口中调用接口成员，调用的都是子类的实现：

RichTextBox r = new RichTextBox();

r.Undo();

// RichTextBox.Undo((IUndoable)r).Undo();

// RichTextBox.Undo((TextBox)r).Undo();

// RichTextBox.Undo

显式实现的接口成员不能标识为 virtual

，也不能实现通常意义的重写，但是它可以被重新实现。

3.6.4　在子类中重新实现接口

子类可以重新实现基类实现的任意一个接口成员。不管基类中该成员是否为 virtual

，当通过接口调用时，重新实现都能够劫持成员的实现。它对接口成员的隐式和显式实现都有效，但后者效果更好。

下面的例子中，TextBox

显式实现 IUndoable.Undo

，所以不能标识为 virtual

。为了重写，RichTextBox

必须重新实现 IUndoable

的 Undo

方法：

public interface IUndoable { void Undo(); }public class TextBox : IUndoable{ void IUndoable.Undo() => Console.WriteLine ("TextBox.Undo");}public class RichTextBox : TextBox, IUndoable

{

public void Undo() => Console.WriteLine ("RichTextBox.Undo");}

从接口调用重新实现的成员时，调用的是子类的实现：

RichTextBox r = new RichTextBox();

r.Undo();         // RichT

extBox.Undo   Case 1((IUndoable)r).Undo();  // RichT

extBox.Undo   Case 2

假定 RichTextBox

定义不变，如果 TextBox

隐式实现 Undo：

public class TextBox : IUndoable

{ public void Undo() => Console.

Wr

iteLine ("TextBox.Undo");}

那么就有了另外一种调用 Undo

的方法，如下面的「Case 3」所示，它将「切断」整个系统：

RichTextBox r = new RichTextBox();r.Undo();         // RichTextBox.Undo   Case 1((IUndoable)r).Undo();  // RichTextBox.Undo   Case 2((TextBox)r).Undo();   // TextBox.Undo

Case 3

从「Case 3」可以看到，通过重新实现来劫持调用的方式仅在通过接口调用成员时有效，而从基类调用时无效。这个特性通常不尽人意，因为它们的语义是不一致的。因此，重新实现主要适合于重写显式实现的接口成员。

接口重新实现的替代方案

即使是显式实现的成员，接口重新实现还是容易出问题，因为：

子类无法调用基类的方法。

基类的作者在定义基类时也许并不期望重新实现其中的方法，或无法接受重新实现后带来的潜在问题。

重新实现是在子类不期望被重写时的最后选择。而更好的选择是在定义基类时无须令子类使用重新实现的方式就能够完成重写，有两种方法可以做到这一点：

当隐式实现成员时，尽可能将其标记为 virtual

。

当显式实现成员时，如果能够预测子类可能要重写某些逻辑，则使用下面的模式：

public class TextBox : IUndoable

{ void IUndoable.Undo()

=>

Undo();  // Calls method below protected virtual void Undo()

=>

Console.WriteLine ("TextBox.Undo");}public class RichTextBox : TextB

ox

{ protected override void Undo()

=

> Console.WriteLine("RichTextBox.Undo");}

如果不希望添加任何的子类，则可以把类标记为 sealed

以制止接口的重新实现。

3.6.5　接口和装箱

将结构体转换为接口会引发装箱。而调用结构体的隐式实现接口成员不会引发装箱：

interface I { void Foo();     }

struct S : I { public void Foo() {} }

...S s = new S();s.Foo();     // No boxing.I i = s;     // Box occurs when c

asting to interface.i.Foo();

3.6.6　默认接口成员（C# 8）

从 C# 8 开始，可以在接口成员中添加默认实现，而该成员不必必须进行实现：

interface ILogger{ void Log (string text) => Console.WriteLine (text);

}

若要在一个广为人知的程序库中为接口添加一个成员以避免破坏现有的成千上万的实现时，这个特性就显得尤为重要了。

默认实现永远是显式的。因而假设一个类实现了 ILogger

接口但并未定义 Log

方法，那么要调用 Log

方法，必须通过接口来进行：

class Logger : ILogger { }...((ILogger)

new Logger()).Log ("message");

这避免了接口实现的多继承问题：如果两个接口中添加了相同的默认成员，那么在决定应该调用哪一个成员的时候是不会存在二义性问题的。

除此之外，接口中还能定义静态成员（包括静态字段）。接口的默认实现可以访问这些静态成员：

interface ILogger{ void Log (string text) =>  Console.WriteLine (Prefix

+ text); static string Prefix

= "";

}

由于接口成员是隐式 public

成员，因此在外部访问其静态成员也是可行的：

ILogger.Prefix

= "File log: ";

如需限制这一行为，可在接口的静态成员上添加访问权限修饰符（例如 private

、protected

和 internal

）。

使用类与使用接口的对比

若类型间能够自然地共享实现，使用类和子类。

若各个实现是独立的，则定义接口。

以上述标准为指导原则，观察下面的类：

abstract class Animal {}

abstract class Bird

: Animal {}abstract class Insect

: Animal {}abstract class FlyingCre

ature : Animal {}abstract class Carnivore

: Animal {}// Concrete classes:class Ostrich : Bird {}class Eagle  : Bird, Fl

yingCreature, Carnivore {} // Illegalclass Bee   : Insect,

FlyingCreature {}      // Illegalclass Flea  : Insect,

Carnivore {}        // Illegal

Eagle

、Bee

和 Flea

类是无法编译的，因为继承多个类是非法的。为了解决这个问题，需要将其中的某些类型转换为接口。问题是转换哪个类型呢？遵照一般原则，我们看出所有的昆虫和飞鸟类共享实现，所以 Insect

和 Bird

仍然使用类的形式。而「能飞的生物」的「飞」是独立的机制；「食肉动物」的「食肉」是独立的机制，所以将 FlyingCreature

和 Carnivore

转换为接口：

interface IFlyingCreature {}

interface ICarnivore   {}

在特定的语义中，Bird

和 Insect

可以对应 Windows

控件和 Web

控件；而 Flying-Creature

和 Carnivore

对应 IPrintable

和 IUndoable

。

在接口中声明实例字段仍然是非法的。这和接口的原则 — 接口用于定义行为而非持有状态 — 是一致的。

3.7　枚举类型

枚举类型是一种特殊的值类型。我们能够在该类型中定义一组命名的数值常量。例如：

public enum BorderSide { Left, Right, Top, Bottom }

使用枚举类型的方法如下：

BorderSide topSide = BorderSide.Top;

bool isTop = (topSide == BorderSide.

Top);  // true

每一个枚举成员都对应一个整数。在默认情况下：

对应的数值是 int

类型的。

按照枚举成员的声明顺序，自动按照 0

、1

、2

…… 进行常量赋值。

当然，也可以指定其他的整数类型代替默认类型，例如：

public enum BorderSide : byte

{ Left, Right, Top, Bottom }

还可以显式指定每一个枚举成员对应的值：

public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }

编译器还支持显式指定部分枚举成员。没有指定的枚举成员，在最后一个显式指定的值基础上递增。因此上例等价于：

public enum BorderSide : byte

{ Left=1, Right, Top=10, Bot

tom }

3.7.1　枚举类型转换

枚举类型的实例可以与它对应的整数值相互显式转换：

int i = (int) BorderSide.Left;

BorderSide side = (BorderSide)

i;bool leftOrRight = (int) side

<= 2;

也可以显式将一个枚举类型转换为另一个。假设 HorizontalAlignment

定义为：

public enum HorizontalAlignment

{ Left = BorderSide.Left, Right = BorderSide.Right, Center}

则两个枚举类型之间的转换是通过对应的整数数值进行的：

HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;

// same as:HorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.

Right;

在枚举表达式中，编译器会特殊对待数值字面量 0

。它不需要进行显式转换：

BorderSide b = 0;  // No cast required

if (b == 0) ...

对 0

进行特殊对待的原因有两个：

第一个枚举成员经常作为默认值。

在合并枚举类型中，0

表示无标志。

3.7.2　标志枚举类型

枚举类型的成员可以合并。为了避免混淆，合并枚举类型的成员要显式指定值，典型的值为 2 的幂次。例如：

[Flags]

enum Bo

rderSides { None=0, Left=1, Right=2, Top=4, Bottom=8 }

或者

enum BorderSides { None=0, Left=1, Right=1<<1

, Top=1<<2

, Bottom=1<<3

}

可以使用位运算符合并枚举类型的值，例如 |

和 &

，它们将作用在对应的整数数值上：

BorderSides leftRight = BorderSides.Left | BorderSides.Right;

if ((leftRight & BorderSides.Left) != 0) Console.WriteLine ("Includes Left");   // Includes Leftstring formatted = leftRight.ToString();  // "Left, Right"BorderSides s = BorderSides.Left;s |= BorderSides.Right;Console.WriteLine (s == leftRight);  // Trues ^= BorderSides.Right;        // Toggles BorderSides.

R

ightConsole.WriteLine (s);        // Left

按照惯例，当枚举类型的成员可以合并时，其枚举类型一定要应用 Flags

特性。如果声明了一个没有标注 Flags

特性的枚举类型，其成员依然可以合并，但若在该枚举实例上调用 ToString

方法，则会输出一个数值而非一组名字。

一般来说，合并枚举类型通常用复数名词而不用单数形式。

为了方便起见，可以将合并的成员直接放在枚举的声明内：

[Flags]enum BorderSides{ None=0, Left=1, Right=1<<1, Top=1<<2, Bottom=1<<3, LeftRight = Left | Right,

TopBottom = Top | Bottom,

All    = LeftRight | TopBottom

}

3.7.3　枚举运算符

枚举类型可用的运算符有：

=  ==  !=  <  >  <=  >=  +  -  ^ & |  ~

+=  -=  ++ --  sizeof

位运算符、算术运算符和比较运算符都返回对应整数值的运算结果。枚举类型和整数类型之间可以做加法，但两个枚举类型之间不能做加法。

3.7.4　类型安全问题

请看下面的枚举类型：

public enum BorderSide { Left, Right, Top, Bottom }

由于枚举类型可以和它对应的整数类型相互转换，因此枚举的真实值可能超出枚举类型成员的数值范围：

BorderSide b = (BorderSide) 12345;

Console.WriteLine (b);

// 12345

位运算符和算术运算符也会产生类似的非法值：

BorderSide b = BorderSide.Bottom;

b++;

// No errors

非法的 BorderSide

的枚举值可能破坏如下的程序：

void Draw (BorderSide side)

{ if   (side == BorderSi

de

.Left) {...} else if (side == BorderSi

de

.Right) {...} else if (side == BorderSi

de

.Top)  {...} else



{...} // Assume BorderSide.Bottom}

上述问题的解决方案之一是再加上一个 else 子句：

...

els

e if (side == BorderSide.Bottom) ... els

e throw new ArgumentException ("Invalid Bo

rderSide: " + side, "side");

另一个解决方案是显式检查枚举值的合法性。可以使用静态方法 Enum.IsDefined

来执行该操作：

BorderSide side = (BorderSide) 12345;

Console.WriteLine (Enum.IsDefined (ty

peof (BorderSide), side));  // False

遗憾的是，Enum.IsDefined

对标志枚举类型不起作用，然而下面的方法（巧妙使用了 Enum.ToString ()

的行为）可以在标志枚举类型合法时返回 true

：

static bool IsFlagDefined (Enum e)

{ decimal d; return !decimal.TryParse(e.ToStr

in

g(), out d);}[Flags]public enum BorderSides { Left=1,

Ri

ght=2, Top=4,

Bottom=8 }static void Main(){ for (int i = 0; i <= 16; i++) {  BorderSides side = (BorderSide

s)

i;  Console.WriteLine (IsFlagDefin

ed

(side) + " "

+ side); }}

3.8　嵌套类型

嵌套类型是声明在另一个类型内部的类型：

public class TopLevel

{ public class Nested

{

}        // Nested class public enum Color {

R

ed, Blue, Tan } // Nested enum}

嵌套类型有如下的特征：

可以访问包含它的外层类型中的私有成员，以及外层类所能访问的所有内容。

可以在声明上使用所有的访问权限修饰符，而不限于 public

和 internal

。

嵌套类型的默认可访问性是 private

而不是 internal

。

从外层类以外访问嵌套类型，需要使用外层类名称进行限定（就像访问静态成员一样）。

例如，为了从 TopLevel

外访问 Color.Red

，必须写作：

TopLevel.Color color = TopLevel.Color.Red;

所有的类型（类、结构体、接口、委托和枚举）都可以嵌套在类和结构体之内。

以下示例在嵌套类型中访问外层私有成员：

public class TopLevel

{ static int x; class Nested {  static void Foo()

{

Console.WriteLi

ne (TopLevel.x)

; } }}

以下示例在嵌套类型上使用 protected

访问权限修饰符：

public class TopLevel

{ protected class Nes

te

d { }}public class SubTopLe

ve

l : TopLevel{ static void Foo() {

n

ew TopLevel.Nested(); }}

以下示例在外层类型外的类型中引用嵌套类型：

public class TopLevel

{ public class Nested

{

}}class Test{ TopLevel.Nested n;}

嵌套类型在编译器中得到了广泛应用，例如编译器在生成迭代器和匿名方法时就会生成包含这些结构内部状态的私有（嵌套）类。

如果使用嵌套类型的主要原因是为了避免命名空间中类型定义杂乱无章，那么可以考虑使用嵌套命名空间。使用嵌套类型的原因应当是利用它较强的访问控制能力，或者是因为嵌套的类型必须访问外层类型的私有成员。

### 3.9 泛型

C# 有两种不同的机制来编写跨类型可复用的代码：继承和泛型。但继承的复用性来自基类，而泛型的复用性是通过带有占位符的模板类型实现的。和继承相比，泛型能够提高类型的安全性，减少类型的转换和装箱。

C# 的泛型和 C++ 的模板是相似的概念，但它们的工作方法不同。我们将在 3.9.14 节讲解。

#### 3.9.1 泛型类型

泛型类型中声明的类型参数（占位符类型）需要由泛型类型的消费者（即提供类型参数的一方）来填充。下面是一个存放类型 T 实例的泛型栈类型 `Stack<T>`。`Stack<T>` 声明了单个类型参数 T：

```cs
public class Stack<T> 
{ 
int position;
T[] data = new T[100];

public void Push (T obj) => data[position++] = obj;
public T Pop() => data[--position];
}
```

`Stack<T>` 的使用方式如下：

```cs
var stack = new Stack<int>();
stack.Push (5); 
stack.Push (10); 
int x = stack.Pop(); 
int y = stack.Pop();
// x is 10 
// y is 5
```

`Stack<int>` 用类型参数 int 填充 T，这会在运行时隐式创建一个类型：`Stack<int>`。若试图将一个字符串加入 `Stack<int>` 中则会产生一个编译时错误。`Stack<int>` 具有如下的定义（为了防止混淆，类的名字将以 # 代替，替换的部分将用粗体展示）：

```cs
public class ### 
{ 
int position;
int[] data = new int[100];
public void Push (int obj) => data[position++] = obj;
public int Pop() => data[--position];
}
```

技术上，我们称 `Stack<T>` 是开放类型，称 `Stack<int`> 是封闭类型。在运行时，所有的泛型实例都是封闭的，占位符已经被类型填充。这意味着以下语句是非法的：

```cs
var stack = new Stack<T>();  // Illegal: What is T?
```

只有在类或者方法的内部，T 才可以定义为类型参数：

```cs
public class Stack<T> 
{
    ...
    public Stack<T> Clone() 
    {
        Stack<T> clone = new Stack<T>(); // Legal
        ...
    }
}
```

#### 3.9.2 为什么需要泛型

泛型是为了代码能够跨类型复用而设计的。假定我们需要一个整数栈，但是没有泛型的支持。那么解决方案之一是为每一个需要的元素类型硬编码不同版本的类（例如 IntStack、StringStack 等）。显然，这将导致大量的重复代码。另一个解决方案是写一个用 object 作为元素类型的栈：

```cs
public class ObjectStack 
{ 
    int position;
    object[] data = new object[10];
    public void Push (object obj) => data[position++] = obj; 
    public object Pop() => data[--position];
}
```

但是 ObjectStack 类不会像硬编码的 IntStack 类一样只处理整数元素。ObjectStack 需要用到装箱和向下类型转换，而这些都不能够在编译时进行检查：

```cs
// Suppose we just want to store integers here: 
ObjectStack stack = new ObjectStack();

stack.Push ("s"); int i = (int)stack.Pop();

// Wrong type, but no error! 
// Downcast - runtime error
```

我们需要的栈既需要支持各种不同类型的元素，又要有一种方法容易地将栈的元素类型限定为特定类型，以提高类型安全性，减少类型转换和装箱。泛型恰好通过参数化元素类型提供了这些功能。`Stack<T>` 同时具有 ObjectStack 和 IntStack 的全部优点。与 ObjectStack 的共同点是 `Stack<T>` 只需要书写一次就可以支持各种类型；而与 IntStack 的共同点是 `Stack<T>` 的元素是特定的某个类型。`Stack<T>` 的独特之处在于操作的类型是 T，并可以在编程时任意替换。

ObjectStack 在功能上等价于 `Stack<object>`。

#### 3.9.3 泛型方法

泛型方法在方法的签名中声明类型参数。

使用泛型方法，许多基本算法就可以用通用方式实现了。以下是交换两个任意类型 T 的变量值的泛型方法：

```cs
static void Swap<T> (ref T a, ref T b) 
{
    T temp = a;
    a = b;
    b = temp;
}
```

通常调用泛型方法不需要提供类型参数，因为编译器可以隐式推断出类型信息。如果有二义性，则可以用以下方式调用泛型方法：

```cs
Swap<int> (ref x, ref y);
```

在泛型中，只有引入类型参数（用尖括号标出）的方法才可归为泛型方法。泛型 Stack 类中的 Pop 方法仅仅使用了类型中已有的类型参数 T，因此不属于泛型方法。

唯有方法和类可以引入类型参数。属性、索引器、事件、字段、构造器、运算符等都不能声明类型参数，虽然它们可以参与使用所在类型中已经声明的类型参数。例如，在泛型的栈中可以写一个索引器返回一个泛型项：

```cs
public T this [int index] => data [index];
```

类似地，构造器可以参与使用已经存在的类型参数，但是不能引入新的类型参数：

```cs
public Stack<T>() { }  // Illegal
```

#### 3.9.4 声明类型参数

可以在声明类、结构体、接口、委托（见第 4 章）和方法时引入类型参数。其他结构（如属性）虽不能引入类型参数，但可以使用类型参数。例如，以下代码中的属性 Value 使用了类型参数 T：

```cs
public struct Nullable<T> 
{ 
    public T Value { get; } 
}
```

泛型或方法可以有多个参数：

```cs
class Dictionary<TKey, TValue> {...}
```

可以用以下方式实例化：

```cs
Dictionary<int,string> myDict = new Dictionary<int,string>();
```

或者：

```cs
var myDict = new Dictionary<int,string>();
```

只要类型参数的数量不同，泛型类型名和泛型方法的名称就可以进行重载。例如，下面的三个类型名称并不会冲突：

```cs
class A    {}

class A<T>   {}

class A<T1,T2> {}
```

习惯上，如果泛型类型和泛型方法只有一个类型参数，且参数的含义明确，那么一般将其命名为 T。当使用多个类型参数时，每一个类型参数都使用 T 作为前缀，后面跟一个更具描述性的名称。

#### 3.9.5 typeof 和未绑定泛型类型

在运行时不存在开放的泛型类型：开放泛型类型将在编译过程中封闭。但运行时可能存在未绑定的泛型类型，这种泛型类型只作为 Type 对象存在。C# 中唯一指定未绑定泛型类型的方式是使用 typeof 运算符：

```cs
class A<T> {} 
class A<T1,T2> {} 
...

// Unbound type (notice no type arguments). 
Type a1 = typeof (A<>); 
// Use commas to indicate multiple type args.
Type a2 = typeof (A<,>);
```

开放泛型类型一般与反射 API（第 19 章）一起使用。

typeof 运算符也可以用于指定封闭的类型：

```cs
Type a3 = typeof (A<int,int>);
```

或开放类型（当然，它会在运行时封闭）：

```cs
class B<T> { void X() { Type t = typeof (T); } }
```

#### 3.9.6 泛型的默认值

default 关键字可用于获取泛型类型参数的默认值。引用类型的默认值为 null，而值类型的默认值是将值类型的所有字段按位设置为 0 的值。

```cs
static void Zap<T> (T[] array) 
{
    for (int i = 0; i < array.Length; i++)
        array[i] = default(T);
}
```

从 C# 7.1 开始，我们可以在编译器能够进行类型推断的情况下忽略类型参数。因此以上程序最后一行可以写为：

```cs
array[i] = default;
```

#### 3.9.7 泛型的约束

默认情况下，类型参数可以由任何类型来替换。在类型参数上应用约束可以将类型参数定义为指定的类型参数。以下列出了可用的约束：

```cs
where T : base-class // Base-class constraint 
where T : interface // Interface constraint 
where T : class // Reference-type constraint 
where T : class? // (See "Nullable reference types") 
where T : struct // Value-type constraint (excludes Nullable types) 
where T : unmanaged // Unmanaged constraint 
where T : new() // Parameterless constructor constraint 
where U : T // Naked type constraint 
// Non-nullable value type, or from C# 8 
// a non-nullable reference type.
where T : notnull
```

在下面的例子中，`GenericClass<T, U>` 要求 T 派生自（或者本身就是）SomeClass 并且实现 Interface1；要求 U 提供无参数构造器。

```cs
class SomeClass {} 
interface Interface1 {}

class GenericClass<T,U> where T : SomeClass, Interface1 
                                        where U : new() 
{...}
```

约束可以应用在方法或者类型定义这些可以定义类型参数的地方。

基类约束要求类型参数必须是子类（或者匹配特定的类）；接口约束要求类型参数必须实现特定的接口。这些约束要求类型参数的实例可以隐式转换为相应的类或接口。例如，我们可以利用框架中定义的 `IComparable<T>` 泛型接口实现泛型的 Max 方法，该方法会返回两个值中更大的一个：

```cs
// Simplified version of interface
public interface IComparable<T>  
{ 
    int CompareTo (T other);
}
```

CompareTo 方法在 this 大于 other 的时候返回正值。以此接口为约束，我们可以将 Max 方法写为（为了避免分散注意力，省略了 null 检查）：

```cs
static T Max <T> (T a, T b) where T : IComparable<T> 
{ 
    return a.CompareTo (b) > 0 ? a : b; 
}
```

Max 方法可以接受任何实现了 `IComparable<T>` 接口的类型参数（大部分内置类型都实现了该接口，例如 int 和 string）：

```cs
int z = Max (5, 10);        // 10
string last = Max ("ant", "zoo"); // zoo
```

类约束和结构体约束规定 T 必须是引用类型或值类型（不能为空）。结构体约束的一个很好的例子是 `System.Nullable<T>` 结构体（请参见 4.7 节）：

```cs
struct Nullable<T> where T : struct {...}
```

C# 7.3 引入了非托管类型约束。该约束是一个增强型的结构体约束。其中 T 必须是一个简单的值类型或该值类型中（递归地）不包含任何引用类型字段。

无参数构造器约束要求 T 有一个 public 无参数构造器。如果定义了这个约束，就可以对类型 T 使用 new () 了：

```cs
static void Initialize<T> (T[] array) where T : new() 
{
    for (int i = 0; i < array.Length; i++)
        array[i] = new T();
}
```

裸类型约束要求一个类型参数必须从另一个类型参数中派生（或匹配）。本例中，Filtered-Stack 方法返回了另一个 Stack，返回的 Stack 仅包含原来类中的一部分元素，并且类型参数 U 是类型参数 T 的子类：

```cs
class Stack<T> 
{ 
    Stack<U> FilteredStack<U>() where U : T {...} 
}
```

#### 3.9.8 继承泛型类型

泛型类和非泛型类一样，都可以派生子类。并且在泛型类的子类中仍可以令基类中类型参数保持开放，如下所示：

```cs
class Stack<T>          {...}

class SpecialStack<T> : Stack<T> {...}
```

子类也可以用具体的类型来封闭泛型类型参数：

```cs
class IntStack : Stack<int> {...}
```

子类型还可以引入新的类型参数：

```cs
class List<T>           {...}
class KeyedList<T,TKey> : List<T> {...}
```

技术上，子类型的所有类型参数都是新的：可以说子类型封闭后又重新开放了基类的类型参数。这表明子类可以为重新打开的类型参数使用更有意义的新名称：

```cs
class List<T> {...}

class KeyedList<TElement,TKey> : List<TElement> {...}
```

#### 3.9.9 自引用泛型声明

一个类型可以使用自身类型作为具体类型来封闭类型参数：

```cs
public interface IEquatable<T> { bool Equals (T obj); }

public class Balloon : IEquatable<Balloon> 
{
    public string Color { get; set; } 
    public int CC { get; set; }
    public bool Equals (Balloon b) 
    {
        if (b == null) return false;
        return b.Color == Color && b.CC == CC; 
    }
}
```

以下写法也是合法的：

```cs
class Foo<T> where T : IComparable<T> { ... }
class Bar<T> where T : Bar<T> { ... }
```

#### 3.9.10 静态数据

静态数据对于每一个封闭的类型来说都是唯一的：

```cs
class Bob<T> { public static int Count; }

class Test 
{
    static void Main() 
    { 
        Console.WriteLine (++Bob<int>.Count); 
        Console.WriteLine (++Bob<int>.Count); 
        Console.WriteLine (++Bob<string>.Count); 
        Console.WriteLine (++Bob<object>.Count); 
    }
    // 1 // 2 // 1 // 1
}
```

#### 3.9.11 类型参数和转换

C# 的类型转换运算符可以进行多种类型转换，包括：

1、数值转换。

2、引用转换。

3、装箱和拆箱转换。

4、自定义转换（通过运算符重载，参见第 4 章）。

根据已知操作数的类型，在编译时就已经决定了类型转换的方式。但对于泛型类型参数来说，由于编译时操作数的类型还未确定，上述规则就会出现特殊的情形。如果导致了二义性，那么编译器会产生一个错误。

最常见的情形是在执行引用转换时：

```cs
StringBuilder Foo<T> (T arg) 
{
    if (arg is StringBuilder)
        return (StringBuilder) arg; // Will not compile
    ... 
}
```

由于不知道 T 的确切类型，编译器会疑惑你是否希望执行自定义转换。上述问题最简单的解决方案就是改用 as 运算符，由于它不能进行自定义类型转换，因此是没有二义性的：

```cs
StringBuilder Foo<T> (T arg) 
{ 
    StringBuilder sb = arg as StringBuilder;
    if (sb != null) return sb;
    ...
}
```

而更一般的做法是先将其转换为 object 类型。这种方法行得通，因为从 object 转换或将对象转换为 object 都不是自定义转换，而是引用或者装箱、拆箱转换。下例中，StringBuilder 是引用类型，所以一定是引用转换：

```cs
return (StringBuilder) (object) arg;
```

拆箱转换也可能导致二义性。例如，下面的代码可能是拆箱转换、数值转换或者自定义转换：

```cs
int Foo<T> (T x) => (int) x;   // Compile-time error
```

而解决方案也是先将其转换为 object，然后再将其转换为 int（很明显，这是一个非二义性的拆箱转换）：

```cs
int Foo<T> (T x) => (int) (object) x;
```

#### 3.9.12 协变

假定 A 可以转换为 B，如果 `X<A>` 可以转换为 `X<B>`，那么称 X 有一个协变类型参数。

由于 C# 有协变（covariance）和逆变（contravariance）的概念，所以「可转换」意味着可以通过隐式引用转换进行类型转换：例如，A 是 B 的子类或者 A 实现 B。而数值转换、装箱转换和自定义转换是不包含在内的。

例如，`IFoo<T>` 类型如果能满足以下条件，则 `IFoo<T>` 拥有协变参数 T：

```cs
IFoo<string> s = ...;IFoo<object> b = s;
```

接口支持协变类型参数（委托也支持协变类型参数，参见第 4 章），但是类不支持协变类型参数。数组也支持协变（如果 A 可以隐式引用转换为 B，则 A [] 也可以隐式引用转换为 B []）。接下来将对此进行一些讨论和比较。

协变和逆变（或简称可变性）都是高级概念。在 C# 中引入和强化协变的动机是允许泛型接口和泛型类型（尤其是 .NET Core 中定义的那些类型，例如 `IEnumerable<T>`）像人们期待的那样工作。即使不了解它们背后的细节，也可以从中获益。

可变性不是自动的

为了保证静态类型的安全性，泛型类型参数不是自动可变的。请看下面的例子：

```cs
class Animal {} 
class Bear : Animal {} 
class Camel : Animal {}

public class Stack<T> 
{ 
int position;
// A simple Stack implementation
T[] data = new T[100];
public void Push (T obj) => data[position++] = obj;
public T Pop() => data[--position];
}
```

下面的语句是不能通过编译的：

```cs
Stack<Bear> bears = new Stack<Bear>();   
Stack<Animal> animals = bears;      // Compile-time error
```

这种约束避免了以下代码可能产生的运行时错误：

```cs
animals.Push (new Camel());   // Trying to add Camel to bears
```

但是协变的缺失可能妨碍复用性。例如，我们希望写一个 Wash 方法操作整个 Animal 栈：

```cs
public class ZooCleaner 
{
    public static void Wash (Stack<Animal> animals) {...}
}
```

而将 Bear 栈传入 Wash 方法则会产生一个编译时错误。一种解决方案是重新定义带有约束的 Wash 方法：

```cs
class ZooCleaner
{ 
    public static void Wash<T> (Stack<T> animals) where T : Animal { ... }
}
```

这样就可以使用如下方式调用 Wash 了：

```cs
Stack<Bear> bears = new Stack<Bear>();
ZooCleaner.Wash (bears);
```

另一种解决方案是让 `Stack<T>` 实现一个拥有协变类型参数的泛型接口，后面会举例讲解。

数组 

由于历史原因，数组类型支持协变。这说明如果 B 是 A 的子类，则 B [] 可以转换为 A []（A 和 B 都是引用类型）。例如：

```cs
Bear[] bears = new Bear[3];
Animal[] animals = bears;

// OK
```

这种复用性的缺点是元素的赋值可能在运行时发生错误：

```cs
animals[0] = new Camel();   // Runtime error
```

声明协变类型参数

在接口和委托的类型参数上指定 out 修饰符可将其声明为协变参数。和数组不同，这个修饰符保证了协变类型参数完全是类型安全的。

为了阐述这一点，假定 `Stack<T>` 类实现了如下的接口：

```cs
public interface IPoppable<outT> { T Pop(); }
```

T 上的 out 修饰符表明 T 只用于输出的位置（例如方法的返回值）。out 修饰符将类型参数标记为协变参数，并且可以进行如下操作：

```cs
var bears = new Stack<Bear>();
bears.Push (new Bear()); // Bears implements IPoppable<Bear>. We can convert to IPoppable<Animal>:
IPoppable<Animal> animals = bears; // Legal
Animal a = animals.Pop();
```

接口中的协变或逆变都是很常见的，在接口中同时支持协变和逆变则是很少见的。

bears 到 animals 的转换是由编译器保证的，因为类型参数具有协变性。在这种情况下，若试图将 Camel 实例入栈，则编译器会阻止这种行为。由于 T 只能在输出位置出现，因此不可能将 Camel 类输入接口中。

特别注意，方法中的 out 参数是不支持协变的，这是 CLR 的限制。

如前所述，我们可以利用类型转换的协变性解决复用性问题：

```cs
public class ZooCleaner 
{ 
    public static void Wash (IPoppable<Animal> animals) { ... } 
}
```

第 7 章讲述的 `IEnumerator<T>` 和 `IEnumerable<T>` 接口的 T 都是协变的。这意味着需要时可以将 `IEnumerable<string>` 转换为 `IEnumerable <object>`。

如果在输入位置（例如方法的参数或可写属性）使用协变参数则会发生编译时错误。

不管是类型参数还是数组，协变（和逆变）仅对引用转换有效，对装箱转换无效。因此，如果编写了一个接受 `IPoppable<object>` 类型参数的方法，那么可以使用 `IPoppable<string>` 调用它，但不能是 `IPoppable <int>`。

#### 3.9.13 逆变

通过前面的介绍我们已经知道，假设 A 可以隐式引用转换为 B，如果 `X<A>` 允许引用类型转换为 `X<B`>，则类型 X 具有协变类型参数。而逆变的转换方向正好相反，即从 `X<B>` 转换到 `X<A>`。它仅在类型参数出现在输入位置上并用 in 修饰符标记时才行得通。以下扩展了之前的例子，假设 `Stack<T>` 实现了如下的接口：

```cs
public interface IPushable<in T> { void Push (T obj); }
```

则以下的语句是合法的：

```cs
IPushable<Animal> animals = new Stack<Animal>();
IPushable<Bear> bears = animals;
bears.Push (new Bear());
```

IPushable 中没有任何成员输出 T，所以将 animals 转换为 bears 时不会出现问题（但是通过这个接口无法实现 Pop 方法）。

即使 T 含有相反的可变性标记，`Stack<T>` 类可以同时实现 `IPushable<T>` 和 `IPoppable<T>`。由于只能通过接口而不是类实现可变性，因此在进行可变性转换之前，必须首先选定 IPoppable 或者 IPushable 接口。而选定的接口会限制操作在合适的可变性规则下执行。

这也说明了为什么类不允许接受可变性类型参数：因为具体实现通常都需要数据进行双向流动。

再看一个例子，以下的接口是.NET Core 中的一个接口定义：

```cs
public interface IComparer<in T> 
{
    // Returns a value indicating the relative ordering of a and b
    int Compare (T a, T b); 
}
```

该接口含有逆变参数 T，因此可以使用 `IComparer<object>` 来比较两个字符串：

```cs
var objectComparer = Comparer<object>.Default;
// objectComparer implements IComparer<object>
IComparer<string> stringComparer = objectComparer;
int result = stringComparer.Compare ("Brett","Jemaine");
```

与协变正好相反，如果将逆变的类型参数用在输出位置（例如返回值或者可读属性）上，编译器将会报告错误。

#### 3.9.14 C# 泛型和 C++ 模板的对比

C# 的泛型和 C++ 的模板在应用程序中很相似，但是它们的工作原理却大不相同。两者都发生了生产者和消费者的关联，且生产者的占位符将被消费者填充。但是在 C# 泛型中，生产者的类型（开放类型，如 `List<T>`）可以编译到程序库（如 mscorlib.dll）中。这是因为生产者和消费者进行关联生成封闭类型是在运行时发生的。而 C++ 模板中，这一关联是在编译时进行的。这意味着 C++ 不能将模板库部署为 .dll，它们只存在于源代码中。这令动态语法检查难以实现，更不用说即时创建或参数化类型了。

为了深究这一情形形成的原因，重新观察 C# 的 Max 方法：

```cs
static T Max <T> (T a, T b) where T : IComparable<T> 
    => a.CompareTo (b) > 0 ? a : b;
```

为什么不能按以下方式实现呢？

```cs
static T Max <T> (T a, T b)
    => (a > b ? a : b);
// Compile error
```

原因是，Max 需要在编译时支持所有可能的 T 类型值。由于对于任意类型 T，运算符 > 没有统一的含义，因此上述程序无法通过编译。实际上，并不是所有的类型都支持 > 运算符。相对地，下面的代码是用 C++ 的模板编写的 Max 方法。该代码会针对每一个 T 值分别编译，对特定 T 呈现的不同的 > 语义，而当 T 不支持 > 运算符时编译失败：

```cs
template <class T> T Max (T a, T b)
{ 
    return a > b ? a : b;
}
```