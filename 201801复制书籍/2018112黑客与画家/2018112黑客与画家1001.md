# 10 编程语言解析

所有机器都有一张操作命令清单，让你可以控制它。有时这个清单非常简短。电水壶就只允许两种操作：打开和关闭。CD 播放器稍微复杂点，除了打开和关闭以外，还能调节音量、播放、暂停、快进、快退、随机播放等。






计算机和其他机器一样，也有一张操作命令清单。比如，可以命令计算机把两个数相加。这种操作命令的总和就是计算机的机器语言（machine language）。

## 01. 机器语言

计算机刚发明的时候，所有程序就是一条条机器语言的命令。没过多久，程序就改成使用汇编语言了，它要比机器语言写起来稍微方便一点。命令清单还是一样的，就是每个命令换了一个更人性化的名字。机器语言的加法命令是 11001101，这可能就是计算机内部的加法表达方式，但是在汇编语言中，这条命令就改成了 add。

机器语言和汇编语言的共同问题就是，只能让大多数计算机做一些很简单的事情。比如，假定你想让计算机的蜂鸣器响 10 次，但是不存在一条直接的机器语言命令让电脑重复进行 n 次操作，所以只能用机器语言写出下面这样的程序：

a　将数字 10 存入内存地址 0

如果内存地址 0 的值为负数，跳到 b 行

蜂鸣器发出声音

将内存地址 0 的值减 1

跳到 a 行

b　…… 程序的其他部分……

如果只是为了让蜂鸣器响 10 次就不得不写这么多代码，不难想象写出一个文字处理器或电子表格将是一项多么浩大的工程。

顺便说一句，请再看一下上面的程序。蜂鸣器真的会响 10 次吗？不，响了 11 次。我不应该在第一行使用 10，而应该使用 9。我故意在这个例子中留了一个 bug，证明编程语言的一个重要特点：一个操作所需的代码越多，就越难避免 bug，也越难发现它们。

## 02. 高级语言

现在假设你不得不用汇编语言开发程序，但是你有了一个助手，他可以帮你承担那些麻烦的脏活。所以，你只要把程序写成下面这样就行了［1］：

dotimes 10 蜂鸣器响

接下来，你的助手会用汇编语言来实现这条命令（假定他不会产生 bug）。

事实上大多数程序员就是这样工作的，不同之处就是，程序员的助手不是一个人，而是编译器。所谓「编译器」，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。

这种简便方式书写的程序所使用的语言就叫做高级语言。它让你能够使用更强大的命令开发程序，比如现在你就有了「重复 n 次操作」的命令，不再仅限于只能做简单的「两个数相加」。

写程序时有了方便的命令，就可以把程序写得更简短。在上面假想的例子中，高级语言写出来的程序的长度只有机器语言的五分之一。所以，要是你犯错了，现在也更容易发现。

高级语言还有一个优点，它使得程序更具有可移植性。不同计算机的机器语言都不是完全相同的。所以，你无法将为某一种机型写的机器语言程序放到另一种机型上运行，只有彻底重写才能实现。但是，如果你的程序是用高级语言写的，你只需要重写编译器就可以了。

编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。

## 03. 开放源码

编译器处理的高级语言代码又叫做源码。它经过翻译以后产生的机器码就叫做目标码。顾客购买市场上的商业软件时得到的往往只是目标码。（目标码很难读懂，所以相当于被加密了，可以保护公司的商业秘密。）但是，后来出现另一种潮流：开放源码的软件。你可以得到源码，并且可以不受限制地修改它。

这两种方式的真正区别在于，开放源码使你对软件有更大的控制权，如果你想理解开源软件如何运行，只要阅读源码就行了。如果愿意，你甚至可以修改软件、重新编译。

你之所以需要这样做，一个原因可能是为了修正 bug。比如，你自己不可能修正 Windows 的 bug，因为你没有源码。（理论上你也许可以破解目标码，但是实际上这是非常难的。另一方面，软件的授权协议一般也不允许你这样做。）这会导致很大的问题。一旦 Windows 出现新的安全漏洞，只能等待微软公司发布解决方法，这还算是快的。如果 bug 的危害性不严重，只是偶尔会让你的机器死机，那么可能不得不等到下一次全面升级后问题才会得到解决。

开放源码的优势还不仅局限于可以自己动手解决 bug。这里的关键是所有人都可以参与。所以，开源软件就像一篇经受同行评议的论文。许许多多的聪明人仔细阅读了 Linux 和 FreeBSD 这样的开源操作系统的源码，发现并且解决了大量的 bug。相比之下，Windows 的可靠性只能依赖于大公司自己的质量保证部门了。

开放源码的拥护者常常被看作反对知识产权的怪人。其中有些人确实如此，但是我本人肯定不反对知识产权。只是如果你要我安装没有源码的软件，我会非常犹豫。普通的消费者也许不需要看到他们使用的文字处理器的源码，但是在非常强调软件可靠性的情况下，出于强烈的工程需求的考虑，会要求开放源码。

## 04. 语言的战争

绝大多数程序员在绝大多数时候都使用高级语言编程。现在很少有人使用汇编语言。程序员的时间要比计算机的时间昂贵得多，后者已经变得很便宜了，所以几乎不值得非常麻烦地用汇编语言开发软件。只有少数最关键的部分可能还会用到汇编语言，比如开发某个计算机游戏时，你需要在微观水平控制硬件，使得游戏速度得到最大限度的终极提高。

Fortran、Lisp、Cobol、Basic、C、Pascal、Smalltalk、C++、Java、Perl 和 Python，全都是高级语言。它们只是比较出名的几种而已。现在的高级语言大概有几百种之多。不同机器语言的指令集基本相同，但是高级语言就不一样，它们开发程序的模式差别相当大。

那么，应该使用哪一种语言？嗯，关于这个问题，现在有很多争论。部分原因是，如果你长期使用某种语言，你就会慢慢按照这种语言的思维模式进行思考。所以，后来当你遇到其他任何一种有重大差异的语言，即使那种语言本身并没有任何不对的地方，你也会觉得它极其难用。缺乏经验的程序员对于各种语言优缺点的判断经常被这种心态误导。

可能因为想炫耀自己见多识广，某些黑客会告诉你所有高级语言基本相似。「所有编程语言我都用过。」某个看上去饱经风霜又酷的黑客往酒吧里一坐，「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」

这当然是一派胡言。各种语言简直是天差地别，比如 Fortran I 和最新版的 Perl 就是两种完全不同的语言，而早期版的 Perl 和最新版的 Perl 之间的差别也大得惊人。但是，那个夸夸其谈的黑客可能真的相信自己的这番话，的确有可能使用所有不同的语言写出了与用原始的 Pascal 语言写的差不多的程序。如果你吃过麦当劳，就会知道全世界各地的麦当劳的味道都几乎一样。

一些黑客只喜欢自己用的语言，反感其他所有的语言。另一些黑客则说所有的语言都一样。事实介于这两个极端之间。语言之间确实有差别，但是很难确定地说哪一种语言是最好的。这个领域依然还在快速发展。

## 05. 抽象性

高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C 语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而 Lisp 语言的层次则是相当高。

如果高层级语言比汇编语言更有利于编程，你也许会认为语言的层次越高越好。一般情况下确实如此，但不是绝对的。编程语言可以变得很抽象，完全脱离硬件，但也有可能走错了方向。比如，我觉得 Prolog 语言就有这个问题。它的抽象能力强得不可思议，但是只能用来解决 2％的问题，其余时间你苦思冥想、运用这些抽象能力写出来的程序实际上就是 Pascal 语言的程序。

另一个你会用到低层次语言的原因就是效率问题。如果你非常关注运行速度，那么最好使用接近机器的语言。大多数操作系统都是用 C 语言写的，这并非偶然。不过，硬件的运行速度越来越快了，所以使用 C 这样的低层次语言开发应用程序的必要性正在不断减少，但是大家似乎还是要求操作系统越快越好。（另一种可能是，人们还是希望「缓存区溢出攻击」继续存在下去，以便让大家时时保持警惕。［2］）

## 06. 安全带还是手铐？

语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。Java 语言是前一个阵营的代表，Perl 语言则是后一个阵营的代表。（美国国防部很看中 Java 也就不足为奇了。）

自由语言派的信徒嘲笑另一方是「B&D」（奴役和戒律，Bondage and Discipline）语言，很无礼地暗示用那些语言编程的人是下等人。我不知道对方如何反击这些喜欢 Perl 的自由派，也许他们不喜欢给别人起绰号，因此我就无从知道。

由于防止程序员做蠢事有好几种方法，所以上面的争论逐渐分化成几个较小的议题。目前最活跃的议题之一就是静态类型语言与动态类型语言之争。在静态类型语言中，写代码时必须知道每个变量的类型。而在动态类型语言中，随便什么时候，你都可以把变量设为任意类型的值。

静态类型语言的拥护者认为这样可以防止 bug，并且帮助编译器生成更快的代码（这两点理由都成立）。动态类型语言的拥护者认为静态类型对程序构成了限制（这点理由也成立）。我本人更喜欢动态类型，痛恨那些限制我的自由的语言。但是，确实有一些很聪明的人看来喜欢用静态类型语言。所以，这个问题依然值得讨论，并没有固定答案。

## 07. 面向对象编程

眼下另一个争论的热点则是面向对象编程。它是一种不同的组织程序的方法。假定你要写一个程序，计算二维图形的面积。首先，你必须知道到底是圆形还是正方形。一种解决方法是用一整块的代码判断遇到的是什么图形，然后再用相应的公式计算面积。面向对象编程不是这样，它的方法是写出两个类，一个是圆形类，另一个是正方形类，然后每个类里面用一小块代码（叫做方法）计算该类图形的面积。求面积的时候，你就问要用哪一个类，然后再使用相应的方法得出最后答案。

这两种不同的计算方法可能听上去很相似，事实上，运行代码后，实际计算面积的运算过程也很相似。（这不奇怪，因为你本来就在解决同一个问题。）但是，代码的形式却是大相径庭。在面向对象编程的方式中，计算圆面积和正方形面积的代码可能分散在不同的文件中。与圆形有关的代码都放在一个文件中，与正方形有关的代码则放在另一个文件中。

面向对象编程的优点在于，如果你需要修改程序，计算另一种图形的面积，比如三角形，你只需要再另外增加一块相应的代码就可以了，甚至可以不修改程序的其他部分。但是，批评者会反驳说，这种方法的缺点是，由于增加代码不用考虑其他部分，结果往往导致写出性能不佳甚至有副作用的代码，就好比造房子不考虑已经完成的部分一样。

关于面向对象编程优劣的争论并不像静态类型与动态类型之争那样壁垒分明，因为编程的时候你只能在静态类型和动态类型之中选一种。但是，面向对象编程只是程度不同的问题。事实上有两种程度的面向对象编程：某些语言允许你以这种风格编程，另一些语言则强迫你一定要这样编程。

我觉得后一类语言不可取。允许你做某事的语言肯定不差于强迫你做某事的语言。所以，至少在这方面我们可以得到明确的结论：你应该使用允许你面向对象编程的语言。至于你最后到底用不用则是另外一个问题了。

## 08. 文艺复兴

有一件事，我想所有软件业的人都会同意，那就是最近出现了很多新的编程语言。直到 20 世纪 80 年代，只有大机构才买得起开发编程语言所需的硬件，所以大多数编程语言都是大公司的教授或者研究员开发的。而现在，一个高中生就·能搞到所有必需的硬件。

Perl 语言的设计者拉里·瓦尔［3］的例子启发了很多黑客：为什么不动手设计一种自己的语言呢？只要你懂得驾驭开源软件社区，就会有很多人在短期内为你提供大量的代码。

结果就是产生了一些也许可以称为「头重脚轻」的语言：它们的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。［4］

另一个结果就是语言的多样化。编程语言之间总是存在很大区别。Fortran、Lisp、APL 都是 1970 年以前开发出来的，它们之间的区别大得就像海星、熊、蜻蜓之间的区别。新兴的开源编程语言肯定将继承这种传统。

现在好像每隔一段日子就能听到一种新出现的语言。乔纳森·埃里克森把这种现象称为「编程语言的文艺复兴」。人们有时还会用另一个说法，即「编程语言的战争」。这并不矛盾，文艺复兴时期就是存在很多战争的。

实际上，很多历史学家相信战争是文艺复兴的一个副产品。［5］当时，欧洲活力旺盛可能就是因为它分成许多互相竞争的小国。它们互相毗邻，所以新思想能够从一个国家传播到另一个国家，但是它们又互相独立，使得单个的统治者无法遏制创新的发展。相比之下，中国古代的封建皇朝禁止民间建造大型的远洋船只，阻止了经济的正常发展。所以，程序员活在这个文艺复兴时代可能是一件好事。如果我们所有人都使用同一种编程语言，反而有可能是坏事。

## 注释

［1］　dotimes 是 Lisp 语言中表示循环处理的命令。—— 译者注

［2］　最常见的几种入侵计算机的手法都是利用了 C 语言的某些特点。当你在 C 语言中为输入的内容分配出一片内存（也叫「缓存」）时，它会被分配在当前运行代码的返回地址旁边。所谓「返回地址」指的是一块特定内存，当前代码运行完毕以后，就要运行这块内存中包含的代码。也就是说，它实际上是计算机下一步要做的事情。

假定有人打算入侵你的计算机，他们猜出你会为某种输入分配 256 字节的缓存，于是他们就提交多于 256 字节的内容，目的是覆盖旁边的「返回地址」。那么，当前代码运行完毕之后，程序的控制权就交给了他们指定的内存地址。这个地址通常是缓存的首地址，缓存中是入侵者事前编好的机器码。于是，入侵者的程序就运行在你的计算机上了。

如果使用更抽象的高级语言，上面的事情是不可能发生的。但是，在 C 语言中，一旦接受用户输入的时候你没有检查输入长度，就创造出了一个安全漏洞。利用这种漏洞的攻击行为就被称为「缓冲区溢出攻击」。在这种攻击中，还有其他方法可以控制计算机，但是覆盖返回地址是最经典的一种。

有意思的是，劫持飞机与「缓冲区溢出攻击」有类似之处。在一般飞机上，乘客区与驾驶舱是相通的，就好像 C 语言中数据区与代码区是相邻的一样。劫机者一旦进入驾驶舱，实际上就相当于把自己从数据提升为代码。

［3］　Larry Wall（1954—）在大学里主修语言学。1987 年为了使管理机房的工作变得方便，他在业余时间创造了 Perl 语言。—— 译者注

［4］　提醒各位亲爱的黑客，我只是打一个比方，请不要尝试在车顶绑上飞机发动机。另外，可以认为这类「头重脚轻」的语言存在已久，Fortran 语言的流行主要就是因为它的函数库。

［5］　参见 Carlo Cipolla 所著的《枪，帆船，帝国：技术革新在 1400~1700 年欧洲扩张早期阶段的作用》（Guns, Sails, and Empires: Technological Innovation and the Early Phases of European Expansion 1400-1700），Pantheon，1965 年出版。
