## 记忆时间

2021-11-06

## 目录

第一部分 技艺

0101 命名

0201 规范

0301 函数

0401 设计原则

## 0101. 命名

### 本章小结

命名在软件设计中有着举足轻重的作用，命名的力量就是语言的力量，好的命名可以保证代码不仅是被机器执行的指令，更是人和人之间沟通的桥梁。

命名的重要性不仅体现在提升代码的可读性上，有意义的命名更能够引导我们更加深入地理解问题域，理清关键业务概念，进行合理的业务抽象，从而设计出更加符合业务语义、易于理解的系统。

因此，每一个程序员都应该掌握一套命名的方法论：了解如何给软件制品（Artifact，包括 Module、Package、Class、Function 和 Variable）命名，如何写注释，如何让代码自明地表达自己，以及如何保持命名风格的一致性。

### 1.0

名为万物之始，万物始于无名，道生一，一生二，二生三，三生万物。

——《易经》

命名常常被认为是编程中的细节问题，其重要性往往被低估。而所谓的工匠精神，往往就是体现在细节之处，就像日本的「煮饭仙人」50 年专注于做好 1 碗米饭。一个名字虽然并不影响程序的执行，但是却对代码的表达力和可读性有着重要的影响。

在程序员的工作中，大部分的时间都在阅读和理解代码，好的命名能够让代码的概念清晰，增加代码的表达力；词不达意的命名会破坏我们思考的连贯性，分散有限的注意力。

### 1.1 命名的力量

无论是对于人名，还是企业名、产品名，命名都有着巨大的力量。

在阿里巴巴初创时期，马云想做一个国际化的电子商务网站，要起一个全球化的名字。有一天，他在旧金山的街上发现阿里巴巴这个名字蛮有意思的，正在思考时，一名服务员送咖啡过来。马云问他：「你知道阿里巴巴吗？」他说：「当然知道了，就是 open seasame（芝麻开门）」。然后马云在街上找了来自不同国家的数十个人，问他们知道阿里巴巴吗？他们大多能讲到芝麻开门。在英文单词里，「a」排名又在第一位，而且大多数人一听（看）到阿里巴巴这个名字都会感到奇怪，这样足以给人留下深刻的印象，「阿里巴巴」的名字由此而来。

在 Java 企业级应用开发的历史上，也有一段和命名有关的有趣历史。在 2000 年左右，EJB（Enterprise Java Bean）大行其道，这让 Martin Fowler、Rebecca Parsons 和 Josh MacKenzie 等人感到很困惑。后来他们发现人们之所以不愿意在他们的系统中使用普通的 Java 对象，是因为其缺少一个酷炫的名字，因此他们在一次会议上给普通的 Java 对象起了个名字 —— POJO（Plain Old Java Object）。当时的 EJB 在开发和部署上给开发者带来了沉重的负担，POJO 概念的提出很快得到了开发者的拥护。Spring 等一系列轻量级框架的诞生，很快终结了 EJB 的统治地位，因此在一定程度上，POJO 这个名字加速了 EJB 的消亡。

### 1.2 命名其实很难

起名字这件事看似不难，但是要经过深思熟虑，取出名副其实、表达性好的名字并不是一件很容易的事。

命名为什么难呢？因为命名的过程本身就是一个抽象和思考的过程，在工作中，当我们不能给一个模块、一个对象、一个函数，甚至一个变量找到合适的名称的时候，往往说明我们对问题的理解还不够透彻，需要重新去挖掘问题的本质，对问题域进行重新分析和抽象，有时还要调整设计和重构代码。因此，好的命名是我们写出好代码的基础。

就像 Stack Overflow 的创始人 Joel Spolsky 所说的：

起一个好名字应该很难，因为一个好名字需要把要义浓缩在一到两个词中。（Creating good names is hard, but it should be hard, because a great name captures essential meaning in just one or two words.）

此外，Martin Fowler 也表示过，他最喜欢的一句谚语是：

在计算机科学中有两件难事：缓存失效和命名。（There are only two hard things in Computer Science: cache invalidation and naming things.）

### 1.3 有意义的命名

代码即文档，可读性好的代码应该有一定的自明性，也就是不借助注释和文档，代码本身就能显性化地表达开发者的意图。这种自明性在很大程度上依赖于我们对问题域的理解，以及命名是否合理。

通常，如果你无法想出一个合适的名字，很可能意味着代码「坏味道」、设计有问题。这时可以思考一下：是不是一个方法里实现了太多的功能？或者类的封装内聚性不够？又或者是你对问题的理解还不够透彻，需要获取更多的信息？

#### 1.3.1 变量名

变量名应该是名词，能够正确地描述业务，有表达力。如果一个变量名需要注释来补充说明，那么很可能说明命名就有问题。

```Java
int d; // 表示过去的天数
```

观察上面的命名，我们只能从注释中知道变量 d 指的是什么。如果没有注释，阅读代码的人为了知道 d 的含义，就不得不去寻找它的实例以获取线索。如果我们能够按照下面这样的方式命名这个变量，阅读代码的人就能够很容易地知道这个变量的含义。

```Java
int elapsedTimeInDays;
```

类似的还有魔术数，数字 86400 应该用常量 SECONDS_PER_DAY 来表达；每页显示 10 行记录的，10 应该用 PAGE_SIZE 来表达。

这样做还有一个好处，即代码的可搜索性，在代码中查找 PAGE_SIZE 很容易，但是想找到 10 就很麻烦了，它可能是某些注释或者常量定义的一部分，出现在不同作用的各种表达式中。

#### 1.3.2 函数名

函数命名要具体，空泛的命名没有意义。例如，processData() 就不是一个好的命名，因为所有的方法都是对数据的处理，这样的命名并没有表明要做的事情，相比之下，validateUserCredentials() 或者 eliminateDuplicateRequests() 就要好许多。

函数的命名要体现做什么，而不是怎么做。假如我们将雇员信息存储在一个栈中，现在要从栈中获取最近存储的一个雇员信息，那么 getLatestEmployee() 就比 popRecord() 要好，因为栈数据结构是底层实现细节，命名应该提升抽象层次、体现业务语义。合理的命名可以使你省掉记住「出栈」的脑力步骤，你只需要简单地说「取最近雇员的信息」。

#### 1.3.3 类名

类是面向对象中最重要的概念之一，是一组数据和操作的封装。对于一个应用系统，我们可以将类分为两大类：实体类和辅助类。

2『实体类和辅助类，做一张属于卡片。（2021-10-13）』—— 已完成

实体类承载了核心业务数据和核心业务逻辑，其命名要充分体现业务语义，并在团队内达成共识，如 Customer、Bank 和 Employee 等。

辅助类是辅佐实体类一起完成业务逻辑的，其命名要能够通过后缀来体现功能。例如，用来为 Customer 做控制路由的控制类 CustomerController、提供 Customer 服务的服务类 CustomerService、获取数据存储的仓储类 CustomerRepository。

对于辅助类，尽量不要用 Helper、Util 之类的后缀，因为其含义太过笼统，容易破坏 SRP（单一职责原则）。比如对于处理 CSV，可以这样写：

```java
CSVHelper.parse(String)

CSVHelper.create(int[])
```

但是我更建议将 CSVHelper 拆开：

```java
CSVParser.parse(String)

CSVBuilder.create(int[])
```

#### 1.3.4 包名

包（Package）代表了一组有关系的类的集合，起到分类组合和命名空间的作用。在 JavaScript 的早期阶段，因为缺乏明确的分包机制，导致程序（特别是大型程序）很容易陷入混乱。

包名应该能够反映一组类在更高抽象层次上的联系。例如，有一组类 Apple、Pear、Orange，我们可以将它们放在一个包中，命名为 fruit。

包的命名要适中，不能太抽象，也不能太具体。此处以上面提到的水果作为例子，如果包名过于具体，比如 Apple，那么 Pear 和 Orange 放进该包中就不恰当了；如果报名太抽象，称为 Object，而 Object 无所不包，这就失去了包用来限定范围的作用。

#### 1.3.5 模块名

这里说的模块（Module）主要是指 Maven 中的 Module，相对于包来说，模块的粒度更大，通常一个模块中包含了多个包。

在 Maven 中，模块名就是一个坐标: <groupId, artifactId>。一方面，其名称保证了模块在 Maven 仓库中的唯一性；另一方面，名称要反映模块在系统中的职责。例如，在 COLA 架构中，模块代表着架构层次，因此，对任何应该遵循 COLA 规范的应用都有着 xxx-controller、xxx-app、xxx-domain 和 xxx-Infrastructure 这 4 个标准模块。更多内容请参考 12.3 节。

### 1.4 保持一致性

保持命名的一致性，可以提高代码的可读性，从而简化复杂度。因此，我们要小心选择命名，一旦选中，就要持续遵循，保证名称始终一致。

#### 1.4.1 每个概念一个词

每个概念对应一个词，并且一以贯之。例如，fetch、retrieve、get、find 和 query 都可以表示查询的意思，如果不加约定地给多个类中的同种查询方法命名，你怎么记得是哪个类中的哪个方法呢？同样，在一段代码中，同时存在 manager、controller 和 handler，会令人感到困惑。

因此在项目中，作者通常按照表 1-1 所示的约定，保持命名的一致性。

表 1-1 方法名约定

| CRUD 操作 | 方法名约定 |
| --- | --- |
| 新增 | create |
| 添加 | add |
| 删除 | remove |
| 修改 | update |
| 查询（单个结果） | get |
| 查询（多个结果） | list |
| 分页查询 | page |
| 统计 | count |

#### 1.4.2 使用对仗词

遵守对仗词的命名规则有助于保持一致性，从而提高代码的可读性。像 first/last 这样的对仗词就很容易理解；而像 fileOpen () 和 fClose () 这样的组合则不对称，容易使人迷惑。下面列出一些常见的对仗词组：

add/remove

increment/decrement

open/close

begin/end

insert/delete

show/hide

create/destroy

lock/unlock

source/target

first/last

min/max

start/stop

get/set

next/previous

up/down

old/new

#### 1.4.3 后置限定词

很多程序中会有表示计算结果的变量，例如总额、平均值、最大值等。如果你要用类似 Total、Sum、Average、Max、Min 这样的限定词来修改某个命名，那么记住把限定词加到名字的最后，并在项目中贯彻执行，保持命名风格的一致性。

这种方法有很多优点。首先，变量名中最重要的部分，即为这一变量赋予主要含义的部分应位于最前面，这样可以突出显示，并会被首先阅读到。其次，可以避免同时在程序中使用 totalRevenue 和 revenueTotal 而产生的歧义。如果贯彻限定词后置的原则，我们就能收获一组非常优雅、具有对称性的变量命名，例如 revenueTotal（总收入）、expenseTotal（总支出）、revenueAverage（平均收入）和 expenseAverage（平均支出）。

需要注意的一点是 Num 这个限定词，Num 放在变量名的结束位置表示一个下标，customerNum 表示的是当前客户的序号。为了避免 Num 带来的麻烦，我建议用 Count 或者 Total 来表示总数，用 Id 表示序号。这样，customerCount 表示客户的总数，customerId 表示客户的编号。

#### 1.4.4 统一业务语言

为什么要统一业务语言呢？试想一下，如果你每天与业务方讨论的是一种编程语言，而在团队内部交流、设计画图时使用另一种语言，编写的代码中体现出来的又是毫无章法、随意翻译的内容，这无疑会降低代码的表达能力，在业务语义和文档、代码之间出现了一条无形的鸿沟。

统一语言就是要确保团队在内部的所有交流、模型、代码和文档中都要使用同一种编程语言。实际上，统一语言（Ubiquitous Language）也是领域驱动设计（Domain Driven Design，DDD）中的重要概念，在 7.4.1 节中会有更加详细的介绍。

#### 1.4.5 统一技术语言

有些技术语言是通用的，业内人士都能理解，我们应该尽量使用这些术语来进行命名。这些通用技术语言包括 DO、DAO、DTO、ServiceI、ServiceImpl、Component 和 Repository 等。例如，在代码中看到 OrderDO 和 OrderDAO，马上就能知道 OrderDO 中的字段就是数据库中 Order 表字段，对 Order 表的操作都在 OrderDAO 里面。

### 1.5 自明的代码

有人说「代码是最好的文档」，我并不完全赞同，我认为更准确的表达应该加上一个定语：「好的代码是最好的文档」。也就是说，代码若要具备文档的功能，前提必须是其本身要具备很好的可读性和自明性。所谓自明性，就是在不借助其他辅助手段的情况下，代码本身就能向读者清晰地传达自身的含义。

#### 1.5.1 中间变量

我们可以通过添加中间变量让代码变得更加自明，即将计算过程打散成多个步骤，并用有意义的变量名来命名中间变量，从而把隐藏的计算过程以显性化的方式表达出来。

例如，我们要通过 Regex 来获得字符串中的值，并放到 map 中。

```java
Matcher matcher = headerPattern.matcher(line);

if (matcher.find()) {
    headers.put(matcher.group(1), matcher.group(2));
}
```

用中间变量，可以写成如下形式：

```java
Matcher matcher = headerPattern.matcher(line);

if (matcher.find()) {
    String key = matcher.group(1);
    String value = matcher.group(2);
    headers.put(key, value);
}
```

中间变量的这种简单用法，显性地表达了第一个匹配组是 key，第二个匹配组是 value。只要把计算过程打散成一系列良好命名的中间值，不透明的语义自然会变得透明。

#### 1.5.2 设计模式语言

使用设计模式语言也是代码自明的重要手段之一，在技术人员之间共享和使用设计模式语言，可以极大地提升沟通的效率。当然，前提是大家都要理解和熟悉这些模式，否则就会变成「鸡同鸭讲」。因此，我们有必要在命名上就将设计模式显性化出来，这样阅读代码的人能很快领会到设计者的意图。

例如，Spring 里面的 ApplicationListener 就充分体现了它的设计和用处。通过这个命名，我们知道它使用了观察者模式，每一个被注册的 ApplicationListener 在 Application 状态发生变化时，都会接收到一个 notify。这样我们就可以在容器初始化完成之后进行一些业务操作，比如数据加载、初始化缓存等。

又如，在进行 EDM（邮件营销）时要根据一些规则过滤掉一些客户，比如没有邮箱地址的客户、没有订阅关系不能发送邮件的客户、3 天内不能重复发送邮件的客户等。

下面是一个典型的 pipeline 处理方式，责任链在处理该问题上是一个很好的选项，FilterChain 这个名字非常恰当地表达出了作者的意图，Chain 表示用的是责任链模式，Filter 表示用来进行过滤。

```java
FilterChain filterChain = FilterChainFactory.buildFilterChain(
        NoEmailAddressFilter.class,
        EmailUnsubscribeFilter.class,
        EmailThreeDayNotRepeatFilter.class);

// 具体的 Filter
public class NoEmailAddressFilter implements Filter {
@Override
public void doFilter(Object context, FilterInvoker nextFilter) {
        Map<String, Object> contextMap = (Map<String, Object>)context;
        String email = ConvertUtils.convertParamType(contextMap.get("email"),String.class);
        if (StringUtils.isBlank(email)) {
            return;
        }
        nextFilter.invoke(context);
        }
}
```

#### 1.5.3 小心注释

如果注释是为了阐述代码背后的意图，那么这个注释是有用的；如果注释是为了复述代码功能，那么就要小心了，这样的注释往往意味着「坏味道」（在 Martin Fowler 的《重构：改善既有代码的设计》一书中，注释就是「坏味道」之一），是为了弥补我们代码表达能力的不足。就像 Brian W. Kernighan 说的那样：「别给糟糕的代码加注释 —— 重新写吧。」

1、不要复述功能。

为了复述代码功能而存在的注释，主要作用是弥补我们表达意图时遭遇的失败，这时要考虑这样的注释是否是必需的。如果编程语言足够有表达力，或者我们擅长用代码显性化地表达意图，那么也许根本就不需要注释。因此，在写注释时，你应该自省自己是否在表达能力上存在不足，真正的高手是尽量不写注释。

在 JDK 的源码 java.util.logging.Handler 中，我们可以看到如下代码：

```java
public synchronized void setFormatter(Formatter newFormatter) {
    checkPermission();
    // Check for a null pointer:
    newFormatter.getClass();
    formatter = newFormatter;
}
```

如果没有注释，那么可能没人知道 `newFormatter.getClass();` 是为了判空，注释「Check for a null pointer」就是为了弥补代码表达能力的失败而存在的。如果我们换一种写法，使用 java.util.Objects.requireNonNull 进行判空，那么注释就完全是多余的，代码本身足以表达其意图。

2、要解释背后意图。

注释要能够解释代码背后的意图，而不是对功能的简单重复。例如，我们在一个系统中看到如下代码：

```java
try {
    // 在这里等待 2 秒
    Thread.sleep(2000);
} catch (InterruptedException e) {
    LOGGER.error(e);
}
```

这里的注释和没写是一样的，因为它只是对 sleep 的简单复述。正确的做法应该是阐述 sleep 背后的原因，比如改写成如下形式就会好很多。

```java
try {
    // 休息 2 秒，为了等待关联系统处理结果
    Thread.sleep(2000);
} catch (InterruptedException e) {
    LOGGER.error(e);
}
```

或者直接用一个 private 方法将其封装起来，用显性化的方法名来表达意图，这样就不需要注释了。

```java
private void waitProcessResultFromA( ) {
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        LOGGER.error(e);
    }
}
```

### 1.6 命名工具

「他山之石，可以攻玉」，当你不知道如何优雅地给变量命名时，可以使用命名工具，快速搜索大型项目中的变量命名，看其他大型项目源码是如何命名的，哪些变量名的使用频率高。特别是对于英语非母语的我们，命名工具会非常有用。

我们可以在 IDE 中安装一个搜索插件，便于搜索海量的互联网上的开源代码。举例说明，如图 1-1 所示，作者一般会安装一个叫作 OnlineSearch 的插件，插件里自带了像 SearchCode 这样的代码搜索工具，也可以自己配置像 Codelf 这样的代码搜索工具。

图 1-1 OnlineSearch 插件

## 0201. 规范

离娄之明，公输子之巧，不以规矩，不能成方圆。

—— 孟子《离娄上》

### 本章小结

混乱会造成复杂，有序会减少复杂度。制定规范是为了从无序走向有序，减少认知成本。在软件开发过程中，大到体系结构和应用架构规范，小到代码格式和空行的约定，都在一定程度上影响着系统的复杂程度。和命名一样，规范的有无，并不影响代码在机器中的解释执行，但是对系统的可理解性和代码的可读性却有着巨大的影响。

帮助技术团队制定规范，也是技术 Leader 和架构师的重要职责，一线的开发工程师不仅要参与到规范的制定中，更要做规范的坚定执行者和维护人，不做「打破窗户」的人。管理者在制定完规范之后，还要建立完善的代码审查（Code Review）机制，以便及时发现和修复「破窗」。

要记住，留给公司一个方便维护、整洁优雅的代码库，是我们技术人员的最高技术使命，也是我们对公司做出的最大技术贡献。

### 2.0

复杂系统的前沿科学家 Mitchell Waldrop 在《复杂》一书中，提出一种用信息熵来进行复杂性度量的方法。所谓信息熵，就是一条信息的信息量大小和它的不确定性之间的关系。举个例子，假设消息由符号 A、C、G 和 T 组成，如果序列高度有序，例如「A A A A A A A … A」，则熵为零。而完全随机的序列，例如「G A T A C G A … A」，熵值达到最大。

由此可见，事物的复杂程度在很大程度上取决于其有序程度，减少无序能在一定程度上降低复杂度，这正是规范的价值所在。通过规范，把无序的混沌控制在一个能够理解的范围内，从而帮助我们减少认知成本，降低对事物认知的复杂度。

### 2.1 认知成本

所谓认知，是指人们获得知识或应用知识的过程。获得知识是要学习的，在学习过程中，我们要交的学费叫作认知成本。那什么是知识呢？知识是人类对经验范围内的感觉进行总结归纳之后发现的规律。混乱无序的东西没有规律，不能形成知识，也就不能被认知到，这就是有组织和无组织的复杂性的区别。

例如，对于一名有经验的飞行员，已经掌握了所有飞机的共同属性，如舵、副翼和节流阀的功能，那么只要通过短时间的指导，使其了解哪些特性是新飞机所特有的，他就能驾驶这架新飞机。

因此，发现共同抽象和机制可以在很大程度上帮助我们理解复杂系统。

### 2.2 混乱的代价

认知是有成本的，而混乱的代价在于让我们对事物无法形成有效的记忆和认知，导致我们每次面对的问题都是新问题，每次面临的场景都是新场景，又要重新理解一遍。

不知道你是否有找不到衣服的痛苦经历，比如我每次找衣服都要花不少时间，黑色短裤在哪里呢？那件白色 T 恤明明昨天还看到的，怎么现在就不翼而飞了呢？问题的根源就在于「混乱」。后来，我痛定思痛，对衣服进行分门别类，收纳整理，找起来会容易得多，如图 2-1 所示。

图 2-1「随心所欲」与「遵守规范」

在工作中，很多工程师向我抱怨他们的系统很凌乱，毫无章法可言，即使花费很长时间也很难理清系统的脉络。在评估一个需求时，要在杂乱无章的代码中找好久才能找到相关的需求改动点，然而真正需要改动的代码可能只有一行而已。这样的无序在很大程度上是系统缺少代码组织结构规范造成的。

规范的缺失会导致工程师不知道应用中有哪些制品（Artifact）、如何给类命名、一个类应该放在哪个包（Package）或哪个模块（Module）里比较合适、错误码应该怎样去写、什么时候该打印日志、选用哪个日志级别。

IBM 大型机之父 Frederick P. Brooks.Jr（「没有银弹」概念的提出者）曾指出：「爱因斯坦认为自然界必定存在着简单的解释，因为上天不是反复无常或随心所欲的。软件工程师没有这样的信仰来安慰自己。许多必须控制的复杂性是随心所欲的复杂性。」

混乱是有代价的，我们有必要使用规范和约定来使大脑从记忆不同的代码段的随意性、偶然性差异中解脱出来。将我们有限的精力用在刀刃上，而不是用来疲于应对各种不一致和随心所欲的混乱。

### 2.3 代码规范

#### 2.3.1 代码格式

代码格式关系到代码的可读性，因此需要遵从一定的规范，包括缩进、水平对齐、注释格式等。关于代码格式，可能会因为语言和个人偏好而不同，但是一个团队最好是选定一种格式，因为一致性可以减少复杂度。

美剧《硅谷》中有一个经典镜头，Richard 与同为开发工程师的女友闹分手，理由是两人对缩进方式有截然不同的习惯，互相鄙视对方的代码风格。Richard 认为「One tab saves four spaces」，缩进使用 Tab 键操作更快，且更节省存储空间；而女友坚持使用空格缩进，连续 4 次敲击空格的声音把 Richard 折磨到几近崩溃。Richard 在吵完架下楼梯时，不小心摔倒了，还淡定地说：「I just tried to go down the stairs four steps at a time.」

举上面的例子是想表达，代码格式的规范不是绝对的，没有一种比另一种更好的说法。它其实是一种约定，一旦约定下来，固化成 IDEA/Eclipse IDE 代码的统一模板，让每个开发人员安装即可，大家遵循约定就好了。

#### 2.3.2 空行规范

空行有什么了不起，值得上升到规范的高度吗？是的，空行是一个小小的细节，但又不仅是一个细节问题。在我第一次领会到空行在概念区隔起到的作用时，其结果让我大吃一惊。

故事要从我开始写技术文章说起，那时写的都是大段大段的文字，段落之间没有空行。直到有一天，技术品牌运营的同事要将我的文章发布到阿里巴巴的技术公众号中，编辑对文章进行重新整理，除了删减个别的内容之外，还将文章按照小段落的形式进行了重构，并在每个小段落之间加上了空行加以区隔。

我惊讶地发现，对于同样的内容，由空行分出小段落比大段文字具有更好的可读性。这让我不禁想起《道德经》中的「三十幅共一毂，当其无，有车之用」，意思是说正是因为有了车轮毂和车轴之间的空白，车轮能够转起来，这正是「无」的价值啊。

自此以后，无论是写文章，还是写代码，我都倾向于使用小段落，并用空行隔开。空行为什么有这么大的作用呢？先来看图 2-2。

图 2-2 墨点的例子

大多数人一看到图 2-2 中的 6 个墨点，会认为这是两组墨点，每组 3 个。这是人类大脑的天性所致，大脑会认为同时发生的任何事物之间都存在某种联系，并且会将事物按某种逻辑模式组织起来。这种「联系」一般是某种类似的点或所处的位置比较接近。

空行在代码中的概念区隔作用同样适用。以 Spring 中的 BeanDefinitionVisitor 为例，在包声明、导入声明和每个函数之间，都有空行隔开。这种极其简单的规则极大地影响代码的视觉外观，每个空白行都是一条线索，提示你下一组代码表示的是不同的概念或功能。

```java
package org.springframework.beans.factory.config;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.MutablePropertyValues;

import org.springframework.beans.PropertyValue;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringValueResolver;

public class BeanDefinitionVisitor {

    private StringValueResolver valueResolver;

    public BeanDefinitionVisitor(StringValueResolver valueResolver) {
        Assert.notNull(valueResolver, "StringValueResolver must not be null");
        this.valueResolver = valueResolver;
    }

    public void visitBeanDefinition(BeanDefinition beanDefinition) {
        visitParentName(beanDefinition);
        visitBeanClassName(beanDefinition);
        visitFactoryBeanName(beanDefinition);
        visitFactoryMethodName(beanDefinition);
        visitScope(beanDefinition);
        visitPropertyValues(beanDefinition.getPropertyValues());
        ConstructorArgumentValues cas = beanDefinition. getConstructor ArgumentValues();
        visitIndexedArgumentValues(cas.getIndexedArgumentValues());
        visitGenericArgumentValues(cas.getGenericArgumentValues());
    }

}
```

删掉这些空白行，代码的可读性就弱了很多，如下所示。

```java
package org.springframework.beans.factory.config;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.springframework.beans.MutablePropertyValues;
import org.springframework.beans.PropertyValue;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringValueResolver;
public class BeanDefinitionVisitor {
    private StringValueResolver valueResolver;
    public BeanDefinitionVisitor(StringValueResolver valueResolver) {
        Assert.notNull(valueResolver, "StringValueResolver must not be null");
        this.valueResolver = valueResolver;
    }
    public void visitBeanDefinition(BeanDefinition beanDefinition) {
        visitParentName(beanDefinition);
        visitBeanClassName(beanDefinition);
        visitFactoryBeanName(beanDefinition);
        visitFactoryMethodName(beanDefinition);
        visitScope(beanDefinition);
        visitPropertyValues(beanDefinition.getPropertyValues());
        ConstructorArgumentValues cas = beanDefinition. getConstructor ArgumentValues();
        visitIndexedArgumentValues(cas.getIndexedArgumentValues());
        visitGenericArgumentValues(cas.getGenericArgumentValues());
    }
}
```

还有一种极端是在每一行代码后面都加上空行，这样空行就失去了意义，其结果是和没有空行一样。

在工作中，我发现很多同事不知道如何正确地使用空行，要么是该空行时没有空行，要么是胡乱空行。现在很多的 IDE 都提供了代码格式化功能，以及代码格式检查插件，在一定程度上可以帮到我们。但是工具毕竟是工具，逻辑概念的组织和区隔还是要靠程序员自己把握。一个简单的原则就是将概念相关的代码放在一起：相关性越强，彼此之间的距离应该越短 。

#### 2.3.3 命名规范

当前的主流编程语言有 50 种左右，分为两大阵营 —— 面向对象和面向过程；按照变量定义和赋值的要求，又可分为强类型语言和弱类型语言。每种语言都有自己独特的命名风格，有些语言在定义时提倡以前缀来区分局部变量、全局变量和变量类型。例如，JavaScript 是弱类型语言，所以其中会有匈牙利命名法的习惯，用 li_count 表示 local int 局部整形变量，使用 $ 给 jQuery 的变量命名。语言的命名风格多样，无可厚非，但是在同一种语言中，如果使用多种语言的命名风格，就会令其他开发工程师反感。

在 Java 中，我们通常使用如下命名约定。

1、类名采用「大驼峰」形式，即首字母大写的驼峰，例如 Object、StringBuffer、FileInputStream。

2、方法名采用「小驼峰」形式，即首字母小写的驼峰，方法名一般为动词，与参数组成动宾结构，例如 Thread 的 sleep (long millis)、StringBuffer 的 append (String str)。

3、常量命名的字母全部大写，单词之间用下划线连接，例如 TOTAL_COUNT、PAGE_SIZE 等。

4、枚举类以 Enum 或 Type 结尾，枚举类成员名称需要全大写，单词间用下划线连接，例如 SexEnum.MALE、SexEnum.FEMALE。

5、抽象类名使用 Abstract 开头；异常类使用 Exception 结尾；实现类以 impl 结尾；测试类以它要测试的类名开始，以 Test 结尾。

6、包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式。通常以 com 或 org 开头，加上公司名，再加上组件或者功能模块名，例如 org.springframework.beans。

#### 2.3.4 日志规范

日志的重要性很容易被开发人员忽视，写好程序的日志可以帮助我们大大减轻后期维护的压力。在实际工作中，开发人员往往迫于时间压力，认为写日志是一件非常烦琐的事情，往往没有足够的重视，导致日志文件管理混乱、日志输出格式不统一，结果在出现故障时影响工作效率。开发人员应在一开始就养成良好的撰写日志的习惯，并在实际的开发工作中为写日志预留足够的时间。

在打印日志时，要特别注意日志输出级别，这是系统运维的需要。详细的日志输出级别分为 OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL 或者自定义的级别。我认为比较有用的 4 个级别依次是 ERROR、WARN、INFO 和 DEBUG。通常这 4 个级别就能够很好地满足我们的需求了。

1、ERROR 级别。

ERROR 表示不能自己恢复的错误，需要立即被关注和解决。例如，数据库操作错误、I/O 错误（网络调用超时、文件读取错误等）、未知的系统错误（NullPointerException、OutOfMemoryError 等）。

对于 ERROR，我们不仅要打印线程堆栈，最好打印出一定的上下文（链路 TraceId、用户 Id、订单 Id、外部传来的关键数据），以便于排查问题。

ERROR 要接入监控和报警系统。ERROR 需要人工介入处理，及时止损，否则会影响系统的可用性。当然也不能滥用 ERROR，否则就会出现「狼来了」的情况。我在实际工作中曾碰到过系统每天会发出上千条错误报警的情况，导致根本没有人看报警内容，在真正出现问题时，也没有人关注，从而引发线上故障。因此，一定要做好 ERROR 输出的场景定义和规范，再配合监控治理，双管齐下，确保线上系统的稳定。

2、WARN 级别。

对于可预知的业务问题，最好不要用 ERROR 输出日志，以免污染报警系统。例如，参数校验不通过、没有访问权限等业务异常，就不应该用 ERROR 输出。

需要注意的是，在短时间内产生过多的 WARN 日志，也是一种系统不健康的表现。因此，我们有必要为 WARN 配置一个适当阈值的报警，比如访问受限 WARN 超过 100 次 / 分，则发出报警。这样在 WARN 日志过于频繁时，我们能及时收到系统报警，去跟进用户问题。例如，如果是产品设计上有缺陷导致用户频繁出现操作卡点，可以考虑做一下流程或者产品上的优化。

3、INFO 级别。

INFO 用于记录系统的基本运行过程和运行状态。

通常来说，优先根据 INFO 日志可初步定位，主要包括系统状态变化日志、业务流程的核心处理、关键动作和业务流程的状态变化。适当的 INFO 可以协助我们排查问题，但是切忌把 INFO 当成 DEBUG 使用，这样会导致记录的数据过多，一方面影响系统性能，日志文件增长过快，消耗不必要的存储资源；另一方面也不利于阅读日志文件。

4、DEBUG 级别。

DEBUG 是输出调试信息，如 request/response 的对象内容。在输出对象内容时，要覆盖 Object 的 toString 方法，否则输出的是对象的内存地址，就起不到调试的作用了。

通常在开发和预发环境下，DEBUG 日志会打开，以方便开发和调试。而在线上环境，DEBUG 开关需要关闭，因为在生产环境下开启 DEBUG 会导致日志量非常大，其损耗是难以接受的。只有当线上出现 bug 或者棘手的问题时，才可以动态地开启 DEBUG。为了防止日志量过大，我们可以采用分布式配置工具来实现基于 requestId 判断的日志过滤，从而只打印我们所需请求的 DEBUG 日志。

#### 2.3.5 异常规范

1、异常处理。

很多的应用系统因为没有统一的异常处理规范，增加了人为的复杂性，具体体现在以下两个方面。

1）代码中到处充斥着异常捕获的 try/catch 的代码，搞乱了代码结构，把错误处理与正常流程混为一谈，严重影响了代码的可读性。

2）异常处理不统一，有的场景对外直接抛出异常，有的场景对外返回错误码，这种不一致性让服务的调用方摸不着头脑，增加了服务的使用成本和沟通成本。

针对以上问题，我建议在业务系统中设定两个异常，分别是 BizException（业务异常）和 SysException（系统异常），而且这两个异常都应该是 Unchecked Exception。

为什么不建议用 Checked Exception 呢？

因为它破坏了开闭原则。如果你在一个方法中抛出了 Checked Exception，而 catch 语句在 3 个层级之上，那么你就要在 catch 语句和抛出异常处理之间的每个方法签名中声明该异常。这意味着在软件中修改较低层级时，都将波及较高层级，修改好的模块必须重新构建、发布，即便它们自身所关注的任何东西都没有被改动过。

这也是 C#、Python 和 Ruby 语言都不支持 Checked Exception 的原因，因为其依赖成本要高于显式声明带来的收益。

最后，针对业务异常和系统异常要做统一的异常处理，类似于 AOP，在应用处理请求的切面上进行异常处理收敛，其处理流程如下：

```java
try {
    // 业务处理
    Response res = process(request);
}
catch (BizException e) {
    // 业务异常使用 WARN 级别
    logger.warn("BizException with error code:{},error message:{}", e.getErrorCode(), e.getErrorMsg());
}
catch (SysException ex) {
    // 系统异常使用 ERROR 级别
    log.error("System error" + ex.getMessage(), ex);
}
catch (Exception ex) {
// 兜底
log.error("System error" + ex.getMessage(), ex);
}
```

千万不要在业务处理内部到处使用 try/catch 打印错误日志，这样会使功能代码和业务代码缠绕在一起，让代码显得很凌乱，并且影响代码的可读性。

2、错误码。

错误码规范并没有统一的约定，错误码管理混乱会给后续的系统维护（特别是在理清系统业务脉络和问题定位上）带来很多麻烦。

错误码非常重要，一定要在系统搭建之初就制定好相应的规范，否则当系统上线后，系统的错误码已经对前端或者外部系统进行了透出，再重构的可能性就很小了。

不同的软件可以有不同的错误码规范策略，这里总结了以下两种方式。

1）编号错误码。

对于平台、底层系统或软件产品，可以采用编号式的编码规范，好处是编码风格固定，给人一种正式感；缺点是必须要配合文档才能理解错误码代表的意思。

例如，数据库软件 Oracle 中总共有 2000 多个异常，其编码规则是 ORA-00001~ORA-02149，每一个错误码都有对应的错误解释。

ORA-00001：违反唯一约束条件。

ORA-00017：请求会话以设置跟踪事件。

ORA-00018：超出最大会话数。

ORA-00019：超出最大会话许可数。

ORA-00023：会话引用进程私用内存；无法分离会话。

ORA-00024：单一进程模式下不允许从多个进程注册。

淘宝开放平台也采用类似的编码方式，0~100 表示平台解析错误，4 表示 User call limited（ISV 调用次数超限）。

另外要注意，对不同的错误波段，一定要预留足够的码号。例如，淘宝开放平台所用的 3 位数就显得有些拘谨，其支撑的错误数最多不能超过 100，超过 100 后，为了向后兼容，只能通过子错误码的方式进行变通处理。

2）显性化错误码。

大型分布式架构下的业务系统中，每个业务都由很多分布式服务组成，而且这些服务都提供给内部系统使用。在这种情况下，除了编号错误码之外，更推荐使用显性化的错误码。

显性化的错误码具有更强的灵活性，适合敏捷开发。例如，我们可以将错误码定义成 3 个部分： 类型 + 场景 + 自定义标识。每个部分之间用下划线连接，内容以大驼峰的方式书写。这里可以打破 Java 的常量命名规范，驼峰方式会更方便阅读。

对于错误类型，我们可以做一个约定：P 代表参数异常（ParamException）、B 代表业务异常（BizException）、S 代表系统异常（SystemException）。一个完整的示例如表 2-1 所示。

表 2-1 错误码约定示例

| 错误类型 | 错误码约定 | 举例 |
| --- | --- | --- |
| 参数异常 | P_XX_XX | P_Customer_NameIsNull: 客户姓名不能为空 |
| 业务异常 | B_XX_XX | B_Customer_NameAlreadyExist: 客户姓名已存在 |
| 系统异常 | S_XX_XX | S_Unknow_Error：未知系统错误 |

如果业务应用的错误都用这种约定来描述和表达，那么只要大家都遵守相同的规范，系统的可维护性和可理解性就会大大提升。

### 2.4 埋点规范

做互联网产品，了解用户的行为和心智很重要。有一句话叫「业务数据化、数据业务化」，即业务要沉淀数据、数据要反哺业务。对于产品经理来说，要清楚用户的第一件事情是做什么、接着还会做什么、用户的轨迹和动线是怎样的。对于运营人员来说，要清楚一次活动带来了多少访问流量、转化率如何、通过不同渠道来的用户表现怎么样、最终这些用户有多少转化成了活跃用户。

以上这些需求都可以使用「埋点技术」实现，「埋点」对于互联网运营至关重要。开源的统计分析工具很多，较常用的有谷歌分析、百度统计和腾讯分析等。无论是开源的还是自研的统计分析工具，其数据处理过程大致可以分为 5 个阶段，如图 2-3 所示。

图 2-3 数据处理的 5 个阶段

埋点规范的价值在于确保被采集上来的数据能够被统计分析，类似协议的作用，因此埋点规范已不再是可有可无的选项，而是必须要遵守的协议。如果不按照规范要求设置埋点格式，数据就无法被使用，规范的内容与具体的实现方式有关。

在阿里巴巴有一个超级位置模型（Super Position Model，SPM）的埋点规范，用于统计分析各种场景的用户行为数据。比如，淘宝社区电商业务（xTao）为外部合作伙伴（外站）提供的一套跟踪引导成交效果数据的解决方案，其中就用到了 SPM。

例如，一个跟踪点击到宝贝详情页的引导成交效果数据的 SPM 示例，其导购链接为 http:// 天猫官网 /item.htm?id=3716461318&&spm=2014.123456789.1.2。

其中，spm=2014.123456789.1.2 叫作 SPM 编码，是用于跟踪页面模块位置的编码，标准 SPM 编码由 4 段组成，采用 a.b.c.d 的格式。

a 代表站点类型，对于 xTao 合作伙伴（外站），a 为固定值，a=2014。

b 代表外站 ID（即外站所使用的 TOP appkey），比如你的站点使用的 TOP appkey=123456789，则 b=123456789。

c 代表 b 站点上的频道 ID，比如外站某个团购频道、某个逛街频道、某个试用频道等。

d 代表 c 频道上的页面 ID，比如某个团购详情页、某个宝贝详情页、某个试用详情页等。

通过基于这套规范采集的数据，我们可以利用 SPM 编码的不同层次来做不同维度的导购效果跟踪分析。

单独统计 spm 的 a 部分，我们可以知道某一类站点的访问和点击情况，以及后续引导和成交情况。

单独统计 spm 的 a.b 部分，我们可以评估某一个站点的访问和点击效果，以及后续引导和成交情况。

单独统计 spm 的 a.b.c 部分，我们可以评估某一个站点上某一频道的访问和点击效果，以及后续引导和成交情况。

单独统计 spm 的 a.b.c.d 部分，我们可以评估某一个频道上某一具体页面的点击效果，以及后续引导和成交情况。

### 2.5 架构规范

规范对于架构来说至关重要。从某种意义上来说，架构就是一组约束，遵从了这些约束，才能符合架构要求；反之，架构将失去意义。例如，你打算采用前后端分离的架构，但又不想遵守前后端分离的约束，允许部分的前端模板代码仍在后端维护，那么这个架构就失去了意义。

因此，我们在设计 COLA 应用架构时特别重视规范的设计。我们要求使用 COLA 架构的应用都遵循相同的分层原则、类似的模块化思想和分包机制。为此，我们把应用模板（基于 Maven Archetype 开发的应用脚手架）也作为 COLA 重要组成部分，更多内容可参考 12.3.3 节。

### 2.6 防止破窗

破窗效应（Broken Windows Theory）是犯罪心理学中一个著名的理论，由 James Q. Wilson 和 George L. Kelling 提出，刊于 The Atlantic Monthly 1982 年 3 月版中一篇题为「Broken Windows」的文章。此理论认为：

环境中的不良现象如果被放任存在，就会诱使人们仿效，甚至变本加厉。以一幢有少许破窗的建筑为例，如果破窗不被修理好，可能将会有破坏者破坏更多的窗户。最终，他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦而没有被清洗掉，那么很快，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。这个现象，就是犯罪心理学中的「破窗效应」。

「第一扇破窗」常常是事情恶化的起点。

从「破窗效应」中我们可以得到这样一个道理：任何一种已存在的不良现象都在传递着一种信息，会导致不良现象无限扩展，同时必须高度警觉那些看起来是偶然的、个别的、轻微的「过错」，如果对「过错」不闻不问、熟视无睹、反应迟钝或纠正不力，就会纵容更多的人「去打烂更多的窗户」，极有可能演变成「千里之堤，溃于蚁穴」的恶果。

在软件工程中，「破窗效应」可谓是屡见不鲜。面对一个混乱的系统和一段杂乱无章的代码，后来人往往会加入更多的垃圾代码。这也凸显了规范和重构的价值。首先，我们要有一套规范，并尽量遵守规范，不要做「打破第一扇窗」的人；其次，发现有「破窗」，要及时地修复，不要让事情进一步恶化。整洁的代码需要每个人的精心呵护，需要整个团队都具备一些工匠精神。

## 0301. 函数

把简单的事情做到极致，功到自然成，最终「止于至善」。

—— 秋山利辉《匠人精神》

### 本章小结

函数是软件系统中的核心要素，无论采用哪种编程范式和编程语言，程序逻辑都是写在函数中的，因此编写好函数是编写好代码的基础。一个系统容易腐化的部分正是函数，不解决函数的复杂性，就很难解决系统的复杂性。

虽然函数不像面向对象技术那么复杂，但要写好函数也不是一件容易的事。在本章中，我们从函数参数、函数职责、函数写法（短小、优化判空和优化缓存等）、函数抽象（组合模式、SLAP），到函数式的代码风格，介绍了如何写好一个函数，怎样让函数更易于理解、更加简洁。掌握了这些技艺，有助于我们写出更好的函数。

### 3.0

函数作为程序中最小的、最重要的逻辑单元，其在软件开发中的重要性不言而喻。如果将数据比作一道菜，那么函数就是菜谱，程序员就是厨师。相同的菜，有不同的做法，由不同的厨师做出来，味道会截然不同。

自从面向对象技术出来以后，很多工程师们把精力更多放在了对象技术上，反而忽视了函数。实际上，面向对象和写好函数并不冲突，函数也是对象的重要组成部分。相比于面向对象技术体系的深奥，写好函数要容易得多。

本章将介绍一些写好函数的技艺，好的函数能够大大降低阅读代码的困难度，提升代码的可读性。在通往匠人的路上，写好函数必不可少。

### 3.1 什么是函数

函数（function）作为数学概念，最早由我国清朝数学家李善兰翻译，出自其著作《代数学》。之所以这么翻译，他给出的理由是「凡此变数中函彼变数者，则此为彼之函数」，即函数指一个量随着另一个量的变化而变化，或者说一个量中包含另一个量。

以 f(x) = 2x + 1 为例，x 是自变量，当 x = 2 时，f(x) = 5，f(x) 是 x 的函数。

### 3.2 软件中的函数

在计算机编程中，函数的作用和数学中的定义类似。函数是一组代码的集合，是程序中最小的功能模块，一次函数调用包括接收参数输入、数据处理、返回结果。同一个函数可以被一个或多个函数调用任意多次。

2『这里有关函数的定义，做一张术语卡片。（2021-10-14）』

实际上，在软件体系中，关于函数有 3 个概念：子程序（Subroutine）、函数（Function）和方法（Method）。在不同的历史阶段，不同的编程语言对「函数」的解释和称呼会有所不同。其中，子程序是比较老的概念，现在基本已经不再用这个概念了；函数是最通用的叫法，特别是随着函数式编程、FaaS（Function as a Service）等概念的兴起，函数被提及得越来越多；方法则是面向对象语言中对函数的叫法。

在英语中，Function 一般代表函数式语言中的函数，而 Method 代表面向对象语言中的函数。但是在中文技术书籍中，将 Method 翻译成「方法」和「函数」的都有，我觉得两种译法都可以。在本书中，「函数」和「方法」都会被用到，在面向对象的语境下大多使用「方法」，其他场景会尽量使用「函数」。

### 3.3 封装判断

好的函数应该是清晰易懂的，我们先从一个简单又实用的函数重构技法说起。如果没有上下文，if 和 while 语句中的布尔逻辑就难以理解。如果把解释条件意图作为函数抽离出来，用函数名把判断条件的语义显性化地表达出来，就能立即提升代码的可读性和可理解性。

下面来看一个例子，在我们的 CRM 系统中，需要判断一个客户是否可以被业务员捡入自己的私海库 [1]。原来的代码是这样写的：

```java
if (customer.getCrmUserId().equals(NIL_VALUE) && customer.getCustomerGroup() != CustomerGroup. CANCEL_ GROUP) {
    privateSea.pickUp(customer);
}
```

在上述代码中，if 后面的判断条件令人十分费解，原因是缺少封装和合理的命名，我们可以用封装判断将其改写成：

```java
if (canPickUpToPrivateSea()) {
    privateSea.pickUp(customer);
}

private boolean canPickUpToPrivateSea() {
    if (StringUtil.isBlank(this.getCrmUserId())) {
        return false;
    }
    if (this.getCustomerGroup() == CustomerGroup.CANCEL_GROUP) {
        return false;
    }
    return true;
}
```

不难发现，重构后的代码要更容易理解，因为通过封装判断，判断条件的业务语义被显性化地表达出来了，代码的可读性自然也好了很多。

[1] 私海库：CRM 中的业务概念，表示销售人员自己专属的客户资源库。公海库：CRM 中的业务概念，表示所有销售人员共享的客户资源库。

### 3.4 函数参数

最理想的参数数量是零（零参数函数），其次是一（一元函数），再次是二（二元函数），应尽量避免三（三元函数）。有足够特殊的理由，才能用 3 个以上参数（多元函数）。当然凡事也不是绝对的，关键还是看场景，在程序设计中，一大忌讳就是教条。在某些场景下，两个参数可能比一个参数好。例如，`Point p = new Piont(0 , 0);`，两个参数就比一个参数要合理，坐标系中的点就应该有两个参数。如果看到 `new Point (0)`，我们会倍感惊讶。

总体上来说，参数越少，越容易理解，函数也越容易使用和测试，因为各种参数的不同组合的测试用例是一个笛卡儿积。如果函数需要 3 个以上参数，就说明其中一些参数应该封装为类了。例如，要绘制一条直线，可以用如下函数声明：

```java
Line makeLine(double startX, double startY, double endX, double endY);
```

上述代码中的 X 和 Y 是作为一组概念被共同传递的，我们应该为这一组概念提供一个新的抽象，叫作 Point。这样将参数对象化之后，参数的个数减少了，表达上也更加清晰。

```java
Line makeLine(Point start, Point end);

class Point {
    double x;
    double y;
}
```

### 3.5 短小的函数

Robert C. Martin 有一个信条：函数的第一规则是要短小，第二规则是要更短小。维护过遗留系统、受过超长函数折磨的读者应该深有体会，相比于 3000 行代码的「庞然大物」，肯定是更短小的函数更易于理解和维护。

有时保持代码的逻辑不变，只是把长方法改成多个短方法，代码的可读性就能提高很多。超长方法是典型的代码「坏味道」，对超长方法的结构化分解是提升代码可读性最有效的方式之一。

那么函数的代码行数多长才合适呢？

这没有一个绝对的量化标准，各团队可以有自己的标准，不同的开发语言可能会稍有不同。如果是 Java 语言，我建议一个方法不要超过 20 行代码，当我把这个规定作为团队代码审查的硬性指标后，发现代码质量得到了显著的改善。

### 3.6 职责单一

按照行数规定函数的长度是定量的做法，实际上，我更喜欢另一种定性的衡量方法，即：一个方法只做一件事情，也就是函数级别的单一职责原则（Single Responsibility Principle，SRP）。

遵循 SRP 不仅可以提升代码的可读性，还能提升代码的可复用性。因为职责越单一，功能越内聚，就越有可能被复用，这和代码的行数没有直接的关联性，但是有间接的关联性。

通常，长方法意味着肯定需要拆分，需要用多个子函数的组合来进行更好的表达。然而短小的函数并不一定就意味着就不需要拆分，只要不满足 SRP，就值得进一步分解。哪怕分解后的子函数只有一行代码，只要有助于业务语义显性化的表达，就是值得的。

举例说明，下面是一个给员工发工资的简单方法：

```java
public void pay(List<Employee> employees) {
    for (Employee e: employees) {
        if (e.isPayDay()) {
            Money pay = e.calculatePay();
            e.deliverPay(pay);
        }
    }
}
```

这段代码非常短小，但实际上做了 3 件事情：遍历所有雇员，检查是否该发工资，然后支付薪水。按照 SRP 的原则，以下面的方式改写更好：

```java
public void pay(List<Employee> employees) {
    for (Employee e: employees){
        payIfNecessary(e);
    }
}

private void payIfNecessary(Employee e) {
    if (e.isPayDay()){
        calculateAndDeliverPay(e);
    }
}

private void calculateAndDeliverPay(Employee e) {
    Money pay = e.calculatePay();
    e.deliverPay(pay);
}
```

虽然原来的方法并不复杂，但按照 SRP 分解后的代码显然更加容易让人读懂，这种拆分是有积极意义的。基本上，遵循 SRP 的函数都不会太长，再配上合理的命名，就不难得到我们想要的短小的函数。

### 3.7 精简辅助代码

所谓的辅助代码（Assistant Code），是程序运行中必不可少的代码，但又不是处理业务逻辑的核心代码，比如判空、打印日志、鉴权、降级和缓存检查等。这些代码往往会在多个函数中重复冗余，减少辅助代码可以让代码显得更加干净整洁，易于维护。

如果辅助代码太多，会极大地干扰代码的可读性，读这种代码会让人抓狂，摸不着头脑。因此，我们应该尽量减少辅助代码对业务代码的干扰。让函数中的代码能直观地体现业务逻辑，而不是让业务代码淹没在辅助代码中。

#### 3.7.1 优化判空

空指针的发明人 Charles Antony Richard Hoare 曾表示对发明空指针的忏悔，说这是一个数十亿美元的错误。为了不抛出 NPE（Null Pointer Exception），我们经常可以看到 `if (obj == null) return;` 的代码，其本身并没有什么问题，也是为了代码的健壮性。只是这样的判空代码多了，会干扰阅读代码的流畅性。

下面来看一个简单的示例，假如我们要获取一个如下的稍有一定嵌套深度的属性值。

```java
String isocode = user.getAddress(). getCountry(). getIsocode(). toUpperCase();
```

因为任何访问对象方法或属性的调用都可能导致 NPE，因此如果我们要确保不触发异常，就得在访问每一个值之前对其进行明确的检查：

```java
if (user != null) {
    Address address = user.getAddress();
    if (address != null) {
        Country country = address.getCountry();
        if (country != null) {
            String isocode = country.getIsocode();
            if (isocode != null) {
                isocode = isocode.toUpperCase();
            }
        }
    }
}
```

Java 8 引入了一个很有趣的特性 —— Optional 类。Optional 类主要解决的问题是「臭名昭著」的空指针异常。Optional 类是一个包含可选值的包装类，意味着 Optional 类既可以含有对象，也可以为空。使用 Java 8 的这个新特性和新语法，我们可以用 Optional 来代替冗长的 null 检查：

```java
String isocode = Optional.ofNullable(user)
    .flatMap(User::getAddress)
    .flatMap(Address::getCountry)
    .map(Country::getIsocode)
    .orElse("default");
```

可以看到，新的写法比旧的判空方式在复杂度和简洁性上都提升了很多，简洁也是一种美。

#### 3.7.2 优化缓存判断

缓存作为应用的重要基础设施，有着非常广泛的使用场景，我们先看一段查询商品信息的缓存实现代码：

```java
public List<Product>getProducts(List<Long>productIds) {
        ...
    List<Product> products = new ArrayList(productIds.size());
    //查询有哪些未命中的商品 ID
    List<Long> notHitIds = productIds.stream().filter(productId -> {
        StringcacheKey = computeKey(productId);
        //从缓存中进行查找
        Result<DataEntry> result = tairManager.get(namespace, cacheKey);
        if (!result.isSuccess()) {
            log.error(
                    String.format("tairgetwithkey(%s)causeerror:%s", cacheKey, result.getRc().getMessage()));
            returntrue;
        }

        if (ResultCode.DATANOTEXSITS.equals(result.getRc())) {
            returntrue;
        }

        Productproduct = result.getValue() == null ? null : result.getValue().getValue();

        if (product == null) {
            returntrue;
        }

        products.add(product);
        returnfalse;
    }).collect(Collectors.toList());

    //未命中缓存的商品 ID 从 DB 中查找
    List<Product> productsFromDB = notHitIds.stream().map(productId -> getProductsFromDb(productId)).collect(
            Collectors.toList());
    products.addAll(productsFromDB);
        ...
    return products;
}
```

该方法的功能其实很简单，就是根据传入的 productId 集合批量查询 Product，由于实现逻辑中夹杂着缓存逻辑，所以整体代码显得臃肿，让人看着很不舒服。

实际上，我们完全可以自研一个缓存框架，使用注解（Annotation）来代替这些铅板代码（Boilerplate Code）。如果使用这种方式重构上面的代码，可以得到如下代码：

```java
@MultiCacheable(cacheNames = "product")
public List<Product> getProducts(@CacheKeyList List<Long> productIds, @CacheNotHit List<Long> notExistIds) {
    return notExistIds.stream().map(productId -> getProductsById (productId)). collect(Collectors.toList());
}
```

可以看到，重构后的代码清晰了很多。而我们现在只需要关注业务逻辑本身，缓存这个技术细节的辅助代码被从业务逻辑中剥离出去，并进行统一维护，既减少了重复，又避免了和具体缓存实现的耦合，可谓是一举多得。

#### 3.7.3 优雅降级

在分布式环境下，一个功能往往需要多个服务的协作才能完成。对于那些对可用性要求非常高的场景，有必要制定一个服务降级的策略，以便当其中一个服务不可用时，我们仍然能够对外提供服务。

针对上述问题，Spring Cloud Hystrix 为我们提供了一个非常优雅的解决方案。利用 Hystrix 提供的 API，我们可以使用注解的方式定义降级服务，从而不用在业务逻辑里面使用 try/catch 来做异常情况下的服务降级。一个典型的 Hystrix 的服务降级代码如下所示：

```java
public class UserService {
    @Autowired
    private RestTemplate restTemplate;
    @HystrixCommand(fallbackMethod = "defaultUser")
    public User getUserById(Long id) {
        return restTemplate.getForObject("http://USER-SERVICE/users/{1}", User.class, id);
    }
    // 在远程服务不可用时，使用降级方法：defaultUser
    public User defaultUser() {
        return new User();
    }
}
```

### 3.8 组合函数模式

组合函数模式（Composed Method Pattern）出自 Kent Beck 的 Smalltalk Best Practice Patterns 一书，是一个非常容易理解上手、实用，对代码可读性和可维护性起到立竿见影效果的编程原则。

组合函数要求所有的公有函数（入口函数）读起来像一系列执行步骤的概要，而这些步骤的真正实现细节是在私有函数里面。组合函数有助于代码保持精炼并易于复用。阅读这样的代码就像在看一本书，入口函数是目录，目录的内容指向各自的私有函数，而具体的内容是在私有函数里实现的。

每次我在做代码审查的时候，都可以发现能够用组合函数进行重构改善的代码。在开源软件中，也时常可以看到利用组合函数优化代码的例子。

以 Spring 中 BeanUtils 的 copyProperties 函数为例，它要实现的功能是将一个 source 类的中字段复制到 target 类中。在 Spring 中，其实现代码如下：

```java
public static void copyProperties(Object source, Object target, Class <?> editable, String... ignoreProperties)
throws BeansException {
    Assert.notNull(source,"Sourcemustnotbenull");
    Assert.notNull(target,"Targetmustnotbenull");
    Class<?>actualEditable=target.getClass();
    if (editable!= null) {
        if (!editable.isInstance(target)) {
            thrownew
            IllegalArgumentException("Targetclass["+target.getClass().getName()+"]notassignabletoEditableclass["+editable.getName()+"]");
        }
        actualEditable=editable;
    }

    PropertyDescriptor[]targetPds=getPropertyDescriptors(actualEditable);
    List<String>ignoreList=(ignoreProperties!= null?Arrays.asList(ignoreProperties):null);
    for (PropertyDescriptortargetPd:targetPds) {
        MethodwriteMethod=targetPd.getWriteMethod();
        if (writeMethod != null && (ignoreList==null || !ignoreList.contains(targetPd.getName()))) {
            PropertyDescriptorsourcePd=getPropertyDescriptor(source.getClass(),targetPd.getName());
            if (sourcePd != null) {
                MethodreadMethod=sourcePd.getReadMethod();
                if (readMethod != null && ClassUtils.isAssignable(writeMethod.getParameterTypes()[0],readMethod.getReturnType())) {
                    try{
                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {
                            readMethod.setAccessible(true);
                        }

                        Objectvalue=readMethod.invoke(source);
                        if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {
                            writeMethod.setAccessible(true);
                        }
                        writeMethod.invoke(target,value);
                    }
                    catch (Throwableex) {
                        thrownew FatalBeanException("Couldnotcopyproperty'"+targetPd.getName()+"'fromsourcetotarget",ex);
                    }
                }
            }
        }
    }
}
```

很明显，上述代码实现中的函数过长，全是细节的平铺，不够直观。我们可以按照组合函数的方式对其进行重构，经过分析，不难发现这个函数做了两件事：一是「判断能不能 copy」，二是「执行 copy」。因此，入口函数可以拆分成如下两个步骤：

```java
private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) {
    checkSourceAndTarget(source, target, editable);
    copySourceToTarget(source, getPropertyDescriptors(actualEditable));
}
```

再看看具体的 copy 过程，也就是逐个把字段（property）相同的值进行复制，实际上做了下面 4 件事情。1）从 target 获取 writeMethod。2）从 source 获取对应的 readMethod。3）判断是否可以 copy。4）执行 copy。

按照上面的拆解，我们可以将 copySourceToTarget() 进一步分解如下：

```java
private static void copySourceToTarget(Object source, PropertyDescriptor[] targetPds) {
    for (PropertyDescriptor targetPd : targetPds) {
        copyProperty(source, targetPd);
    }
}

private static void copyProperty(Object source, PropertyDescriptor targetPd) {
    Method writeMethod = getWriteMethodFromTarget(targetPd);
    Method readMethod = getReadMethodFromSource(source, targetPd);
    if (canCopy(writeMethod, readMethod)) {
        doRealCopy(source, targetPd, writeMethod, readMethod);
    }
}

private static boolean canCopy(Method writeMethod, Method readMethod) {
    return readMethod != null &&
    ClassUtils.isAssignable(writeMethod.getParameterTypes() [0], readMethod.getReturnType());
}

private static Method getWriteMethodFromTarget(PropertyDescriptor targetPd) {
    return targetPd.getWriteMethod();
}

private static Method getReadMethodFromSource(Object source, PropertyDescriptor targetPd) {
    PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());
    if (sourcePd == null) {
        return null;
    }
    return sourcePd.getReadMethod();
}

private static void doRealCopy(Object source, PropertyDescriptor targetPd, Method writeMethod, Method readMethod) {
}
```

可以看到，重构后的代码相比重构前的代码，无论是在可读性还是可理解性上，都提升了很多。

类似的案例还有很多，而且并不会涉及什么高深的思想，只要我们愿意，很多时候只需要多做一点点，就可以写出更好的代码，这也是「工匠精神」的一种体现。

就像 Kent Beck 说的：「我不是一个伟大的程序员，只是习惯比较好而已。」只有养成精益求精、追求卓越的习惯，才能保持精进，写出好的代码。

### 3.9 SLAP

抽象层次一致性（Single Level of Abstration Principle，SLAP），是和组合函数密切相关的一个原则。组合函数要求将一个大函数拆成多个子函数的组合，而 SLAP 要求函数体中的内容必须在同一个抽象层次上。如果高层次抽象和底层细节杂糅在一起，就会显得凌乱，难以理解。

举个例子，假如有一个冲泡咖啡的原始需求，其制作咖啡的过程分为 3 步。1）倒入咖啡粉。2）加入沸水。3）搅拌。

其伪代码（pseudo code）如下：

```java
public void makeCoffee() {
    pourCoffeePowder();
    pourWater();
    stir();
}
```

如果要加入新的需求，比如需要允许选择不同的咖啡粉，以及选择不同的风味，那么代码就会变成这样：

```java
public void makeCoffee(boolean isMilkCoffee, boolean isSweetTooth, CoffeeType type) {
// 选择咖啡粉
if (type == CAPPUCCINO) {
    pourCappuccinoPowder();
}

else if (type == BLACK) {
    pourBlackPowder();
}

else if (type == MOCHA) {
    pourMochaPowder();
}

else if (type == LATTE) {
    pourLattePowder();
}

else if (type == ESPRESSO) {
    pourEspressoPowder();
}

// 加入沸水
pourWater();

// 选择口味
if (isMilkCoffee) {
    pourMilk();
}

if (isSweetTooth) {
    addSugar();
}

// 搅拌
stir();

}
```

如果继续有更多的需求加入，那么代码会进一步恶化，最后变成一个谁也看不懂且难以维护的逻辑迷宫。

再回看上面的代码，新需求的引入当然是根本原因。但除此之外，另一个原因是新代码已经不再满足 SLAP 了。具体选择用什么样的咖啡粉是倒入咖啡粉这个步骤应该去考虑的实现细节，和主流程步骤不在一个抽象层次上。同理，加奶和加糖也是实现细节。

因此，在引入新需求以后，制作咖啡的主要步骤从原来的 3 步变成了 4 步。1）倒入咖啡粉，会有不同的选择。2）加入沸水。3）调味，根据需求加糖或加奶。4）搅拌。

按照组合函数和 SLAP 原则，我们要在入口函数中只显示业务处理的主要步骤。具体的实现细节通过私有方法进行封装，并通过抽象层次一致性来保证，一个函数中的抽象在同一个水平上，而不是高层抽象和实现细节混杂在一起。

根据 SLAP 原则，我们可以将代码重构为：

```java
public void makeCoffee(boolean isMilkCoffee, boolean isSweetTooth, CoffeeType type) {
    // 选择咖啡粉
    pourCoffeePowder(type);
    // 加入沸水
    pourWater();
    // 选择口味
    flavor(isMilkCoffee, isSweetTooth);
    // 搅拌
    stir();
}

private void flavor(boolean isMilkCoffee, boolean isSweetTooth) {
    if (isMilkCoffee) {
        pourMilk();
    }
    if (isSweetTooth) {
        addSugar();
    }
}

private void pourCoffeePowder(CoffeeType type) {
    if (type == CAPPUCCINO) {
        pourCappuccinoPowder();
    }
    else if (type == BLACK) {
        pourBlackPowder();
    }
    else if (type == MOCHA) {
        pourMochaPowder();
    }
    else if (type == LATTE) {
        pourLattePowder();
    }
    else if (type == ESPRESSO) {
        pourEspressoPowder();
    }
}
```

重构后的 makeCoffee() 又重新变得整洁如初了，满足 SLAP 实际上是构筑了代码结构的金字塔。金字塔结构是一种自上而下的，符合人类思维逻辑的表达方式。关于金字塔原理的更多内容，请参考 8.5.3 节。

在构筑金字塔的过程中，要求金字塔的每一层要属于同一个逻辑范畴、同一个抽象层次。在这一点上，金字塔原理和 SLAP 是相通的，世界就是如此奇妙，很多道理在不同的领域同样适用。

上面列举了 Spring 源码中的一个「坏味道」，接下来我们来看 Spring 的「好味道」。在 Spring 中，做上下文初始化的核心类 AbstractApplicationContext 的 refresh() 函数为我们在遵循 SLAP 方面做了一个很好的示范。

```java
public void refresh()

throws BeansException,IllegalStateException {
synchronized (
    this.startupShutdownMonitor) {
        // Prepare this context for refreshing.
        prepareRefresh();
        // Tell the subclass to refresh the internal bean factory.
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        // Prepare the bean factory for use in this context.
        prepareBeanFactory(beanFactory);
        try {
            // Allows post-processing of the bean factory in context subclasses.
            postProcessBeanFactory(beanFactory);
            // Invoke factory processors registered as beans in the context.
            invokeBeanFactoryPostProcessors(beanFactory);
            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);
            // Initialize message source for this context.
            initMessageSource();
            // Initialize event multicaster for this context.
            initApplicationEventMulticaster();
            // Initialize other special beans in specific context subclasses.
            onRefresh();
            // Check for listener beans and register them.
            registerListeners();
            // Instantiate all remaining(non-lazy-init)singletons.
            finishBeanFactoryInitialization(beanFactory);
            // Last step: publish corresponding event.
            finishRefresh();
        }
        catch(BeansException ex) {
            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();
            // Reset 'active' flag.
            cancelRefresh(ex);
            // Propagate exception to caller.
            throw ex;
        }
        finally {
            // Reset common introspection caches in Spring's core,
            // since we might not ever need metadata for singleton
            // beans anymore
            ...
            resetCommonCaches();
        }
    }
}
```

试想，如果上面的代码逻辑不是这样写，而是平铺在 refresh() 函数中，结果会是怎样？

### 3.10 函数式编程

函数式编程和面向对象编程并没有本质上的区别。在函数式编程中，函数不仅可以调用函数，也可以作为参数被其他函数调用。从这个角度看，对象在作为值被传递时，也是对业务逻辑的封装，只不过它不仅包含函数，还包含属性。

函数式和面向对象的差异更多体现在编程风格上。函数式的风格在某些场景下可以让代码变得更加简洁、优雅，这也是 Java 8 要引入函数式的原因。在 Java 8 之前，「值」是非常重要的，因为编程语言的整个目的就在于操作值，参数传递只有值传递（包括原始对象和引用对象的值）。在 Java 8 之后，Java 需要同样重视「函数」。

函数式编程中最重要的特征之一，就是你可以把函数（你的代码）作为参数传递给另一个函数。为什么这个功能很重要呢？主要有以下两个原因。

1、减少冗余代码，让代码更简洁、可读性更好。

2、函数是「无副作用」的，即没有对共享的可变数据操作，可以利用多核并行处理，而不用担心线程安全问题。

例如，同样是实现 String 到 Integer 转化的功能，按照代码冗余程度排序，经典类大于匿名类，匿名类大于 Lamda（匿名函数），Lamda 大于方法引用。接下来，我们分别来看 4 种不同方式的代码实现。

1、经典类实现。

```java
// 经典类
Function<String, Integer> strToIntClass = new StrToIntClass();

public static class StrToIntClass implements Function<String, Integer> {
    @Override
    public Integer apply(String s) {
        return Integer.parseInt(s);
    }
}
```

2、匿名类实现。

```java
// 匿名类
Function<String, Integer>  strToIntAnanymousClass = new Function <String, Integer>() {
    @Override
    public Integer apply(String s) {
        return Integer.parseInt(s);
    }
};
```

3、Lamda 实现。

```java
// Lamda
Function<String, Integer> strToIntLammda = s -> Integer.parseInt(s);
```

4、方法引用实现。

```java
// 方法引用
Function<String,Integer> strToIntMethodRefrence = Integer::parseInt;
```

可以明显地看到，函数式编程的代码量更少，实现上更优雅、简洁。简洁也是控制复杂度的重要手段之一。

## 0401. 设计原则

每个人都有义务捍卫、遵守或完善原则。原则可以修正，但是不能肆意妄为。

—— 瑞·达利欧《原则》

### 本章小结

本章介绍的设计原则能够指导我们编写出更好的代码。但还是那句话，不要教条，软件是一种平衡的艺术。要清楚一点，我们不是为了满足这些原则而工作的，原则只是背后的指导思想。我们的目的是构建可用的软件系统，并尽量减少系统的复杂度。在不能满足所有原则时，要懂得适当取舍。

### 4.0

所谓原则，就是一套前人通过经验总结出来的，可以有效解决问题的指导思想和方法论。遵从原则，可以事半功倍；反之，则有可能带来麻烦。

在软件设计领域中，有很多这样的原则，遵从这些设计原则可以有效地指导我们设计出更灵活、易于扩展和维护的软件系统。需要注意的是，和其他道理一样，原则并非是形而上学的静态客观真理，不是说每一个设计都要教条地遵守每一个原则，而是要根据具体情况进行权衡和取舍。

### 4.1 SOLID 概览

SOLID 是 5 个设计原则开头字母的缩写，其本身就有「稳定的」的意思，寓意是「遵从 SOLID 原则可以建立稳定、灵活、健壮的系统」。5 个原则分别如下。

Single Responsibility Principle（SRP）：单一职责原则。

Open Close Principle（OCP）：开闭原则。

Liskov Substitution Principle（LSP）：里氏替换原则。

Interface Segregation Principle（ISP）：接口隔离原则。

Dependency Inversion Principle（DIP）：依赖倒置原则。

SOLID 最早由 Robert C. Martin 在 2000 年的论文「Design Principles and Design Patterns」中引入。在 2004 年前后，Michael Feathers 提醒 Martin 可以调整一下这些原则的顺序，那么它们的首字母的缩写就可以排列成 SOLID。这个新名字的确促进了 SOLID 思想的传播，再一次证明了命名的重要性。

SOLID 原则之间并不是相互孤立的，彼此间存在着一定关联，一个原则可以是另一个原则的加强或基础；违反其中的某一个原则，可能同时违反了其他原则。其中，开闭原则和里氏代换原则是设计目标；单一职责原则、接口分隔原则和依赖倒置原则是设计方法。

2『开闭原则和里氏代换原则是设计目标，单一职责、接口隔离、依赖倒置原则是设计方法。做一张任意卡片。（2021-11-06）』—— 已完成

### 4.2 SRP

任何一个软件模块中，应该有且只有一个被修改的原因。

SRP 要求每个软件模块职责要单一，衡量标准是模块是否只有一个被修改的原因。职责越单一，被修改的原因就越少，模块的内聚性（Cohesion）就越高，被复用的可能性就越大，也更容易被理解。

例如，有一个 Rectangle 类（如图 4-1 所示），该类包含两个方法，一个方法用于把矩形绘制在屏幕上，另一个方法用于计算矩形的面积。

图 4-1 Rectangle 类

按照 SRP 的定义，Rectangle 类是违反了 SRP 原则的。因为 Rectangle 类具有至少两个职责，不管是改变绘制逻辑，还是面积计算逻辑，都要改动 Rectangle 类。

为了遵从 SRP 原则，我们需要把两个职责分离出来，放在两个不同的类中，这样就可以互相不影响了。最简单的解决方案是将数据与函数分离，如图 4-2 所示。设计两个用来做逻辑处理的类，每个类只包含与之相关的函数代码，互相不可见，这样就不存在互相依赖的情况了。

图 4-2 数据和函数分离

上面的方式有点「贫血」模式的味道。我们也可以采用面向对象的做法，把重要的业务逻辑与数据放在一起，然后用 Rectangle 类来调用其他没那么重要的函数，如图 4-3 所示。

图 4-3 业务逻辑和数据在一起

另外，SRP 不仅在模块和类级别适用，在函数级别同样适用，3.6 节中已经介绍了如何做到函数级别的 SRP。

### 4.3 OCP

软件实体应该对扩展开放，对修改关闭。

对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其进行任何修改。

为什么 OCP 这么重要？因为可扩展性是我们衡量软件质量的一个重要指标。在软件的生命周期内，更改是难免的，如果有一种方案既可以扩展软件功能，又可以不修改原代码，那是我们梦寐以求的。因为不修改就意味着不影响现有业务，新增的代码不会对既有业务产生影响，也就不会引发漏洞。

在面向对象设计中，我们通常通过继承和多态来实现 OCP，即封装不变部分。对于需要变化的部分，通过接口继承实现的方式来实现「开放」。因此，区别面向过程语言和面向对象语言最重要的标志就是看它是否支持多态。

实际上，很多的设计模式都以达到 OCP 目标为目的。例如，装饰者模式，可以在不改变被装饰对象的情况下，通过包装（Wrap）一个新类来扩展功能；策略模式，通过制定一个策略接口，让不同的策略实现成为可能；适配器模式，在不改变原有类的基础上，让其适配（Adapt）新的功能；观察者模式，可以灵活地添加或删除观察者（Listener）来扩展系统的功能。

当然，要想做到绝对地「不修改」是比较理想主义的。因为业务是不确定的，没有谁可以预测到所有的扩展点，因此这里需要一定的权衡，如果提前做过多的「大设计」，可能会犯 YAGNI（You Ain't Gonna Need It）的错误。

### 4.4 LSP

程序中的父类型都应该可以正确地被子类型替换。

里氏替换原则由 2008 年图灵奖得主、美国第一位计算机科学女博士 Barbara Liskov 教授和卡内基·梅隆大学的 Jeannette Wing 教授于 1994 年提出。

LSP 认为「程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的」，即子类应该可以替换任何基类能够出现的地方，并且经过替换后，代码还能正常工作。

根据 LSP 的定义，如果在程序中出现使用 instanceof、强制类型转换或者函数覆盖，很可能意味着是对 LSP 的破坏。

#### 4.4.1 警惕 instanceof

如果我们发现代码中有需要通过强制类型转换才能使用子类函数的情况，或者要通过 instanceof 判断子类类型的地方，那么都有不满足 LSP 的嫌疑。

出现这种情况的原因是子类使用的函数没有在父类中声明。在程序中，通常使用父类来进行定义，如果一个函数只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该函数。

可以通过 提升抽象层次来解决此问题，也就是将子类中的特有函数用一种更抽象、通用的方式在父类中进行声明。这样在使用父类的地方，就可以透明地使用子类进行替换了，具体做法请参考 8.5.2 节。

#### 4.4.2 子类覆盖父类函数

子类方法覆盖（Override）了父类方法，并且改变了其含义。这样在做里氏替换时，就会出现意想不到的问题。

在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反之，则不成立。如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

有时，现实世界中「is-a」的关系，在软件设计中不一定适合使用继承关系。好的继承应该是子类可以替换任何父类出现的地方，而不出现问题。如果两个实体有内在的「is-a」的关系，但是在外在行为上表现并不一致，我们就需要警惕继承在此是不是最合适的了。

例如，正方形是一个矩形，但是如果你把正方形设计成矩形的子类，就会出现一些意想不到的问题。以计算面积为例，矩形是 a 乘以 b，而正方形是 a 的平方，它们在含义上是有区别的。

假如 Rectangle 类是如下形式：

```java
public class Rectangle {
    protected int width;
    protected int height;
    public void setWidth(int width) {
        this.width = width;
    }
    public void setHeight(int height) {
        this.height = height;
    }
    public int area() {
        return width * height;
    }
}
```

现在我们想要用 Square 去继承 Rectangle，并且复用其计算面积的方法。为了适配 Rectangle 的行为，我们可以在 Square 做 set 操作时做一些判断，如果不符合正方形的定义，则抛出异常，其代码如下：

```java
public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        throw new RuntimeException("setWidth is not available for Square");
    }
    @Override
    public void setHeight(int height) {
        throw new RuntimeException("setHeight is not available for Square");
    }
    public void setLength(int length) {
        this.width =
        this.height = length;
    }
}
```

这样的设计实际上破坏了 LSP 原则，因为在 Retangle 出现的地方使用 Square 进行替换，就会抛出异常。实际上，这也是一个著名的设计问题 —— 正方形 - 矩形问题（Square-rectangle Problem），有兴趣的读者可以探索更多解法。

### 4.5 ISP

多个特定客户端接口要好于一个宽泛用途的接口。

接口隔离原则认为不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。

我们先分别来看不遵循 ISP（见图 4-4）和遵循 ISP（见图 4-5）。

图 4-4 未遵循 ISP 的示例

图 4-5 遵循 ISP 的示例

对比二者可以发现，遵循 ISP 的做法，在依赖关系和语义的表达上会更加精确。类 A 不需要用到「方法 4」和「方法 5」，就可以选择不依赖他们。

在做接口拆分时，我们也要满足单一职责原则，让一个接口的职责尽量单一，而不是像图 4-4 中那样无所不包。满足 ISP 之后，最大的好处是可以将外部依赖减到最少。你只需要依赖你需要的东西，这样可以降低模块之间的耦合（Couple）。

### 4.6 DIP

模块之间交互应该依赖抽象，而非实现。

DIP 要求高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖抽象。

类不是孤立的，一个类需要依赖于其他类来协作完成工作。但是这种依赖不应该是特定的具体实现，而应该依赖抽象。也就是我们通常所说的要「 面向接口编程」。然而「面向接口编程」只是实现 DIP 的一个技法，DIP 本身的意义要宽泛得多，它是一种思想，是一种软件设计的哲学。

这个原则实在是太重要了，社会化分工协作在某种意义上也是在遵从 DIP。例如，一个生产计算机主板的公司，其显卡插槽肯定是按照业界标准接口（共同抽象）来设计的，而不会设计成只支持某个特定公司的显卡。这样，只要主板公司和显卡公司都依赖同一个抽象（显卡接口协议），就能实现互通了。

遵循 DIP 会大大提高系统的灵活性。如果类只关心它们用于支持的特定契约，而不是特定类型的组件，就可以快速而轻松地修改这些低级服务的功能，同时最大限度地降低对系统其余部分的影响。

例如，在 Java 应用中使用 Logger 框架有很多选择，比如 log4j、logback、common logging 等。每个 Logger 的 API 和用法都稍有不同，有的需要用 isLoggable () 来进行预判断，以便提高性能，有的则不需要。如果要切换不同的 Logger 框架，会非常复杂，可能要改动很多地方。产生这些问题的原因是我们直接依赖了 Logger 框架，应用和 Logger 框架强耦合在一起了。

我曾维护过的一个阿里巴巴的交易系统，其中就有非常复杂的 Logger 依赖关系，如图 4-6 所示。

图 4-6 复杂的 Logger 依赖关系

导致这种复杂依赖的根源，是引用直接依赖了 Logger 框架（见图 4-7），导致后续的 Logger 框架升级必须要保持向后兼容，最终形成了图 4-6 中复杂的依赖关系。

图 4-7 直接依赖 Logger

实际上，只要遵循依赖倒置原则（如图 4-8 所示），这类问题就会很容易解决。依赖倒置，就是要反转依赖的方向，让原来紧耦合的依赖关系得以解耦，这样依赖方和被依赖方都有更高的灵活度。

图 4-8 依赖倒置后的 Logger 依赖

所以我强烈建议所有的业务系统都应该有这样一个 Logger 抽象，来屏蔽对具体 Logger 框架的依赖。这也是为什么我们要在 COLA 中引入新的 Logger 抽象，目的就是要和具体的 Logger 框架进行解耦。

除了组件级别的 DIP，在架构层面，DIP 同样有着重要的指导意义。例如，在 COLA 架构中，领域层不应该直接依赖基础设施层，它们之间的解耦就是通过 DIP 完成的。关于领域层的设计的内容，可以参考 7.8.3 节和 12.3 节。

### 4.7 DRY

DRY 是 Don't Repeat Yourself 的缩写，DRY 原则特指在程序设计和计算中避免重复代码，因为这样会降低代码的灵活性和简洁性，并且可能导致代码之间的矛盾。DRY 是 Andy Hunt 和 Dave Thomas 在 The Pragmatic Programmer 一书中提出的核心原则。

2『已下载书籍「2020120The-Pragmatic-Programmer2Ed | 2020120程序员修炼之道2Ed」。（2021-11-06）』

系统的每一个功能都应该有唯一的实现。也就是说，如果多次遇到同样的问题，就应该抽象出一个共同的解决方法，不要重复开发同样的功能。在 8.5.1 节中，我们通过创建缺失的抽象来消除重复代码，就是一个很好的 DRY 案例。

贯彻 DRY 可以让我们避免陷入「散弹式修改」（Shotgun Surgery）的麻烦，「散弹式修改」是 Robert Martin 在《重构》一书中列出的一个典型代码「坏味道」，由于代码重复而导致一个小小的改动，会牵扯很多地方。

### 4.8 YAGNI

YAGNI（You Ain't Gonna Need It）的意思是「你不会需要它」，出自 Ron Jeffries 的 Extreme Programming Installed 一书。

2『已下载书籍「2021093Extreme-Programming-Installed」。（2021-11-06）』

YAGNI 是针对「大设计」（Big Design）提出来的，是「极限编程」提倡的原则，是指你自以为有用的功能，实际上都是用不到的。因此，除了核心的功能之外，其他的功能一概不要提前设计，这样可以大大加快开发进程。它背后的指导思想就是尽可能快、尽可能简单地让软件运行起来。

但是，这里出现了一个问题。仔细推敲，你会发现 DRY 原则和 YAGNI 原则是不兼容的。前者追求「抽象化」，要求找到通用的解决方法；后者追求「快和省」，意味着不要把精力放在抽象化上面，因为很可能「你不会需要它」。因此，就有了 Rule of Three 原则。

### 4.9 Rule of Three

Rule of Three 也被称为「三次原则」，是指当某个功能第三次出现时，就有必要进行「抽象化」了。这也是软件大师 Martin Fowler 在《重构》一书中提出的思想。

三次原则指导我们可以通过以下步骤来写代码。

1、第一次用到某个功能时，写一个特定的解决方法。

2、第二次又用到的时候，复制上一次的代码。

3、第三次出现的时候，才着手「抽象化」，写出通用的解决方法。

这 3 个步骤是对 DRY 原则和 YAGNI 原则的折中，是代码冗余和开发成本的平衡点。同时也提醒我们反思，是否做了很多无用的超前设计、代码是否开始出现冗余、是否要重新设计。软件设计本身就是一个平衡的艺术，我们既反对过度设计（Over Design），也绝对不赞成无设计（No Design）。

### 4.10 KISS 原则

KISS（Keep It Simple and Stupid）最早由 Robert S. Kaplan 在著名的平衡计分卡理论中提出。他认为把事情变复杂很简单，把事情变简单很复杂。好的目标不是越复杂越好，反而是越简洁越好。

KISS 原则被运用到软件设计领域中，常常会被误解，这成了很多没有设计能力的工程人员的挡箭牌。在此，我们一定要理解「简单」和「简陋」的区别。

真正的「简单」绝不是毫无设计感，上来就写代码，而是「宝剑锋从磨砺出」，亮剑的时候犹如一道华丽的闪电，背后却有着大量的艰辛和积累。真正的简单，不是不思考，而是先发散、再收敛。在纷繁复杂中，把握问题的核心。

### 4.11 POLA 原则

POLA（Principle of least astonishment）是最小惊奇原则，写代码不是写侦探小说，要的是简单易懂，而不是时不时冒出个「Surprise」。

在《复杂》一书的第 7 章「度量复杂性」中，就阐述了用「惊奇度」来度量复杂度的方法，「惊奇度」越高，复杂性越大，这也是侦探小说要比一般小说更「烧脑」的原因。

如何减少「惊奇」呢？首要的当然是规范和标准。在第 2 章中，我们已经讨论了大量的代码规范和设计规范，给出了可落地实施的案例。