## 记忆时间

## 目录

第一部分 技艺

0501 设计模式

0601 模型

0701 DDD 精髓

## 0501. 设计模式

利用模式，我们可以让一个解决方案重复使用，而不是重复造轮子。

With patterns, you can use the solution a million times over, without ever doing it the same way twice.

—— 克里斯托佛·亚历山大

### 本章小结

在本章中，我们了解了 GoF 的 23 种设计模式，熟练掌握设计模式非常重要，不仅可以给我们的设计带来灵活性，还能丰富技术词汇储备，方便交流。除此之外，我们还着重介绍了在设计模式类书籍中较少谈及的拦截器模式、插件模式和管道模式。这 3 个模式虽然不在 GoF 设计模式之列，但运用非常广泛，我们也应该掌握。

最后提醒一下，设计模式只是一种工具或手段，而不是目的。千万不要为了让程序看起来更有设计感，而在场景中套用设计模式。

### 5.0

设计模式（Design Pattern）是一套代码设计经验的总结，并且该经验必须能被反复使用，被多数人认可和知晓。设计模式描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案，具有一定的普遍性，可以反复使用。其目的是提高代码的可重用性、可读性和可靠性。

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。正确使用设计模式，可以提高程序员的思维能力、编程能力和设计能力，使程序设计更加标准化、代码编制更加工程化，从而大大提高软件开发效率。

### 5.1 模式

所谓模式，就是得到很好的研究的范例。设计模式，就是设计范例。《孙子兵法》中充斥着各种模式，「置之死地而后生」是战争模式；「三十六计」条条都是模式，比如「走为上」和「空城计」都是战争模式。

每一个模式都有典型意义，具有学习价值。通过研究这些模式，学习者可以相互交流，在自己的实践中举一反三、推陈出新，并加以应用。

模式不是框架（Framework），也不是过程。模式不是简单的「问题的解决方案」，必须是典型问题的解决方案，是可以让学习者举一反三的，是理论和实践之间的中介环节。模式具有一般性、简单性、重复性、结构性、稳定性和可操作性等特征。

模式不能套用，必须结合具体情况和上下文（Context）使用。不要以为在任何一个系统中都要使用某些设计模式。系统的设计模式也不是含有设计模式就好，更不是含有越多的设计模式就越好。

就像我对团队的要求，每个人都必须牢牢掌握常用设计模式的用法，要做到「知道」，但不要滥用。

### 5.2 GoF

提到设计模式，就一定会提到「四人组」（Gang of Four，GoF）。1995 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合作出版了《设计模式：可复用面向对象软件的基础》（ Design Patterns: Elements of Reusable Object-Oriented Software）一书，书中收录了 23 个设计模式。这是设计模式领域的里程碑事件，实现了软件设计模式的突破。这 4 位作者在软件开发领域里也被著称为「四人组」，如图 5-1 所示。

图 5-1 设计模式四人组

根据模式所完成的工作类型来划分，模式可分为创建型模式、结构型模式和行为型模式，如图 5-2 所示。

图 5-2 设计模式分类

1、创建型模式：用于描述「怎样创建对象」，主要特点是「将对象的创建与使用分离」。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者 5 种创建型模式。

2、结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合 7 种结构型模式。

3、行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器 11 种行为型模式。

以上提到了 GoF23 种设计模式的分类，简要介绍如下。

1、单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点，以便外部获取该实例，其拓展是有限多例模式。

2、原型（Prototype）模式：将一个对象作为原型，通过对其进行复制操作而复制出多个和原型类似的新实例。

3、工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。

4、抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

5、建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同的需要分别创建它们，最后构建成该复杂对象。

6、代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

7、适配器（Adapter）模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

8、桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。

9、装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。

10、外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

11、享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。

12、组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

13、模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使子类可以在不改变该算法结构的情况下，重定义该算法的某些特定步骤。

14、策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

15、命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。

16、职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式可以去除对象之间的耦合。

17、状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。

18、观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

19、中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

20、迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

21、访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

22、备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

23、解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

需要注意的是，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大型系统开发中常常会同时使用多种设计模式。

关于这 23 种模式的详细内容，市场上的很多相关图书都有所讲解，本书不做过多介绍。需要进一步学习的读者，建议去看「四人组」的著作《设计模式：可复用面向对象软件的基础》，此外，Head first Design Pattern 和《设计模式解析》也值得阅读。

在 23 种设计模式之外的广义的设计模式还有很多，它们虽然不在 GoF 设计模式之列，但应用也很广泛。接下来我会重点介绍 3 个使用广泛的设计模式。

### 5.3 拦截器模式

拦截器模式（Interceptor Pattern），是指提供一种通用的扩展机制，可以在业务操作前后提供一些切面的（Cross-Cutting）的操作。这些切面操作通常是和业务无关的，比如日志记录、性能统计、安全控制、事务处理、异常处理和编码转换等。

在功能上，拦截器模式和面向切面编程（Aspect Oriented Programming，AOP）的思想很相似。不过，相比于 AOP 中的代理实现（静态代理和动态代理），我更喜欢拦截器的实现方式，原因有二：一个其命名更能表达前置处理和后置处理的含义，二是拦截器的添加和删除会更加灵活，如图 5-3 所示。

图 5-3 拦截器的实现原理

不同于 Java 的动态代理是利用 Java 反射机制的，拦截器模式完全是利用面向对象技术的，巧妙地使用组合模式外加递归调用实现了灵活、可扩展的前置处理和后置处理。

在拦截器模式中，主要包含以下角色。

TargetInvocation：包含了一组 Interceptor 和一个 Target 对象，确保在 Target 处理请求前后，按照定义顺序调用 Interceptor 做前置和后置处理。

Target：处理请求的目标接口。

TargetImpl：实现了 Target 接口的对象。

Interceptor：拦截器接口。

InterceptorImpl：拦截器实现，用来在 Target 处理请求前后做切面处理。

各角色之间的关系如图 5-4 所示。

图 5-4 实现拦截器模式的类图

我们可以按照下面的步骤实现一个拦截器模式。

2、创建 Target 接口。

```java
public interface Target {
    public Response execute(Request request);
}
```

2、创建 Interceptor 接口。

```java
public interface Interceptor {
    public Response intercept(TargetInvocation targetInvocation);
}
```

3、创建 TargetInvocation。

```java
public class TargetInvocation {
private
List<Interceptor> interceptorList =
new
ArrayList<>();
private
Iterator<Interceptor> interceptors;
private
Target target;
private
Request request;
public
Response invoke(){
if
( interceptors.hasNext() ){
Interceptor interceptor = interceptors.next();
// 此处是整个算法的关键，这里会递归调用 invoke ()
interceptor.intercept(
this
);//2
}
return
target.execute(request);
}
public
void addInterceptor(Interceptor interceptor){
// 添加新的 Interceptor 到 TargetInvocation 中
interceptorList.add(interceptor);
interceptors = interceptorList.iterator();
}
}
```

4、创建具体的 Interceptor。

AuditInterceptor 实现如下：

```java
public class

AuditInterceptor

implements

Interceptor{

@Override

public

Response intercept(TargetInvocation targetInvocation) {

if(targetInvocation.getTarget() == null) {

throw new

IllegalArgumentException("Target is null");

}

System.out.println("Audit Succeeded ");

return

targetInvocation.invoke();

}

}

LogInterceptor 实现如下：

public class

LogInterceptor

implements

Interceptor {

@Override

public

Response intercept(TargetInvocation targetInvocation) {

System.out.println("Logging Begin");

Response response = targetInvocation.invoke();

System.out.println("Logging End");

return

response;

}

}
```

5、使用 InterceptorDemo 来演示拦截器设计模式。

```java
public class

InterceptorDemo {

public

static void main(String[] args) {

TargetInvocation targetInvocation =

new

TargetInvocation();

targetInvocation.addInterceptor(

new

LogInterceptor());

targetInvocation.addInterceptor(

new

AuditInterceptor());

targetInvocation.setRequest(

new

Request());

targetInvocation.setTarget(request->{

return new

Response();});

targetInvocation.invoke();

}

}
```

6、执行程序，输出结果。

```java
Logging Begin
Audit Succeeded
Logging End
```

拦截器模式在开源框架中被广泛使用，例如，MVC 框架 Struts2 的 Interceptor 机制正是使用该模式，只是在 Struts2 中 Target 叫 Action，TargetInvocation 叫 ActionInvocation。在开源流程引擎 Activity 中也有使用该模式，其 Target 叫 Command。在 COLA 框架中，同样使用拦截器模式来进行 Command 的前置和后置处理。

### 5.4 插件模式

插件（plug-in）模式扩展方式和普通的对象扩展方式的不同之处在于，普通的扩展发生在软件内部，插件式扩展发生在软件外部。比如，我们在一个项目中使用了策略模式，当需要添加新的策略时，我们不得不重新编译代码、打包和部署，新的策略才能生效。

而插件式扩展是发生在软件外部的，新扩展以一个单独的组件（比如 jar 包）的方式加入软件中，软件本身不需要重新编译、打包。有些插件模式甚至可以做到热部署，即在运行时实现插件的加载或卸载，做到真正的即插即用（Pluggable）。

在此方面，我们熟知的软件有很多，如 Chrome、Eclipse、Photoshop 和 VisualStudio 都做了很好的插件支持。插件模式可以让我们动态地给软件添加或删除一些功能，好处是任何人都可以给软件进行功能上的扩展，而不用去改软件本身的代码。

插件模式的实现原理和策略模式类似，要求主程序中做好扩展点接口的定义，然后在插件中进行扩展实现。因此，插件模式的难点不在于如何开发插件，而在于如何实现一套完整的插件框架。

在一个插件框架中，通常会涉及以下概念。

1、ExtensionPoint：扩展点，用来标识可以扩展的功能点。

2、Extension：扩展，是对 ExtensionPoint 的扩展实现。

3、PluginDescriptor：插件描述，即描述插件的元数据，定义了包括对外暴露的扩展点，运行插件所需要的依赖等信息。一个 PluginDescriptor 对应一个 Plugin.xml 配置。

4、PluginRegistry：插件注册，用来进行插件注册和存储。

5、PluginManager：插件管理，用来装载和激活插件实例。

6、Plugin：插件实例，当 PluginManager 调用 activate 方法激活 Plugin 时，就会产生一个 Plugin 实例。

上述概念之间的关系如图 5-5 所示。

图 5-5 插件模式的概念类图

关于如何实现一个插件框架，还有许多细节，比如，如何解析 plugin 元数据、如何处理插件之间的依赖关系、如何动态加载 extension 中客户自定义的参数等。特别是类型为 class 的参数，需要采用一定的 classloader 机制。

有关这些实现细节，我推荐一个开源项目 JPF（Java Plug-in Framework），它受到了 Eclipse 的插件式启发，致力于打造一个通用的 Java 插件框架。有兴趣的读者可以访问 SOURCEFORGE 的 JPF 相关页面获取相关资料和源代码。

### 5.5 管道模式

管道这个名字源于自来水厂的原水处理过程。原水要经过管道，一层层地过滤、沉淀、去杂质、消毒，到管道另一端形成纯净水。我们不应该把所有原水的过滤都放在一个管道中去提纯，而应该把处理过程进行划分，把不同的处理分配在不同的阀门上，第一道阀门调节什么，第二道调节什么…… 最后组合起来形成过滤纯净水的管道。

这种处理方式实际上体现了一种分治（Divid and Conquer）思想，这是一种古老且非常有效的思想。关于分治思想，将会在第 9 章中详细介绍。接下来，我们来看管道模式的实际应用。

#### 5.5.1 链式管道

看过 Tomcat 源码或阿里巴巴开源的 MVC 框架 WebX 源码的读者，应该对其中的管道（Pipeline）和阀门（Valve）不会陌生。一个典型的管道模式，会涉及以下 3 个主要的角色。1）阀门：处理数据的节点。2）管道：组织各个阀门。3）客户端：构造管道并调用。

对应现实生活中的管道，我们一般使用一个单向链表数据结构作为来实现，如图 5-6 所示。这也是链式管道区别于拦截器模式之处。其实在功能上，拦截器、管道、过滤器、责任链有类似之处，在实际工作中，我们可以根据具体情况灵活选用。

图 5-6 基于链表的管道

基于上面的分析，我们可以按照下面的步骤实现一个简单的链式管道。

1、创建阀门和管道接口。

1）阀门接口：

```java
public interface
Valve {
public
Valve getNext();
public
void setNext(Valve v);
public
void invoke(String s);
}
```

2）管道接口：

```java
public interface
Pipeline {
public
Valve getHead();
public
Valve getTail();
public
void setTail(Valve v);
public
void addValve(Valve v);
}
```

2．创建阀门的基础实现。

```java
public abstract class
ValveBase
implements
Valve{
public
Valve next;
public
Valve getNext() {
return
next;
}
public
void setNext(Valve v) {
next = v;
}
public abstract
void invoke(String s);
}
```

3．实现具体的阀门

1）普通阀门一：

```java
public class
FirstValve
extends
ValveBase {
public
void invoke(String s) {
s = s.replace("11","first");
System.out.println("after first Valve handled: s = " + s);
getNext().invoke(s);
}
}
```

2）普通阀门二：

```java
public class
SecondValve
extends
ValveBase{
@Override
public
void invoke(String s) {
s = s.replace("22","second");
System.out.println("after second Valve handled: s = " + s);
getNext().invoke(s);
}
}
```

3）尾阀门：

```java
public class
TailValve
extends
ValveBase {
public
void invoke(String s) {
s = s.replace("33", "third");
System.out.println("after tail Valve handled: s = " + s);
}
}
```

4、实现具体的管道.

```java
public class
StandardPipeline
implements
Pipeline {
protected
Valve head;
protected
Valve tail;
public
Valve getHead() {
return
head;
}
public
Valve getTail() {
return
tail;
}
public
void setTail(Valve v) {
tail = v;
}
public
void addValve(Valve v) {
if
(head ==
null
) {
head = v;
v.setNext(tail);
}
else
{
Valve current = head;
while
(current !=
null
) {
if
(current.getNext() == tail) {
current.setNext(v);
v.setNext(tail);
break;
}
current = current.getNext();
}
}
}
}
```

5、组装管道，实现客户端调用。

```java
public class Client {
public static void main(String[] args) {
String s = "11,22,33";
System.out.println("Input : " + s);
StandardPipeline pipeline =
new
StandardPipeline();
TailValve tail =
new
TailValve();
FirstValve first =
new
FirstValve();
SecondValve second =
new
SecondValve();
pipeline.setTail(tail);
pipeline.addValve(first);
pipeline.addValve(second);
pipeline.getHead().invoke(s);
}
}
```

6、执行客户端程序并输出结果。

```java
Input : s = 11, 22, 33
after first Valve handled: s = first, 22, 33
after second Valve handled: s = first, second, 33
after tail Valve handled: s = first, second, third
```

#### 5.5.2 流处理

管道模式还有一个非常广泛的应用 —— 流式处理，即把自来水厂的原水换成数据，形成数据流。管道模式适用于那些在一个数据流上要进行不同的数据计算场景，这种方式称为流处理，也称为流式计算。

流是一系列数据项，一次只生成一项。程序可以从输入流中逐个读取数据项，然后以同样的方式将数据项写入数据流。一个程序的输出流很有可能是另一个程序的输入流。

熟悉 UNIX 或 Linux 命令的读者对管道应该不会陌生，管道（|）是把一个程序的输出直接连接到另一个程序的输入命令符，这样就能方便快捷地进行流式数据处理，比如：

```java
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

UNIX 的 cat 命令会把两个文件连接起来创建流，tr 会转化流中的字符，sort 会对流中的行进行排序，而 tail -3 则给出流的最后 3 行。

鉴于流式计算在处理数据流上的优雅性，Java 8 在引入函数式编程的同时，还提供了 Stream API 对集合流进行流式计算。例如，在 Java 8 之前，如果需要从一个 transaction 列表中筛选金额大于 1000 的交易，然后按货币分组，那么需要大量模板化的代码来实现这个数据处理，如下所示：

```java
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();
for
(Transaction transaction : transactions){
if
(transaction.getPrice() > 1000){
Currency currency = transaction.getCurrency();
List<Transaction> transactionsForCurrency = transactionsByCurrencies. get(currency);
if
(transactionsForCurrency ==
null
){
transactionsForCurrency =
new
ArrayList<>();
transactionsByCurrencies.put(currency, transactionsForCurrency);
}
transactionsForCurrency.add(transaction);
}
}
```

同样的事情，如果用流处理，一行代码就可以实现。

```java
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream().filter(t -> t.getPrice() > 1000).collect(Collectors.groupingBy(Transaction::getCurrency));
```

翻看 JDK 源码，你会发现，支撑 Stream API 背后的原理正是管道模式。在构建 Stream 时，会调用核心类 ReferencePipeline 来创建管道，其内部采用双向列表的数据结构对操作（Operation）进行存放，然后包（wrap）成 Sink 链表等待执行，整个处理是延迟执行的，只有在最后收集（Collect）被调用时才会被执行。

## 0601. 模型

建模的艺术就是去除实在中与问题无关的部分。

—— 利普·沃伦·安德森（1977 年诺贝尔物理学奖得主）

### 本章小结

建模在软件设计中占有重要的地位，是我们分析问题和架构设计的重要手段。UML 为我们提供了一套标准的需求分析和软件架构的表示法，共用一套表示法和描述语言的好处是可以减少认知成本，提升沟通效率。

但是，我们也要看到 UML 并没有覆盖所有的建模场景，有时我们不用完全拘泥于现有的教条。只要合理地使用线条、图形、箭头和颜色来描述我们想要表达的技术问题或者业务问题，就是好的「建模」。还是那句话，建模并不意味着要用特定的符号、工具和流程。不管你用什么建模工具、什么表示法，只要有助于对问题域的理解，就是好的模型。

### 6.0

在软件工程中，有两个高阶工作分别是架构和建模。如果把写代码比喻成「施工」，那么架构和建模就是「设计图纸」。相比于编码，建模的确是对设计经验和抽象能力要求更高的一种技能。例如，在当前热门的人工智能和机器学习领域，建模就是其中非常重要的工作。

### 6.1 什么是模型

模型是对现实世界的简化抽象。建立模型有很多方法，并不意味着要用特定的符号、工具和流程。我们只是想在研究复杂东西时，让其中的一些部分易于理解。因此，无论使用何种建模工具和表示法（Notation），只要有助于我们对问题域的理解，均可认为是好的模型。

在一个信息爆炸的时代，有时，不必要的细节反而会让情况更加难以理解。在处理问题时，我们最好隐藏那些不必要的细节，只专注于重要的方面，抓住问题的本质。这也是建模和抽象的价值所在。

在不同的场景下，模型对相同的实体会有不同的表达方式。模型的作用就是表达不同概念的性质。根据使用场景的不同，模型大致可以分为物理模型、概念模型、数学模型和思维模型等。

#### 6.1.1 物理模型

物理模型是拥有体积及重量的物理形态概念实体物件，是根据相似性理论制造的按原系统比例缩小（也可以是放大或与原系统尺寸一样）的实物。例如，风洞实验中的飞机模型、水力系统实验模型、建筑模型和船舶模型和汽车模型（如图 6-1 所示）等。

图 6-1 汽车模型

#### 6.1.2 数学模型

数学模型是用数学语言描述的一类模型，可以是一个或一组代数方程、微分方程、差分方程、积分方程或统计学方程，也可以是某种适当的组合数学模型。利用这些方程可以定量地或定性地描述系统各变量之间的相互关系或因果关系，来描述系统的行为和特征，而不是系统的实际结构。如图 6-2 所示，是一个对汽车 4S 店进行销售预测的建模过程。

图 6-2 4S 店销售预测建模

#### 6.1.3 概念模型

概念模型是对真实世界中问题域内的事物的描述，是领域实体，而不是对软件设计的描述，它和技术无关。概念模型将现实世界抽象为信息世界，把现实世界中的客观对象抽象为某一种信息结构，这种信息结构并不依赖于具体的计算机系统。以一辆汽车为例，我们可以画出图 6-3 所示的领域模型。

图 6-3 汽车的领域模型

#### 6.1.4 思维模型

我们把用简单易懂的图形、符号或者结构化语言等表达人们思考和解决问题的形式，统称为思维模型。简单来说，就是我们可以总结出一些能够解决特定问题的「思维套路」，这些套路能帮助我们高效地解决问题。例如，8.5.3 节中介绍的金字塔模型就是一种非常好的结构化思维模型。

#### 6.1.5 模型不能代替现实

模型毕竟是模型，不能代替现实，就像类比不能代替问题本身一样。建模的过程与建模者的观察视角和对问题的认知有直接关系，所以我们要带着审视的眼光去看待模型。

就像牛顿认为两个物体之间的引力正比于它们质量的乘积，这是对一种特定现象的数学描述 —— 数学模型。牛顿自己推测过引力的可能原理：地球就像海绵一样，不断吸收天空降落下来的轻质流体，这种流体作用到地球上的物体，导致它们下降。很多年后，爱因斯坦提出了一种不同的引力原理模型 —— 广义相对论，引力被概念化为四维时空的几何特性。相比之下，爱因斯坦的引力模型显然更加科学，但引力的本质是什么，为什么时空弯曲可以产生引力，答案仍然是一个谜。

模型在软件开发中的作用也是一样的，我们也要用发展的眼光来看待模型，能解决当前问题的模型就是好模型，随着时间的推移，我们可能要像重构代码那样去重构模型，确保它能跟上我们对问题域的最新理解。

### 6.2 UML

在软件领域，影响力最强的建模工具当属统一建模语言（Unified Modeling Language，UML）了。

1997 年，对象管理组织（Object Management Group，OMG）发布了 UML。UML 的目标之一是为开发团队提供标准通用的设计语言来开发和构建计算机应用。UML 提出了一套 IT 专业人员期待多年的统一的标准建模符号。通过使用 UML，用户能够阅读和交流系统架构和设计规划，就像建筑工人使用的建筑设计图一样。

UML 拥有一种定义良好的、富有表现力的表示法，这对软件开发过程非常重要。标准的表示法让分析师或开发者能够描述一个场景、阐明一种架构，并准确地将这些信息告诉别人。

总的来说，我们构建的 UML 模型将以一定的保真度和角度展现要构建的真实系统。但是复杂软件系统面临的问题是多样的，在不同的软件研发阶段，针对不同的使用目的，我们需要不同的模型图，每一种模型图都提供了系统的某一种视图。

UML 分为结构型和行为型建模图形，具体分类如图 6-4 所示。

图 6-4 UML 分类

关于 UML 的资料和书籍已有很多。在本书中，我不打算详尽描述每一种建模图形，需要进一步学习的读者，推荐阅读 Grady Booch 等人的《面向对象分析与设计》和 Larman 的《UML 和模式应用》这两本书。

下面详细介绍一下类图，主要有两个原因。

首先，在面向对象设计中，类图占有非常重要的地位。类图不仅可以表示类之间的关系，其表示法还可以表达领域概念之间的关系，非常适合进行领域建模。在我的团队中，都是用类 UML 类图来制作领域模型的。

其次，我在面试和工作的过程中发现很多应试者并不熟悉 UML 类图，要么不会画类图，要么用错表示法。

### 6.3 类图

类（Class）封装了数据和行为，是面向对象的重要组成部分，是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。

类图用于描述类以及它们的相互关系。在分析时，我们利用类图来说明实体共同的角色和责任，这些实体提供了系统的行为。在设计时，我们利用类图来记录类的结构，这些类构成了系统的架构。在类图中，两个基本元素是类，以及类之间的关系。

#### 6.3.1 类的 UML 表示法

在 UML 中，类由包含类名、属性和操作 3 部分组成，这 3 部分使用分隔线分隔的矩形表示。例如，定义一个 Employee 类，包含属性 name、age 和 email，以及操作 getName ()，在 UML 类图中，该类如图 6-5 所示。

图 6-5 类图示例

Employee 类对应的 Java 代码片段如下：

```java
public class
Employee {
private
String name;
private
int age;
private
String email;
public
void getName() {
return
name；
}
}
```

在 UML 类图中，类一般由以下 3 个部分组成。

1、类名（Name）：每个类都必须有一个名字，类名是一个字符串。

2、类的属性（Attributes）：属性指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。

3、类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。

类图中属性和操作的格式有规格说明。属性规格说明格式是「可见性 属性名称：类型」，比如「- name : String」。操作规格说明格式是「可见性 操作名称（参数名称：类型）：返回值类型」，比如「+ getName () : String」。

其中，可见性、名称和类型的定义分别如下。

可见性：表示该属性对于类外的元素而言是否可见，包括公有（public）、私有（private）和受保护（protected），在类图中分别用符号 +、- 和 #表示。

名称：按照惯例，类的名称以大写字母开头，单词之间使用驼峰隔开。属性和操作的名称以小写字母开头，后续单词使用驼峰。

类型：表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。

类和类之间的关系主要有关联关系、依赖关系和泛化关系。接下来，我们重点来看这些关系的 UML 表示法。

#### 6.3.2 类的关联关系

关联（Association）关系是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。关联关系是类与类之间常用的一种关系。在 UML 类图中，用实线连接有关联关系的对象所对应的类。在代码实现上，通常将一个类的对象作为另一个类的成员变量。

在使用类图表示关联关系时，可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词来表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色。因此，在一个关联关系中可以包含两个角色名，角色名并不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。

在 UML 中，关联关系通常又包含以下 6 种形式。

1、双向关联。

在默认情况下，关联是双向的。例如，一位教师（Teacher）可以教授一或多门课程（Course），一门课程只能被一位教师教授，因此 Teacher 类和 Course 类之间具有双向关联关系，如图 6-6 所示。

图 6-6 双向关联实例

在图 6-6 中，三角形标注表示关联关系的阅读方向，是可选的。直线两边的数字代表关联的重数性（Multiplicity），也是可选的，表示两个关联对象在数量上的对应关系。在 UML 中，对象之间的多重性可以直接在关联直线上用一个数字或数字范围表示。

对象之间可以存在多种多重性关联的关系，常见的多重性表示方式如表 6-1 所示。

表 6-1 多重性表示方式

| 表示方法 | 多重性说明 |
| --- | --- |
| 1..1 | 表示另一个类的一个对象只与该类的一个对象有关系 |
| 0..* | 表示另一个类的一个对象与该类的零个或多个对象有关系 |
| 1..* | 表示另一个类的一个对象与该类的一个或多个对象有关系 |
| 0..1 | 表示另一个类的一个对象没有或只与该类的一个对象有关系 |
| m..n | 表示另一个类的一个对象与该类最少 m，最多 n 个对象有关系（mn） |

2、限定关联。

限定关联（Qualified association）具有限定符（Qualifier），限定符的作用类似 HashMap 中的键（key），用于从一个集合中选择一个或多个对象。例如，一个用户（User）可以有多个角色（Role），但是在一个场景（Scenario）下，它只会是一种角色。

对于限定关联，有一点需要注意，即多重性的变化。例如，比较图 6-7a 和图 6-7b，限定减少了在关联目标端的多重性，通常是由多变为一，因为限定关联通常是从较大集合中选择一个实例。

图 6-7 限定关联实例

用代码实现限定关联时，成员变量通常是 Map，而 Map 的键就是限定符，图 6-7b 对应的 Java 代码片段如下：

```java
public class
User {
private
Map<String, Role> roles;
public
Role getRole(String scenario){
return
roles.get(scenario);
}
}
public class
Role {
}
```

3、单向关联。

类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如，顾客（Customer）拥有地址（Address），则 Customer 类与 Address 类具有单向关联关系，如图 6-8 所示。

图 6-8 单向关联实例

4、自关联。

在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个节点类（Node）的成员又是节点 Node 类型的对象，如图 6-9 所示。

图 6-9 自关联实例

设计模式中的装饰者模式也是一种自关联，都有类似如下的代码形式：

```java
public class Node {
private Node subNode;
}
```

5、聚合关系。

聚合（Aggregation）关系表示整体与部分的关联关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在 UML 中，聚合关系用带空心菱形的直线表示。例如，汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此汽车和发动机是聚合关系，如图 6-10 所示。

图 6-10 聚合关系实例

在用代码实现聚合关系时，成员对象通常作为构造方法、Setter 方法或业务方法的参数注入整体对象中，图 6-10 对应的 Java 代码片段如下：

```java
public class
Car {
private
Engine engine;
// 构造注入
public
Car(Engine engine) {
this
.engine = engine;
}
// 设值注入
public
void setEngine(Engine engine) {
this.engine = engine;
}
}
public class
Engine {
}
```

6、组合关系。

组合（Composition）关系也表示类之间整体和部分的关联关系，但是在组合关系中，整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有「同生共死」的关系。在 UML 中，组合关系用带实心菱形的直线表示。例如，人的头部（Head）与嘴（Mouth），嘴是头部的组成部分，如果头部不存在，那么嘴也就不存在了，因此头部和嘴是组合关系，如图 6-11 所示。

图 6-11 组合关系实例

在用代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类。成员对象域整体对象有同样的生命周期，也就是要「共生死」，这也是组合和聚合的主要区别。代码上的体现是组合没有 Setter 方法，图 6-11 对应的 Java 代码片段如下：

```java
public class
Head {
private
Mouth mouth;
public
Head() {
mouth =
new
Mouth (); // 实例化成员类
}
}
public class
Mouth {
}
```

#### 6.3.3 类的依赖关系

依赖（Dependency）关系是一种使用关系，特定事物的改变可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时，使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在 UML 中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如，教师（Teacher）上课时使用投影仪（Projector）进行演示，如图 6-12 所示。

在系统实施阶段，依赖关系通常通过 3 种方式来实现。

1、第一种方式（也是常用的一种方式）是将一个类的对象作为另一个类中方法的参数，如图 6-12 所示。

图 6-12 依赖关系实例

2、第二种方式是在一个类的方法中将另一个类的对象作为其局部变量。

3、第三种方式是在一个类的方法中调用另一个类的静态方法。

第一种方式对应的 Java 代码片段如下：

```java
public class
Teacher {
public
void use(Projector projector) {
projector.demonstrate();
}
}
public class
Projector {
public
void demonstrate() {
}
}
```

#### 6.3.4 类的泛化关系

泛化（Generalization）关系也称为继承关系，用于描述父类与子类之间的关系。父类称为基类或超类，子类称为派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。在代码实现时，我们使用面向对象的继承机制来实现泛化关系，例如，在 Java 语言中使用 extends 关键字。

举例说明，Student 类和 Teacher 类都是 Person 类的子类，Student 类和 Teacher 类继承了 Person 类的属性和方法，Person 类的属性包含姓名（name）和年龄（age），每一个 Student 和 Teacher 也都具有这两个属性。另外，Student 类增加了属性学号（studentNo），Teacher 类增加了属性教师编号（teacherNo），如图 6-13 所示。

图 6-13 泛化关系实例

图 6-13 对应的 Java 代码片段如下：

```java
// 父类
public class
Person {
protected
String name;
protected
int age;
……
}
// 子类
public class
Student
extends
Person {
private
String studentNo;
……
}
// 子类
public class
Teacher
extends
Person {
private
String teacherNo;
……
}
```

#### 6.3.5 接口与实现关系

面向对象语言中会引入接口的概念。在接口中，通常没有属性，其操作通常都是抽象的，只有操作的声明，没有操作的实现。在 UML 中，类与接口之间的实现关系通常是用带空心三角形的虚线来表示。例如，第 13 章介绍的「工匠平台」中，每一个度量项（Metrics）都是可度量的（Measurable），其实现如图 6-14 所示。

图 6-14 实现关系实例

需要注意的是，UML 提供了多种方法表示接口实现（Interface realization）。例如，在 UML 2 中新定义的插座表示法（Socket notation），有助于表示「类 X 需要（使用）接口 Y」。在上面的例子中，我们有一个统计类（Statistics）要使用度量项进行统计，其插座表示法如图 6-15 所示。

图 6-15 接口和实现的插座表示法

### 6.4 领域模型

在理解领域模型之前，我们先思考一下软件开发的本质是什么。从本质上来说，软件开发过程就是问题空间到解决方案空间的一个映射转化，如图 6-16 所示。

图 6-16 软件开发的本质

在问题空间中，我们主要是找出某个业务面临的挑战及其相关需求场景用例分析；而在解决方案空间中，则通过具体的技术工具手段来进行设计实现。

就软件系统来说，「问题空间」就是系统要解决的「领域」问题。因此，也可以简单理解为一个领域就对应一个问题空间，是一个特定范围边界内的业务需求的总和。

「领域模型」就是「解决方案空间」，是针对特定领域里的关键事物及其关系的可视化表现，是为了准确定义需要解决问题而构造的抽象模型，是业务功能场景在软件系统里的映射转化，其目标是为软件系统的构建统一的认知。

例如，请假系统解决的是人力工时的问题，属于人力资源领域，对口的是 HR 部门；费用报销系统解决的是员工和公司之间的财务问题，属于财务领域，对口的是财务部门；电商平台解决的是网上购物问题，属于电商领域。可以看出，每个软件系统本质上都解决了特定的问题，属于某一个特定领域，实现了同样的核心业务功能来解决该领域中核心的业务需求。

总结一下，领域模型在软件开发中的主要起到如下作用。

帮助分析理解复杂业务领域问题，描述业务中涉及的实体及其相互之间的关系，是需求分析的产物，与问题域相关。

是需求分析人员与用户交流的有力工具，是彼此交流的语言。

分析如何满足系统功能性需求，指导项目后续的系统设计。

关于如何进行领域建模，会在第 7 章中详细介绍。

### 6.5 敏捷建模

和开发模式一样，建模也可以用一套价值观、原则和实践来进行指导，以求尽可能地敏捷。敏捷建模方法的重点如下。

模型能用来沟通和理解。

力争用简单的工具创建简单的模型。

我们知道需求是变化的，因此创建模型时要拥抱变化。

重点是交付软件，而不是交付模型。模型能带来价值时，我们就使用；如果模型没有价值，不能加速软件的交付，就不创建它们。

我们只保留必要的模型。如果模型完成了它的使命，就可以把它扔掉。这能让我们轻装上阵，而不会陷入繁忙的工作。

我们使用多种模型。在使用模型时会考虑不同的角度和抽象层次，还有不同的读者。对于创建出来的所有模型，我们都知道它的读者是谁、要达成什么目标。如果我们还没理解目标，就不会创建模型。

### 6.6 广义模型

除了像 UML 这样的「正规军」，我认为凡是可以实现对复杂问题的抽象、帮助理解问题域、让沟通变得更高效的图形化方法都是建模。

#### 6.6.1 C4 模型

C4 模型由 Simon Brown 提出。C4 模型提出使用上下文（Context）、容器（Container）、组件（Component）和代码（Code）等一系列分层的图表，来描述不同缩放级别的软件架构，其主要构件如图 6-17 所示。

图 6-17 C4 模型中的主要构件

#### 6.6.2 UI 流程图

UI 流程图使用页面之间的流转来描述系统交互流程。用户可以通过 UI 流程图进行业务分析和检查，UI 流程图也可以作为系统文档向新人介绍业务。如图 6-18 所示，UI 流程图和 C4 模型一样，虽然不是标准的 UML，但也非常实用。

图 6-18 UI 流程图实例

#### 6.6.3 业务模型

除描述技术以外，用户也可以用图形化的方式来描述业务。图形化的表达往往比文字更容易使人理解，也更加生动。原始人没有文字，漫长的进化过程诞生了文字后，人类处理图像的进程比语言快了 60000 倍 [1]。我们回忆图片类的信息要比文字类信息容易 6 倍，这也是「一图胜千言」的原因。

图 6-19 描述了一个电商网站客户动线，虚线表示不同阶段跳出（终止交易），线条的粗细表示流量的大小，很形象、生动，我们可以很容易地看出来下单漏洞是如何发生的。

图 6-19 电商网站客户动线

图 6-20 是关于 O2O 就医的流程，这张图非常巧妙地使用了线条（line），线条本身除了表达时间顺序外，还用来作为线上（online）和线下（offline）的区隔，线条上面的是 online，下面的是 offline，直观明了，让人印象深刻。

图 6-20 基本就医的 O2O 流程

由此可见，好的图形表示法不仅需要我们对问题域有深入的理解，还要我们具备一定的想象力和创造力。UML 可以表达大部分软件工程中遇到的问题，提供了大家都熟悉的表示法，省去了重新理解图形元素的负担，因此我们应该优先使用 UML 来表达。但是在面对一些特殊场景时，UML 的表达能力有限，我们也可以尝试不一样的表达。

[1] 信息参考自 Thermopylae Sciences + Technology 公司官网。

## 0701. DDD 的精髓

你可以，不代表你应该。

（Just because you can, doesn't mean you should.）

—— 施莉琳·凯尼恩

### 本章小结

本章重点介绍了什么是 DDD，对比了传统的数据驱动设计和 DDD 的领域驱动设计之间的区别，以及 DDD 带来的好处和实施 DDD 可能存在的风险。完整的 DDD 理念和方法论是一门庞大的学问，不可能在一章内容中做到面面俱到。本章中所展现的内容是作者结合自身实践，整理出的关于 DDD 的精髓和要义，一定程度上可作为 DDD 的指导手册。

DDD 有一定的学习门槛和学习曲线，还是那句话：不要教条。如果只是照搬 DDD 的概念，最多也只是学到了「形」。真正的面向对象大师，即使不用 Repository、Aggregate Root 和 ValueObject 这些概念，也能很好地完成领域驱动设计。

### 7.0

在第 6 章中，我们简要介绍了什么是模型、模型在软件开发中的重要性，以及一些常用的建模方式在软件工程中的应用。本章将重点讲解领域驱动设计（Domain Driven Design，DDD），包括 DDD 的重要概念，以及如何进行领域建模。

### 7.1 什么是 DDD

DDD 是 Eric Evans 在 2003 年出版的《领域驱动设计：软件核心复杂性应对之道》（ Domain-Driven Design: Tackling Complexity in the Heart of Software）一书中提出的具有划时代意义的重要概念，是指通过统一语言、业务抽象、领域划分和领域建模等一系列手段来控制软件复杂度的方法论。

DDD 的革命性在于领域驱动设计是面向对象分析的方法论，它可以利用面向对象的特性（封装、多态）有效地化解复杂性，而传统 J2EE 或 Spring+Hibernate 等事务性编程模型只关心数据。这些数据对象除了简单的 setter/getter 方法外，不包含任何业务逻辑，业务逻辑都是以过程式的代码写在 Service 中。这种方式极易上手，但随着业务的发展，系统也很容易变得混乱复杂。

### 7.2 初步体验 DDD

在介绍 DDD 之前，我喜欢用这个银行转账的案例来做一个 DDD 和事务脚本（Transaction Script）的简单对比。我们要实现一个银行转账的功能，如果用传统的事务脚本方式实现，业务逻辑通常会被写在 MoneyTransferService 中，而 Account 仅仅是 getters 和 setters 的数据结构，也就是所谓的「贫血模式」。其代码如下所示：

```java
public class
MoneyTransferServiceTransactionScriptImpl
implements
MoneyTransferService {
private
AccountDao accountDao;
private
BankingTransactionRepository bankingTransactionRepository;
. . .
@Override
public
BankingTransaction transfer(
String fromAccountId, String toAccountId, double amount) {
Account fromAccount = accountDao.findById(fromAccountId);
Account toAccount = accountDao.findById(toAccountId);
. . .
double newBalance = fromAccount.getBalance() - amount;
switch
(fromAccount.getOverdraftPolicy()) {
case
NEVER:
if
(newBalance < 0) {
throw new
DebitException("Insufficient funds");
}
break;
case
ALLOWED:
if
(newBalance < -limit) {
throw new
DebitException(
"Overdraft limit (of " + limit +") exceeded: " + newBalance);
}
break;
}
fromAccount.setBalance(newBalance);
toAccount.setBalance(toAccount.getBalance() + amount);
BankingTransaction moneyTransferTransaction =
new
MoneyTranferTransaction(fromAccountId,toAccountId,amount);
bankingTransactionRepository.addTransaction(moneyTransferTransaction);
return
moneyTransferTransaction;
}
}
```

上述代码有些读者可能会比较眼熟，因为大部分系统都是这么写的。评审完需求，工程师画几张 UML 图完成设计，就开始像上面这样写业务代码了，这样写基本不用太动脑筋，完全是过程式的代码风格。

同样的业务逻辑，接下来看使用领域建模是怎么做的。在使用 DDD 之后，Account 实体除账号属性之外，还包含了行为和业务逻辑，比如 debit () 和 credit () 方法。

```java
public class
Account {
private
String id;
private
double balance;
private
OverdraftPolicy overdraftPolicy;
. . .
public
double balance() {
return
balance; }
public
void debit(double amount) {
this
.overdraftPolicy.preDebit(
this
, amount);
this
.balance =
this
.balance - amount;
this
.overdraftPolicy.postDebit(
this
, amount);
}
public
void credit(double amount) {
this
.balance =
this
.balance + amount;
}
}
```

透支策略 OverdraftPolicy 也不仅仅是一个 Enum 了，而是被抽象成包含业务规则并采用策略模式的对象。

```java
public interface

OverdraftPolicy {

void preDebit(Account account, double amount);

void postDebit(Account account, double amount);

}

public class

NoOverdraftAllowed

implements

OverdraftPolicy {

public

void preDebit(Account account, double amount) {

double newBalance = account.balance() - amount;

if

(newBalance < 0) {

throw new

DebitException("Insufficient funds");

}

}

public

void postDebit(Account account, double amount) {

}

}

public class

LimitedOverdraft

implements

OverdraftPolicy {

private

double limit;

. . .

public

void preDebit(Account account, double amount) {

double newBalance = account.balance() - amount;

if

(newBalance < -limit) {

throw new

DebitException(

"Overdraft limit (of " + limit + ") exceeded: "+newBalance);

}

}

public

void postDebit(Account account, double amount) {

}

}

而 Domain Service 只需要调用 Domain Entity 对象完成业务逻辑。

public class

MoneyTransferServiceDomainModelImpl

implements

MoneyTransferService {

private

AccountRepository accountRepository;

private

BankingTransactionRepository bankingTransactionRepository;

. . .

@Override

public

BankingTransaction transfer(

String fromAccountId, String toAccountId, double amount) {

Account fromAccount = accountRepository.findById(fromAccountId);

Account toAccount = accountRepository.findById(toAccountId);

. . .

fromAccount.debit(amount);

toAccount.credit(amount);

BankingTransaction moneyTransferTransaction =

new

MoneyTranferTransaction(fromAccountId,toAccountId,amount);

bankingTransactionRepository.addTransaction(moneyTransferTransaction);

return

moneyTransferTransaction;

}

}
```

通过 DDD 重构后，虽然类的数量比以前多了一些，但是每个类的职责更加单一，代码的可读性和可扩展性也随之提高。

### 7.3 数据驱动和领域驱动

#### 7.3.1 数据驱动

目前主流的开发模式是由数据驱动的。数据驱动的开发很容易上手，有了业务需求，创建数据库表，然后编写业务逻辑，开发过程如图 7-1 所示。数据驱动以数据库为中心，其中最重要的设计是数据模型，但随着业务的增长和项目的推进，软件开发和维护的难度会急剧增加。

图 7-1 数据驱动研发过程

以客户关系管理（Customer Relationship Management，CRM）为例，其中很重要的概念有销售、机会、客户、私海、公海，实体的定义分别如下。

销售（Sales）：公司的销售人员，一个销售可以拥有多个销售机会。

机会（Opportunity）：销售机会，每个机会包含至少一个客户信息，且归属于一个销售人员。

客户（Customer）：客户，也就是销售的对象。

私海（Private sea）：专属于某个销售人员的领地（Territory），私海里面的客户，其他销售人员不能触碰。

公海（Public sea）：公共的领地，所有销售人员都可以从公海里捡入客户到其私海。

按照我们曾经学习的数据库建模理论，对于上面的场景，不难画出图 7-2 所示的实体联系（Entity Relationship，ER）图。

图 7-2 CRM 的 ER 图

可以看到，图 7-2 所示的 ER 图中不存在公海和私海，因为所谓的机会在私海，就是这个机会是不是归属某个销售，这样我们只需要看机会上是否有 salesId。如果有，说明机会被某个销售占有，也就是在私海中；反之，这个机会就在公海中。

在这种开发模式下，最后的产出是几张数据库表，以及针对表中数据进行操作的事务脚本，如图 7-3 所示。

图 7-3 事务脚本实现

#### 7.3.2 领域驱动

领域驱动设计关心的是业务中的领域划分（战略设计）和领域建模（战术设计），其开发过程不再以数据模型为起点，而是以领域模型为出发点，研发过程如图 7-4 所示。领域模型对应的是业务实体，在程序中主要表现为类、聚合根和值对象，它更加关注业务语义的显性化表达，而不是数据的存储和数据之间的关系。

这是「领域驱动设计」和「数据驱动设计」之间显著的区别。

图 7-4 领域驱动研发过程

仍以上面的 CRM 为例。假如我们先不考虑数据模型，而是采用面向对象分析（Object Oriented Analysis，OOA）对这个场景进行领域建模，那么可以得到图 7-5 所示的领域模型。

图 7-5 CRM 的领域模型

可以看到，在图 7-5 中，领域模型的描述更加贴近业务，一些重要的业务术语和概念没有丢失，更完整地表达了业务语义。即使是产品经理或者业务人员，也不难看懂这样的领域模型，甚至他们可以和技术人员一起参与到梳理领域模型和创建活动中来。

通过 DDD 的战略设计和战术设计，我们可以为问题域划分出合适的子域，并对域中的业务进行建模。图 7-6 所示是我们在实际工作中为 CRM 进行的领域战略设计。

图 7-6 CRM 的领域划分

#### 7.3.3 ORM

很明显，领域模型和数据模型并不是一一对应的关系，但也不排除，有些情况领域模型和数据模型是趋同的，但是大部分情况都需要做一层映射（Mapping）。为了弥补二者之间的差异，行业先驱们做了很多关于映射工作的尝试，这种技术有一个名称叫作对象关系映射（Object Relationship Mapping，ORM），如图 7-7 所示。

图 7-7 对象关系映射

ORM 曾经非常火，记得当年 Hibernate 才出现时，我用尽了其中的高级技巧，比如继承关系映射、多对多关系映射…… 结果弄出来的东西却变成了「四不像」，既不像 Entity，也不像数据对象（Data Object，DO）。

ORM 的问题在于它太理想化，期望通过工具把数据建模和领域建模合一，这样的尝试注定是很难成功的。仍以上述的 CRM 案例为例，在数据模型中根本就没有私海和公海这两个实体，工具是无法映射的。因此，Hibernate 和 JPA 的衰落是可以预见的。现在使用最多的是 MyBatis，它很简单，完全不理会复杂的关系和对象之间的复杂关系映射，只做数据库表和 DO 之间的简单映射。

复杂的数据库关系和对象关系之间的差异，其本质是数据模型和领域模型之间的差异，而这种差异的多样性和灵活性是很难通过规则预先定义的，这也是为什么工具的作用会很有限。现在的互联网大厂大多使用 MyBatis，原因也在于此。因此，如果你打算实践 DDD，请一定不要让工具帮你去建模，工具不会抽象，也不会思考，还是要老老实实自己动手去建。

### 7.4 DDD 的优势

通过上面的介绍，相信读者对 DDD 有了一些认识，接下来对 DDD 的优势会更容易接受。如果一开始不能接受 DDD 也没有关系，我其实也经历过「排斥 — 接受 — 使用」的过程。当真正领会 DDD 的精髓之后，我就再不愿意回到以前的开发模式了。下面将 DDD 带来的核心好处总结如下。

#### 7.4.1 统一语言

统一语言（Ubiquitous Language）的主要思想是让应用能和业务相匹配，这是通过在业务与代码中的技术之间采用共同的语言达成的。业务语言起源于公司的业务侧，业务侧拥有需要实现的概念。业务语言中的术语由公司的的业务侧和技术侧通过协商来定义（意味着业务侧也不能总是选到最好的命名），目标是创造可以被业务、技术和代码自身无歧义使用的共同术语，

即统一语言。代码、类、方法、属性和模块的命名必须和统一语言相匹配，必要的时候需要对代码进行重构！

试想，在 PRD 文档、设计文档、代码以及团队日常交流中，如果有一套领域术语是统一无歧义的，是否会极大地提升沟通和工作效率？在日常工作中，因为概念理解不一致，或者语言表达上的问题，导致沟通效率低，甚至发生误解的情况实在太多了。所以，明确概念、形成统一语言至关重要。

#### 7.4.2 面向对象

DDD 的核心是领域模型，这一方法论可以通俗地理解为先找到业务中的领域模型，以领域模型为中心，驱动项目开发。领域模型的设计精髓在于面向对象分析、对事物的抽象能力，一个领域驱动架构师必然是一个面向对象分析的大师。

DDD 鼓励我们接触到需求后第一步就是考虑领域模型，而不是将其切割成数据和行为，然后用数据库实现数据，用服务实现行为，最后造成需求的首尾分离。DDD 会让你首先考虑业务语言，而不是数据。DDD 强调业务抽象和面向对象编程，而不是过程式业务逻辑实现。重点不同，导致编程世界观不同。

#### 7.4.3 业务语义显性化

统一语言也好，面向对象也好，最终的目都是为代码的可读性和可维护性服务。统一语言使得我们的核心领域概念可以无损地在代码中呈现，从而提升代码的可理解性。例如，在银行转账的案例中，按照事务脚本的写法来写「透支策略」的业务概念，其含义完全被淹没在代码逻辑中没有突显出来。但是，如果我们使用策略模式将其抽象出来，让业务语义得到显性化的表达，代码的可读性就会提升很多。

面向对象也是让代码尽量体现领域实体和实体之间的关系原貌，所以目的也是业务语义被显性化地表达，显性化的结果是代码更容易被理解和维护，殊途同归，一切都是为了控制复杂度。在软件的世界里，任何的方法论如果最终不能落在「减少代码复杂度」这个焦点上，那么都是有待商榷的。

#### 7.4.4 分离业务逻辑和技术细节

代码复杂度是由业务复杂度和技术复杂度共同组成的。实践 DDD 还有一个好处，是让我们有机会分离核心业务逻辑和技术细节，让两个维度的复杂度有机会被解开和分治。如图 7-8 所示，核心业务逻辑是整个应用的核心，最好只是简单 Java 类（Plan Old Java Object，POJO）。也就是说，核心业务逻辑对技术细节没有任何依赖，依赖都是由外向内的，即使有由内向外的依赖，也应该通过依赖倒置来反转依赖的方向。通过这样的划分，Entities 只要安安心心地处理业务逻辑就好，业务逻辑越复杂，这样划分带来的好处越明显。

图 7-8 业务逻辑和技术细节分离的架构

为什么说数据库、框架和 UI 都是技术细节呢？

数据库：业务逻辑不应该受限于存储方式，也就是不论你是使用关系型数据库还是 NoSQL，都不应该影响业务逻辑的实现。数据本身很重要，但数据库技术仅仅是一个实现细节。

UI：UI 只是一种 I/O 设备的呈现，Web、WAP 和 Wireless 都是不同的 I/O，我们的核心业务逻辑应该与如何呈现解耦，以及针对不同的端可以使用不同的适配器（Adaptor）去做适配。

框架：不要让框架侵入我们的核心业务代码，以 Spring 为例，最好不要在业务对象中到处写 @autowired 注解。业务对象不应该依赖框架。

这么说来，这些技术细节是不重要了吗？不是的，技术细节是一个系统的必要组成部分，也非常重要。技术细节和核心业务逻辑是两个维度的重要性，如果把软件比喻成一个人，那么核心业务逻辑是大脑，技术细节是身体，二者都很重要，分开处理主要是为了降低复杂度。

### 7.5 DDD 的核心概念

#### 7.5.1 领域实体

毫不夸张地说，我们的软件系统就是对现实世界的真实模拟。如图 7-9 所示，现实世界中的事物在软件世界中可以被模拟成一个对象：该事物在现实世界中被赋予什么职责，在软件世界中就被赋予什么职责；在现实世界中拥有什么特性，在软件世界中就拥有什么属性；在现实世界中拥有什么行为，在软件世界中就拥有什么函数；在现实世界中与哪些事物存在怎样的关系，在软件世界中就应当与它们发生怎样的关联。这正是面向对象编程的核心思想，也是 DDD 中寻找领域实体的核心思想。

图 7-9 现实世界与软件世界

假如现在你需要设计一个中介系统，一个典型的 User Story 是「小明去找工作，中介让他留个电话，有工作机会就会通知他」。我们要如何寻找该业务中的关键领域实体呢？一个简单的方式就是「找名词」，分析这些名词，不难得到以下可能成为实体的候选项。

小明：一个求职者。

电话：求职者的相关信息，可以是一个属性。

中介：可以拆解为中介公司和中介公司的员工两个概念。

工作机会：对于中介系统来说，工作机会应该是最关键的实体之一。

通知：作为名词是一个实体，但是作为一个动词是在暗示我们可以使用 Notify。

是的，对于这个简单的 User Story，这样分析就可以了。当然，随着更多的 Story 被加入，我们会补充更多的实体，比如增加了「中介费是按照小明第一个月工资的 30% 收取」，那么就可能要引入「订单」和「支付」等实体。

以上就是我在实际工作中寻找领域实体的大致过程。从方法论的角度来说，也叫作「用例分析法」，详细的步骤会在 7.6.1 节中介绍。

#### 7.5.2 聚合根

聚合根（Aggregate Root）是 DDD 中的一个概念，是一种更大范围的封装，会把一组有相同生命周期、在业务上不可分割的实体和值对象放在一起，只有根实体可以对外暴露引用，这也是一种内聚性的表现。

确定聚合边界要满足固定规则（Invariant），是指在数据变化时必须保持的一致性规则，具体规则如下。

根实体具有全局标识，最终负责检查规定规则。

聚合内的实体具有本地标识，这些标识在 Aggregate 内部才是唯一的。

外部对象不能引用除根 Entity 之外的任何内部对象。

只有 Aggregate 的根 Entity 才能直接通过数据库查询获取，其他对象必须通过遍历关联来发现。

Aggegate 内部的对象可以保持对其他 Aggregate 根的引用。

Aggregate 边界内的任何对象在修改时，整个 Aggregate 的所有固定规则都必须满足。

仍以银行转账的例子来说明，如图 7-10 所示，账号（Account）是客户信息（CustomerInfo）Entity 和值对象（Address）的聚合根，交易（Tansaction）是流水（Journal）的聚合根，流水是因为交易才产生的，具有相同的生命周期。

图 7-10 聚合根示例

#### 7.5.3 领域服务

有些领域中的动作是一些动词，看上去并不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单地把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，推荐的实践方式是将它声明成一个服务。

这样的对象不再拥有内置的状态，其作用仅仅是为领域提供相应的功能。Service 往往是以一个活动来命名，而不是 Entity 来命名。

例如在银行转账的例子中，转账（transfer）这个行为是一个非常重要的领域概念，但是它发生在两个账号之间，归属于账号 Entity 并不合适，因为一个账号 Entity 没有必要去关联它需要转账的账号 Entity。在这种情况下，使用 MoneyTransferDomainService 就比较合适了。识别领域服务，主要看它是否满足以下 3 个特征。

1、服务执行的操作代表了一个领域概念，这个领域概念无法自然地隶属于一个实体或者值对象。

2、被执行的操作涉及领域中的其他对象。

3、操作是无状态的。

#### 7.5.4 领域事件

领域事件（Domain Event）是在一个特定领域由一个用户动作触发的，是发生在过去的行为产生的事件，而这个事件是系统中的其他部分或者关联系统感兴趣的。

为什么领域事件如此重要？因为在分布式环境下，很少有业务系统是单体的（Monolithic），消息作为分布式系统间耦合度最低、最健壮、最容易扩展的一种通信机制，是我们实现分布式系统互通的重要手段。关于领域事件，我们需要注意两点，分别是事件命名和事件内容。

1、事件命名。

事件是表示发生在过去的事情，所以在命名上 推荐使用 Domain Name + 动词的过去式 + Event，这样可以更准确地表达业务语义。例如，在银行转账的例子中，对于转账成功和失败我们都需要发出事件通知，可以定义两个领域事件如下。

1）MoneyTransferedEvent：表示转账成功发出的事件。

2）MoneyTransferFailedEvent：表示转账失败发出的事件。

2、事件内容。

事件内容在计算机术语中叫作 payload，有以下两种形式。

1）自恰（Enrichment）：就是在事件的 payload 中尽量多放数据，这样 consumer 不需要回查就能处理消息，也就是自恰地处理消息。

2）回查（Query-Back）：这种方式是只在 payload 放置 id 属性，然后 consumer 通过回调的形式获取更多数据。这种形式会加重系统的负载，可能会引起性能问题。

#### 7.5.5 边界上下文

领域实体的意义是有上下文的，比如同样是 Apple，在水果店和苹果手机专卖店中表达出的含义就完全不一样。边界上下文（Bounded Context）的作用是限定模型的应用范围，在同一个上下文中，要保证模型在逻辑上统一，而不用考虑它是不是适用于边界之外的情况。

那么不同上下文之间的业务实体要如何实现交互呢？就像关系数据库和对象之间需要 ORM 一样，不同上下文之间的实体也需要映射。在 DDD 中，这种机制叫作上下文映射（Context Mapping），我们可以使用防腐层（Anti-Corruption）来完成映射的工作。

如图 7-11 所示，在我们开发的 CRM 系统中，商家的客户大部分是来自于 ICBU 网站的会员，虽然二者有很多属性都是一样的，但我们还是有必要引入防腐层来做上下文映射，主要有以下两个原因。

1）虽然属性大部分一样，但二者的作用和行为在各自上下文中是不一样的。

2）解耦影响，加入了防腐层之后，网站的会员变化就不会影响到 CRM 系统了。

图 7-11 边界上下文示例

### 7.6 领域建模方法

#### 7.6.1 用例分析法

1、方法介绍。

用例分析法是进行领域建模中最简单可行的方式，其步骤如下。

1）获取用例描述。既然领域模型指的是问题域模型，那么建模也一定要从问题域入手。那么问题域的知识如何表现出来呢？一种最常见的方式是通过用例，也可以通过场景（Scenario）来分析，总之就是一段格式化的需求文字描述。

2）寻找概念类。寻找概念类就是对获取的用例描述进行语言分析，识别名词和名词短语，将其作为候选的概念类。当然，需求描述中的名词不可能完全等价于概念类，自然语言中的同义词和多义词都需要在此处进行区分。还有很多名词可能只是概念类的属性，不过没关系，在这一步骤中可以都提取出来，在第 4 步中再区分出概念类和属性。

3）添加关联。关联意味着两个模型之间存在语义联系，在用例中的表现通常为两个名词被动词连接起来，如图 7-12 所示。

在添加关联关系时要注意以下几点。

并非所有动词关联的概念类都需要作为关联存在，更重要的是我们需要判断两个概念类的关系是否需要被记住。

应该尽量避免加入大量关联。

关联不代表数据流，也不代表系统调用关系。

图 7-12 语义分析示例

4）添加属性。我们需要区分概念类和属性（当然名词列表也会有无用的词语）。例如，对于上文抽取到的名词列表，「品名」是「商品」的属性，「iTouch」为无用的词语。

如何判断一个名词是否是属性？可以用下面两种方式。

能完全通过基本数据类型（数字、文本、日期）表达的大多是属性。

如果一个名词只关联一个概念类，并且其自身没有属性，那么它就是另一个概念类的属性。

5）模型精化。模型精化是可选的步骤，有时我们希望在领域模型中表达更多的信息，这时会利用一些新的手段来表达领域模型，包括泛化、组合和子域划分等。领域模型可以使用 UML 的泛化和组合表达模型间的关系，表达的是概念类的「is-a」和「has-a」的关系。子领域划分是常见的拆解领域的方式，通常来说，我们会将更内聚的一组模型划分为一个子领域，形成更高一层的抽象，有利于系统的表达和分工。

2、案例介绍。

下面举例说明，内容来自论文「Object-Oriented Analysis from Textual Specifications」，文中讲述了如何通过自然语言分析来做面向对象分析。

用例描述如下所示：

Vendors may be sales employees or companies. Sales employees receive a basic wage and a commission, whereas companies only receive a commission. Each order corresponds to one vendor only, and each vendor has made at least one order, which is identified by an order number. One basic wage may be paid to several sales employees. The same commission may be paid to several sales employees and companies.

接下来，我们按照用例分析法的步骤来建模。

1）寻找概念类。首把所有名词标记出来，作为概念类的候选类：vendors, sales employees, companies, basic wage, commission, order, order number。

2）添加关联。如图 7-13 所示，接下来为名词添加关联，连接这些名词的动词会出现在关联的线上。注意，根据上面的用例，我们还不清楚给供应商（Vendor）支付佣金（Commission）的主体是谁，但这并不妨碍在本阶段的建模。

图 7-13 添加关联示例

3）添加属性。最后，为这些候选的概念类选择属性。在本例中，如果一个概念类只处于一个被动的关联关系中（如 Basic Wage, Commission, OrderNumber），那么它需要作为关联类的属性，如图 7-14 所示。

图 7-14 添加属性示例

#### 7.6.2 四色建模法

1、方法介绍。

四色建模法源于 Peter Coad 的 Java Modeling In Color With UML 一书，它是一种模型的分析和设计方法，要把所有模型分为 4 种类型，用 4 种颜色表示，如图 7-15 所示。

图 7-15 四色模型

在四色模型中，我们将抽象出来的对象分成 4 种原型（archetype）。

1）业务关键时刻（Moment-Interval）。

这种对象表示那些在某个时间点存在或者会存在一段时间。这样的对象往往表示了一次外界的请求，比如一次询价（Quotation）、一次下单（Order）或者一次租赁（Rental）。

Moment-Interval 是最重要的一类对象，是系统的价值所在，一般用粉红色来表示。这样的对象一般有一个起始时间和终止时间，以及一个唯一的标识号，用来唯一地标识这一次客户请求，比如 OrderNo。

注意，「业务关键时刻」是我给「Moment-Interval」起的中文名称，本来想直译为「时刻 - 时间段」，但感觉「时刻 - 时间段」不能体现出这种对象类型的重要性。

2）角色（Role）。

这种对象表示一种角色，往往由人或者物来承担，会有相应的责任和权利。一般，一个 Moment-interval 对象会关联多个 Role。例如，一次下单涉及两个 Role，分别是客户（Customer）和商品（Product）。

这类对象是除 Moment-interval 对象之外最重要的一类对象，一般用黄色来表示。

3）人 - 事 - 物（Party,Place or Thing）。

这种对象往往表示一种客观存在的事物，例如人、组织、产品或者配件等，这些事物会在一种 moment-interval 中扮演某个 Role。例如，某个人既会在一次购买中扮演 Customer 的角色，也可以在询价中扮演询价人的角色。这类对象的重要程度排在第三，一般用绿色来表示。

4）描述（Description）。

这种对象一般是用于分类或者描述性的对象，它的属性一般是这一类事物都有的属性，一般用蓝色来表示。

2、案例介绍。

下面通过一个电商业务场景，来介绍如何通过四色模型进行建模，该案例来自 InfoQ 的文章《运用四色建模法进行领域分析》。

用户故事如下：

现在你是一家在线电子书店的 COO。突然有一天，有一位顾客向你投诉，说他订购的书少了一本，并且价钱算错了，他多给了钱。在承诺理赔之前，你需要核对这位顾客说的是否属实。那么这时你需要知道什么样的信息才能做出准确的判断。

简单来说，你需要知道这位顾客订购了哪些书籍、付了多少钱，以及书店到底为这个顾客递送了哪些书籍。不幸的是，由于科技不够发达，你无法直接驾驶时间机器回到从前去亲眼看看发生了什么事。但幸运的是，你并不需要这么做，你只需要看看这位顾客的订单和网银的支付记录，以及你们书店交给 EMS 的快递单存根，就可以知道这些信息了。

从上面这个故事中我们可以看到： 任何的业务事件都会以某种数据的形式留下足迹。我们对于事件的追溯可以通过对数据的追溯来完成。正如在故事中，你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度地还原当时事情发生的场景。当把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰地推测出在过往的一段时间内发生了哪些事情。

为什么这些业务数据具备可追溯性（Tracibility）呢？因为这些数据都是关键业务流程执行的结果。如图 7-16 所示，比如订单是业务的起点，而 快递存根是业务的终点，正是这些数据在支撑运营体系的关键流程的执行结果。

图 7-16 在线电子书店的关键业务流程

除了上述例子之外，对于任何一笔正常的经济往来，我们需要知道如下内容。

如果我付出一笔资金，那么我的权益是什么？

如果我收到一笔资金，那么我的义务是什么？

这些问题都需要业务系统捕捉到相应的足迹才能够回答，所以企业的业务系统的主要目的之一，就是记录这些足迹，并将这些足迹形成一条有效的追溯链。

足迹通常都具有一个有意思的特性，即它们是 Moment-interval（要么是「时间时刻」，要么是「时间段」）的。发现这些业务关键时刻对象就是建模的起点。对这些对象稍加整理，我们就能得到图 7-17 所示的整个领域模型的骨干。

图 7-17 在线电子书店的业务关键时刻对象

在得到骨干之后，我们需要丰富这个模型，使它可以更好地描述业务概念。这时我们需要补充一些实体对象，通常实体对象有 3 类，即人 - 事 - 物（Party，Place or Thing），如图 7-18 所示。

图 7-18 在线电子书店的人 - 事 - 物对象

在这个基础上，我们可以进一步抽象，将这些实体参与到各种不同的流程中去，这时就需要用到角色（Role），如图 7-19 所示。

图 7-19 在线电子书店的角色对象

最后，把一些需要描述的信息放入描述（Description）对象，如图 7-20 所示。

图 7-20 电子书店的描述对象

这样，我们就得了应用四色建模方法建立的一套领域模型。简要回顾一下上面的过程，不难发现此次建模的次序和重点。

1、首先以满足管理和运营的需要为前提，寻找需要追溯的事件，或者称为关键业务时刻。

2、根据这些需要追溯，寻找足迹以及相应的关键业务时刻对象。

3、寻找「关键业务时刻」对象周围的「人 - 事 - 物」对象。

4、从「人 - 事 - 物」中抽象出角色。

5、把一些描述信息用对象补足。

由于在第一步中我们就将管理和运营目标作为建模的出发点，因此整套模型实际上是围绕「如何有效地追踪这些目标」而建立的，这样可以保证模型能够支撑企业的运营。

### 7.7 模型演化

建模不是一次性的工作，也不可能是一次性的工作。业务在变化，我们对业务的理解在变化，因此模型也要随之变化。就像生产力和生产关系，当生产关系不能满足生产力发展时，一轮变革就在所难免了。

建模的过程很像盲人摸象，不同背景人用不同的视角看同一个东西，其理解也是不一样的。比如两个盲人都摸到大象鼻子，一个人认为是像蛇（活的能动），而另一个人认为像消防水管（可以喷水），那么他们将很难集成，双方都无法接受对方的模型。

事实上，他们需要一个新的抽象，这个抽象需要把蛇的「活着的特性」与消防水管的「喷水功能」合并到一起，而这个抽象还应该排除前两个模型中一些不确切的含义和属性，比如毒牙或者卷起来放到消防车上去的行为。此时，这个新的抽象也许还不叫大象鼻子，但是已经很接近大象鼻子的属性和功能了，随着对模型对象和业务理解的深入，我们会不断调整演化模型，使其越来越逼近真相。

世界上唯一不变的就是变化，模型和代码一样，也需要不断地重构和演化。在每一次演化之后，开发人员应该对领域知识都会有更加清晰的认识，这使得理解上的突破成为可能。通过一系列快速的改变，我们得到了更符合用户需要且更加切合实际的模型，其功能性及说明性急速提升，而复杂性却随之降低。这种突破需要我们对业务有更加深刻的领悟和思考。

### 7.8 为什么 DDD 饱受争议

要不要 DDD？如何实现 DDD？在业界一直是有争议的话题，虽然很多团队声称自己是 DDD 的，但是能够把 DDD 运用得很好并从中受益的团队并不多。我就见过有团队花大力气去做 DDD 的转型，结果系统的复杂度不但没有降低，反而变得更加复杂，又不得不花大力气改回 Service+DAO 的贫血模式。

为什么 DDD 项目会失败呢？这里说的「失败」并不仅仅指项目做不出来，很少有项目是通过「写代码」实现不了的，这里的「失败」更多地是指项目没有达到预期的控制复杂度的效果。以我的经历来看，DDD 项目失败的主要原因如下。

#### 7.8.1 照搬概念

很多人是通过阅读《领域驱动设计：软件核心复杂性应对之道》开始入门领域驱动设计的，这本书中提到了很多概念，比如 Repository、Domain 和 ValueObject 等，但是初学者可能会误认为在项目架构中加入 Repository、Domain 和 ValueObject 就变成了 DDD 架构。如果没有悟出其精髓就在项目中加入这些概念，那充其量也不过是「老三层架构」的变种； 反之，对于一个面向对象分析的高手而言，不使用这些概念也可以实现领域驱动设计。

很多失败的 DDD 项目，都是因为团队教条地照搬概念，而没有领会 DDD 的精髓导致的，这一点非常值得我们注意。

#### 7.8.2 抽象的灵活性

不同的人看问题的角度和对业务的理解各不相同，对未来的前瞻性思考也有所不同，这就导致在对同一个业务进行建模时经常会出现分歧。更麻烦的是，这些不同的模型通常都能工作，没有一个绝对的标准判断哪个模型更「正确」。

不同于纯粹的技术，领域建模的确十分依赖经验，更加依赖个人的综合能力。因此，如果团队决定实施 DDD，必须要有一个经验丰富的人来带领，否则，不合理的抽象还不如没有抽象。

#### 7.8.3 领域层的边界

在 DDD 的架构中，核心部分是领域层。但是领域层的边界在哪里，如何划分 Application 层逻辑和 Domain 层逻辑是很模糊的，在实际项目中，架构层次边界的模糊也会导致项目结构混乱无序。

图 7-21 是一个非常流行的关于 DDD 架构的分层结构，我们可以看到 Domain 是对 Infrastructure 有依赖的。在开始实践 DDD 时，包括 COLA 1.0，我们都采用了这种分层机制。

图 7-21 DDD 的架构分层

也经常有人问我，Repository 要放在哪里，是放在 Domain 层，还是 Infrastructure 层？

一开始我对这个问题是不以为然的，直到读到 Robert C. Martin 的《架构整洁之道》一书，作者提出整洁的架构应该是「核心业务逻辑和技术细节相分离」的，才触发了我对 Domain 依赖 Infrastructure 合理性的重新思考，最终在 COLA 2.0 时，我们决定让 Domain 变得更加独立。

我们可以通过以下两种方式消除 Domain 的依赖问题。

1、使用依赖倒置，让 Infrastructure 反向依赖 Domain。

2、将 Repository 上移到 Application 层，也就是把组装 Entity 的责任转移给 Application。

分离之后的架构将是以 Domain 为核心的环状形式，如图 7-8 所示。这样的设计更加有利于关注点的分离和控制复杂度，具体的做法可以参考 13.6 节。