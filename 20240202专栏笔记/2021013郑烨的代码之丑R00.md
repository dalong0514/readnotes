## 记忆时间

## 卡片

### 0101. 主题卡 ——

这本书的主题核心，就是最大的反常识卡，并且注意时间脉络。

### 0201. 术语卡 ——

根据反常识，再补充三个证据——就产生三张术语卡。

### 0202. 术语卡 ——

### 0203. 术语卡 ——

### 0301. 人名卡 ——

根据这些证据和案例，找出源头和提出术语的人是谁——产生一张人名卡，并且分析他为什么牛，有哪些作品，生平经历是什么。

### 0401. 金句卡 ——

最后根据他写的非常震撼的话语——产生一张金句卡。

### 0501. 行动卡 ——

行动卡是能够指导自己的行动的卡。

### 0601. 数据信息卡 ——

### 0701. 任意卡 ——

最后还有一张任意卡，记录个人阅读感想。

## 0000. 开篇词 | 这一次，我们从「丑」代码出发

我在「极客时间」里已经写了两个专栏，分别是《10x 程序员工作法》和《软件设计之美》，从工作原则和设计原则两个方面对软件开发的各种知识进行了探讨，帮助你搭建了一个开启程序员精进之路的框架。不过，无论懂得多少道理，程序员依然要回归到写代码的本职工作上。所以，这次我准备和你从代码的坏味道出发，一起探讨如何写代码。

### 01. 千里之堤毁于蚁穴

为什么要讲这个话题，就让我们先从一次代码评审讲起。在一次代码评审中，我注意到了这样一段代码：

```java
public void approve(final long bookId) {
    ...
    book.setReviewStatus(ReviewStatus.APPROVED);
    ...
}
```

这是在一个服务类里面写的，它的主要逻辑就是从仓库中找出一个作品，然后，将它的状态设置为审核通过，再将它存回去。前后的代码都属于常规的代码，但是，设置作品评审状态的代码引起了我的注意，于是有了下面这段对话。

我：这个地方为什么要这么写？

同事：我要将作品的审核状态设置为审核通过。

我：这个我知道，但为什么要在这里写 setter 呢？

同事：你的意思是？

我：这个审核的状态是作品的一个内部状态，为什么服务需要知道它呢？也就是说，这里通过 setter，将一个类的内部行为暴露了出来，这是一种破坏封装的做法。

同事被我说动了，于是这段代码变成了下面这个样子：

```java
public void approve(final long bookId) {
    ...
    book.approve();
    ...
}
```

之所以我注意到这段代码，完全是因为这里用到了 setter。在我看来，setter 就是一个坏味道，每次一看到 setter，我就会警觉起来。

setter 的出现，是对于封装的破坏，它把一个类内部的实现细节暴露了出来。我在《软件设计之美》中讲过，面向对象的封装，关键点是行为，而使用 setter 多半只是做了数据的聚合，缺少了行为的设计，这段代码改写后的 approve 函数，就是这里缺少的行为。

再扩展一步，setter 通常还意味着变化，而我在《软件设计之美》中讲函数式编程时也说过，一个好的设计应该尽可能追求不变性。所以，setter 也是一个提示符，告诉我们，这个地方的设计可能有问题。

你看，一个小小的 setter，背后却隐藏着这么多的问题。而所有这些问题，都会让代码在未来的日子变得更加不可维护，这就是软件团队陷入泥潭的开始。

我也一直和我团队的同学说，「写代码」有两个维度：正确性和可维护性，不要只关注正确性。能把代码写对，是每个程序员的必备技能，但能够把代码写得更具可维护性，这是一个程序员从业余迈向职业的第一步。

将坏味道重构为整洁代码

或许你也认同代码要有可维护性，也看了很多书，比如《程序设计实践》《代码整洁之道》等等，这些无一不是经典中的经典，甚至连怎么改代码，都有《重构》等着我们。没错，这些书我都读过，也觉得从中受益匪浅。

不过，回到真实的工作中，我发现了一个无情的事实：程序员们大多会认同这些书上的观点，但每个人对于这些观点的理解却是千差万别的。

比如书上说：「命名是要有意义的」，但什么样的命名才算是有意义的呢？有的人只理解到不用 xyz 命名，虽然他起出了自认为「有意义」的名字，但这些名字依然是难以理解的。事实上，大部分程序员在真实世界中面对的代码，就是这样难懂的代码。

这是因为，很多人虽然知道正面的代码是什么样子，却不知道反面的代码是什么样子。这些反面代码，Martin Fowler 在《重构》这本书中给起了一个好名字，代码的坏味道（Bad Smell）。

在我写代码的这 20 多年里，一直对代码的坏味道非常看重，因为它是写出好代码的起点。有对代码坏味道的嗅觉，能够识别出坏味道，接下来，你才有机会去「重构（Refactoring）」，把代码一点点打磨成一个整洁的代码（Clean Code）。Linux 内核开发者 Linus Torvalds 在行业里有个爱骂人的坏名声，原因之一就是他对于坏味道的不容忍。

所以，我也推荐那些想要提高自己编程水平的人读《重构》，如果时间比较少，就去读第三章「代码的坏味道」。

不过，《重构》中的「代码的坏味道」意图虽好，但却需要一个人对于整洁代码有着深厚的理解，才能识别出这些坏味道。否则，即使你知道有哪些坏味道，但真正有坏味道的代码出现在你面前时，你仍然无法认得它。

比如，你可以看看 Info、Data、Manager 是不是代码库经常使用的词汇，而它们往往是命名没有经过仔细思考的地方。在很多人眼中，这些代码是没有问题的。正因如此，才有很多坏味道的代码才堂而皇之地留在你的眼皮底下。

所以，我才想做一个讲坏味道的专栏，把最常见的坏味道直接用代码形式展现出来。在这个专栏里，我给你的都是即学即用的「坏味道」，我不仅会告诉你典型的坏味道是什么，而且也能让你在实际的编程过程中发现它们。比如前面那个例子里面的 setter，只要它一出现，你就需要立即警觉起来。

这里我也整理了一份「坏味道自查表」，把一些明显的「坏味道」信号列了出来，你可以和自己的代码做对比。

除了为你列出来哪些代码有坏味道之外，我还会给你讲支撑这些「坏味道」之所以为「坏味道」的原因，比如说：长方法和大类之所以为坏味道，因为它们都违背了单一职责的原则。

有坏味道的代码需要经过重构才能长成新的样子，在这个专栏里，我也会提到一些重构的手法，比如，改名（Rename）、提取方法（Extract Method）等等。在今天，拜许多能力强大的 IDE 所赐，重构已经变得越来越自动化，《重构》里的很多手法已经成为了 IDE 中的一个选项。

我还想给你一个安全提示，即便 IDE 功能再强大，也不要忘了重构的重要根基：测试。即便像 Java 这样，IDE 功能已经非常强大了，依然会有一些像反射之类的场景可能会从自动化重构的鼻子底下溜走。所以，重构一段代码之前，最好能够给它写下测试，确保改动前后的代码，功能上是一致的。

如果你订阅过我的《10x 程序员工作法》和《软件设计之美》，你就会发现，三个专栏一脉相承，这些背后的道理恰恰就是我在那两个专栏中已经提到过的内容。所以，三个专栏一并服用，效果会更佳。

写在最后

最后，还是要做一个自我介绍。我叫郑晔，一个写代码超过二十年的程序员，做过与软件开发的各种工作：编代码、带团队、做咨询、写开源。正如前面所说，我已经在极客时间平台上写了两个专栏，分享我在软件开发中的各种思考。这次，我会带你进入到我的基本功里，帮你一起写好代码。

十年前，我在 InfoQ 写过一个专栏《代码之丑》，把一些真实世界的代码展示了出来，让大家看到丑陋代码是什么样子的。

不少读者都表示，那个专栏让他们受益匪浅。不过，那个系列只是我日常工作的随手之作，没有更好地整理。这个专栏就是脱胎于 InfoQ 上的《代码之丑》，我对相关内容进行了更系统地整理，保证即便看过那个《代码之丑》专栏，你依然能够在这里有所收获。

这是一条通往代码精进之路，我愿意与你一起前行，成为你在这条路上的向导。如果你想摆脱平庸的小白程序员状态，成为一个更优秀的程序员，那么，请加入我的专栏，让我们一起修炼，日益精进写代码的手艺！

### 黑板墙

看到这个 Setter，有个疑惑。在现在的项目中，service 层经常出现各种 setter，基本是把所有逻辑都放到 service 层了。之前网上查询了一些资料，把这种称之为「失血模型」。代码这样写有哪些坏处？在既有的项目中，如果要改变的话，需要从哪里做起呢？作者回复：后面会有一讲专门讨论这个问题，简言之，就是缺了行为，暴露了细节，解决办法就是，引入行为，封装细节。2020-12-28

两个专栏其实已经听了不止一遍，一直想再认真学习一遍，却没能做到。结果现在已经脱离了编程一线，转型项目经理了，不过还是希望终有一天可以继续写代码。写 setter 的原因很有可能是因为那些教程或者代码生成工具，set、get 不亦乐乎。info、Data、Manager 我之前也常用。去 InfoQ 看了一下十年前的专栏，摘抄一下要点：1）让判断条件做真正的选择。2）判断条件里面不允许多个条件的组合。3） switch 陷阱。4）重复，是最为常见的坏味道。5）大心脏是不受喜欢的（函数应该只做一件事）。6）代码的声明和使用应尽量接近。7）工欲善其事，必先利其器（Effective 你的语言）。8）有时候，没有选择是幸福的（两个字符串类）。9）不允许出现多层缩进。10）条件编译里面不允许包含多条执行语句。11）封装全局变量（封装出个行为来）。12）尽量编写无状态方法。13）当容器开始嵌套容器，请考虑封装。14）使用工厂方法处理多个构造函数。2021-01-05

接手一个买回来的商业产品，做二次开发，里面有大量重复代码，此时需要新增一些功能，给的工期短，简单粗暴的办法是继续复制粘贴，再修改修改就可以上线使用，实际上，我们现在就是这么干的。我想请问的是，针对这种烂代码，要去修改它，是应该坚持边加功能边重构，还是一顿复制粘贴用起来先，后续再重构，还是怎么处理比较好。作者回复：先确认你们自己的策略是什么，如果是短时间用用，就抛弃，然后自己重写，还是就打算以这个系统为核心一直维护下去，不同的策略方案是不同的。如果要抛弃，就是另起炉灶，按照好的标准要求新代码；如果是维护，每做一块，就重构一块，并且向负责人说明情况，做好投入技术债的准备。2021-02-03

我们现在的 service 层就是 saveUser,serviceImpl 里调用一个 mybatis 的 mapper.save (user)，请问这样的设计形式是否是混淆了业务和技术，请问有什么建议可以优化？作者回复：如果 mapper 是一个接口的话，就还好。因为它把具体的实现隔离开了。2021-01-22

老师，如果我需要封装一个方法能够对类的一个字段进行多种状态的更改应该怎么封装比较好？作者回复：为什么是一个方法而不是多个方法呢？用一个方法的结果就是一个 setter 的变体。2020-12-31

一个几百行的长 SQL 算不算方法过长呢？一个 bean 有上百个字段光设置属性的值并转 json 不电网络库的代码肯定不止 40 行了。这个怎么解决？作者回复：写出几百行的 SQL，一般都是些存储过程，而存储过程早在很多年前就已经被列到不推荐的做法里了。如果是普通的语句，除非是做某些特殊的统计，一般不建议这么做。一个 Bean 为什么要有上百个字段呢？以我的经验看，这通常是没有想清楚就把所有的东西都塞进来了。所以，应该做的是，做职责分解，把不同的内容放到不同的接口去。2020-12-30

有个疑问想向老师请教，那个 setter 例子，如果一个状态可以改成多种，是应该为了保持可读性重复写多次差不多的代码，还是将要修改的目标状态当成参数也传进去呢？作者回复：如果是顺着你的思路思考这个问题，那答案应该是把状态作为一个参数传递进去。但这样思考问题，还是按照暴露细节的方式在思考，我在《软件设计之美》里讲过，封装应该是考虑行为的，究竟是什么行为导致状态的变化，这是我们应该思考的问题。2020-12-29

## 0001. 课前热身 | 这些需求给到你，你会怎么写代码？

我在开篇词中提到，缺乏识别代码坏味道的感觉，这才让很多问题代码堂而皇之地留在了自己的眼皮底下。识别坏味道，单纯学理论是不够的，你得结合具体问题进行分析，所以我才在课程中加入了大量真实的代码案例，帮助你理解坏味道。当然，除此之外，你还要有足够多的练习。为了让你能够深度地参与到这个专栏的学习中，代码能力得到有效提升，我准备了一个课前热身的环节：大家一起来写代码。

我们要编写一个待办事项管理的软件，你可以看我下面给出的需求，它是以命令行应用的方式存在的。

### 第一阶段：基本功能

1、添加 Todo 项。

```
todo add <item>

1. <item>

Item <itemIndex> added
```

2、完成 Todo 项。

```
todo done <itemIndex>

Item <itemIndex> done.
```

3、查看 Todo 列表，缺省情况下，只列出未完成的 Todo 项。

```
todo list

1. <item1>

2. <item2>

Total: 2 items
```

4、使用 all 参数，查看所有的 Todo 项。

```
todo list --all

1. <item1>

2. <item2>

3. [Done] <item3>

Total: 3 items, 1 item done
```

要求：1）Todo 项存储在本地文件中；2）Todo 项索引逐一递增。

### 第二阶段：支持多用户

1、用户登录。

```
todo login -u user

Password:

Login success!
```

2、用户退出。

```
todo logout

Logout success!
```

要求：1）只能看到当前用户的 Todo 列表；2）同一个用户的 Todo 项索引逐一递增；3）当前用户信息存储在配置文件中～/.todo-config。

### 第三阶段：支持 Todo 列表导入和导出

1、Todo 列表导出。

```
todo export > todolist
```

2、Todo 列表导入。

```
todo import -f todolist
```

### 第四阶段：支持数据库持久化

在配置文件中，配置数据库连接信息。

1、初始化数据库。

```
todo init
```

要求：1）没有数据库的情况下，使用本地文件；2）在有数据库的情况下，使用数据库；3）在本地文件已经存在的情况，将本地信息导入到数据库中。

以上我给出的是最基本的需求，你可以根据自己的实际编码情况，适当补充一些细节，比如，相应的错误提示。你可以用自己最熟悉的程序设计语言、按照自己最习惯的方式编写代码，并在 Github 上以公开仓库的方式提交自己的代码，将仓库链接贴在这节课的留言区下，我会顺着链接找到你的仓库，去查看你写的代码。

为了方便代码的阅读，请你按如下要求编写你的代码：1）在项目的 README 文件中，写出如何构建和执行你的应用；2）需求分成四个阶段，请你按顺序依次完成每个阶段的需求；3）每完成一个阶段的代码，创建一个 tag，tag 名称分别为 todo-phase-1、todo-phase-2、todo-phase-3、todo-phase-4。

之所以要把需求分阶段，主要是方便大家参与，即便你时间有限，只写第一个阶段的代码，依然是一个完整的需求。学过《10x 程序员工作法》的同学都知道，任务分解是一个重要的工作原则，分阶段需求其实就是一种需求层面上的任务分解。在专栏结束之前，我会专门制作一期加餐，点评大家的代码。

### 黑板墙

github 地址：[caitlingao/task_demo](https://github.com/caitlingao/task_demo)。交付内容包括：四个阶段的代码和每个阶段简单的开发分析设计文档。最近在学习 Rust，所以尝试用 Rust 完成这次作业，断断续续用了一周多终于完成第一版，在第一版的基础上又重构了一版，这是重构后的第二版。作者回复：真棒，有 Rust 的版本了！2021-01-13

前端 er 来提交代码了。完成了前三个阶段：[front-end-captain/todo: A TODO project to be used in the terminal](https://github.com/front-end-captain/todo)。2021-01-12

[robbietree8/todo-cli: Micronaut Todo -cli Application](https://github.com/robbietree8/todo-cli)。2021-04-01

[JetaimeNotLove/todo: 用于学习极客时间专栏代码之丑](https://github.com/JetaimeNotLove/todo)，第一阶段基本完成，明天完善下，感觉写的还不错，期待下面的课程打脸。2021-02-21

[TodoList: 待办事项练习](https://gitee.com/wangdengwu/todo-list)，Java 实现，目前完成了第一阶段。2021-02-08

完成第一个阶段，努力在结课前都完成：[TaXueWWL/todo-board: 极客时间代码之丑作业题](https://github.com/TaXueWWL/todo-board)。2021-02-07

1『上面的这位感觉技术水平很强，可以去看他的其他库。（2021-05-03）』

[tofdragon/todoList](https://github.com/tofdragon/todoList)。2021-01-24

第一阶段昨天下午工作之余写的，今天上午来交个一阶段的作业，有空了剩下也会继续写的：[kamjin1996/todo-manager: todo命令行小工具](https://github.com/kamjin1996/todo-manager)。2021-01-14

第一阶段，all 参数，item 展示问题。请问老师是不是 —— 总体上未完成的 item 先于已完成的 item 展示。未完成 item 之间按照加入顺序展示，已完成 item 之间按照完成的顺序展示，是这样吗？作者回复：这是实现细节，都可以，最简单的做法是直接按照顺序展示，不分完成未完成。2021-01-13

我终于可以交作业啦，虽然只是第一阶段，但是居然花了我近 20 个小时，果然变写代码，菜是原罪啊 ，地址：[chenmingchao92/todo-manager](https://github.com/chenmingchao92/todo-manager)。作者回复：多好的一个练手的项目啊！可以重写几遍试试。2021-01-07

[quzehu/todo-command: 极客时间-代码之丑专栏课前练习 一个待办事项命令应用](https://github.com/quzehu/todo-command)。2021-01-05

第一版功能初步完成了，但是很多细节还需重构。[liudaming/todo: 极客时间课程todo](https://github.com/liudaming/todo)。作者回复：完成比完美更重要。2020-12-30

采用 python3 编写，代码支持 Linux、Windows 环境，未打包，具体环境搭建及测试说明见 README.md。[mukuss/todo-list: a job](https://github.com/mukuss/todo-list/tree/main)。作者回复：Python 是 TIOBE 2020 的年度语言，赞！2020-12-30

元旦交代码。1）阶段二，不提供注册用户的功能，将支持的用户信息全部写在 `～/.todo-config` 文件中？2）阶段三，导出的是 all 还是仅未完成，还是可以加指令控制选项？作者回复：第一个问题，答案是可以。第二个问题，导出的是 all，相当于数据库的导入导出。你可以自己加命令行参数，做一些控制，如果你时间多的话。2020-12-29

## 0002. 结束语 | 写代码是一件可以一生精进的事

在结束语这一讲，我想和你聊聊程序员精进的话题。创作《10x 程序员工作法》之初，我曾经定下了「写下 100 篇」的宏伟目标。在第三个专栏结束的时候，这个当年许下的宏伟目标终于实现了。如果为这 100 篇的内容找一个共同的主题，那就是程序员精进之路。

### 01. 程序员精进之路

在很多人心目中，程序员是一个辛苦的职业，一方面，各种新东西层出不穷，程序员们要努力追随，另一方面，业务飞速发展，我们唯有积极应对。那么，是什么支撑你在这个富有挑战的行业里坚持前行呢？于我而言，这个问题的答案是，热爱。

在我的心目中，编程是一项有趣的智力活动，从最初解决一个特定的小问题，到现在创造一个方案去解决一个系统的问题，无不需要费尽心力去探寻一个好的解决方案。时至今日，即便我写程序已经二十多年了，但每次程序运行通过时，我心里依然还是有一些小激动，因为支撑程序运行的每行代码里都有自己的思考在里面。

正是每次一点点积累起来的成就感，激励着我不断去探索更好的做法。一开始，为了解决特定的问题，我四处搜集着各种编程技巧。当我理解了基本功的重要性后，就去拼命地补齐各种基础知识，构建起一个知识体系。随着开源软件运动的兴起，我知道了，原来有各种工具和程序库可以简化自己的工作。因为见识过别人的运指如飞，我曾专门练习了各种快捷键和命令行。

当我已经能够很好地解决自己面对的各种功能问题时，我开始抬起头，有了更大的视野。我学习了各种软件设计的知识，让自己的代码不仅仅是为了今天，也能够面对未来。我学习了各种程序设计语言，看到了隐藏在语言背后的编程范式和思考习惯。我学习了各种软件开发的最佳实践，懂得了怎样让一群人更好地协同。

我做的所有努力，都是为了更好地写代码。有了对于软件开发更多的思考，回过头再来写代码时，我就能看到更多的维度，能意识到自己在写的代码对他人和未来的影响，这时自然会尽力把自己的代码写得更整洁。

时至今日，如果你问我，对自己写的代码满意吗？我的答案还是不满意。写代码是一门手艺，需要不断地打磨。一方面，坚持写代码，保持自己对于代码的体感；另一方面，保持对于代码的敏感度，不断思考对于代码的改进，寻找更好的写法。

经过一段时间，我总会发现代码中让我不满意的地方，这会成为新的驱动力，让我进一步扩充自己的知识，把新的理解注入到代码之中。每次拓展知识边界，与之相伴的都是极大的智力愉悦。也正是这种智力上的快感，让我得到了进一步前进的动力。一个正向反馈的循环就是这样逐步推进，让我在写了二十多年代码之后，依然乐此不疲。

我在《软件设计之美》中讲过，一个好的设计是在一个「小内核」上构建起来，然后，逐步添加更多模型。我们的知识拓展过程也是如此。我的「小内核」就是编写代码这件事，所有一切知识的拓展都是围绕这个内核展开的。写代码是一件可以持续一生的事情，但前提条件是，找到自己的热爱，建立起自己的正向反馈。坚持写代码，发掘代码中值得改进的地方，不断拓展自己的知识边界，寻找更好的代码写法，这就是最朴素的程序员精进之路。

### 02. 代码的敏感度

对于一个不断精进的程序员而言，发掘代码中值得改进的地方，需要对代码有细致入微的敏感度，这样才能体察代码间细微的差别。我给你举个例子：注释。

代码该不该写注释呢？在一些人看来，没有注释的代码不值得写，这甚至成了一些程序员的宗教信仰。如果你问他们为什么要写注释，他们的回答多半是「让程序更加容易理解」。但有另外一群人则将注释视为坏味道，他们会说，为什么不把代码写得更清楚，让代码不需要注释呢？被逼到角落的「注释程序员」依然不会束手就擒，他们不会承认自己不能把代码写清楚，而会说，有些代码必须要有注释才能解释清楚，比如一些算法。

好了，双方的主要观点陈述完毕。你怎么看待注释呢？

早在 1984 年，《计算机程序设计艺术》的作者 Donald Knuth 就给出了一个回答，他提出了「文学编程（Literate Programming）」的概念，其核心要义就是要将程序写得像用自然语言进行表达一样顺畅。虽然作为一种编程范式，它并没有流行起来，但它背后蕴含的思想却影响了很多人，也给我们提出了更高的技术追求。

一个好的程序应该像一篇优美的文章，读起来自然流畅，二者背后有诸多相通之处，你会看到，许多优秀程序员都有着优秀的表达能力。所以，回到写代码本身，把程序本身写得更清楚直白才应该是我们的追求。关于如何把代码写好，我在这个专栏已经讲了很多了。

具体「注释」这件事上，我的观点是，「注释」有其价值，但不应该是主力。我们没见过哪篇文章是要求把注脚作为主旨的，同样，过于强调注释，无异于本末倒置。写代码首先应该是把代码本身写好，至于那些确实无法用代码陈述清楚的部分，我们再考虑用注释。

所以，我赞同把「注释」当做坏味道的提示，先竭力把代码写到不需要用注释，而把注释当作最后的选择。确实有一些特定的处理需要注释，无论是一个精巧的算法，还是一个特殊的技巧。用这个标准要求自己，你会发现，大多数代码其实不需要注释，因为它们太普通了。

你看到了，即便像注释这么简单的东西，写与不写，背后都有着可以探究的各种细节。诚如我在前面所说，写代码是一门手艺，需要不断地打磨。唯有不限界地拓展自我，才可能对代码有细致入微地把握。你发现了，打磨手艺，锤炼自己对于代码的敏感度，坏味道是一个不错的出发点。这也是我写这个专栏的初衷，帮你从识别出那些你曾视而不见的「坏味道」，提升你对代码的敏感度。

在这个专栏中，我给出的就是全部的坏味道吗？显然不是。只要拿出《重构》对照一下，你就会发现，坏味道还有许多，比如，霰弹式修改和发散式变化。我没有拿出来讲，不是它们不重要，而是它们不像我在这个专栏中罗列的这些坏味道那样，有非常直观的表现。

比如，霰弹式修改说的是一次变化要在很多类的内部做修改，但能否察觉出自己改了很多类，这就依赖于每个人的敏感度了。同样，发散式变化说的是，不同的变化都会改到同样的模块上。发现这种坏味道，需要你意识到，对同一个模块的修改是由于不同的原因造成的，这对于敏感度的要求就更高了。

无论如何，「知道」有哪些坏味道是第一步的。我建议你在学习了本专栏之后，花上一点时间，通读一下《重构》的第三章「代码的坏味道」，在开篇词中我就提到过这件事，但与那时不同的是，现在你已经通关了我们这个专栏。

我在专栏里讲的所有这一切，一方面，让你对一些代码的坏味道有直观的认识；另一方面，也是更重要的，对于这些坏味道的分析，是为了帮你看到代码里的细微之处，帮助你提升对于代码的敏感度。有了不同的敏感度，再去通读「代码的坏味道」，你会有不一样的收获。

这些道理都是知易行难，今天我们的课程就告一段落了，但是你的精进之路并未停止。

有了「坏味道」的基础之后，接下来最重要的是，你要在实际的工作中反复地锤炼自己的编程手艺，用这些坏味道作为尺子，衡量自己的代码，不断地找到代码更好的写法。这个专栏以及它的两个「兄弟」，帮你开启了程序员的精进之路，但这条路，总归还是要自己去走！

### 黑板墙

个人感想：1）郑老师从业二十多年依旧在打磨编程手艺，瑞思拜！2）依稀记得 RUP 刚出来的时候，就有人认为今后程序员会被淘汰，因为你甚至可以画画图就生成代码。二十多年过去了，为什么编程仍旧是一门手艺活，而不是大规模的工业化生产？3）我觉得大厂们应该早就实现了工业化生产，毕竟好多年前就可以在一天之内复制粘贴出一个竞品 App 出来。那么在这样的大厂的工业化生产中，个人手艺的重要程度有多少呢？4）说到磨练手艺似乎就会讲到匠人精神，讲到匠人精神大多会拿日本举例子。举个听来的日本刀的例子。职业的刀匠花费大量时间人工打磨的日本刀可以作为工艺品卖出高价，但如果要大规模装备军队的话，就只能依靠工业化生产降低成本。日本刀的收藏家会为刀匠的手艺买单，那么是否会有客户为编程的手艺买单呢？5）通过文学编程来反对注释可能有些牵强，毕竟曾经有段时间通过在代码注释里写文档再把文档抽取出来（如 JavaDoc）也被称为文学编程。程序员不爱写注释和不爱写文档的理由应该是一样的，那么解决的方法只有两种：要么代码像文档一样清晰，要么文档本身就是可执行的代码。郑老师讲的应该是前者，而个人理解的文学编程是后者。文学编程在数据科学 / 机器学习等研究性质的编程中用得较多（如 Jupyter Notebook）。生产系统中要用的话，可能会是 DSL 的形式？（如 Cucumber）6）散弹式修改和发散式变化，应该能够通过自动化分析提交历史得出，这样就不需要依赖个人判断了。不知道都有哪些工具实现了？

作者回复：手艺的重要性，取决于你给自己的定位。从行业整体的角度上，写一个 App 或是网站的速度，确实是越来越快了。这是建立在我们现在有了大量的基础设施上的，有人在最初设计好了架构，其它的程序员都是在这个架构基础上进行构建。这就在建筑行业，有人是设计师，有人是负责施工，你想扮演什么角色呢？建筑的设计师，他们其实也是艺术家，但其实他们也是手艺人，市面的建筑工人可以找到很多，但建筑设计师却很难找到一大把。在程序员这个行业里，优秀的架构师和普通的代码编写者之间并没有一个清晰的界限，他们都在写代码，但他们写的代码重要性是截然不同的，当然，他们的身价也是截然不同的。

你去问任何一个架构师，他绝对不屑于只完成功能，他肯定有更高的追求，无论是让系统的架构更有可扩展性，还是让系统承载更大的容量，抑或是让系统变得更快。这些都是一种不断打磨的手艺，需要不断地锤炼。当你一不小心走到一个公司或是一个领域的最前列，能够给予你指导的，不再是别人已有的解决方案，而是你的品位，而品位的锤炼就是在日常中不断打磨出来的。回到你的问题上，你可以选择永远做一名普通的编码者，在别人画好的圈子里面跳舞，但也没有资格抱怨，世界对你的不公，为什么程序员是有天花板的。你也可以让自己不断地提升，去追求更好的手艺，成为那个让别人可以依赖的人，去解决更多好的问题。2021-02-09

关于注释最近我也冒出了困惑，事由是这样的新来了一位同事他写注释很勤奋，几乎达到一行代码一行注释，当时隐隐觉得不对劲，Review 他的代码后，发现基上是业务怎么要求他就怎么翻译为代码，缺少聚合和封装，因为大家不是一个项目组，且我也不负责考核他，所以就没有去做进一步的事。故事到这你肯定好奇我为什么会去关心他的代码和注释，这是因为这哥们做我背后，他打字手很重，就像一挺 JQ 在持续扫射，以我的经验除了聊天时大家打字有那么快以外，非除是遇到代码大神已经 把绝大部分的事想得很清楚一气合成所有的代码，要不都会在编码时有停下来一段思考的时间，在一天中不会连续高强度的持续输出有效代码。今天在看到 "一个好的程序应该像一篇优美的文章，读起来自然流畅，二者背后有诸多相通之处，你会看到，许多优秀程序员都有着优秀的表达能力。" 深以为然，作家在写作时是要经过反复构思来回修改的，形象点的说法叫磨稿。作者回复：每每写专栏，于我自己而言，就是一遍痛苦的梳理过程。你们看到的稿子都是几经打磨之后的产物。2021-02-09

郑老师，问个问题，我看一些好的开源软件各种继承、实现类关系很复杂，这些开源软件开发之前是需要建模吗？这么多关系怎么分配？作者回复：这其实是一个设计问题，设计一开始都不会太复杂，只解决核心问题，随着需求的增长，设计才会一点一点复杂起来。2021-02-19