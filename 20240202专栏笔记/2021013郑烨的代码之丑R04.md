## 记忆时间

## 目录

0201多久进行一次代码评审最合适.md

0202新需求破坏了代码怎么办.md

0203熊节什么代码应该被重构.md

0204课前作业点评发现你代码里的坏味道.md

## 0201多久进行一次代码评审最合适.md

### 总结时刻

今天的加餐我们讨论了代码评审。对于很多人来说，代码评审只是一个发现问题的过程，而通过今天的讨论，我们知道了代码评审是一个沟通反馈的过程。站在沟通反馈的角度，我们关注的是，尽可能多地暴露问题，尽可能多地做代码评审。代码评审可以从实现方案正确性、算法正确性和代码坏味道的角度去发现问题。代码评审的频率是越高越好，频率越高，发现和解决问题的难度越低，团队越容易坚持下去。

如果把代码评审推向极致就是随时随地做代码评审，这个实践就是结对编程。如果今天的内容你只能记住一件事，那请记住：代码评审暴露的问题越多越好，频率越高越好。

### 1.0

前面我们讲了很多代码的坏味道，我们的关注点都在代码本身上。知道了什么样的代码是坏味道，有了具体的评判标准。那么，该如何去运用坏味道这把「尺子」呢？

有一个发现坏味道的实践，就是代码评审，也就是很多人熟悉的 Code Review，Wikipedia 上定义是这样的：

代码评审，是指对计算机源代码系统化地审查，常用软件同行评审的方式进行，其目的是在找出及修正在软件开发初期未发现的错误，提升软件质量及开发者的技术。

大多数程序员都经历过代码评审，也都能够初步理解代码评审本身存在的价值，这也是差不多全行业都认为有价值的一个实践。只不过，每个团队在代码评审的实践差别还挺大的，有的团队是在一个完整的开发周期结束之后，做一次代码评审；有的是安排每周的代码评审；有的则是每天都要做代码评审。之所以会有这样的差异，主要就是团队对于代码评审本身的理解有差异。

所以，这一讲我们就来谈谈，到底应该如何理解代码评审。

### 1.1 代码评审是一个沟通反馈的过程

关于代码评审，第一个问题就是，为什么要做代码评审？

这个问题其实比较简单，没有人能够保证自己写出来的代码是没有问题的，而规避个体问题的主要方式就是使用集体智慧，也就是团队的力量。这个答案是从个体的角度在看问题，其实，看待代码评审还有一个团队视角，代码评审的过程，也是一个知识分享的过程，保证一些细节的知识不再是隐藏在某一个人的头脑中，而是放置到了团队的层面。

不过，无论是从哪个角度看代码评审，它的本质，就是沟通反馈的过程。我把我对这段代码的理解分享给你，你把你对这段代码的想法共享给我。有人给出代码实现的知识，有人贡献出对技术的理解。

如果我们理解了代码评审是一个沟通反馈的过程，那就可以把沟通反馈的一些原则运用到代码评审中。我在《10x 程序员工作法》里，花了一个模块的篇幅讲了沟通反馈，我们希望沟通要尽可能透明，尽可能及时。把这样的理解放到代码评审中，就是要尽可能多暴露问题，尽可能多做代码评审。

### 1.2 暴露问题

我们先来说暴露问题。代码评审就是一个发现问题的过程，这是一个大家都能理解的事情。但问题就在于，要发现什么问题？

如果泛泛地回答，那自然就是代码实现中的各种问题。然而，这个答案还可以细化一下，做代码评审时，我们可以从下面几个角度来看代码：1）实现方案的正确性；2）算法的正确性；3）代码的坏味道。

我们一个一个来看，先来说实现方案。理论上说，实现方案应该是设计评审中关注的内容，但在实际工作中，并不是所有团队都能够很好地执行设计评审，而且设计评审有时也关注不到特别细的点，所以，一些实现方案的问题只有在代码评审中才能发现。

在一次代码评审中，我看到一个批量处理的 REST 接口，接到请求经过一些处理之后，它会调用另外一个服务，因为这个服务只支持单一的请求，所以，REST 接口只能一个一个地向这个服务发送请求。

如果一切正常的话，这个接口是没有问题的。但是，如果在处理过程中出现失败，没有把所有的请求发给另一个服务，这个接口的行为是什么样呢？是需要客户端重新发起请求，还是服务端本身重新调用接口？如果是服务端负责重试，那么，这个方案本身没有任何重试的机制，也就是说，一个请求一旦出错，它就丢了，业务不能顺利地完成。

当我把这个问题抛了出来时，同事一下子愣住了。显然，他只考虑了正常的情况，而没有考虑出现失败的情况。把它做成一个完整的方案，很可能还需要做一个后台服务，负责替未能得到有效处理的任务善后，显然，这就不是代码调整，而是整个方案的调整。

这是很多程序员，尤其是经验比较少的程序员写程序经常会出现的问题：正常情况一切顺利，异常情况却考虑不足。

我们再来说说算法正确性。

别看整个行业都十分重视算法，但那是在面试的过程中。真正到了实际工作里，算法复杂度常常被人忽略。

我们之前讲过嵌套的代码，对于循环语句，我们要把处理一个元素的代码提取出来。不过，这有时候也会带来一些意想不到的问题。

有一次代码评审，我看到了一段写得很干净的代码，就是把循环里对于一个元素的处理拆了出去。还没等我来赞美这段代码写得好，我就看到了单个元素处理的代码，每次都要查询一次数据库，找出相应的元素，做修改之后再存回去。

就这样，单独看每段代码都是对的，但合在一起就出了问题，本来可以通过一次查询解决的问题变成了 N 次查询。

我再给你讲一个让我印象深刻的故事。在我职业生涯的初期，我做过一段时间图像识别的工作。有一次，一个实习生说自己的代码太慢了，让我帮忙看看。

从表面上看，代码写得还不错，不是一眼能够看出问题。仔细看了半天，我在一个遍历图像像素点的循环里发现了一个图像复制的代码，也就是说，每循环一次，都要把整个图像复制一遍，代码慢就在所难免了。

我相信，如果这是一个算法练习，这两个同事都能够有效地解决这个问题，但放在工程里，就难免挂一漏万了。所以，算法正确性也是我们要在代码评审中关注的。

无论是实现方案的正确性，还是算法的正确性，对于大多数团队来说，都会关注到。但代码坏味道却是很多团队容易忽略的，这里面的关键点就是很多团队对于坏味道的标准太低了。

在这个专栏里，我讲了很多坏味道，有一些是你早就认同的，有一些则在挑战你的认知。也正是因为有这些挑战你认知的部分，所以很多代码即便经过评审，也依然会产生很多问题。关于坏味道，我们整个专栏都在说，更多的细节我就不在这里讨论了。

### 1.3 及时评审

说完代码评审中要暴露的问题，我们再来说说代码评审的另外一个方面，代码评审的频率。

不同的团队代码评审，频率是不一样的，最糟糕的肯定是不评审，整个团队闭着眼睛向前冲，这就不是我们关心的范畴。常见的评审频率是每个迭代评审一次，也有每周评审的。

我对评审的建议是，提升评审的频率，比如，每天评审一次。

评审周期过长是有问题的，周期过长，累积的问题就会增多，造成的结果就是太多问题让人产生无力感。如果遇到实现方案存在问题，要改动的代码就太多了，甚至会影响到项目的发布。

而提升评审的频率，评审的周期就会缩短，每个周期内写出来的代码就是有限的，人是有心力去修改的。学过我任何一个专栏的同学都知道，我在专栏中反复强调短小的价值，只有及时的沟通反馈，才有可能实现这一原则。

你或许会好奇，我们是不是可以再进一步提升评审的频率呢？

肯定可以，如果把代码评审推至极致，就是有个人随时随地来做代码评审。我在《10x 程序员工作法》讲过极限编程的理念，就是把好的实现推向极致，而代码评审的极致实践就是结对编程。

结对编程就是两个人一起写一段代码，一个人主要负责写，一个人则站在用外部视角保证这段代码的正确性。好的结对编程对两个人的精力集中度要求是很高的，两个人一起写一天代码其实是很累的一件事，不过，也正是因为代码是两个人一起写，代码质量会提高很多。

从我之前经历的一些团队实践来看，结对编程还有一个额外的好处，就是对于团队中的新人提升极大，这就是拜结对编程这种高强度的训练和反馈所赐。高强度的训练和反馈，本质上就是一种刻意练习，而刻意练习是一个人提升最有效的方式。

我知道，对于大多数团队来说，是没有条件做大规模的结对编程的。但对个体来说，创造一些机会与高手一起写代码也是很好的。即便不能一起写，去观摩高手写代码也能学到很多东西。再退一步，实在身边没有机会，去网上看看高手写代码也是一种学习方式。

### 黑板墙

思考题：你在代码评审上有哪些经验，或者遇到过哪些让你印象深刻的问题代码，欢迎在留言区分享你的经验。

原文：把循环里对于一个元素的处理拆了出去。还没等我来赞美这段代码写得好，我就看到了单个元素处理的代码，每次都要查询一次数据库，找出相应的元素，做修改之后再存回去。

结论：我认为这个每次查一次数据库没问题。决策依据：1）这样的单行操作更易理解。2）批查询可能伴随大事物（毕竟你是更新动作，可能要锁「悲观或乐观」所有数据行）。3）如果更新操作不需要锁数据行，也就是数据行的变更对更新操作的正确性无影响。那么通过加缓存会是更好的解决方案。综上所述，保证业务逻辑简单是第一原则。2021-02-01

老师，您说的太对了。因为一个敏捷教练，小波带领我们做了很多。例如：工程实践、每天 code review、结对编程。团队也已经这样运作了将近一年。好处多多，老师您都说了。但是最近碰到一些问题：因为我们技术们，尽管没有的 Leader，但大家都执行的不错。结对编程、code review、暴徒式编程。但是最近 code review 上大家的分享越来越少了。

我猜测几种可能：

1、是不是随着大家技术的水涨船高，问题越来约少呢？

2、因为我最近分享老师的代码之丑，大家觉得 code review 变了一个调调，换成分享坏味道了？（其实分享代码之丑的时候，我分享初衷是想让大家都可以学习到，但是我本身自己做的就不太好，代码里面还有好多坏味道，直接去讲，担心大家会不会觉得太空呢？有句话说：道理都懂，可就是过不好这一生！实践真的太难了）

3、会不会我们的 code review 没有回顾会？没有去总结如何把 code review 做的更好？

4、是不是我们没有明确 code review 都需要做哪些事儿？列出来 1 2 3。

5、会不会是每天都 code review，频率太高了呢？每天工作量毕竟也是有限的？

6、会不会是太经常了，心态上已经没有最开始那么重视？我们每天 5 点 code review，我有的时候心里面会想，到 5 点就算这一天的工作做完了，开个会就下班了！

我期望老师给个意见，如何能让我们的 code review 更上一个台阶，做的更好、更有效率呢？

作者回复：你们如果能够坚持做得很好，那真的要恭喜你们了！Code Review 这种事是为了发现问题，如果没有发现问题，一种可能是代码写得真好，另一可能是你们遇到了团队的瓶颈，发现不了问题。实话说，后一种可能性更大。Code Review 不是一个结束，而是一个开始，发现了问题要去修改。我的团队发现问题后修改的工作量还不小，即便我们的频率已经算很高了，还是能发现不少的问题。所以，如果你们自己发现不了太多问题，可以引入别人的视角，帮你们发现问题。2021-02-01

郑老师，有没有用系统思考的方式评估过代码评审在软件开发中的位置或者作用？作者回复：如果你需要的是代码评审的价值，可以搜搜「why code review matter」。2021-01-30

我从来没经经历过代码评审，所以我感觉从老师这里真的学到了好多好多。作者回复：在一个正规的团队中工作，能学到很多基本的东西。2021-01-31

代码评审本身就是对团队成员代码质量提升的有效方法，之前我每次 commit 都会要求我自己先检查一下有没有更好的方式，然后老大再去看一下，每次找出问题来自己也会很难受，然后慢慢自己也都会注意起来。作者回复：自己重视，比团队重视提高得更快。2021-01-30

自己团队其实也一直在做代码 review，老大也比较重视。读完作者这篇文章感觉自己的收获就是 review 的方向有了：实现方案的正确性，算法的正确性和代码的坏味道。这点我觉得的可以在 review 的时候刻意注意的地方。特别认同作者说的刻意练习，不好的习惯，只能通过刻意的练习将其纠正过来。这个也是我最近自我感觉提高的一点，刻意的去做正确的事，慢慢的自己提高是很明显的。作者回复：刻意练习最重要的是适当的反馈。2021-01-30

来个新鲜的案例，昨天代码评审时发现的问题：

```java
List<String> a = new ArrayList<>();
// 筛选数据，符合条件的添加到 a 中
List<String> b = new ArrayList<>();
a.addAll(b);
// 筛选数据，符合条件的添加到 b 中
// 结束返回 a
return a;
```

对引用的认识不清楚，集合的 addAll 方法是把参数集合中的每一个 Element 添加到自己这个集合中，不是把集合做为一个 Elements 添加到集合中，形成多维关系。事后追问了一个问题，同一个对象添加到两个不同的集合中，然后再从其中一个集合中取出对象对其进行修改，问此时另一个集合中的那个对象的受影响吗？作者回复：嗯，代码评审有经验的人会多问一句，就能发现不少问题。2021-01-30

还是菜鸟的时候，所在的团队有 Code Review，Leader 对每个人提交的代码都会亲自 Review 并指出问题，Leader 做评审的时候都会带上小本本记下问题，那段时间自己成长的特别快。后来因为某些原因团队解散，经历过的其他的一些团队再也没有那么好的 Review 氛围了。作者回复：运气不错。2021-01-30

做几年码农了，一直没人给我 review。当第一次有人给我 review 时，被说像刚毕业的，羞愧难当。如果在没有 review 氛围的公司，怎么提高自己的代码质量？作者回复：这就是缺乏反馈的结果，自己不知道自己的代码究竟写得怎么样。你从开始学习这个专栏，其实，就已经进入到一个提高自己代码质量的过程里了，至少，现在看到有坏味道的代码，你应该能够发现一些了。接下来，你可以去读读书，比如像《代码整洁之道》、《重构》之类的书，还是要看一下的。接下来，就是在实践中，不断地去打磨手艺了。当然，如果你身边有人能够通过代码评审的方式给你反馈，你的提高会更快。2021-02-06

## 0202新需求破坏了代码怎么办.md

### 总结时刻

这一讲，我用了两个例子给你讲了新需求到来时需要关注的地方，它们分别是：1）增加新接口；2）改动实体。

接口和实体，其实也是一个系统对外界产生影响的重要部分，一个是对客户端提供能力，一个是产生持久化信息。所以，我们必须谨慎地思考它们的变动，它们也是坏味道产生的高发地带。对于接口，我们对外提供得越少越好，而对于实体，我们必须仔细分析它们扮演的角色。如果今天的内容你只能记住一件事，那请记住：谨慎地对待接口和实体的变动。

### 2.0

我前面课程讲的所有坏味道都是告诉你如何在已有的代码中发现问题。不过你要明白，即便我们能够极尽所能把代码写整洁，规避各种坏味道，但我们小心翼翼维护的代码，还是可能因为新的需求到来，不经意间就会破坏。一个有生命力的代码不会保持静止，新的需求总会到来，所以，写代码时需要时时刻刻保持嗅觉。这一讲加餐，我来给你讲讲两个发生在真实项目中的故事。

### 2.1 一次驳回的实现

我们的系统里有这样一个功能，内容作品提交之后要由相应的编辑进行审核。既然有审核，自然就有审核通过和不通过的情况，这是系统中早早开发完成的功能。

有一天，新的需求来了：驳回审核通过的章节，让作品的作者重新修改。造成作品需要驳回的原因有很多，比如，审核标准的调整，这就会导致原先通过审核的作品又变得不合格了。在实现这个需求之前，我们先来看看代码库里已经有怎样的基础。

首先，系统里已经有了审核通过和审核不通过的接口。

```java
PUT /chapter/{chapterId}/review
DELETE /chapter/{chapterId}/review
```

在这个设计里，将章节（chapter）的审核（review）当作了一个资源。在创建章节的时候，章节的审核状态就创建好了。审核通过，就相当于对这次审核进行了修改，而审核不通过，就相当于删除了这个资源。对应着这两个接口，就有两个对应的服务接口：

```java
class ChapterService {
  public void approve(final ChapterId chapterId) {
    ...
  }
  
  public void reject(final ChapterId chapterId) {
    ...
  }
}
```

顾名思义，approve 函数对应着审核通过，而 reject 对应着审核不通过。相应地，章节上有一个状态字段，标识现在章节处于什么样的状态。章节是待审核、审核通过，还是审核不通过，就是通过这个字段标记出来的。

```java
class Chapter {
  private Status status = Status.PENDING;
  
  public void approve() {
    this.status = Status.APPROVED;
  }
  
  public void reject() {
    this.status = Status.REJECTED;
  }
}
```

好，我们已经知道了这些基础了，那驳回的需求该怎么设计呢？

既然增加了一个驳回的功能，那就增加一个驳回的接口，然后，在服务中增加一个驳回的服务，最后，再在状态中增加一个驳回的状态。这么做，听上去非常合理，你是不是已经按捺不住自己蠢蠢欲动的双手，准备写代码了呢？

且慢！我嗅到了一丝坏味道，这个坏味道来自于我们要增加一个接口。

来一个新需求，增加一个新接口，对于很多人来说，这是一种常规操作。但我们必须对新增接口保持谨慎。

接口，是系统暴露出的能力，一旦一个接口提供出去，你就不知道什么人会以什么样的方式使用这个接口。

我们常常看到很多系统有很多接口，如果你仔细梳理一番，就会发现，有很多接口提供类似的功能，这会让初次接触到系统的新人一脸茫然。即便你打算对系统进行清理，当清理掉一个你以为根本没有人用的接口时，就会有人跑出来告诉你，这个接口调整影响了他们的业务。

所以，我们必须对接口的调整慎之又慎。最好的办法就是从源头进行限制，也就是说，当我们想对外提供一个接口时，我们必须问一下，真的要提供一个新接口吗？

回到这个案例上，我们面对这个需求的第一反应和大多数人一样，也是增加一个新的接口。但是，是否真的要增加一个新的接口呢？如果不增加新接口，这就意味着要复用已有的接口。但复用的前提是：新增的业务动作是可以通过已有的业务来完成的，或是对已有业务进行微调就可以。

那么，到底是需要新增，还是复用，真正要回答这个问题，还是要回到业务上。

在原有的业务中，审核通过会进入到下一个阶段，而审核不通过，就会退回到作者那里进行修改。那驳回之后呢？它也会要求作者去修改。

说到这里，你就不难发现了，驳回的动作和审核不通过，二者的后续动作是一样的。它们的差别只是起始的状态，如果原来的状态是待审核，经过一个审核不通过的动作，状态就变成了审核不通过；而如果原来的状态是审核通过，经过一个驳回的动作，状态就变成了驳回。所以，我们完全可以复用原来的审核不通过接口。

既然是复用接口，所有的变化就全部都是内部变化了，我们可以根据章节当前的状态进行判断，设置相应的状态。具体到代码上，我们既不需要增加驳回的接口，也不需要增加驳回的服务，只需要在 Chapter 类内部进行修改，代码改动量比原先预期的就小了很多。其代码结构大体如下所示：

```java
class Chapter {
  private Status status = Status.PENDING;
  ...
    
  public void reject() {
    if (status == Status.PENDING) {
      this.status = Status.REJECTED;
      return;
    }
    
    if (status == Status.APPROVED) {
      ...
.      
    }  
  }
}
```

按照这个理解，我们只要增加一个驳回的状态，在当前状态是审核通过时，将这个新状态赋值上去就可以了。

看上去，我们已经把这次要改动的代码限制在一个最小的范围。但其实，我还想再问一个问题，我们真的需要这么一个状态吗？

是否增加一个驳回的状态，回答这个问题还是要回到业务上，驳回后续的处理与审核不通过的状态有什么不同。

按照产品经理本来的需求，他是希望做出一些不同来，比如，处于审核不通过的状态，编辑端是无法查看的，而处于驳回状态的，编辑是可以查看的。但在当前的产品状态下，我们是否可以将二者统一起来呢？也就是说，都按照审核不通过来处理呢？

产品经理仔细想了想，觉得其实也可以，于是，两种不同的状态在这里得到了统一，也就是说，我们根本没有增加这个驳回的新状态。

事情说到这里，你就会发现，在这次的业务调整中，后端服务的代码其实没有做任何修改，只是前端的代码在需要驳回时增加了一个对审核不通过的调用，而所有这一切的起点，只是我们对于增加一个新接口的嗅觉。

### 2.2 一次定时提交的实现

我再来给你讲另外的一个与「实现」有关的故事。

在我们的系统中，一般情况下，作者写完一章之后就直接提交了，这是系统中已经实现好的一个功能。现在来了新的需求，有时候，作者会囤一些稿子，为了保证自己每天都有作品提交，作者希望作品能够按自己设定的时间去提交，也就是说，一个章节在它创建的时候，并不会直接提交到编辑那里去审核，而是要到特定的时间之后，再来完成作品的提交。

实际上，「每天都有作品提交」就是一种连续的签到，通常来说，系统都会给连续签到以奖励，这也是对于作者的一种激励手段。

如果你面对这样一个需求，你会怎么实现呢？

与这个需求最直接相关的代码就是章节信息了：

```java
class Chapter {
  // 章节 ID
  private ChapterId chapterId;
  // 章节标题
  private String title;
  // 章节内容
  private String content;
  // 章节状态
  private Status status;
  // 章节创建时间
  private ZonedDateTime createdAt;
  // 章节创建者
  private String createdBy;
  // 章节修改者
  private String modifiedBy;
  // 章节修改时间
  private ZonedDateTime modifiedAt;
  ...
}
```

显然，要实现这个需求，需要有一个定时任务，定期去扫描那些需要提交的作品。这个是没有问题的，但是，这些定时的信息要放在哪里呢？我似乎已经看到你跃跃欲试的样子了。你可能会想：这个实现还不简单，在章节上加上一个调度时间就行了：

```java
class Chapter {
  ...
  private ZonedDateTime scheduleTime;
}
```

确实，这么实现并不复杂。但我想请你稍微停顿一下，别急着写这段代码。这种做法我又嗅到了一丝坏味道，因为我们要改动实体了。有需求就改动实体，这几乎是很多人不假思索的编码习惯，然而，对于一个业务系统而言，实体是其中最核心的部分，对它的改动必须有谨慎的思考。随意修改实体，必然伴随着其它部分的调整，而经常变动的实体，就会让整个系统难以稳定下来。一般来说，一个系统的业务并不会经常改变，所以，核心的业务实体应该是一个系统中最稳定的部分。

不过，你可能会说：「我有什么办法，需求总在变，就总会改动到这个实体。」

需求总在变，这是没有错的，但它是否真的要改动到业务实体呢？很多时候，这只是应有的职责没有分析清楚而已。具体到我们这个例子里面，我们需要的是定时提交一个章节，而这个定时信息并不是核心业务实体的一部分，只是在一种特定场景下所需要的信息而已。所以，它根本不应该添加到 Chapter 这个类里面。

不放在 Chapter 这个类里面，那要放到哪呢？很显然，这里少了一个模型，一个关于调度的模型。我们只要增加一个新的模型，让它和 Chapter 关联在一起就好了：

```java
class ChapterSchedule {
  private ChapterId chapterId;
  private ZonedDateTime scheduleTime;
  ...
}
```

有了这个模型，后续再有关于调度的信息就可以放到这个模型里面了，而更重要的是，我们的核心模型 Chapter 在这个过程中是保持不变的。我们之所以要把定时提交的信息与章节本身分开，因为这二者改变的原因是不同的。你或许已经发现了，是的，如果将二者混在一起，就是违反了单一职责原则。对于一个程序员来说，深入理解单一职责原则是非常必要的。到这里，定时提交的问题看上去已经得到了一个很合理的解决，有了基础的数据结构，修改对应的接口和服务，对大多数程序员来说，都是一件驾轻就熟的事情。那么，这个讨论就结束了吗？我们可能暂时还不能停下来。

我们新增的需求是定时发布，之所以要有这么个需求，因为这和作者的激励是相关的。要想确定作者的激励，就要确定章节的提交时间，问题是，我们怎么确定章节的提交时间呢？在原来实现中，创建时间就是提交时间，因为章节是立即提交的，而现在创建时间和提交时间有可能不同了。你可能会想到，创建时间不行，那就用修改时间。我告诉你，这也不行，修改时间是章节信息最后一次修改的时间，它有可能因为各种原因变更，最简单的就是编辑审核通过，这个时间就会变。

分析到这里，我们突然发现，模型里居然没有一个地方可以存放提交时间，是的，我们需要修改实体了，我们要给它增加一个提交时间：

```java
class Chapter {
  ...
  private ZonedDateTime submittedAt;
}
```

到这里，估计有些人已经懵了。前面我们辛辛苦苦地讨论，为的就是不在 Chapter 里增加信息，而这里，我们竟然就增加了一个字段。

前面我们说了，一个字段该不该加在一个类上，取决于其改变的原因。前面的定时时间确实不该加，而这里的提交时间却是应该加的。提交时间本来就是章节的一个属性，只不过如前面所说，之前，这个信息与创建时间是共用的，而如今，因为定时提交的出现，二者应该分开了。

或许你还有一个疑问，我们难道不能直接用 submittedAt 去存储调度时间吗？严格地说，不行。因为调度时间可能与具体提交的时间有差异。我举个例子，因为某种原因，系统宕机了，启动之后，调度任务执行，这时可能已经过了调度时间很多了，但这个时候提交章节，它的时间就不会是调度时间。

至此，我们完整地分析完了定时提交的实现，你还记得我们为什么要做这个分析吗？没错，因为它要改动核心的实体，而这又是一个坏味道的高发地带。

### 黑板墙

思考题：你平时是怎么对待接口和实体的变动的呢？

我想问一个和这节课内容无关，但是我很迷茫的事情，就是 => 如何提高「解决问题的思路」，事情是这样的：前两天我们有个项目，需要导出客户账单的 pdf，每个月每个账号要导出来多个账单 pdf（比如这个月 10 个 pdf，上个月 20 个 pdf），然后这些 pdf 要以导出时候的时间戳做命名（例如今天导出时间戳是 12384958293 ，明天同样导出本月的话单 时间戳就是 12384923049）并可以根据时间戳作为 pdf 账单内容的顺序（时间戳最小的是第一个账单，时间戳最大的是最后一页账单），客户导出的时候根据 pdf 的顺序一个一个的将 pdf 下载下来。这样产生的问题就是，明明只需要每个月只生成一份的 pdf，变成了每次导出都要重新生成。然后我们负责开发这块的同事（我们技术最厉害的，解决问题的思路很「宽」） 就和产品经理说这个事。

产品经理说：这是要求的，必须要以时间戳做名称。

开发的同事：但是这样很浪费系统资源，每次都要重新生成重新导出。

。。。。。。（争吵十分钟）

当时他们在讨论的时候，我也在考虑这个问题，如果是我，我要怎么办才能既保证产品经理要求的时间戳方式，又能不浪费系统资源（即，每个月的 pdf 无论客户导出多少次，系统内都只生成一份当月的 pdf），但是我没跳出来「根据 pdf 的顺序一个一个的将 pdf 下载下来」这个圈，一直以这个为依据去思考如何解决这个问题。

这时候，我那个负责开发这块内容的同事就说，那这样吧，我把这些 pdf 封装到一个 zip 里边，然后把 zip 按照时间戳来命名，可以吧，这样既可以达到你说的每次下载都要根据时间戳命名的要求，又能满足每个月只需要生成一份 pdf，不浪费系统资源的要求。

当时我就眼前一亮 是啊，我咋就没有想到用「zip 压缩封装」的方式呢，这样不仅时间戳的要求满足了（pdf 在 zip 里边排序的方式也可以用其他方式表示），还将本来需要下载多次的 pdf，变成了下载一次，优化了下载的体验，一举多得啊。

说了上边的事情，我主要想表达的就是，怎么样才能提高自己解决问题的思路呢，zip 我知道，将多个 pdf 封装到一个 zip 里我也见过，可以说这些东西我全懂，但是我就是没能将他们联系到一起，去解救这个问题。其实，也许还有更好的办法去解决这个东西。但是，通过这个事情我就发现了 => 我解决问题的思路真的很「狭隘」, 水平很低。

因此，老师有没有什么推荐的书籍之类的，能提高遇到问题的时候，解决这些问题的思路呢，我觉得解决问题的思路这件事太重要了，可能比学技术更重要。学技术只要下功夫基本就差不多，但是提高自己解决问题的能力这件事自己完全不知道该怎么做，才能提高自己这方面的能力，还希望老师能指点一下。2021-02-02

汇总：1）案例一，面对同个问题，未看郑大佬的解法时我的思路是相反的。2）入口要写成 2 个方法，决策依据是单一职责（如果可以明确走不同分支，就不该通过状态判断来让一个函数实现复用）。至于实现部分是否走相同函数，那是关于复用和隔离的权衡，与时间和场景有关，并不绝对。3）我的理解，郑老师是把审批不通过和驳回都归为「拒绝」的方法，所以也符合单一职责。从业务的角度来评定单一职责。而我是从代码实现的角度来评定。作者回复：这里的重点是，接口不要轻易增加，一定要多问几个为什么。2021-02-04

请教一个问题，如果因为需求变动，确认过眼神，某个实体确实不需要了，该不该把他删了。不删的话，代码有误导性，删的话，所有用到过这个实体的地方都得改。作者回复：如果是确实不需要了，建议删掉。你纠结的点其实就是代码写得不好的地方，正好借着机会调整一下。删代码还是比较容易的，调用关系很容易发现，简单的方法靠 IDE 快捷键就好。2021-02-02

应该不是所有的需求都可以像文中描述的一样，最终避免改动接口的。一样要改动接口的话，增加新接口的同时保留和有计划地废弃旧接口，应该也是合理的接口升级实践。基础设施做得好（开发效率高，接口监控到位），搬砖熟练的话，可能新需求还没分析完，新接口已经实现好了......作者回复：当然不是所有的需求都不改动接口，这里的重点是要谨慎地分析该不该加新接口。程序员一定不能把脑力劳动做成体力劳动。2021-02-02

请教下一个应用不同模块都有查询功能，入参和出参都类似，请问这种情况是对外暴露一个接口，入参里加个业务类型做区分，还是暴露 2 个接口，感谢。2021-03-23

## 0203熊节什么代码应该被重构.md

代码坏味道的说法源自《重构》这本书，坏味道和重构这两个概念几乎是如影随形。提及《重构》这本书，在国内谁还能比《重构》两版的译者熊节更了解它呢？所以，这一讲，我就请来了我的老朋友熊节，谈谈在他眼中看到的重构和坏味道。

自从翻译了《重构》以后，很多公司找我去做重构的培训，光是华为一家，这个主题在各个不同的部门就培训过好些次。每次讲这个主题，我都觉得挺为难的：重构这事有什么可培训的呢，不就是一个无脑模式匹配的事吗！然而跟各家公司的读者们一交流，我就发现事情并没有那么简单。

很多人一说到重构，就聊到虚无缥缈的事上了，像什么架构啦、文化啦，等等。我不得不先把他们拉住仔细问问，他们是怎么读《重构》这本书的？这一问我就发现，原来很多读者（恐怕是绝大多数读者），还没弄明白这本书到底应该怎么读。

### 3.1 什么代码应该被重构？

《重构》这本书，以及重构这门手艺，提纲挈领的部分，都在一个关键的问题上：什么代码应该被重构。你可能会说，质量不好的代码需要被重构。没错，可是代码的质量到底应该如何评判呢？

首先我们要明确的是，代码的好与坏不应当用个人好恶、「含混的代码美学」来表达，因为这会带来两个困难：

第一，每个人对于「好」或「美」的观念可能相当不同；

第二，对于坏代码缺乏明确的「症状」判断，也就很难提出明确的改进措施。

即便是一些经典的程序设计原则，也有同样的问题。例如「高内聚低耦合」，尽管这是所有人都赞同的设计原则，但究竟什么样的代码呈现了「低内聚」、什么样的代码呈现了「高耦合」、「低内聚」与「高耦合」是否总是同时出现、应该以何种办法提高内聚降低耦合…… 这些问题仍然是悬而未决的。因此，对于真正在一线工作的人来说，「高内聚低耦合」很多时候就成了一句咒语，念完咒语后，呼唤出的其实还是每个人原本的编程习惯与风格，并不真正指导任何行为的改变。

而当我们去观察「低内聚高耦合」带来的问题时，事情就变得明朗了。比如，当我们仔细阅读《重构》第三章时，我们会发现，「低内聚」会直接引发的现象是「霰弹式修改」（Shotgun Surgery）：

每当需要对某个事情做出修改时，你都必须在许多不同的类内做出许多小修改，那么就可以确定，你所面临的坏味道是霰弹式修改。当需要修改的代码分散在多处，你不但很难找到它们，也很容易忘记某个重要的修改。

而「高耦合」直接引发的现象则是有某种相似性、但又表现不同的「发散式变化」（Divergent Change）：

如果某个类经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。

我再举另一个设计原则的例子。「迪米特原则」也是常被提及的面向对象设计原则之一，然而知道这个名称是一回事，知道如何识别不符合迪米特原则的代码，则又需要更多的个人经验。《重构》第三章则把这个原则表述为两个非常直观的症状：「过长的消息链」（Message Chains）和「中间人」（Middle Man）。

如果你看到用户向一个对象请求另一个对象，而后者再次请求另一个对象，然后再请求另一个对象…… 这就是消息链。在实际代码中，你看到的可能是一长串取值函数，或者一长串临时变量。

人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。

你发现没？对于开始我们提到的「什么代码应该被重构」这个关键问题，虽然《重构》作者 Martin Fowler 和 Kent Beck 非常客气地声称：「并不试图给你一个何时必须重构的精确衡量标准」，实际上，《重构》给出的 24 项「坏味道」（在《重构》第一版中是 22 项）已经形成了一个非常明确的代码质量检查清单。

尽管这本书从未声称这是一份完备的坏味道清单，但在实际工作中，还不用说完全识别并消除这份列表中的全部坏味道，只要能做到命名合理、没有重复、各个代码单元（类、函数等）体量适当、各个代码单元有明确且单一的职责、各个代码单元之间有恰当的交互，这就已经是质量相当高的代码了。

更重要的是，伴随着对具体症状的了解，对症的解决办法也变得明确。在《重构》第三章里非常明确地讲到：

1、对于「霰弹式修改」，解决的办法是使用「搬移函数」和「搬移字段」，把所有需要修改的代码放进同一个模块。

2、对于「发散式变化」，解决的办法是首先用「提炼函数」将不同用途的逻辑分开，然后用「搬移函数」将它们分别搬移到合适的模块。

3、对于「过长的消息链」，你应该使用「隐藏委托关系」；对于「中间人」，对症的疗法则是「移除中间人」，甚至直接「内联函数」。

这就是我前面所说的「无脑模式匹配」。讲到这里，你也就明白了，对于绝大多数程序员而言，阅读和使用《重构》这本书的正确方法就应该是：

1、打开任意一段代码（可以是自己刚写完的或者马上要动手修改的）。

2、翻开《重构》第三章，遍历其中的每个坏味道。

3、识别这段代码中是否存在上述坏味道。

4、如有，则遵循该坏味道所列的重构手法，对该段代码进行重构。

5、如无，则继续遍历代码。

上述过程不需要玄妙的理论和含混的代码美学，只需要机械的重复和简单的模式匹配。正因为此，重构才是一项完完全全具备可操作性、能够在任何遗留代码库上实践的技术。

### 3.2 培养对「坏味道」的判断力

当然，每位实践者仍然「必须培养出自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长」。

就在最近，我看到某大厂的一位「代码委员会理事」在文章里说，某段代码「挺好的，长度没超过 80 行，逻辑比较清晰」。而在我看来，一个函数超过 7 行就已经是「太长」（这还是在考虑到 Java 语法比较啰嗦的前提下）。这就是不同实践者「自己的判断力」所体现的差异。

尽管从来没有明确指定对每个函数或类的代码行数要求，但「对象健身操」这篇文章（见于《ThoughtWorks 文集》）提出的 9 项规则已经有非常明确的指向：1）方法中只允许使用一级缩进；2）不允许使用 else 关键字；3）封装所有的原生类型和字符串……

3『 [ThoughtWorks文集（精选版） - InfoQ](https://www.infoq.cn/minibook/thoughtworks-anthology)』

在这样的规则约束下，写出一个超过 10 行的函数将是相当困难的（实际上在「规则 6：保持实体对象简单清晰」中已经明确提出，每个类的长度不能超过 50 行）。

正如「对象健身操」这篇文章的作者 Jeff Bay 自己所说，这套「健身操」的意义在于：「在一个简单的项目里尝试一些比以前严格得多的编码标准…… 会迫使你更为严格地以面向对象的风格编写代码」，从而「以一种全新的方式思考你的代码」。

不过这得需要你刻意练习。正所谓「台上一分钟，台下十年功」，缺乏在受控环境下的刻意练习，很难通过工作中的自然积累提升判断力。

另外，对正确的代码构造足够熟悉，也是很重要的一个基本功，这个观点最早是 Kent Beck 的《实现模式》这本书中提到的。什么意思呢？

2-3『

[实现模式（豆瓣）](https://book.douban.com/subject/3324516/)

已下载书籍「2021077Implementation-Patterns」。

 』

传说旧时民间古董店的学徒需要先在仓库里看真货，看得多了，见到假货时就会本能地提起警觉。对于代码也是一样：程序员需要熟悉正确的代码构造，在看到有问题的代码构造时才会本能地提起警觉。并且，「正确的代码构造」并非无穷无尽，实际上在单线程编程中，几十个常见的模式已经几乎能够完全覆盖所有场景。

Kent Beck 在前言里说「这是一本关于如何编写别人能懂的代码的书」，尽管他还谦虚地说这本书「不是模式书籍」，但实际上《实现模式》充分地展现了「模式」的本意：它提供了一整套「用代码表述意图」的模式语言，这套语言能让程序员在最短的时间内学会如何写出具有表现力的代码，并且自然而然地远离坏味道。

从一开始就以合理的方式编程，从而使坏味道不要出现，我想这才是负责任的程序员应该采取的工作方式。

当然，极限编程的各种实践，尤其是工程技术实践彼此紧密相关。例如自动化测试、持续集成、集体代码所有制的缺失，都会导致代码的坏味道更容易堆积。而从另一个角度来看，这些实践从任何一个切入，又都会自然地引导出其他相关的实践。

一位「知行合一」的程序员最终会发现，极限编程是唯一合理且有效的软件开发方法。最终，只有采用以可工作的软件为核心的软件开发方法，才能得到高质量的可工作的软件，这就是《敏捷宣言》第二句关于坏味道的终极答案。

郑老师说：熊节老师对于问题的分析总是这么一针见血。重构就是一个模式匹配的过程，识别出坏味道，运用对应的重构手法解决问题。坏味道是一切重构的起点，而识别坏味道不是靠个人审美，而要依赖通用的标准。我的这个专栏就是把一些坏味道用更直接的代码形式展现在你面前，让你可以日常的工作中，不断地锻炼自己的代码嗅觉。

### 黑板墙

思考题：经过熊节老师的讲解，你是不是对重构和坏味道有了新的认识呢？

就我经历过的团队（传统企业信息中心）来看，不论是初级还是中级的同事，总是喜欢学习和研究分布式架构相关的知识点，而不喜欢阅读如《重构》、《代码整洁之道》一类的提高程序员最本质的手艺 —— 写代码。然而，分布式的东西对我所经历的团队来说并不重要，因为实际上能用上的并不多。然而，每次 Code Review 总会有一些让人摸不着头脑要讲半天的代码，虽然也加了静态代码复杂度检查之类的，但是还是层出不穷。或许是这个浮躁的信息爆炸时代让架构师课程随手可得，却让人忘了自己去追求所谓的整洁代码之美，其实个人觉得一堆可维护的代码就是取悦同事取悦领导最佳的方式。作为 TL，只能尽可能多培养识别坏味道的嗅觉，帮助团队成员指出坏味道并改正，先独善其身，才能有机会兼济天下，能指导和培养一个是一个。知易行难，学习的最高层次就是输出，找一两个小时，团队坐在一起 Code Review 也是一个输出和输入的过程，发挥集体智慧，走向重构。

作者回复：这是一个有趣的角度，现在大部分人其实用不到复杂的分布式知识，但这东西却成了主流，这与大公司面试方式有关。和当年受微软影响，各公司面试智力题有异曲同工的作用。微软后来发现，这种选拔人才的方式有问题，需要改进，估计国内公司也需要经过一个漫长的过程之后，发现他们用这种方式选出来的人，与他们需要的人之间存在差距。毕竟，有大量用户规模的事，只有一些大公司的核心团队才会遇到，而大部分人需要的是，写好代码。而大部分人学习分布式只是学习屠龙术，空有一身本事，无处施展。2021-02-05

读书不等于掌握；掌握了不等于正在执行；执行了不等于一直在践行；识别出坏味道并践行重构的能力就像武功一样，不用就会慢慢荒废。难的不是掌握这个能力，最难的是坚持践行合一。作者回复：知行合一，谈何容易。2021-02-04

这种极限拆分，对于很多业务代码，拆分成很多方法，更加零散一些，而且有些拆出来的方法几乎不会被复用。这样还有必要拆分么？作者回复：举个不是特别恰当的例子，这就像现在还在吃糠咽菜，就担心钱多了该怎么花。先把函数拆小，能不能复用才能看出来，没有拆，何谈复用。再者，更重要的是，拆出来的目标不一定要复用，而是为了让代码更清晰。2021-02-04

静态代码扫描，其实也不治根，规约然后说了，但是就是存在，还是得从意识上去唤醒这种细节点，毕竟只能要求自己，团队太难驱动。作者回复：先做好自己，再去影响他人。2021-02-04

这种机械和简单的模式匹配最好能交给机器去做。作者回复：道理上是这样的，问题是，现在这种模式匹配机器暂时还没法识别，也许是一个值得探索的方向。2021-02-04

学习了老师的三个专栏，收获颇多，感谢分享。请问老师，除了专栏中提到的书籍和示例代码等一些代码片段，哪里可以找到更多符合高质量代码标准的完整的工程 / 代码示例？感觉通过学习了专栏之后，再结合优秀优秀代码会加深理解。目前 github 上代码太多，没办法逐个甄别，如果老师能够帮忙推荐一些最好了，感激不尽。作者回复：Google 的开源项目代码质量一般都很高，推荐 Guava。Spring 的也可以看看。2021-04-22

每次都能 get 到好的新主题，进而课后可以做专项的主题学习。课程内容反而是附赠的。本章：1）get：缺乏在受控环境下的刻意练习，很难通过工作中的自然积累提升判断力。原本认知：一直认为对象健身操过于苛刻，不适合在工作中应用，只是理想化的东西。但如果把它做为训练手段，用于提高自己对代码坏味道的觉察心，就直接豁然开朗了。下来可以时常写些小玩意，对照着苛刻下。2）get：《实现模式》，书已买，拜读下。2021-02-05

## 0204课前作业点评发现你代码里的坏味道.md

### 总结时刻

今天我们点评了大家代码中存在的一些问题，除了之前在专栏中讲到过的坏味道，今天我们还讲到了一些一眼就可以看出问题的坏味道：1）使用缩写；2）用 I 表示接口，用 Impl 表示实现；3）使用 static 函数或变量；4）使用 singleton 模式；5）写得潦草的 README。

你在写代码时也要注意这些问题。我还借着 static 函数的调整过程，给你演示了如何一步一步地重构代码，保证代码的安全。希望你能够理解，重构不是大开大合的过程，而就是这样细小而微的操作。如果今天的内容你只能记住一件事，那请记住：尽量不使用 static。

### 4.0

在这个专栏刚开始的时候，我给你留了一个课前作业，实现一个待办事项管理的软件。许多同学都利用自己的业余时间完成了这个作业，感谢大家的付出！

学习代码的坏味道，听别人讲是一种方式，但这种方式总会让人有一种隔岸观火的感觉，虽然知道有问题，但感觉并不深刻。最直接受益的方式就是自己写了代码，然后，让别人来点评。其实，这就是某种形式的代码评审。所以，这一讲，我们就来做一次「代码评审」，直接来看看代码中存在的问题。题目背景我就不再做过多的介绍了，如果没有来得及完成作业的同学，可以先到「课前作业区」回顾一下题目。既然是指出问题，得罪大家可能就在所难免了，希望你不要介意，毕竟能够发现自己的问题是精进的第一步。

### 4.1 从已知的坏味道出发

在极客双同学的代码仓库里，我在一段代码中看到了之前我们课程中讲过的坏味道：

3『

[benben773/todomaster](https://github.com/benben773/todomaster)

[todomaster/ProcessTxtServiceImpl.java at main · benben773/todomaster](https://github.com/benben773/todomaster/blob/main/todomaster/src/main/java/com/test/service/impl/ProcessTxtServiceImpl.java)

』

```java
Item itemNew = new Item(item.getName());
itemNew.setUserIndex(userIndex);
itemNew.setIndex(initUserIndex);
```

我们的业务需求是添加 TODO 项，这段代码就是在这个过程中创建一个新的 TODO 项对象。那这段代码有什么问题？一方面，这里有 setter，另一方面，这里的 setter 只在初始化的过程中用到。显然，我们可以用一个更完整的构造函数替换掉它。

其实，从这段代码出发，我们还能看到一些小问题，比如，这里创建 TODO 项设置了两个字段，一个是 userIndex，一个是 index。index 可以理解，表示这个 TODO 项的索引，但 userIndex 是什么呢？你需要仔细阅读代码才能发现，它其实是一个用户的标识，表示这个索引项是由某个用户创建的。既然是用户标识，按照通常的做法它可以叫 userId，这就降低了理解的难度。

这段代码所在类的声明也是一个让人出戏的地方：

```java
public class ProcessTxtServiceImpl implements ProcessItemservice
```

这个类实现了一个接口 ProcessItemservice，显然，这里的拼写是有问题的，它应该是 ProcessItemService，另外，它的名字叫做「处理（TODO）项的服务」，一方面，在一个服务名字上用了处理这个动词，另一方面，「处理」这个名字也是特别泛化的一个名字。如果是我来声明这个接口，它可能就叫 ItemService。

所以，你可以看到，仅仅是一个接口的命名，就有这么多的问题。

我们再来看这个类的命名 ProcessTxtServiceImpl，这个名字里有一个 Txt 是容易让人困惑的，一般来说，如果不是特别的原因，尽量不要用缩写。

我初看到这个名字时，着实想了半天它表示什么含义，一开始我以为是表示事务（Transaction），常有人把事务缩写成 Tx，如果它的含义是表示事务，那么这里就是一个拼写错误了。后来，我才想明白，这里的 Txt 表示的是文本（Text），仅仅省了一个字母，却造成了理解上更大的障碍，实在有些得不偿失。

如果 Txt 表示的是文本，这里就暴露出另外一个问题。这里为什么要有一个文本呢？其实是对应着另外一个数据库存储的实现，这是第四阶段的要求。

文本和数据库的差别到底是体现在哪里呢？体现在存储上。而在这段代码中，差别从服务层面就开始了，换言之，按照这段代码的逻辑，实现数据库存储，就需要把整个的业务逻辑重新写一遍。显然，这种做法是从结构上来看是有问题的，会造成大量的重复代码。

理解了文本和数据库只差别在存储这件事，我们再回过头来看这个类的声明。

```java
public class ProcessTxtServiceImpl implements ProcessItemservice
```

这个为数据库预留的实现根本就是不需要的，只有一个 ItemService 的实现就够了，换言之，也就没有必要声明出一个接口，这里的类层次这么复杂，根本就是没有必要的。

```java
public class ItemService
```

这里我再补充一个点，很多 Java 程序员给类命名有个不好的习惯，用「I」打头给接口命名，用「Impl」给实现类结尾，这其实是早期的一种编程习惯，准确地说，这就是没有想好命名的偷懒方式。其实，它也是我们讲到的「用技术术语命名」的一种具体体现方式。后来的代码基本上就不这么做了，因为我们可以找到更准确的描述。但很多人的编程习惯却留在了早期，所以，这也算是一种遗毒的吧。

### 4.2 一个「静态」的问题

接下来，我们再来看一个很多人代码中都存在的问题。

3『

[liudaming/todo: 极客时间课程todo](https://github.com/liudaming/todo)

[todo/UserContext.java at main · liudaming/todo](https://github.com/liudaming/todo/blob/main/src/main/java/com/timegeekbang/todo/user/UserContext.java)

』

下面是来自刘大明同学的一段代码，这是一个用以存放用户信息的类。单看这段代码本身，其实写得还是非常不错的，代码本身并不长，而且考虑了很多的细节。我们暂且忽略其它的细节，我注意到这段代码的主要原因是因为它用到了 static：

```java
public class UserContext {
  
  private static ThreadLocal<Integer> USERID = new ThreadLocal();


  private UserContext() {
    throw new UnsupportedOperationException();
  }


  public static String getUserID() {
    return String.valueOf(USERID.get());
  }


  public static void setUserID(Integer userID) {
    USERID.set(userID);
  }
}
```

在《10x 程序员工作法》讲到测试驱动开发时，我曾经讲了 static 函数的问题，简单总结一下就是：1）从本质上说，static 函数是一种全局函数，static 变量是一种全局变量，全局的函数和变量是我们尽量规避的；2）一个函数调用了 static 函数不好测试；3）除了写程序库，日常开发尽可能不用 static 函数。

那怎么消除 static 函数呢？消除 static 函数，最简单的做法就是用普通的函数调用替换掉 static 函数，也就是把这里的 static 都去掉。涉及到相应的字段，也要去掉 static。这种做法没有问题，但通常这种做法太粗暴了。这里我们尝试着用重构的方式一步一步地把它替换掉。

首先，我要去掉这里的构造函数，因为这里的构造函数是私有的，无法调用，而我们要用普通的函数，自然就需要构造出一个对象来。

```java
public class UserContext {
  
  private static ThreadLocal<Integer> USERID = new ThreadLocal();


  public static String getUserID() {
    return String.valueOf(USERID.get());
  }


  public static void setUserID(Integer userID) {
    USERID.set(userID);
  }
}
```

然后，我们需要找到对应的调用点，这里就以其中的一个为例，下面就是在退出登录的地方调用了这里的 static 函数：

```java
public class UserAccounts {
  ...
  
  public void loginOut() {
    UserContext.setUserID(null);
  }
}
```

我们可以把它改成对象的调用：

```java
public class UserAccounts {
  ...
  
  public void loginOut() {
    new UserContext().setUserID(null);
  }
}
```

这样，我们就有了一个对象，因为原来的函数是 static 函数，所以，这里的调用，本质上还是原来的函数，所以不会有影响。然后，我们把这个创建出的对象变成这个类的字段，如果你使用的是支持重构功能的 IDE，这就是一个快捷键的操作（引入字段，Introduce Field）：

```java
public class UserAccounts {
  ...
  
  private UserContext context = new UserContext();
  
  public void loginOut() {
    context.setUserID(null);
  }
}
```

如果在一个类有多个调用点，不妨都改成这个新字段的函数调用，正如我们前面所说，目前还是一个 static 函数，无论从哪个对象调用，调用的都是同一个函数。

通常来说，这个 static 函数应该不只是在一个类中使用，所以，它应该是在多个类中间共享的，为了保证多个类中间使用同一个 UserContext 对象，UserContext 对象的初始化就不能在这个类进行，而要在同一个地方初始化，所以，我们这里可以把 UserContext 对象作为构造函数的参数传进来：

```java
public class UserAccounts {
  ...
  
  private UserContext context;
  
  public UserAccounts(..., final UserContext context) {
    ...
    this.context = context;
  }
  
  public void loginOut() {
    context.setUserID(null);
  }
}
```

有了这个基础，我们再在 UserAccounts 这个对象初始化的时候，把这个 UserContext 对象传进来：

```java
new UserAccounts(..., new UserContext());
```

如此一来，UserContext 这个对象的初始化就放到对象组装的过程中了，这就可以在多个不同的对象组件中共享这个对象了。如此往复，将所有的调用点都这么修改，我们就消除了对于 static 函数的依赖。现在，我们可以动手消除 static 了：

```java
public class UserContext {
  
  private ThreadLocal<Integer> USERID = new ThreadLocal();


  public String getUserID() {
    return String.valueOf(USERID.get());
  }


  public void setUserID(Integer userID) {
    USERID.set(userID);
  }
}
```

消除 static 函数本身并不难，这里我是借着这个简单的例子，给你演示一下，如何一步一步地进行重构。可能这比很多人以为的大刀阔斧地修改代码来得要琐碎得多，但只有这样一点一点调整，代码足够安全，每一步都是能够停下来的。

无论如何，请别忘了，真正能给予我们修改有效性回答的是，单元测试。

估计很多人看到这里就会说，如果 static 都成了坏味道，那 Singleton 模式该怎么办呢？答案就是尽可能不用 Singleton 模式。我在《软件设计之美》中讲可测试性和设计模式时，都说到过 Singleton 模式，简单地说，系统里只有一个实例和限制系统里只能构建出一个实例，这是两件事，而且，如果一个函数牵扯到 Singleton 类也不好测试。

在一些同学的代码中，我也看到的 Singleton 模式的使用，处理手法其实与这里消除 static 函数是类似的，只不过，Singleton 稍微好一点的是，它的函数和字段本身都已经是普通的类成员了，我们只需要把那个限制实例唯一的 static 函数和字段消除就可以了。

说了半天的代码问题，我还想对很多人普遍忽略的小问题说上几句，这就是文档，对应到各位的代码库中，主要就是 README。

一个开源项目的好坏与否，同它的文档质量是强相关的。我知道，作为程序员，大家的普遍兴趣都是写代码，所以，文档就常常被忽略了。

如果我不了解这个项目的背景，很多人的 README 给我提供的信息量是非常有限的。

大家的 README 普遍存在的问题有两种，一种是信息量太少，比如，只写了如何构建一个项目，另一种是把 README 当成 blog，在里面写了自己的心得体会。无论是哪种，信息的有效性都很差。

README 文件是一个项目的门面，它应该给我们提供关于这个项目的背景信息，比如，这个项目是做什么的、当前的状态、如何入手等等。你可以找一些经典的开源项目，去看看好的 README 是怎么写的。好的程序员要学会表达，不仅仅会用代码表达，也要会用文字表达。

好，这就是大家作业中的所有问题了吗？当然不是，代码中存在的问题还很多。不过，你不用担心，即便这个专栏的正式更新结束了，我也会考虑以加餐的形式，继续我们这个云端的代码评审环节。所以，之前没来得及写代码的同学依然可以继续写，说不定下次就会谈到你的代码。

### 黑板墙

思考题：我们今天谈到了文档，你平时写文档吗？或者，你平时阅读项目文档，发现什么值得改善的地方吗？

「用 I 表示接口，用 Impl 表示实现」，这种问题需要怎么修改？目前我的写法都是 用 Impl 表示实现，接口就正常写成 XxxxService。作者回复：如果一个接口只有一个实现类，也许不需要这个层次关系，即便有，一个命名可以是 DefaultXXX。如果一个接口有多个实现类，那就需要把不同实现类的特点描述出来，比如，FileXXX，DbXXX 等等。2021-02-07

static 转成 final 的那步里，如果不止是 UserAccounts 而是其他类也要用到这同一份 userContext 那应该怎么获取？能保证是同一份吗？作者回复：你仔细看一下，调整的过程是，先把对象变成同一个对象，然后，才是消除 static，所以，它们用的肯定是同一个对象。2021-02-06

我觉得 impl 是过时的设计，说服力还不够，个人感觉挺直观的，有什么负面案例呢？如果在项目中消减这种设计，还是得有说服力的说法。麻烦再深入讲解下。2021-04-24

如果一个接口只有一个实现类，也许不需要这个层次关系，即便有，一个命名可以是 DefaultXXX。有接口，单元测试时方便 mock。如果没有接口，只能是集成测试？作者回复：你可以站在类型的角度去理解，其实，mock 时模拟的是一个类型，这个类型可以是用一个接口实现的，也可以是用一个类去实现的。所以，没有接口，只有类是没有问题的。2021-02-18