## 记忆时间

2021-05-06

## 目录

0101缺乏业务含义的命名如何精准命名.md

0102乱用英语站在中国人的视角来看英文命名.md

0103重复代码简单需求到处修改怎么办.md

0104长函数为什么你总是不可避免地写出长函数.md

## 0101缺乏业务含义的命名如何精准命名.md

### 总结时刻

我们今天讲了两个典型的命名坏味道：1）不精准的命名；1）用技术术语命名。命名是软件开发中两件难事之一（另一个难事是缓存失效），不好的命名本质上是增加我们的认知成本，同样也增加了后来人（包括我们自己）维护代码的成本。好的命名要体现出这段代码在做的事情，而无需展开代码了解其中的细节，这是最低的要求。再进一步，好的命名要准确地体现意图，而不是实现细节。更高的要求是，用业务语言写代码。

至此，我们已经对命名有了一个更深入的认识。下一讲，我们来说说国外那些经典的讲编码的书都不曾覆盖到的一个话题：英文命名。如果今天的内容你只能记住一件事，那请记住：好的命名，是体现业务含义的命名。

### 1.0

讲写代码的书通常都会从命名开始讲，《程序设计实践》如此，《代码整洁之道》亦然。所以，我们这个讲代码坏味道的专栏，也遵循传统，从命名开始讲。不过，也许你会说：「我知道，命名不就是不能用 abcxyz 命名，名字要有意义嘛，这有什么好讲的。」然而，即便懂得了名字要有意义这个道理，很多程序员依然无法从命名的泥潭中挣脱出来。

### 1.1 不精准的命名

我们先来看一段代码：

```java
public void processChapter(long chapterId) {
  Chapter chapter = this.repository.findByChapterId(chapterId);
  if (chapter == null) {
    throw new IllegalArgumentException("Unknown chapter [" + chapterId + "]");  
  }
  
  chapter.setTranslationState(TranslationState.TRANSLATING);
  this.repository.save(chapter);
}
```

这是一段看上去还挺正常的代码，甚至以很多团队的标准来看，这段代码写得还不错。但如果我问你，这段代码是做什么的。你就需要调动全部注意力，去认真阅读这段代码，找出其中的逻辑。经过阅读我们发现，这段代码做的就是把一个章节的翻译状态改成翻译中。

问题来了，为什么你需要阅读这段代码的细节，才能知道这段代码是做什么的？

问题就出在函数名上。这个函数的名字叫 processChapter（处理章节），这个函数确实是在处理章节，但是，这个名字太过宽泛。如果说「将章节的翻译状态改成翻译中」叫做处理章节，那么「将章节的翻译状态改成翻译完」是不是也叫处理章节呢？「修改章节内容」是不是也叫处理章节呢？换句话说，如果各种场景都能够叫处理章节，那么处理章节就是一个过于宽泛的名字，没有错，但不精准。

这就是一类典型的命名问题，从表面上看，这个名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。如果说我在做的是一个信息处理系统，你根本无法判断，我做是一个电商平台，还是一个图书管理系统，从沟通的角度看，这就不是一个有效的沟通。要想理解它，你需要消耗大量认知成本，无论是时间，还是精力。

命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在。或许这么说你的印象还是不深刻，我们看看下面这些词是不是经常出现在你的代码里：data、info、flag、process、handle、build、maintain、manage、modify 等等。这些名字都属于典型的过于宽泛的名字，当这些名字出现在你的代码里，多半是写代码的人当时没有想好用什么名字，就开始写代码了。我相信，只要稍微仔细想想，类似的名字你一定还能想出不少来。

回到前面那段代码上，如果它不叫「处理章节」，那应该叫什么呢？首先，命名要能够描述出这段代码在做的事情。这段代码在做的事情就是「将章节修改为翻译中」。那是不是它就应该叫 changeChapterToTranlsating 呢？

不可否认，相比于「处理章节」，changeChapterToTranlsating 这个名字已经进了一步，然而，它也不算是一个好名字，因为它更多的是在描述这段代码在做的细节。我们之所以要将一段代码封装起来，一个重要的原因就是，我们不想知道那么多的细节。如果把细节平铺开来，那本质上和直接阅读代码细节差别并不大。

所以，一个好的名字应该描述意图，而非细节。就这段代码而言，我们为什么要把翻译状态修改成翻译中，这一定是有原因的，也就是意图。具体到这里的业务，我们把翻译状态修改成翻译中，是因为我们在这里开启了一个翻译的过程。所以，这段函数应该命名 startTranslation。

```java
public void startTranslation(long chapterId) {
  Chapter chapter = this.repository.findByChapterId(chapterId);
  if (chapter == null) {
    throw new IllegalArgumentException("Unknown chapter [" + chapterId + "]"); 
  }
  
  chapter.setTranslationState(TranslationState.TRANSLATING);
  this.repository.save(chapter);
}
```

### 1.2 用技术术语命名

我们再来看一段代码：

```java
List<Book> bookList = service.getBooks();
```

可以说这是一段常见得不能再常见的代码了，但这段代码却隐藏另外一个典型得不能再典型的问题：用技术术语命名。

这个 bookList 变量之所以叫 bookList，原因就是它声明的类型是 List。这种命名在代码中几乎是随处可见的，比如 xxxMap、xxxSet。这是一种不费脑子的命名方式，但是，这种命名却会带来很多问题，因为它是一种基于实现细节的命名方式。

我们都知道，编程有一个重要的原则是面向接口编程，这个原则从另外一个角度理解，就是不要面向实现编程，因为接口是稳定的，而实现是易变的。虽然在大多数人的理解里，这个原则是针对类型的，但在命名上，我们也应该遵循同样的原则。为什么？我举个例子你就知道了。

比如，如果我发现，我现在需要的是一个不重复的作品集合，也就是说，我需要把这个变量的类型从 List 改成 Set。变量类型你一定会改，但变量名你会改吗？这还真不一定，一旦出现遗忘，就会出现一个奇特的现象，一个叫 bookList 的变量，它的类型是一个 Set。这样，一个新的混淆就此产生了。

1-3『这里突然意识到，常规集合用 List 表示，去重后的集合用 Set 表示。跟之前看 JS 里实现去重数组功能的代码关联起来了。（2021-05-06）』

那有什么更好的名字吗？我们需要一个更面向意图的名字。其实，我们在这段代码里真正要表达的是拿到了一堆书，所以，这个名字可以命名成 books。

```java
List<Book> books = service.getBooks();
```

也许你发现了，这个名字其实更简单，但从表意的程度上来说，它却是一个更有效的名字。虽然这里我们只是以变量为例说明了以技术术语命名存在的问题，事实上，在实际的代码中，技术名词的出现，往往就代表着它缺少了一个应有的模型。比如，在业务代码里如果直接出现了 Redis：

```java
public Book getByIsbn(String isbn) {
  Book cachedBook = redisBookStore.get(isbn);
  if (cachedBook != null) {
    return cachedBook;
  }
  
  Book book = doGetByIsbn(isbn);
  redisBookStore.put(isbn, book);
  return book;
}
```

通常来说，这里真正需要的是一个缓存。Redis 是缓存这个模型的一个实现：

```java
public Book getByIsbn(String isbn) {
  Book cachedBook = cache.get(isbn);
  if (cachedBook != null) {
    return cachedBook;
  }
  
  Book book = doGetByIsbn(isbn);
  cache.put(isbn, book);
  return book;
}
```

再进一步，缓存这个概念其实也是一个技术术语，从某种意义上说，它也不应该出现在业务代码中。这方面做得比较好的是 Spring。使用 Spring 框架时，如果需要缓存，我们通常是加上一个 Annotation（注解）：

```java
@Cacheable("books")
public Book getByIsbn(String isbn) {
  ...
}
```

程序员之所以喜欢用技术名词去命名，一方面是因为，这是大家习惯的语言，另一方面也是因为程序员学习写代码，很大程度上是参考别人的代码，而行业里面优秀的代码常常是一些开源项目，而这些开源项目往往是技术类的项目。在一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。

如果这个部分的代码确实就是处理一些技术，使用技术术语无可厚非，但如果是在处理业务，就要尽可能把技术术语隔离开来。

### 1.3 用业务语言写代码

无论是不精准的命名也好，技术名词也罢，归根结底，体现的是同一个问题：对业务理解不到位。我在《10x 程序员工作法》专栏中曾经说过，编写可维护的代码要使用业务语言。怎么才知道自己的命名是否用的是业务语言呢？一种简单的做法就是，把这个词讲给产品经理，看他知不知道是怎么回事。

从团队的角度看，让每个人根据自己的理解来命名，确实就有可能出现千奇百怪的名字，所以，一个良好的团队实践是，建立团队的词汇表，让团队成员有信息可以参考。团队对于业务有了共同理解，我们也许就可以发现一些更高级的坏味道，比如说下面这个函数声明：

```java
public void approveChapter(long chapterId, long userId) {
  ...
}
```

这个函数的意图是，确认章节内容审核通过。这里有一个问题，chapterId 是审核章节的 ID，这个没问题，但 userId 是什么呢？了解了一下背景，我们才知道，之所以这里要有一个 userId，是因为这里需要记录一下审核人的信息，这个 userId 就是审核人的 userId。

你看，通过业务的分析，我们会发现，这个 userId 并不是一个好的命名，因为它还需要更多的解释，更好的命名是 reviewerUserId，之所以起这个名字，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。

```java
public void approveChapter(long chapterId, long reviewerUserId) {
  ...
}
```

从某种意义上来说，这个坏味道也是一种不精准的命名，但它不是那种一眼可见的坏味道，而是需要在业务层面上再进行讨论，所以，它是一种更高级的坏味道。我初入职场的时候，有一次为一个名字陷入了沉思，一个工作经验丰富的同事对此的评价是：你开始进阶了。确实，能够意识到自己的命名有问题，是程序员进阶的第一步。

### 黑板墙

思考题：前面我们提到了一些代码中常见的不精准的命名所用的词汇，你还能想到哪些词呢？欢迎在留言区分享你的想法。也欢迎你把这节课分享给你身边对命名问题感到困惑的朋友。

老师提的命名不规范，在项目中全中。还有项目总监写的这种代码：`aaaaaa.updateFlight(airOrder, airOrderOld)`，各种不规范命名。作者回复: aaaaa 还是突破底线了。2020-12-28

汇总：1）实际工作时，去抓别人的命名规范其实挺不舒服的，显得自己爱计较，而且在缺少共同认知，一般人家也觉得你爱计较。2）命名其实就是对抽象的定义。不能描述业务含义的命名往往是由于抽象的角度不正确或不明确引起的。设计建模时我们会说，业务驱动，认知先行。这里的认知先行就是要先建立与业务侧达成共识的模型（可以认为就是文中让产品看看能不能理解）。然后基于这个认知模型直接翻译成代码，不要扯什么实现和设计允许不一致，好的设计和实现应该就是一模一样的。这样翻译出来的代码，其行为和能力的定义（命名）自然是对应在业务特征上的。遗憾的是，大多数时候，在一个叫现实的东西面前，我不得不低下头，毕竟时间有限，测试支撑无力，在对项目没有足够认知之前，我们只能用最小的改动、最大的复用和差不多的命名去实现功能，设计和对齐认知的事情放到后面可能存在的重构上。（实现先行，设计随后）作者回复：坚持做正确的事情有难度，不坚持却难以提升。2020-12-29

18 年末，我看了你的 10X 工作法专栏，里面有提到过「代码的坏味道」碰巧那时候我刚读完重构第一版，对你专栏的的观点非常认同，几个月之后重构出了第二版，一半是好奇，一半是自己对优秀代码的向往把书买回来读完了。几个月前我看完了软件设计之美。这样一想三年过去了，自己在代码量有了更多的积累，每次回过去看那些重构的原则，都会有新的体会，写的时候依旧会犯迷糊，一个查询方法，是用 listXX，getXX 还是 queryXX 呢，光是思考这些我都会想好一会，还有就是有时候写的时候觉得合适的，之后等整个功能完成回去检查时又觉得这样不好了。动手之前想的更多了。

为了命名，和同事展开了很多争论：原命名为 `$personsArray`。我的任务是重构。我在重构过程中，我把变量换为 Collection 类型，变量名改为 `$persons`。同事给我 review 的建议：「应该把 `$persons` 改为 `$personCollection`。1）因为变量如之前的 legacy 代码的 personArray，表明了这个变量的类型，所以，我们用 `$personCollection` 有助于其他人阅读和理解。2）person 的 Collection 可以是一个 person 为 Collection，也可以是多个 persons，于是这个变量不一定永远是复数 persons。」请问老师，怎么怼回去？感觉他们说得也有理啊……您的这些理论，有出处 reference 吗？作者回复：当它把类型从 Array 改成 Collection，就需要改一次变量名，那以后同样的事情还是会发生的。同样，这里的复数实际上也可以里面只有一个，这并不是问题。你可以看一下我在文章结尾附上的资料，这是我在《10x 程序员工作法》关于命名的介绍。2020-12-30

xxxMap 这种命名表示映射关系，比如：书 id 与书的映射关系，不能命名为 bookIdMap 么？一时没想到好的命名，老师能给点建议么？作者回复：按照我习惯的约定，Map 表示的是一个数据结构，而映射关系我会写成 Mapping。2020-12-30

看完后我去 review 了下我的代码，确实有的地方命名太过宽泛。之前也遇到过返回值类型改了之后，下面的变量名很尴尬的问题。以后写代码会注意的到了。作者回复：有所得，没白学。2020-12-29

听完老师的课，对有意义的名字的理解有进了一步，之前只做到不用 abcd 等来命名，今天学到了名字要根据场景取一个有业务含义的名字。表明意图的名字可以让 Review 代码的人先了解意图，再结合情况来看是否要了解细节。作者回复：有直接的收获就好，专栏没白学。2020-12-29

进入程序员这个行业，第一个使用的框架就是 Rails，Rails 在很多地方做了很好的约定，例如：Controller 名字要用复数，Model 名字要用单数，相对应的数据库表名名字要用复数等。老师课程中举的变量名 bookList 的例子，在 Rails 中约定的命名就是 books。现在已经不再使用 ROR 了，但是在动手之前还是会认真思考，尤其是有多种方式可以选择，拿不准要采用哪种的时候会想，如果这种场景在 Rails 下会怎样处理，这个时候通常心里就有答案了。现在研发团队成员命名随心所欲。数据库字段驼峰式与蛇形式混合双打；字段名单复数不分，如：表示操作人的字段名定义为 people；一个修改账号状态的方法里还会有更新这个账号下关联的其它业务的代码；`Example.Criteria c1`，`Example.Criteria c2` 这样的命名更是随处可见。每次读代码都是苦不堪言。作者回复：从最佳实践的角度来说，Rails 一直是表现优异的，因为它的设计者是行业中的佼佼者。所以，我在《软件设计之美》中，专门把它拿出来讲。2021-01-02

```java
@GetMapping("getTotalSettlementInfoByYear")
@ApiOperation ("公司结算信息按年求和")

public Result<List<RepMonthCompanyDTO>> getTotalSettlementInfoByYear(@RequestParam String year) {
	List<RepMonthCompanyDTO> list = repMonthCompanyService.getTotalSettlementInfoByYear(year);
	return new Result<List<RepMonthCompanyDTO>>().ok(list);
}
```

这是我前俩天刚写的，欢迎老师给出点评。我是起方法名和字段名经常会特别长，很纠结。

作者回复：名字长不是问题，问题是表达是否清晰，像 repMonthCompanyService 这个名字，是不太容易一眼看出来含义的。另外，传给 service 的参数是一个字符串，这个从逻辑上是有问题的，没有进行参数的校验。后面的内容也会讲到，这个做法是一种缺乏封装的表现。变量名是 list，按照这一讲的说法是用技术术语在命名。再有，这个 URI 是 getTotalSettlementInfoByYear，这是不符合 REST 的命名规范的，比如，动词不应该出现在 URI 里，分词应该是「-」，byYear 实际上是一个过滤条件等等。2020-12-30

刚写代码时，老鸟通常会对菜鸟说教：你不要期望一次将代码写好，得注重健壮性（鲁棒性）、可读性、可维护性、可扩展性，多思考、常重构.... 多看书去看看《重构》《代码整洁之道》等等。然而你看他的提交记录除了改 bug 就没重构过！再看看他写的代码（后面举例），你会发现他推荐你看的书他其实没读完或者根本没读过！（类比于学算法让你看算法导论）当你再追问为什么不按书中 / 大厂规范做，他两手一滩说到不能教条要变通，脱离场景谈优化都是耍流氓 —— 得按咱们团队规范写（其实没规范），我写的就符合规范！（我 C，直接说照着你的代码风格写不就好了，非得套在一堆大道理凸显自己，事后分析起来仍旧是个笑话！其实，在大多数情况下，个体是无法对抗群体习惯的！）

```java
UserDao userDao = dao.UserDao();
UserService userSrv = services.UserService();
UserRepository userRepo = repositories.UserRespository();
```

汇总：1）包名明明已经限定语义，赋值运算符右侧 User 后的后缀其实是可以省略。左侧的变量名，在一般场景可以用 dao/srv/repo 表示，在聚合场景可能还得用 userDao/chapterDao 来区分。这就完了？怎么可能！包名 dao/model 用单数而 services 和 repositories 用复数！对就是这么坑，这么任性！2）对于缩略词的命名：userId 还是 userID？Isbn 还是 ISBN。3）我的理解，api、service、repository 这几层通常是面向业务的，应该使用面向业务的命名；dao 层的业务就是和具体数据源打交道，所以命名可以是 UpdateXXXByID，希望老师针对软件的每个分层给点命名建议！

作者回复：先对你的处境表示一下同情。分层命名一般是团队的习惯，像我现在的团队，一般是用 resource/application/service/repository 来命名，实际上，这里的 application 对应着 DDD 中的应用服务，service 对应着领域服务，在很多团队里，这些都放到了 service 里面。也有的团队 resource 叫 controller，repository 叫 mapper 或 dao。具体叫哪个，按照团队的约定就好。2020-12-29

老师说的初入职场思考命名那块，深有同感，我现在就发现不会写代码了 不知道怎么样才能写好 也不知道这些对不对 导致写的特别慢 不知道啥时候能度过这个迷茫期。作者回复：坚持以这个标准，多看一些代码，积累一些经验。2020-12-28

我们的代码里恰好就有类似 userId 的问题，实际业务是创建者和修改者，可惜方法都给取名 uId 了，虽然有方法名，但听完课感觉还是应该统一一下。作者回复：能直接用起来，真好。2020-12-28

对于返回集合类型，我一直用的是 `**List` 或者 `**Set`，之前还以为这样能够让同事一下子比较明了，这就是 list 或 set。如果是面向接口编程，那么返回的应该是一个集合。对于技术含义，自己代码里经常带有这样。应该用一个模型去实现，这样更好替换具体实现。2021-03-15

看您在评论留言说映射关系写成 Mapping，那如果一个章节 id 与章节的 `map Map<chapterId,chapter> `是不是可以写成 chapterMapping？作者回复：可以，但是不建议，这是直接映射通常也是一种技术思维，最好能找到更好的业务术语，否则，就会走到另一条「老路」上。2021-02-04

如果是 map 的命名，老师的意思是以 mapping 结尾吗？还有如果是那种复杂结构的 map，类似于，`map<string，map<>>`，这种怎么命名好一点呢？作者回复：通常来说，在写代码的过程中，map 是一种数据结构，而 mapping 是映射的意思，英文上是不一样的。重点不是 map 对象该如何命名，而是业务上是什么含义。2021-01-23

看了老师提到的根据业务场景去命名，真的很提高我的认知。以往对于命名的规范只存在于不要使用不明含义的表达，但是却从来没有人告诉我们需要使用表达清晰到位的词语去进行命名。userId 以及 xxxList，xxxMap 这些在太多场景下被使用，看了老师的分析深深的震撼了我。即使是写业务代码，原来我们也可以将自己的代码打磨的更加精准。跟着老师学，一步一步精进。2020-12-30

## 0102乱用英语站在中国人的视角来看英文命名.md

### 总结时刻

今天我们讲了几个英语使用不当造成的坏味道：1）违反语法规则的命名；2）不准确的英语词汇；3）英语单词的拼写错误。这是国内程序员因为语言关系而造成的坏味道，英语是目前软件开发行业的通用语言，一个程序员要想写好程序，要对程序中用到的英语有一个基本的感觉，能够发现代码中的这些坏味道。其实，还有一些常见的与语言相关的坏味道，因为比较初级，我只放在这里给你提个醒，比如：1）使用拼音进行命名；2）使用不恰当的单词简写（比如，多个单词的首字母，或者写单词其中的一部分）。

我们还讨论了如何从实践层面上更好地规避这些坏味道：1）制定代码规范，比如，类名要用名词，函数名要用动词或动宾短语；2）要建立团队的词汇表（是的，我们在上一讲也提到了）；3）要经常进行代码评审。

命名之所以如此重要，因为它是一切代码的基础。就像写文章一样，一个错别字满天飞的文章，很难让人相信它会是一篇好的文章，所以，命名的重要性是如何强调都不为过的。如果今天的内容你只能记住一件事，那请记住：编写符合英语语法规则的代码。

### 2.0

上一讲，我们讲了两种常见的命名的坏味道，这一讲的话题还是命名，只不过，这个主题是国外那些经典编程书籍所不曾涵盖的话题：英语命名。现在主流的程序设计语言都是以英语为基础的，且不说欧美人设计的各种语言，就连日本人设计的 Ruby、巴西人设计的 Lua，各种语法采用的也全都是英语。所以，想要成为一个优秀的程序员，会用英语写代码是必要的。

这里并不是说，程序员的英语一定要多好，但最低限度的要求是写出来的代码要像是在用英语表达。或许你听说过，甚至接触过国内的一些程序员用汉语拼音写代码，这就是一种典型的坏味道。鉴于现在的一些程序设计语言已经支持了 UTF-8 的编码格式，用汉语拼音写代码，还不如用汉字直接写代码。当然，这个坏味道实在是太低级了，我就不在这里深入讨论了。让我们来看看还有哪些可能会不经意间忽略的坏味道。

### 2.1 违反语法规则的命名

我们来看一段代码：

```java
public void completedTranslate(final List<ChapterId> chapterIds) {
  List<Chapter> chapters = repository.findByChapterIdIn(chapterIds);
  chapters.forEach(Chapter::completedTranslate);
  repository.saveAll(chapters); 
}
```

初看之下，这段代码写得还不错，它要做的是将一些章节的信息标记为翻译完成。似乎函数名也能反映这个意思，但仔细一看你就会发现问题。因为 completedTranslate 并不是一个正常的英语函数名。从这个名字你能看出，作者想表达的是「完成翻译」，因为是已经翻译完了，所以，他用了完成时的 completed，而翻译是 translate。这个函数名就成了 completedTranslate。由此，你可以看到，作者已经很用心了，但遗憾的是，这个名字还是起错了。

一般来说，常见的命名规则是：类名是一个名词，表示一个对象，而方法名则是一个动词，或者是动宾短语，表示一个动作。以此为标准衡量这个名字，completedTranslate 并不是一个有效的动宾结构。如果把这个名字改成动宾结构，只要把「完成」译为 complete，「翻译」用成它的名词形式 translation 就可以了。所以，这个函数名可以改成 completeTranslation：

```java
public void completeTranslation(final List<ChapterId> chapterIds) {
  List<Chapter> chapters = repository.findByChapterIdIn(chapterIds);
  chapters.forEach(Chapter::completeTranslation);
  repository.saveAll(chapters); 
}
```

这并不是一个复杂的坏味道，但这种坏味道在代码中却时常可以见到，比如，一个函数名是 retranslation，其表达的意图是重新翻译，但作为函数名，它应该是一个动词，所以，正确的命名应该是 retranslate。其实，只要你懂得最基本的命名要求，知道最基本的英语规则，就完全能够发现这里的坏味道。比如，判断函数名里的动词是不是动词，宾语是不是一个名词？这并不需要英语有多么好。自己实在拿不准的时候，你就把这个词放到字典网站中查一下，确保别用错词性就好。

对于大多数国内程序员来说，字典网站是我们的好朋友，是我们在写程序过程中不可或缺的一个好伙伴。不过，有些人使用字典网站也会很随意。

### 2.2 不准确的英语词汇

有一次，我们要实现一个章节审核的功能，一个同事先定义出了审核的状态：

```java
public enum ChapterAuditStatus {
    PENDING,
    APPROVED,
    REJECTED;
}
```

你觉得这段代码有问题吗？如果看不出来，一点都不奇怪。如果你用审核作为关键字去字典网站上搜索，确实会得到 audit 这个词。所以，审核状态写成 AuditStatus 简直是再正常不过的事情了。然而，看到这个词的时候，我的第一反应就是这个词好像不太对。因为之前我实现了一个作品审核的功能，不过我写的定义是这样的：

```java
public enum BookReviewStatus {
    PENDING,
    APPROVED,
    REJECTED;
}
```

抛开前缀不看，同样是审核，一个用了 audit，一个用了 review。这显然是一种不一致。本着代码一致性的考虑，我希望这两个定义应该采用同样的词汇。于是，我把 audit 和 review 同时放到了搜索引擎里查了一下。原来，audit 会有更官方的味道，更合适的翻译应该是审计，而 review 则有更多核查的意思，二者相比，review 更适合这里的场景。于是，章节的审核状态也统一使用了 review：

```java
public enum ChapterReviewStatus {
    PENDING,
    APPROVED,
    REJECTED;
}
```

相比之下，这个坏味道是一个高级的坏味道，英语单词用得不准确。但这个问题确实是国内程序员不得不面对的一个尴尬的问题，我们的英语可能没有那么好，体会不到不同单词之间的差异。很多人习惯的做法就是把中文的词扔到字典网站，然后从诸多返回的结果中找一个自己看着顺眼的，而这也往往是很多问题出现的根源。这样写出来的程序看起来就像一个外国人在说中文，虽然你知道他在说的意思，但总觉得哪里怪怪的。

在这种情况下，最好的解决方案还是建立起一个业务词汇表，千万不要臆想。一般情况下，我们都可以去和业务方谈，共同确定一个词汇表，包含业务术语的中英文表达。这样在写代码的时候，你就可以参考这个词汇表给变量和函数命名。

下面是一个词汇表的示例，从这个词汇表中你不难看出：一方面，词汇表给出的都是业务术语，同时也给出了在特定业务场景下的含义；另一方面，它也给出了相应的英文，省得你费劲心思去思考。当你遇到了一个词汇表中没有的术语怎么办呢？那就需要找出这个术语相应的解释，然后，补充到术语表里。

建立词汇表的另一个关键点就是，用集体智慧，而非个体智慧。你一个人的英语可能没那么好，但一群人总会找出一个合适的说法。我在《软件设计之美》里讲到领域驱动设计时，曾经讲过通用语言，其实，业务词汇表也应该是构建通用语言的一部分成果。

### 2.3 英语单词的拼写错误

我再给你看一段曾经让我迷惑不已的代码：

```java
public class QuerySort {
    private final SortBy sortBy;
    private final SortFiled sortFiled;
    ...
}
```

初看这段代码时，我还想表扬代码的作者，他知道把查询的排序做一个封装，比起那些把字符串传来传去的做法要好很多。但仔细看一下代码，我脑子里就冒出了一系列问号。sortFiled 是啥？排序文件吗？为啥用的还是过去式？归档？被这段代码搞晕的我只好打开提交历史，找出这段代码的作者，向他求教。

我：这个字段是啥意思？

同事：这是排序的字段啊。

我：排序的字段？

同事：你看，这个查询排序类有两个字段，一个是排序的方式，升序还是降序，另一个就是排序的字段。

我：字段这个单词是这么拼吗？

同事：不是吗？哦！是 field，拼错了，拼错了。

你看，是他把单词拼错了。

其实，偶尔的拼写错误是不可避免的，这就像我们写文章的时候，出现错别字也是难免的。之所以要在这个专栏中把拼写错误作为一种独立的坏味道，是因为在很多国内程序员写的程序中，见到的拼写错误比例是偏高的。

在这个故事里面，我都已经当面指出了问题，这个同事甚至都没有第一时间意识到自己的拼写是错误的，这其实说明了一种尴尬的现状：很多程序员对英语的感觉并没有那么强。事实上，这个同事不止一次在代码里出现拼写错误了，一些拼写错误是很直白的，一眼就能看出来，所以，通常在代码评审的时候就能发现问题。这次的拼写错误刚好形成了另外一个有含义的单词，所以，我也被困住了。

对今天的程序员来说，工具已经很进步了，像 IntelliJ IDEA 这样的 IDE 甚至可以给你提示代码里有拼写错误（typo），不少支持插件的工具也都有自己的拼写检查插件，比如 Visual Studio Code 就有自己的拼写检查插件。在这些工具的帮助之下，我们只要稍微注意一下，就可以修正很多这样低级的错误。

这一讲的内容几乎是完全针对国内程序员的。对于国外程序员来说，他们几乎不会犯这些错误。英语是程序员无论如何也绕不过去的一关，越是想成为优秀程序员，越要对英语有良好的感觉。当然，这里并不强求所有人的英语都能达到多好的程度，至少看到一些明显违反英语规则的代码，自己应该有能力看出来。

英语和程序设计语言其实是一样的，想用好，唯有多多练习。我自己的英语水平也算不上多好，但我读过很多技术文档，也看了很多开源的代码。之前因为参加开源项目和在外企工作的经历，也写过很多的英语邮件和文档，逐渐对程序中的英语有了感觉。

有些人注意到，我的开源项目 Moco 的文档是用英语写的，这其实是我强迫自己练习的结果。如果说英语是一门全功能的程序设计语言，那么程序中用到的英语就是一门 DSL（领域特定语言）。相比起完全掌握好英语，掌握程序中用到的英语就要简单一些了。

### 黑板墙

思考题：我们在这一讲里讲到了程序员和英语之间的关系，我想请你分享一下，你在工作中与英语的关系，无论是遇到的问题，或是自我提升的经验，都行。欢迎在留言区分享你的经验，也欢迎你把这节课的内容分享给团队的小伙伴，大家一起精进「英语命名」。

参考资料：[动词：英语宇宙的中心](https://time.geekbang.org/column/article/248732)

汇总：1）我的英语不行，所以我想反驳。2）我就是一个将中文词丢字典网，然后挑顺眼的惯犯。但英语水平的不足，我也很绝望呀。有些时候没有选择是幸福的，我很希望一个中文单词丢进去只返回一个英文单词，这样就不用挑战我的英语水平了。3）达成共识高于英语描述准确。如果团队的英语水平普遍都不高，写得标准真的不见得比中文拼音的认知成本低。在有一定业务背景知识的前提下，如果命名用标准的英语，我需要百度下其中各字段的单词意思，然后才能理解该命名对应的业务含义，不是人家命名不好而是我个人英语水平不行，不认识的单词连猜都没法猜；而如果命名采用中文缩写，甚至中文首字母缩写，这命名水准有些低端，但我能猜出来其对应的业务含义，基于业务背景的认知能为我提供这层觉察心。两者之间还是能有一定效益差异的，遗憾的是 bad 命名效益还更高。4）只可意会不可言传，中国人在意会这个事上是真的有先天优势。如果所有人的意会都准确无误，那还有必要追求言语的准确吗？

作者回复：首先，作为程序员，提升英语水平是应该做的一项努力，这是通向高手的必经之路。否则，就只能在低水平徘徊了，毕竟，写程序的高手外国人居多。不要指望和低水平的下棋能下成高手，没有可能的。其次，英语这种东西没有什么困难，习惯而已。虽然有些单词不那么直观，但用多了，你就习惯了，所有的单词都一样。有很多单词，我习惯了英文，有时会一下子想不起中文是什么来。最后，意会不可能准确无误，否则，就不会有女孩的心思男孩你别猜了。基于这个假设的讨论，就不必了。2020-12-29

见过一个系统里面一个属性有三种命名，看的头大。作者回复：这个叫不一致。2020-12-29

刚毕业的时候在一家游戏公司工作过，一个同事代码里方法命名和字段命名都是中文，「张飞大招」，「刘备属性」诸如此类的看着代码很出戏。还听说个一个印度同事变量名非常的长 100 多个字符。作者回复：中文命名如果能统一，其实也不错。2021-01-05

如果再查单词的时候，能捎带看一下例子、语境，会更好。好处 1：对一个单词的理解不仅仅是词典里面的翻译，根据语境能更清晰的理解含义。好处 2：这对英语的提升也有很大的帮助，学习一门语言都是通过语境来学习的。费事儿的是需要稍微花费点儿时间去查。改进：我也需要这么做，不能只查单词和意思。作者回复：进一分，有一分的欢喜。2021-01-03

刚开始写代码的时候，虽然没有用汉语拼音去命名，但英文用的也是乱七八糟。当时的 TeamLeader 每次 Code Review 在命名上都会花很大的力气帮忙纠正。在 Code Review 的时候除了记录他说的问题，也观察他的方法，每当他发现有问题的地方，都是先去「词典网站」上搜索，然后细研究下面的事例句子，最后从中找到最符合场景的单词。同时他还建议去看一些好的开源项目，看里面的设计、命名和实现等等。慢慢的自己也继承了他的方法，而且，自己整理了一份表格类似于课程里讲提到的「术语表」，每次看到好的命名就会把它记下来，方便以后使用。这份「术语表」后来中断了，学习完今天的课程，后面要继续维护起来。另外，推荐一个命名的插件 CODELF，它的 github 地址是：[unbug/codelf: A search tool helps dev to solve the naming things problem.](https://github.com/unbug/codelf)。作者回复：很好的补充，这个网站确实要比很多程序员自己的选择好。2021-01-03

1『直接在 Vscode 插件市场搜关键词「codelf」可以找到该插件，安装后选中命名的单词右键后点击「CodeLf」即可跳转到结果网页。这个工具目前感觉蛮好用的。（2021-05-06）』

请问下老师，audit 和 review 两个词的区别应用在哪里查到的。平时我们记单词只有相同的中文翻译，并不能帮助理解区别。于是，我把 audit 和 review 同时放到了搜索引擎里查了一下。原来，audit 会有更官方的味道，更合适的翻译应该是审计，而 review 则有更多核查的意思，二者相比，review 更适合这里的场景。作者回复：我用的是 google，根据二者英文释义进行地比较。2020-12-28

在不知道要用什么词的情况下：1）词汇网站：如 dict.cn。2）把第一步搜到的词在 github 上搜一下，看下别人怎么用的。作者回复：非常好的补充。2021-01-11

虽然老师文中提到：使用不恰当的单词简写（比如，多个单词的首字母，或者写单词其中的一部分）。即不要使用不完整的英文字母，但是平常开发时经常碰到如 message-msg、button-btn 等简写方式，这个也是不允许的吗？必须在任何场景都写完整的英文单词吗？作者回复：有一些行业通用的缩写可以用，最好不要自己创造，前提是约定好。2021-01-08

我在银行工作，他们变量命名都是几个单词首字母，或者一个单词拿一半，比如，付款人账号 pyernum，这种还能看出含义，再如发起方代码 std500aqid，根本就看不出含义，我如之前命名都是比较规范的，银行有特们自己的命名规范，现在我的命名规范按阿里来的，想问他们这种算特殊系统的主流规范吗，还是只此一家这种。作者回复：你这个还真是比较特别，肯定是特殊情况，建议考虑先建立词汇表，再把词汇表展示给大家看，讨论一下命名的合理性。共识是很重要的。2021-01-06

在实际的实践中，我认为乱用英语命名是以下两方面的原因导致的，1）团队成员的英语水平不是很强，具体业务中，无法找到合适的词汇来表达。比如之前做过的保险业务系统的开发，保险的很多词汇不知道怎么用英语说，也没有可以参考的词汇表，只能上网查，代码写得千奇百怪。2）缺少规范，缺少代码 review。文中老师说比较好的实践是建立一套词汇表，实际项目中，着急忙慌开始做了，大家看进度不看代码，只要能跑就行，bug 出了修修补补又一年，皆大欢喜。结果就是没啥实质的进步，下个项目还是如此，一年又一年...... 看看留言区总监能写出 aaaa 的代码我也是服了......作者回复：保险词汇一定是有对应英文表达的，国外的保险业务已经运行很多年了，只是我们要花时间去找这些对应的表达。我在做网文，一开始对于「男频」、「女频」这样的词汇，也不知道该怎么翻译，看了一些外国网站之后，才知道可以写成「Male Lead」、「Female Lead」。2021-01-06

很多时候命名是业务上的，比如一些客户的自造词，这个模块的关键词就是这个自造词，想翻译都没法翻。比如我最近遇到的一个自造词叫「奕尊」，这该怎么翻译。作者回复：我也害怕自造的词，不过，从我的实践看，大多数自造词实际上是词汇量匮乏的结果，很多人不知道自己的领域中有更合适的表达方式。所以，一种解决方案就是，问清楚这个词的含义，看看能不能找到一个正常的词来表达。2020-12-30

请教老师一个问题，针对特定的英文缩写，比如 DNS，如果写 get 方法，您一般是用 getDns() 还是 getDNS()，我理解是后面的，但 IDEA 经常提示警告。作者回复：其实都可以，团队约定就好。2020-12-29

我的英语是在搭建 gentoo 和 arch 时候发现翻译版本太落后，或者翻译不完整，然后就索性直接看官方英文版了，把认不得的单词就记背单词软件里。然后就这样一直加一直背，大概不到一年时间，看技术文档 80% 的词都看得懂了。现在基本有问题先用英语 Google 搜索，看不懂的新概念才会看一些中文文章。所有问题，第一时间查的是官方最新英文文档。作者回复：在实际的场景中学习，这才是学习的正道。2020-12-29

3『

### 附件：动词 —— 英语宇宙的中心

陈亦峰 2020-06-15

今天我们继续阅读 Successful Remote Working 这篇文章，深入分析句子、讲解词汇。

Establishing a high level of trust among remote managers and employees starts with having good meeting rituals. Meetings should be conducted on video if at all possible, and start with a「check in」for each team member. The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity. Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.

在远程工作过程中，经理和员工之间的高度信任始于一套良好的会议仪式。只要可能，会议就应该通过视频方式进行，并从每个团队成员「报到」开始。报到的过程可以让大家陈述他们当天的感受，还有哪些事情可能影响他们的情绪或生产力。经理们必须以身作则，因为你的行动比你的言辞更重要。关于会议仪式方面的建议，Humble 推荐了《核心协议》作者 Richard Kasperowski 写的《高能团队迷你书》。

An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a「standup.」Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.

定期的会议日程安排也有助于为分散的团队创建组织秩序。每天的网络短会取代了每日「立会」。因为远程工作团队比同地点办公团队具有更高的独立性，所以每周可能只需要开两次例会，就可以让所有成员保持步调一致。

One-on-one meetings between employee and manager are extremely important, and must be treated as sacrosanct. These meetings are for the employee, with discussions about their career and other personal concerns. Humble had two absolute rules: The one-on-one is not a status meeting, and managers should never be allowed to cancel the meeting.

员工和经理之间的一对一会议非常重要，必须拥有神圣不可更改的地位。一对一会议是为员工安排的，用于讨论他们的职业生涯和其他个人问题。Humble 有两条铁律：一对一会议不是检查工作进度的会议，管理者永远不得取消一对一会议。

1、不及物动词 + 介词。

Establishing a high level of trust among remote managers and employees starts with having good meeting rituals.

在英语语言的宇宙里，动词是宇宙中心。今天首先来讲一讲宇宙中心的基本规则。

我们都知道，英语动词分为及物动词和不及物动词。

所谓及物动词（transitive verb，缩写 vt.），就是动词后面可以直接跟「物」的动词。这个「物」就是动作的对象，也是动词的宾语。例如 I invited Tom.（我邀请了汤姆。）

汤姆这个人就是那个「物」，invite 是及物动词，后面可以直接跟宾语，而且必须有这个「物」，不然句子不完整，不能说 I invited 后面就没了。

不及物动词（intransitive verb，缩写 vi.）就是不能直接跟「物」（宾语）的动词。这类动词自身词义完整。例如 walk、smile、sleep，我走、我笑、我睡，都不用说明动作对象，也不能直接跟宾语。

如果不及物动词后面想要跟「物」（宾语）的话，例如要说「她对我笑」，怎么办呢？这时候，无处不在、无所不能的介词就要发挥作用了。不及物动词后面加上介词之后，就秒变「及物」动词，我们可以说「She smiled at me, and I smiled back.（她冲我笑笑，我也冲她笑笑。）」。从语法角度讲，smile at me，me 是 at 介词的宾语，at me 整个是 smile 的状语。

还有一个常用的习语 smile from ear to ear，也是加了介词 from，字面意思是「从左边耳朵笑到右边耳朵」，其实就是「眉开眼笑」、「笑得合不拢嘴」的意思。

此外，需要特别说明一下，在不及物动词后面加的 up、down、in 等小词，并不一定都扮演介词的角色。换言之，只有 up、down、in 等这些小词后面跟了宾语的时候，它们才是介词。有「物」可「介」，才能称为介词。如果无「物」可「介」，也就是小词后面不跟宾语的时候，这些小词起到的是副词的作用，表示前面那个动词的状态，英语语法上也称其为副词小品词（adverb particles）。一个动词可以和副词小品词构成不同的动词短语，例如 break down、give up 等。

对于介词和副词小品词的不同，我们来举例说明一下。

例句 1：I ran down the road.（此句中带有介词宾语，有物可「介」，down 为介词）

例句 2：Please sit down.（此句中不带宾语，down 为副词小品词）

上述概念本身都很好理解，它们只是语法知识而已，更重要的是语言本身的实践和应用。有的动词只是及物动词，这类动词不跟宾语的话，句子就是错的。相反，有的动词只是不及物动词，如果不加介词直接跟宾语，也是病句。不及物动词往往可以搭配不同的介词，形成不同的含义和用法。

但是，更多的动词既可以是及物动词，也可以是不及物动词。同一个动词存在几种不同含义和用法，这种情况比比皆是。例如 Let's eat 是不及物动词，I can't eat seafood 是及物动词。这就需要我们勤查词典，结合例句来理解和学习，同时还要自己多造句来练习。

回过头来看文章中的这句话。

这句话由动名词 establishing a high level of trust among remote managers and employees 做主语，「经理和员工之间建立高度信任」，谓语动词 start 是不及物动词，所以要加上介词 with，才能接宾语 having good meeting rituals（有一套好的会议仪式）。

需要指出的是，我们这里说的宾语是介词 with 的宾语，而不是 start 动词的宾语，不及物动词不能接宾语，介词 with 加后面的介词宾语一起的介宾结构做 start 的状语。当然，这个也是语法知识，知道一下原理就好。我们已经反复说过好几次，学习英语知道原理只是第一小步，懂得意思并且记住 start with 这个固定的搭配，并多查多读几个例句，才是最重要的。

2、被动语态。

Meetings should be conducted on video if at all possible, and start with a「check in」for each team member.

关于动词的另外一个重点内容就是被动语态。语态是用来说明主语和动词之间关系的动词形式。英语语法中的语态只有两种，主动语态（active voice）和被动语态（passive voice）。主动语态中主语是动作的执行者，被动语态中主语是动作的承受者。因此，只有及物动词才有被动语态。

被动语态由「助动词 be+ 及物动词的过去分词」构成，被动语态的时态变化只需要改变 be 的形式，过去分词部分不变。疑问式和否定式的变化也是如此。

这么说估计你能理解，但是还是比较抽象，我们通过例句来讲解一下什么时候需要用被动语态。

首先，当我们希望强调动作的承受着和动作或事件本身，而不想强调动作的执行者（或者根本不知道动作的执行者）的时候，往往会用被动语态。这样的叙述方式，可以使得句子听上去更加具有客观性，因此这种情况一般在科研、学术著作中较为常见。

例句：Too many books have been written about the Second World War.

翻译：关于第二次世界大战的书太多了。（强调书，而不是书的作者。）

其次，很多时候，我们讲话的时候，总是习惯先说已知的旧信息，把新的信息留在句末。

例句：Nice picture! ~Indeed. It was painted by my grandfather.

翻译：这幅画画得真不错！~ 的确，这是我爷爷画的。（这里要突出的新信息是画的作者，所以放在句子的末尾，其他信息都是已知的。）

此外，有时候为了保持一句话或者几句话里的主语不变，也需要使用被动语态。

例句：Joe left my house around 5 pm, and was hit by a car about 30 minutes later.

翻译：乔下午五点左右离开我家，大约三十分钟后就被车撞了。（可以说 a car hit him，但主语就要发生变化了；主语不变更加自然。）

好了，知识讲完了，我们来看看文中这句话使用的被动语态是不是符合上面的情况。

Meetings should be conducted on video，会议尽量要通过视频方式来开，其实就是会议「被」开，但翻译成中文就听不出被动语态了。首先，这句话希望强调会议本身，而不是开会的人，句子听上去也比较有客观性；第二，meeting 同时充当前半句被动语态（be conducted）和后面半句话主动语态（start with）的主语，这样句子听上去会比较自然。

3、宾语从句和定语从句。

The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity.

这句话的主语是 the check in，动词短语名词化，指「点名」或「报到」这件事情，let 是谓语动词，后面跟宾语加上不带 to 的不定式。let…do…，你把这个当固定短语来记就好。

加黑部分是 state 的宾语从句，可以让团队成员谈一谈，一是他们当天有何感受，二是还有哪些事情。什么事情呢？后面还套了一个定语从句，就是下加黑部分，可能影响他们情绪或生产力的那些事情。串在一起就是「报到」这个形式，让团队成员能谈一谈上面讲的这两个问题。

4、lead by example。

Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.

固定搭配 lead by example 很常用，指的是领导「身先士卒」「以身作则」。下面这句话是世界卫生组织前任总干事陈冯富珍演讲中说的一句话：

例句：I must lead by example, and I must be held accountable to Member States.

翻译：我必须以身作则，我也必须对会员国负责。

为什么要以身作则呢？因为 what you do is more important than what you say。有一个英语成语也是这个意思：action speaks louder than words（行胜于言）。

5、huddle 和 standup。

An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a「standup」. Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.

这段的句式结构比较简单，我们讲一下两个词。

第一个是 huddle，它原本的含义是「（因为寒冷或害怕）挤在一起或缩成一团」，英语解释是 to gather closely together, usually because of cold or fear。

例句：Tired and lost, we huddled together around the fire.

翻译：我们疲惫不堪，又迷了路，于是都围着火堆挤作一团。

后来这个词引申用到一些体育比赛中，指「队员靠拢在一起，磋商比赛战略战术的行为」。

例句：In many sports like football and rugby, the team huddles before each play. The huddle is strategic: it keeps the team informed and connected throughout the game. For software teams, the stand-up is like the team's huddle to keep everyone aware of the team's landscape and progress.

翻译：在许多运动中（例如足球和橄榄球），全体队员在每次比赛前都要靠拢在一起磋商战术。这一安排具有战略意义：它在整场比赛中保持全队信息和精神相通。对于软件开发团队来说，每日站会就像球队的赛前战术会，让每个成员都知道团队的最新情况和进展。

「standup」顾名思义，就是大家站着开的会。这是敏捷开发（Agile Development）流程中必不可少的环节，其实就是开发团队全员参加的每日例会，定时定点，时间较短，或者说为了控制会议时间，要求大家站着开会，不说废话，不打瞌睡。团队成员在站会前一般都会准备好需要更新的内容，从而确保会议高效。每日站会的目的，在于预估并安排每日的工作计划，促进团队沟通合作，提高透明度，共享工作的进展和障碍（highlight progress and flag blockers），并得到快速响应。

小结：今天的内容就讲到这里，照例还是留一段话给你自己课后分析。今天我们重点讲了动词的两种类型，及物动词和不及物动词，还讲了动词的两种语态，主动语态和被动语态。相信你对这些语法概念并不陌生，这是中学甚至小学就讲过的内容，我们今天其实只是复习。

尽管是复习，我相信，你听了之后一定会似曾相识但又感觉不甚熟悉。，英语里面有个短语叫 a nodding acquaintance，翻成中文就是「点头之交」，现在也可以叫「点赞之交」。英语学习过程中，我们充满了这样的点头之交，似乎知道，但又不是十分知道；讲完之后，或许会想起来一些曾经看过的概念，但回头没多久又很快想不起来。这是非常正常的现象，因为技能没有真正掌握之前，知识本身也不会十分巩固。

动词作为英语宇宙的中心，变化万千，要讲时态和语态，还能和不同的介词（或者副词小品词）搭配幻化出各种不同的意思，的确不是讲几个语法概念和读几个例句就能囊括的，同样也需要我们日积月累。掌握了动词并且能够运用自如，你就相当于站在宇宙的中心，洞悉万物一切的变化。

老师号，请教一下这个句子：I must lead by example, and I must be held accountable to Member States. 这句话后半句「be held accountable」的用法不太理解。1）held 为什么要用被动语态？2）held 后为什么跟了个形容词 accountable？我看字典上说 hold 一般加个名词，比如「office」「power」「responsibility」等。作者回复：这个固定搭配短语的主动语态是 hold somebody accountable, 意思是让某人负起责任，如果变成被动语态，就变成 somebody be held accountable，就是句子里的意思，陈冯富珍作为总干事，要对成员国负责的意思。2020-08-04

』

## 0103重复代码简单需求到处修改怎么办.md

### 总结时刻

这一讲我们讲到重复代码，讲到了几个典型的坏味道：1）复制粘贴的代码；2）结构重复的代码；3）if 和 else 代码块中的语句高度类似。

很多重复代码的产生通常都是从程序员偷懒开始的，而这些程序员的借口都是为了快，却为后续工作埋下更多地隐患，真正的「欲速而不达」。复制粘贴的代码和结构重复的代码，虽然从观感上有所差异，但本质上都是重复，只不过，一个是名词的微调，一个是动词的微调。程序员千万不要复制粘贴，如果需要复制粘贴，首先应该做的是提取一个新的函数出来，把公共的部分先统一掉。if 和 else 的代码块中的语句高度类似，通常是程序员不经意造成的，但这也是对于写代码没有高标准要求的结果。让 if 语句做真正的选择，是提高代码表达准确性的重要一步。作为一个精进中的程序员，我们一定要把 DRY 原则记在心中，时时刻刻保持对「重复」的敏感度，把各种重复降到最低。如果今天的内容你只能记住一件事，那请记住：不要重复自己，不要复制粘贴。

### 3.0

前面两讲，我们讨论了命名中的坏味道。今天，我们来讨论另外一个常见的坏味道：重复代码。记得我刚开始工作的时候，有人开玩笑说，编程实际上就是 CVS（CVS 是当时流行的一个版本控制工具，相当于今天的 Git），也就是 Ctrl+C、Ctrl+V、Ctrl+S，或许你已经听出来了，这是在调侃很多程序员写程序依靠的是复制粘贴。

时至今日，很多初级程序员写代码依然规避不了复制粘贴，基本的做法就是把一段代码复制过来，改动几个地方，然后，跑一下没有太大问题就万事大吉了。殊不知，这种做法就是在给未来挖坑。

通常情况下，只要这些复制代码其中有一点逻辑要修改，就意味着所有复制粘贴的地方都要修改。所以，我们在实际的项目中，常常看见这样的情况：明明是一个简单的需求，你却需要改很多的地方，需要花费很长的时间，结果无论是项目经理，还是产品经理，对进度都很不满意。

更可怕的是，只要你少改了一处，就意味着留下一处潜在的问题。问题会在不经意间爆发出来，让人陷入难堪的境地。复制粘贴是最容易产生重复代码的地方，所以，一个最直白的建议就是，不要使用复制粘贴。真正应该做的是，先提取出函数，然后，在需要的地方调用这个函数。其实，复制粘贴的重复代码是相对容易发现的，但有一些代码是有类似的结构，这也是重复代码，有些人对这类坏味道却视而不见。

### 3.1 重复的结构

我们看一下下面的几段代码：

```java
@Task
public void sendBook() {
  try {
    this.service.sendBook();
  } catch (Throwable t) {
    this.notification.send(new SendFailure(t)));
    throw t;
  }
}
```

```java
@Task
public void sendChapter() {
  try {
    this.service.sendChapter();
  } catch (Throwable t) {
    this.notification.send(new SendFailure(t)));
    throw t;
  }
}
```

```java
@Task
public void startTranslation() {
  try {
    this.service.startTranslation();
  } catch (Throwable t) {
    this.notification.send(new SendFailure(t)));
    throw t;
  }
}
```

这三段函数业务的背景是：一个系统要把作品的相关信息发送给翻译引擎。所以，结合着代码，我们就不难理解它们的含义，sendBook 是把作品信息发出去，sendChapter 就是把章节发送出去，而 startTranslation 则是启动翻译。这几个业务都是以后台的方式在执行，所以，它们的函数签名上增加了一个 Task 的 Annotation，表明它们是任务调度的入口。然后，实际的代码执行放到了对应的业务方法上，也就是 service 里面的方法。

这三个函数可能在许多人看来已经写得很简洁了，但是，这段代码的结构上却是有重复的，请把注意力放到 catch 语句里。之所以要做一次捕获（catch），是为了防止系统出问题无人发觉。捕获到异常后，我们把出错的信息通过即时通讯工具发给相关人等，代码里的 notification.send 就是发通知的入口。相比于原来的业务逻辑，这个逻辑是后来加上的，所以，这段代码的作者不厌其烦地在每一处修改了代码。

我们可以看到，虽然这三个函数调用的业务代码不同，但它们的结构是一致的，其基本流程可以理解为：1）调用业务函数；2）如果出错，发通知。

当你能够发现结构上的重复，我们就可以把这个结构提取出来。从面向对象的设计来说，就是提出一个接口，就像下面这样：

```java
private void executeTask(final Runnable runnable) {
  try {
    runnable.run();
  } catch (Throwable t) {
    this.notification.send(new SendFailure(t)));
    throw t;
  }
}
```

有了这个结构，前面几个函数就可以用它来改写了。对于支持函数式编程的程序设计语言来说，可以用语言提供的便利写法简化代码的编写，像下面的代码就是用了 Java 里的方法引用（Method Reference）：

```java
@Task
public void sendBook() {
  executeTask(this.service::sendBook);
}
```

```java
@Task
public void sendChapter() {
  executeTask(this.service::sendChapter);
}
```

```java
@Task
public void startTranslation() {
  executeTask(this.service::startTranslation);
}
```

经过这个例子的改写，如果再有一些通用的结构调整，比如，在任务执行前后要加上一些日志信息，这样的改动就可以放到 executeTask 这个函数里，而不用四处去改写了。这个例子并不复杂，关键点在于，能不能发现结构上的重复。因为相比于直接复制的代码，结构上的重复看上去会有一些迷惑性。比如，在这个例子里，发送作品信息、发送章节、启动翻译看起来是三件不同的事，很难让人一下反应过来它也是重复代码。

一般来说，参数是名词，而函数调用，是动词。我们传统的程序设计教育中，对于名词是极度重视的，但我们必须认识到一点，动词也扮演着重要的角色，尤其是在函数式编程兴起之后。那你就需要知道，动词不同时，并不代表没有重复代码产生。

理解到这一点，我们就容易发现结构上的相似之处。比如在上面的例子中，发送作品信息、发送章节、启动翻译之所以看上去是三件不同的事，只是因为它们的动词不同，但是除了这几个动词之外的其它部分是相同的，所以，它们在结构上是重复的。

### 3.2 做真正的选择

我们再来看一段代码：

```java
if (user.isEditor()) {
  service.editChapter(chapterId, title, content, true);
} else {
  service.editChapter(chapterId, title, content, false);
}
```

这是一段对章节内容进行编辑的代码。这里有一个业务逻辑，章节只有在审核通过之后，才能去做后续的处理，比如，章节的翻译。所以，这里的 editChapter 方法最后那个参数表示是否审核通过。在这段代码里面，目前的处理逻辑是，如果这个章节是由作者来编辑的，那么这个章节是需要审核的，如果这个章节是由编辑来编辑的，那么审核就直接通过了，因为编辑本身同时也是审核人。不过，这里的业务逻辑不是重点，只是帮助你理解这段代码。

问题来了，这个 if 选择的到底是什么呢？

相信你和我一样，第一眼看到这段代码的感觉一定是，if 选择的一定是两段不同的业务处理。但只要你稍微看一下，就会发现，if 和 else 两段代码几乎是一模一样的。在经过仔细地「找茬」之后，才能发现，原来是最后一个参数不一样。

只有参数不同，是不是和前面说的重复代码是如出一辙的？没错，这其实也是一种重复代码。只不过，这种重复代码通常情况下是作者自己写出来的，而不是粘贴出来的。因为作者在写这段代码时，脑子只想到 if 语句判断之后要做什么，而没有想到这个 if 语句判断的到底是什么。但这段代码客观上也造就了重复。

写代码要有表达性。把意图准确地表达出来，是写代码过程中非常重要的一环。显然，这里的 if 判断区分的是参数，而非动作。所以，我们可以把这段代码稍微调整一下，会让代码看上去更容易理解：

```java
boolean approved = user.isEditor();
service.editChapter(chapterId, title, content, approved);
```

请注意，这里我把 user.isEditor () 判断的结果赋值给了一个 approved 的变量，而不是直接作为一个参数传给 editChapter，这么做也是为了提高这段代码的可读性。因为 editChapter 最后一个参数表示的是这个章节是否审核通过。通过引入 approved 变量，我们可以清楚地看到，一个章节审核是否通过的判断条件是「用户是否是一个编辑」，这种写法会让代码更清晰。

如果将来审核通过的条件改变了，变化的点全都在 approved 的这个变量的赋值上面。如果你追求更有表达性的做法，甚至可以提取一个函数出来，这样，就把变化都放到这个函数里了，就像下面这样：

```java
boolean approved = isApproved(user);
service.editChapter(chapterId, title, content, approved);

private boolean isApproved(final User user) {
  return user.isEditor();
}
```

为了说明问题，我特意选择了一段简单的代码，if 语句的代码块里只有一个语句。在实际的工作中，if 语句没有有效地去选择目标是经常出现的，有的是参数列表比较长，有的是在 if 的代码块里有多个语句。

所以，只要你看到 if 语句出现，而且 if 和 else 的代码块长得又比较像，多半就是出现了这个坏味道。如果你不想所有人都来玩「找茬」游戏，赶紧消灭它。

重复是一个泥潭，对于程序员来说，时刻提醒自己不要重复是至关重要的。在软件开发里，有一个重要的原则叫做 Don't Repeat Yourself（不要重复自己，简称 DRY），我在《软件设计之美》中也讲到过它，而更经典的叙述在《程序员修炼之道》中。

在一个系统中，每一处知识都必须有单一、明确、权威地表述。

Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

写代码要想做到 DRY，一个关键点是能够发现重复。发现重复，一种是在泥潭中挣扎后，被动地发现，还有一种是提升自己识别能力，主动地发现重复。这种主动识别的能力，其实背后要有对软件设计更好的理解，尤其是对分离关注点的理解（如果你对「分离关注点」的知识感兴趣，可以参考我在《软件设计之美》中的 02 讲）。

### 黑板墙

思考题：这一讲的主题是重复代码，你在实际工作中都遇到过什么样的重复代码，你是怎样处理它们的呢？欢迎在留言区分享你的经验。

自己总结重复代码过多的一些原因：1）代码结构不合理导致同一个实现散落各处由于初期代码结构设计不合理导致后续功能实现无法快速找到已有实现，或者找到了但是不好引用已有实现。改进：初期设计代码逻辑合理，对于不合理的地方要及时重构，防止演变成原因。2）为了稳定性，不动老逻辑拷贝一份。由于对于业务的不熟悉和对自己代码能力的不信任不敢重构导致。改进：通过微重构进行多次迭代小改进慢慢优化。3）写的时候为了快。由于时间紧张或者能力问题无法识别出的坏代码。改进：提升能力。作者回复：很好的补充。2021-01-05

俗话说，天下文章一大抄，代码估计也是同理。但是，如果代码写好了，老程序员是不是可以反复利用自己写过的代码了，而慢慢地变得没有什么代码好写了呢？（有感于自己写文章，写来写去也没有什么特别新的洞见，最近学习也有类似的感觉，很多得到上的付费课程感觉都是东抄抄西抄抄）作者回复：反复利用的代码，为什么不是去写一个程序库？得到的课程是另外一个问题，你要是觉得雷同，说明你的见识涨了。2021-01-08

汇总：1）对于自己写的代码，重复写了多遍的，或者逻辑相似但是又不好直接引用的地方，发现后及时重构，如果项目时间紧迫来不及修改，会写好 TODO，在下一次做修改或者闲暇的时候修改好；2）多人协作，对于别人的代码还是要考虑一下的，会和对方打个招呼再去改动。以前有位同事就很不喜欢别人改动他的代码，一次因为有人重构了他的代码引发了 bug，他当场大发雷霆。同时他也不去改动别人的代码，即使逻辑一样他也会再写一遍，问其原因，回答要么是不知道，要么说抽象好的方法写的太复杂看不懂，不敢用。基于这样的原因，代码库里留存着很多重复的代码。作者回复：我特别鼓励代码的集体所有，这样，就没有代码属于谁的说法了。不能透明沟通的人，不适合在团队中工作。2021-01-09

和别人共同协作开发的时候，有时候也挺纠结是不是和别人有重复的代码，如果有谁来修改的问题。作者回复：在一个职业的队伍里，谁发现谁修改。2021-01-07

代码重复这个在项目中太常见了。有些创建对象 new 对象重复，这个时候我一般用工厂模式去解决。再就是很多 if 条件处理不同的逻辑，这种情况一般都用策略模式去解决。再就是实体之间的赋值，一般都用工具 BeanUtils 或者 MapStruct。作者回复：对，很多问题是可以用设计模式和工具框架去解决的。2021-01-05

DRY 不要重复自己，代码重复，结构重复，分支结构类似都是重复，学习抽象，分离关注点。2021-03-25

郑老师，我看到你有的方法参数加了 final 修饰，有的没有。我只知道 final 修饰一个对象，对象的引用不可修改，对象的值是可以改的。不知道这里加 final 的意义在哪里，希望老师能解惑一下，谢谢。作者回复：我鼓励的做法是都加上 final 参数，如果没加，可能是漏了。后面讲到可变的数据时，提到了 final 的使用，你可以看一下。2021-01-27

## 0104长函数为什么你总是不可避免地写出长函数.md

### 总结时刻

今天我们讲了程序员最深恶痛绝的坏味道：长函数。没有人愿意去阅读长函数，但许多人又会不经意间写出长函数。毫无疑问，长函数是一个坏味道。对于团队而言，一个关键点是要定义出长函数的标准。不过，过于宽泛的标准是没有意义的，想要有效地控制函数规模，几十行的函数已经是标准的上限了，这个标准越低越好。

我们还分析了长函数产生的原因：1）有人以性能为借口；2）有人把代码平铺直叙地摊在那里；3）有人只是每次增加了一点点。其中，平铺直叙是把函数写长最常见的原因。之所以会把代码平摊在那里，一方面是把多个业务写到了一起，另一方面是把不同层次的代码写到了一起。究其根因，那是「分离关注点」没有做好。每次增加一点点，是另外一个让代码变长的原因，应对它的主要办法就是要坚守「童子军军规」，但其背后更深层次的支撑就是要对坏味道有着深刻的认识。如果今天的内容你只能记住一件事，那请记住：把函数写短，越短越好。

### 4.0

这一讲，我们来讲一个你一定深恶痛绝的坏味道：长函数。有一个关于程序员的段子，说程序员一定要用大屏显示器，而且一定要竖起来用，这样才能看到一个函数的全貌。这显然是在调侃函数很长，小屏甚至横屏都不足以看到整个函数，只有竖起来才行。

只要一提到长函数，无论是去被迫理解一个长函数的含义，还是要在一个长函数中，小心翼翼地找出需要的逻辑，按照需求微调一下，几乎所有程序员都会有不愉悦的回忆。可以这么说，没有人喜欢长函数，但在实际工作中，却不得不去与各种长函数打交道。

不知道你在实际工作中遇到最长的函数有多长，几百上千行的函数肯定是不足以称霸的。在我的职业生涯中，经常是我以为自己够见多识广了，但只要新接触到一个有悠久历史的代码库，就总会有突破认知的长函数出现。长函数是一个「我一说，你就知道怎么回事」的坏味道，我就不准备用一个典型的长函数来开启这一讲了，否则，这一讲的篇幅都不够了。但是，为了统一认识，我准备先讨论一下多长的函数算是长函数，我们来看一个案例。

### 4.1 多长的函数才算「长」？

有一次，我在一个团队做分享，讲怎么把一个长函数重构成小函数。现场演示之后，我问了大家一个问题：在你心目中，多长的函数才算长呢？一个现场听众很认真地思考了一下，给出了一个答案：100 行。我很尴尬地看了一下自己刚刚重构掉的两个函数，最长的一个都不到 100 行。换言之，以他的标准来看，这个函数根本就不是长函数，根本就没有必要重构。

对于函数长度容忍度高，这是导致长函数产生的关键点。如果一个人认为 100 行代码不算长，那在他眼中，很多代码根本就是没有问题的，也就更谈不上看到更多问题了，这其实是一个观察尺度的问题。这就好比，没有电子显微镜之前，人们很难理解疾病的原理，因为看不到病毒，就不可能理解病毒可以致病这个道理。

一个好的程序员面对代码库时要有不同尺度的观察能力，看设计时，要能够高屋建瓴，看代码时，要能细致入微。

这里的要点就是，看具体代码时，一定要能够看到细微之处。我在《10x 程序员工作法》专栏中讲到过「任务分解」，关键点就是将任务拆解得越小越好，这个观点对代码同样适用。随着对代码长度容忍度的降低，对代码细节的感知力就会逐渐提升，你才能看到那些原本所谓细枝末节的地方隐藏的各种问题。

回到具体的工作中，「越小越好」是一个追求的目标，不过，没有一个具体的数字，就没办法约束所有人的行为。所以，通常情况下，我们还是要定义出一个代码行数的上限，以保证所有人都可以按照这个标准执行。

我自己写代码的习惯是这样的。像 Python、Ruby 这样表达能力比较强的动态语言，大多数情况下，一行代码（one-liner program）可以解决很多问题，所以，我对自己的要求大约是 5 行左右，并且能够用一行代码解决的问题，就尽量会用一行代码解决；而像 Java 这样表达能力稍弱的静态类型语言，我也争取在 10 行代码之内解决问题。

当然，这是我对自己的要求，在实际的项目中，可能不是每个人都能做到这一点，所以，我给了一个更为宽松的限制，在自己的标准上翻了番，也就是 20 行。这不是一个说说就算的标准，我们应该把它变成一个可执行的标准。比如，在 Java 中，我们就可以把代码行的约束加到 CheckStyle 的配置文件中，就像下面这样：

```java
<module name="MethodLength">
    <property name="tokens" value="METHOD_DEF"/>
    <property name="max" value="20"/>
    <property name="countEmpty" value="false"/>
</module>
```

这样，在我们提交代码之前，执行本地的构建脚本，就可以把长函数检测出来（关于 CheckStyle，我在《10x 程序员工作法》中讲项目自动化时专门做过介绍，你有兴趣不妨了解一下）。如果你用的是其它的程序设计语言，不妨也找一下相应的静态检查工具，看看是否提供类似的配置。

我知道，即便是以 20 行为上限，这也已经超过很多人的认知，具体的函数行数可以结合团队的实际情况来制定，但是，我非常不建议把这个数字放得很大，就像我前面说的那样，如果你放到 100 行，这个数字基本上是没有太多意义的，对团队也起不到什么约束作用。

我之所以要先讨论多长的函数算是长函数，是因为如果你不能认识到代码行的标准应该很低，那么在接下来的讨论中，有些代码示例可能在你看来，就根本不需要调整了。

### 4.2 长函数的产生

不过，限制函数长度，是一种简单粗暴的解决方案。最重要的是你要知道，长函数本身是一个结果，如果不理解长函数产生的原因，还是很难写出整洁的代码。接下来，我们就来看看长函数是怎么产生的。

#### 4.2.1 以性能为由

人们写长函数的历史由来已久。在《软件设计之美》专栏里，我讲过程序设计语言的发展历史。像 C 语言这种在今天已经是高性能的程序设计语言，在问世之初，也曾被人质疑性能不彰，尤其是函数调用。

在一些写汇编语言的人看来，调用函数涉及到入栈出栈的过程，显然不如直接执行来得性能高。这种想法经过各种演变流传到今天，任何一门新语言出现，还是会以同样的理由被质疑。所以，在很多人看来，把函数写长是为了所谓性能。不过，这个观点在今天是站不住的。性能优化不应该是写代码的第一考量。

一方面，一门有活力的程序设计语言本身是不断优化的，无论是编译器，还是运行时，性能都会越来越好；另一方面，可维护性比性能优化要优先考虑，当性能不足以满足需要时，我们再来做相应的测量，找到焦点，进行特定的优化。这比在写代码时就考虑所谓性能要更能锁定焦点，优化才是有意义的。

#### 4.2.2 平铺直叙

除了以性能为由把代码写长，还有一种最常见的原因也会把代码写长，那就是写代码平铺直叙，把自己想到的一点点罗列出来。比如下面这段代码（如果你不想仔细阅读，可以直接跳到后面）：

```java
public void executeTask() {
    ObjectMapper mapper = new ObjectMapper();
    CloseableHttpClient client = HttpClients.createDefault();
    List<Chapter> chapters = this.chapterService.getUntranslatedChapters();
    for (Chapter chapter : chapters) {
        // Send Chapter
        SendChapterRequest sendChapterRequest = new SendChapterRequest();
        sendChapterRequest.setTitle(chapter.getTitle());
        sendChapterRequest.setContent(chapter.getContent());


        HttpPost sendChapterPost = new HttpPost(sendChapterUrl);
        CloseableHttpResponse sendChapterHttpResponse = null;
        String chapterId = null;
        try {
            String sendChapterRequestText = mapper.writeValueAsString(sendChapterRequest);
            sendChapterPost.setEntity(new StringEntity(sendChapterRequestText));
            sendChapterHttpResponse = client.execute(sendChapterPost);
            HttpEntity sendChapterEntity = sendChapterPost.getEntity();
            SendChapterResponse sendChapterResponse = mapper.readValue(sendChapterEntity.getContent(), SendChapterResponse.class);
            chapterId = sendChapterResponse.getChapterId();
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                if (sendChapterHttpResponse != null) {
                    sendChapterHttpResponse.close();
                }
            } catch (IOException e) {
                // ignore
            }
        }


        // Translate Chapter
        HttpPost translateChapterPost = new HttpPost(translateChapterUrl);
        CloseableHttpResponse translateChapterHttpResponse = null;
        try {
            TranslateChapterRequest translateChapterRequest = new TranslateChapterRequest();
            translateChapterRequest.setChapterId(chapterId);
            String translateChapterRequestText = mapper.writeValueAsString(translateChapterRequest);
            translateChapterPost.setEntity(new StringEntity(translateChapterRequestText));
            translateChapterHttpResponse = client.execute(translateChapterPost);
            HttpEntity translateChapterEntity = translateChapterHttpResponse.getEntity();
            TranslateChapterResponse translateChapterResponse = mapper.readValue(translateChapterEntity.getContent(), TranslateChapterResponse.class);
            if (!translateChapterResponse.isSuccess()) {
                logger.warn("Fail to start translate: {}", chapterId);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if (translateChapterHttpResponse != null) {
                try {
                    translateChapterHttpResponse.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }
    }
```

这段代码的逻辑是，把没有翻译过的章节发到翻译引擎，然后，启动翻译过程。在这里翻译引擎是另外一个服务，需要通过 HTTP 的形式向它发送请求。相对而言，这段代码还算直白，当你知道了我上面所说的逻辑，你是很容易看懂这段代码的。

这段代码之所以很长，主要原因就是把前面所说的逻辑全部平铺直叙地摆在那里了，这里既有业务处理的逻辑，比如，把章节发送给翻译引擎，然后，启动翻译过程；又有处理的细节，比如，把对象转成 JSON，然后，通过 HTTP 客户端发送出去。

从这段代码中，我们可以看到平铺直叙的代码存在的两个典型问题：1）把多个业务处理流程放在一个函数里实现；2）把不同层面的细节放到一个函数里实现。

这里发送章节和启动翻译是两个过程，显然，这是可以放到两个不同的函数中去实现的，所以，我们只要做一下提取函数，就可以把这个看似庞大的函数拆开，而拆出来的几个函数规模都会小很多，像下面这样：

```java
public void executeTask() {
    ObjectMapper mapper = new ObjectMapper();
    CloseableHttpClient client = HttpClients.createDefault();
    List<Chapter> chapters = this.chapterService.getUntranslatedChapters();
    for (Chapter chapter : chapters) {
        String chapterId = sendChapter(mapper, client, chapter);
        translateChapter(mapper, client, chapterId);
    }
}
```

拆出来的部分，实际上就是把对象打包发送的过程，我们以发送章节为例，先来看拆出来的发送章节部分：

```java
private String sendChapter(final ObjectMapper mapper,
                           final CloseableHttpClient client,
                           final Chapter chapter) {
    SendChapterRequest request = asSendChapterRequest(chapter);


    CloseableHttpResponse response = null;
    String chapterId = null;
    try {
        HttpPost post = sendChapterRequest(mapper, request);
        response = client.execute(post);
        chapterId = asChapterId(mapper, post);
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        try {
            if (response != null) {
                response.close();
            }
        } catch (IOException e) {
            // ignore
        }
    }
    return chapterId;
}


private HttpPost sendChapterRequest(final ObjectMapper mapper, final SendChapterRequest sendChapterRequest) throws JsonProcessingException, UnsupportedEncodingException {
    HttpPost post = new HttpPost(sendChapterUrl);
    String requestText = mapper.writeValueAsString(sendChapterRequest);
    post.setEntity(new StringEntity(requestText));
    return post;
}


private String asChapterId(final ObjectMapper mapper, final HttpPost sendChapterPost) throws IOException {
    String chapterId;
    HttpEntity entity = sendChapterPost.getEntity();
    SendChapterResponse response = mapper.readValue(entity.getContent(), SendChapterResponse.class);
    chapterId = response.getChapterId();
    return chapterId;
}


private SendChapterRequest asSendChapterRequest(final Chapter chapter) {
    SendChapterRequest request = new SendChapterRequest();
    request.setTitle(chapter.getTitle());
    request.setContent(chapter.getContent());
    return request
```

当然，这个代码还算不上已经处理得很整洁了，但至少同之前相比，已经简洁了一些。我们只用了最简单的提取函数这个重构手法，就把一个大函数拆分成了若干的小函数。

顺便说一下，长函数往往还隐含着一个命名问题。如果你看修改后的 sendChapter，其中的变量命名明显比之前要短，理解的成本也相应地会降低。因为变量都是在这个短小的上下文里，也就不会产生那么多的命名冲突，变量名当然就可以写短一些。

平铺直叙的代码，一个关键点就是没有把不同的东西分解出来。如果我们用设计的眼光衡量这段代码，这就是「分离关注点」没有做好，把不同层面的东西混在了一起，既有不同业务混在一起，也有不同层次的处理混在了一起。我在《软件设计之美》专栏中，也曾说过，关注点越多越好，粒度越小越好。

#### 4.2.3 一次加一点

有时，一段代码一开始的时候并不长，就像下面这段代码，它根据返回的错误进行相应地错误处理：

```java
if (code == 400 || code == 401) {
  // 做一些错误处理
}
```

然后，新的需求来了，增加了新的错误码，它就变成了这个样子：

```java
if (code == 400 || code == 401 || code == 402) {
  // 做一些错误处理
}
```

你知道，一个有生命力的项目经常会延续很长时间，于是，这段代码有很多次被修改的机会，日积月累，它就成了让人不忍直视的代码，比如：

```java
if (code == 400 || code == 401 || code == 402 || ...
  || code == 500 || ...
  || ...
  || code == 10000 || ...) {
  // 做一些错误处理
}
```

后来人看到这段代码就想骂人了。当他从版本控制的历史中找到这些代码的作者，去询问这些处理的来龙去脉时，每个人其实都很委屈，他们当时也没做太多，只是加了一个判断条件而已。任何代码都经不起这种无意识的累积，每个人都没做错，但最终的结果很糟糕。对抗这种逐渐糟糕腐坏的代码，我们需要知道「童子军军规」：

让营地比你来时更干净。—— 童子军军规

Robert Martin 把它借鉴到了编程领域，简言之，我们应该看看自己对于代码的改动是不是让原有的代码变得更糟糕了，如果是，那就改进它。但这一切的前提是，你要能看出自己的代码是不是让原有的代码变得糟糕了，所以，学习代码的坏味道还是很有必要的。

至此，我们看到了代码变长的几种常见原因：1）以性能为由；2）平铺直叙；3）一次加一点。

你会发现，代码变长根本是一个无意识的问题，写代码的人没有觉得自己把代码破坏了。但只要你认识到长函数是一个坏味道，后面的许多问题就自然而然地会被发掘出来，至于解决方案，你已经看到了，大部分情况下，就是拆分成各种小函数。

### 黑板墙

思考题：你在实际的工作中遇到过长函数吗？讲讲你和长函数斗争的故事，欢迎在留言区写下你的经历。如果你身边有人正在为「长函数」苦恼，也欢迎你把这节课分享给他。

举个场景。创建商品聚合实体的场景：1）查找商品，校验商品是否存在。2）查找店铺，校验店铺是否存在，获取店铺 code。3）用商品和店铺查找合作关系。4）用合作关协查找合同，验证合同合法。以上只是举例，实际场景可能还会有 5，6，7，8，9。而这个场景的特点：每个环节的执行依赖上个环节的回参作为输入，以至于只能平铺（哪怕每个环节都提炼成 1 行函数调用）而没办法拆分开去封装。而一旦平铺，行数超过 10-20 就很容易。像这种场景，郑老师怎么看。可以进一步拆分的话该如何拆？作者回复：拆分是没有问题的，但拆分出来的每一个步骤，都应该是一个独立的函数，然后，在大的函数中将它们聚合起来。2021-01-07

把一个开发人员从习惯写长函数培养到会写短函数大概需要多少时间和成本？作者回复：看要求了，我在代码检查里加限制，新来的同学立刻就能学会。2021-01-08

在代码库里看到很多这样平铺直叙的代码，类似这样。

```
if 旧账号存在
删除旧账号的所有权限
if 删除成功
将新管理员身份设置为管理员
将旧管理身份设置为普通员工
if 设置成功
为新管理员添加管理员权限
if 权限设置成功
修改企业账号为新管理员账号
if 修改成功
修改 redis 缓存
```

这个方法的逻辑是，转移管理员账号给一个新的管理员，这个方法大约 80 行的样子。分析了一下，大家这样写的原因：1）成员都是自己野蛮生长起来的，没有见过好的范例；2）团队里没有成型的规范，即使有也没有人坚持，代码随便写，只要功能实现了就行。

像上面这样只要把各种情况顺序写进去就行了，比较简单，不用考虑太多。可这样带来的问题就是，后面维护起来就要花很大精力把逻辑搞清楚才能下手去修改。另外，像上面那样，如果中间某一步执行失败，整个方法就失败，但是前面几步的操作却不能回滚。

对这段代码的优化，可以抽取出几个小方法，如：修改新旧管理员身份，删除旧账号权限，为新管理员赋值权限，修改企业账号，修改缓存等，使代码更容易阅读。另外，可以借鉴 Rails 中 ActiveRecord::Callbacks 的封装方式使代码看上去更简洁。上面方法是 Java 的一段代码，对 Java 不是很熟，不知道 Java 相关的框架中是否有类似于 Rails 的 Callbacks 封装。

作者回复：你的分析思路是对的，把一步一步拆分开来。Java 有各种 AOP，有兴趣可以看一下。2021-01-10

前人留下的一个类 6000 多行代码，函数没有几个，想改却改不动，改完后，别人提交之后就产生冲突，解决冲突后，别人又提交，又冲突。只改一点点，CI 过不了，一周下来，没啥产出。作者回复：小步修改，小步提交。2021-01-08

「因为变量都是在这个短小的上下文里，也就不会产生那么多的命名冲突，变量名当然就可以写短一些。」这句话真的很有启发。之前还和同事在争论，变量名太长的问题。他们说「we love long variable names, because it is very self-explanatory」。我现在可以跟他们说问题在与函数写得太长。作者回复：是的，变量名字长可能就是函数长的结果。2021-01-07

请问一下老师，遇到 JDBC 读取 resultset 或者 set 一个 prepared statement 而列又很多时应该怎么简化？往往轻轻松松就几时行了… 有什么精简优雅的缩短方法吗？作者回复：难道不是用框架吗？这年头为啥要用裸的 JDBC 呢？2021-01-19

我见过 10 万行的类，上万行的长函数。这些都是在工业软件中，由非计算机专业的人开发的代码。作者回复：代码行书没有上限，写的人就没有底线。2021-01-10

为啥是「关注点越多越好」？作者回复：对于大多数人的问题在于，能发现的关注点太少了，能观察到的侧面就太少，拆分的粒度远远不足。所以，尝试多发现一些问题，再来说怎么组合。2021-01-10

之前做项目时，确实经历过老师文中讲到的平铺直叙和一次加一点这种情况。回想了一下，出现这种情况的原因有以下几点：1）历史遗留问题，没有可参照的范例。2）无高手进行代码 review，项目组各种规范及工具使用不到位。3）自己的水平不够。前两点无法改变，第三点我可以改变，就是学了软件设计之美、设计模式之美等专栏后，培养了自己这方面的意识。另外就是关注了您的开源项目，能时不时去看看源码，赏心悦目，严格要求自己，哈哈。作者回复：改变自己能改变的，让自己成长为配得上更好团队的水准。2021-01-09

一次加一点这个，我有时候也在想这个。但是就是没人愿意主动去做这个事情。1）重构时间只能自己平时解决。2）重构造成的风险自己担责。3）往后面累加对自己来说是最安全的。每每想改变的时候，总是会考虑到这些因素。作者回复：坑未来的人，也许就是自己。其实重构现在都有工具了，几乎是无风险的，关键是意识。2021-01-08

对于长函数抽取出小函数也是一个技术活。作者回复：抽取的动作只是一个快捷键的事，抽取的意识需要培养。2021-01-08

如果函数里面的行写得很长呢？还应不应该插入换行？如果插入换行的话就会增加行数，如果不差入换行，在看代码时就要经常移动水平滚动条。作者回复：按代码行而非物理行计数你就不纠结了。2021-01-07

从编写单元测试角度来看，1）一个长函数的测试需要 Mock 一堆依赖；2）长函数一定会有很多的条件分支，会加大我们的认知复杂度，代码会很难读，从而你的单元测试也会很难写，即使覆盖每一个条件分支，当业务逻辑的变更时，你可能代码只改了一行，你的所有的测试都会飘红，这是测试可能会让你难以维护。在 10x 中郑大说过，把测试写简单，简单到一目了然，不需要证明它的正确性，那其实我们的函数也是一样，我的方法也应该尽可能的小，保证每个方法的单一职责，他只做一件事。作者回复：这个角度是没问题的，只是写测试的人太少了。2021-01-07

我理解函数的代码行数应该是函数的主逻辑，如果函数内嵌套了函数应该是可以不算在内的。作者回复：啥叫函数嵌套函数？提取出去就不是这个函数的一部分了。2021-01-07

一个函数长短与否，如果是偏好问题，其实无解。每个人的对于长短的偏好并不一样。有人喜欢短函数，可能是因为，看到大于一个屏幕的代码，就焦虑得不行，就担心自己看不懂。有人喜欢长函数，一个完整的业务在一个过程里，从头到尾读完，要改动就在这里改，有问题也就是这里的问题。说起性能，只要拿不出性能测定的手段，拿不出性能测定的数据，都是臆想成分居多，大概率只是为自己的偏好找借口。只要有性能测定的方法，只要有配套测试用例和自动化体系，可维护就是一个结果，代码怎么写、怎么改，都是由性能测定和测试系统来保障的。我遇到过不少人，喜欢短函数，这些人有个特点，都是急性子的人。我遇到过不少人，啥函数都能津津有味读下来，都是慢性子的人。作者回复：重点就是不能根据个人品味来，众口难调，一定要有一个统一的团队标准。2021-01-07

我理解老师说的一个函数的 5 行和 10 行是指函数体吧，应该不包含函数头（函数名）和函数尾（比如大括号），所以自己数的时候要记得减去。作者回复：用工具检查就好了，不用自己数。2021-01-07

函数不超过多少行时，别人会用一些有名的开源库来回你，这怎么办？作者回复：有名的开源程序库是以什么著称的，是代码写得好吗？当然不是了，所以，它们并不是好代码的代表。2021-01-14