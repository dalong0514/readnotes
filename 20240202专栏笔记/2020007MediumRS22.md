## 记忆时间

## 目录

20200501Understanding-Execution-Context-and-Execution-Stack-in-Javascript.md

20200502My-Top-5-Pandas-Data-Manipulation-Functions.md

20200502Putting-a-Laravel-app-into-production.md

20200503Web-Scraping-of-10-Online-Shops-with-Python-and-Scrapy.md

20200503nine-JavaScript-Interview-Questions.md

20200526Presentational-and-Container-Components.md

## 20200501Understanding-Execution-Context-and-Execution-Stack-in-Javascript.md

2『 [Sukhjinder Arora – Bits and Pieces](https://blog.bitsrc.io/@Sukhjinder)，作者的博客是个宝藏，深挖。』

If you are or want to be a JavaScript developer, then you must know how the JavaScript programs are executed internally. The understanding of execution context and execution stack is vital in order to understand other JavaScript concepts such as Hoisting, Scope, and Closures. Properly understanding the concept of execution context and execution stack will make you a much better JavaScript developer.

Tip: Use Bit to build JS apps faster with components. It helps you share and reuse components with your team, using them to build new apps! Give it a try.

3『 [The shared component cloud · Bit](https://bit.dev/) 』

### 01. What is an Execution Context?

Simply put, an execution context is an abstract concept of an environment where the Javascript code is evaluated and executed. Whenever any code is run in JavaScript, it’s run inside an execution context.

Types of Execution Context. There are three types of execution context in JavaScript.

1 Global Execution Context — This is the default or base execution context. The code that is not inside any function is in the global execution context. It performs two things: it creates a global object which is a window object (in the case of browsers) and sets the value of this to equal to the global object. There can only be one global execution context in a program.

2 Functional Execution Context — Every time a function is invoked, a brand new execution context is created for that function. Each function has its own execution context, but it’s created when the function is invoked or called. There can be any number of function execution contexts. Whenever a new execution context is created, it goes through a series of steps in a defined order which I will discuss later in this article.

3 Eval Function Execution Context — Code executed inside an eval function also gets its own execution context, but as eval isn’t usually used by JavaScript developers, so I will not discuss it here.

### 02. Execution Stack

Execution stack, also known as「calling stack」in other programming languages, is a stack with a LIFO (Last in, First out) structure, which is used to store all the execution context created during the code execution. When the JavaScript engine first encounters your script, it creates a global execution context and pushes it to the current execution stack. Whenever the engine finds a function invocation, it creates a new execution context for that function and pushes it to the top of the stack.

1『执行上下文也是一个「对象」实体，call stack 里的基本单元就是这些执行上下文对象；时常画一画那个 JS 系列文章里第一篇的架构图；』

The engine executes the function whose execution context is at the top of the stack. When this function completes, its execution stack is popped off from the stack, and the control reaches to the context below it in the current stack. Let’s understand this with a code example below:

```js
let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
console.log('Inside Global Execution Context');
```

When the above code loads in the browser, the Javascript engine creates a global execution context and pushes it to the current execution stack. When a call to first() is encountered, the Javascript engines creates a new execution context for that function and pushes it to the top of the current execution stack.

When the second() function is called from within the first() function, the Javascript engine creates a new execution context for that function and pushes it to the top of the current execution stack. When the second() function finishes, its execution context is popped off from the current stack, and the control reaches to the execution context below it, that is the first() function execution context.

When the first() finishes, its execution stack is removed from the stack and control reaches to the global execution context. Once all the code is executed, the JavaScript engine removes the global execution context from the current stack.

### 03. How is the Execution Context created?

Up until now, we have seen how the JavaScript engine manages the execution context, Now let’s understand how an execution context is created by the JavaScript engine. The execution context is created in two phases: 1) Creation Phase and 2) Execution Phase.

1『 JS 里代码的执行，脑子里时刻要有创建阶段和执行阶段这两个概念，变量声明在创建阶段就动起来了，执行阶段的时候才真正赋值，这两个阶段的分离有助于理解「提升」的概念。』

### 04. The Creation Phase

The execution context is created during the creation phase. Following things happen during the creation phase: 1) Lexical Environment component is created. 2) Variable Environment component is created. So the execution context can be conceptually represented as follows:

```js
ExecutionContext = {
  LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
  VariableEnvironment = <ref. to VariableEnvironment in  memory>,
}
```

#### 4.1 Lexical Environment

The official ES6 docs define Lexical Environment as:

A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.

3『 [ECMAScript 2015 Language Specification – ECMA-262 6th Edition](http://ecma-international.org/ecma-262/6.0/) 』

Simply put, A lexical environment is a structure that holds identifier-variable mapping. (here identifier refers to the name of variables/functions, and the variable is the reference to actual object [including function object and array object] or primitive value).

For example, consider the following snippet:

```js
var a = 20;
var b = 40;
function foo() {
  console.log('bar');
}
```

So the lexical environment for the above snippet looks like this:

```js
lexicalEnvironment = {
  a: 20,
  b: 40,
  foo: <ref. to foo function>
}
```

Each Lexical Environment has three components: 1) Environment Record. 2) Reference to the outer environment. 3) This binding.

Environment Record. The environment record is the place where the variable and function declarations are stored inside the lexical environment. There are also two types of environment record :

1 Declarative environment record — As its name suggests stores variable and function declarations. The lexical environment for function code contains a declarative environment record.

2 Object environment record — The lexical environment for global code contains a objective environment record. Apart from variable and function declarations, the object environment record also stores a global binding object (window object in browsers). So for each of binding object’s property (in case of browsers, it contains properties and methods provided by browser to the window object), a new entry is created in the record.

Note — For the function code, the environment record also contains an arguments object that contains the mapping between indexes and arguments passed to the function and the length(number) of the arguments passed into the function. For example, an argument object for the below function looks like this:

```js
function foo(a, b) {
  var c = a + b;
}
foo(2, 3);
// argument object
Arguments: {0: 2, 1: 3, length: 2},
```

Reference to the Outer Environment. The reference to the outer environment means it has access to its outer lexical environment. That means that the JavaScript engine can look for variables inside the outer environment if they are not found in the current lexical environment.

1『闭包的概念。』

This Binding. In this component, the value of this is determined or set. 

1 In the global execution context, the value of this refers to the global object. (in browsers, this refers to the Window Object).

2 In the function execution context, the value of this depends on how the function is called. If it is called by an object reference, then the value of this is set to that object, otherwise, the value of this is set to the global object or undefined(in strict mode). For example:

1『 this 值的绑定分 2 种情况，在全局执行上下文里绑定什么（全局变量，浏览器里即对象 window），在函数执行上下文里绑定什么（取决于函数调用的方式，又可以分为 2 大类，被一个对象引用调用的话绑定到该对象上，否则绑定到全局对象或 undefined）。从这两个维度来看，一下子清晰很多；函数对象里的 this 绑定：1）直接调用，其绑定到全局对象 window，在严格模式下绑定到 undefined。2）作为某个对象的方法被调用（提取），其绑定到该对象上；3）通过 new 调用构造函数构建新对象，其绑定到这个新对象上。4）通过 call/apply 方法调用，其绑定到 call/apply 方法指定的对象上，指定的对象是作为参数传入 call/apply 方法里的。』

```js
const person = {
  name: 'peter',
  birthYear: 1994,
  calcAge: function() {
    console.log(2018 - this.birthYear);
  }
}
person.calcAge(); 
// 'this' refers to 'person', because 'calcAge' was called with 'person' object reference
const calculateAge = person.calcAge;
calculateAge();
// 'this' refers to the global window object, because no object reference was given
```

Abstractly, the lexical environment looks like this in pseudocode:

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
    }
    outer: <null>,
    this: <global object>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
    }
    outer: <Global or outer function environment reference>,
    this: <depends on how function is called>
  }
}
```

#### 4.2 Variable Environment

It’s also a Lexical Environment whose EnvironmentRecord holds bindings created by VariableStatements within this execution context. As written above, the variable environment is also a lexical environment, So it has all the properties and components of a lexical environment as defined above.

In ES6, one difference between LexicalEnvironment component and the VariableEnvironment component is that the former is used to store function declaration and variable (let and const) bindings, while the latter is used to store the variable (var) bindings only.

### 05. Execution Phase

In this phase assignments to all those variables are done and the code is finally executed.

### 06. Example

Let’s look at some example to understand the above concepts:

```js
let a = 20;
const b = 30;
var c;
function multiply(e, f) {
 var g = 20;
 return e * f * g;
}
c = multiply(20, 30);
```

When the above code is executed, the JavaScript engine creates a global execution context to execute the global code. So the global execution context will look something like this during the creation phase:

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

1『之前没注意，var 声明是单独创建了一个「变量环境」，跟「词法环境」是同一个 level 的。（2020-08-27）』

During the execution phase, the variable assignments are done. So the global execution context will look something like this during the execution phase.

```js
GlobalExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: 20,
      b: 30,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

When a call to function multiply(20, 30) is encountered, a new function execution context is created to execute the function code. So the function execution context will look something like this during the creation phase:

```js
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

After this, the execution context goes through the execution phase that means assignments to the variables inside the function are done. So the function execution context will look something like this during the execution phase:

```js
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: 20
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

After the function completes, the returned value is stored inside c. So the global lexical environment is updated. After that, the global code completes and the program finishes.

Note — As you might have noticed that the let and const defined variables do not have any value associated with them during the creation phase, but var defined variables are set to undefined. 

This is because, during the creation phase, the code is scanned for variable and function declarations, while the function declaration is stored in its entirety in the environment, the variables are initially set to undefined (in case of var) or remain uninitialized (in case of let and const). This is the reason why you can access var defined variables before they are declared (though undefined) but get a reference error when accessing let and const variables before they are declared. This is, what we call hoisting.

Note — During the execution phase, if the JavaScript engine couldn’t find the value of let variable at the actual place it was declared in the source code, then it will assign it the value of undefined.

1『对「提升」改理解加深了很多很多。在执行环境的创建阶段，代码里的变量声明和函数声明会被扫描，其中函数声明会被整体存入到环境里，变量声明这边分 2 种情况：var 声明的变量会被直接赋值（没赋值的话指定为 undefined），而 let、const 声明的变量在此阶段不会被赋值（执行阶段才会赋值）。这就可以解释提升为啥只对 var 变量和函数有效，在执行阶段里，因为前面的创建阶段这 2 个东西已经被存入环境里了，在声明语句之前就可以用执行语句操作，但是 let、const 声明的变量在前面没赋值过，当然报错，所以 let、const 声明的变量必须要在其执行语句之前。』

## 20200502My-Top-5-Pandas-Data-Manipulation-Functions.md

Note that the DataFrame and Series function would be used even before the data manipulation function is applied, so I would not explain those functions. Here are 5 Pandas functions that I frequently use in my daily work.

### 01. crosstab

crosstab is a pandas function to compute a cross-tabulation of two (or more) factors. If you did not what is cross-tabulation is, let me show you with an example.

```py
pd.crosstab(index = mpg['origin'], columns = mpg['model_year'])
```

two-factors cross-tabulation example

Above is an example of what is cross-tabulation is. The data itself is still a DataFrame object. We specify the index and the columns of the table from the category variables of our dataset; in my case, I use the ‘origin’ and the ‘model\_year’ category variables. By default, the crosstab function would compute a frequency of the factors and show it on the cross-tabulation. Although, we could change it by introducing another factor, which often is a continuous variable.

```py
pd.crosstab(index = mpg['origin'], columns = mpg['model_year'], values = mpg['mpg'], aggfunc = 'mean')
```

cross-tabulation with the continuous variable as another factor

Above, if we add the ‘mpg’ variable into the values and set the aggfunc parameter as ‘mean’ we would get cross-tabulation with mean of the ‘mpg’ separated by the category. It is similar to what we called the pivot table Pandas function pivot\_table could achieve similar results.

### 02. cut

Pandas cut function is used to binning the continuous values into discrete intervals. We use cut when we need to segment and sort continuous values into bins. For you who did not know what binning is; it is a process of putting the continuous value into a certain range interval. It is best described by using the histogram plot.

```py
mpg['mpg'].hist()
```

Example of the histogram plot

Here we input the continuous values into a certain range interval and create bins. Each bar shows the values that fall into those intervals, with the higher the bar is the bigger the frequency is.

The range interval depends on the number of bins. For example, if we have a continuous variable with a minimum value 10 and maximum value 45 and we want to create 10 bins then the range interval would be (max-min)/bins. Which means (45–10)/10 = 3.5. So the first bin would be filled by the continuous value that was present between 10 to 13.5 and so on.

This function is also useful for going from a continuous variable to a categorical variable. For example, the cut function could convert ages to groups of age ranges. Let’s show this function with a dataset example.

```py
pd.cut(x = mpg['mpg'], bins = 4, labels = [1,2,3,4])
```

In the function above, I set the bins parameter to 4 because I want to get 4 categories with the labels is set as 1,2,3, and 4. The output from the cut function would be a series with all the continuous values that have been binned and converted into the respectable category. Here is how it looks like if I put it into the data frame.

```py
mpg['mpg_bin'] = pd.cut(x = mpg['mpg'], bins = 4, labels = [1,2,3,4])
mpg[['mpg', 'mpg_bin']]
```

### 03. qcut

In pandas, we have cut function and we also have a qcut function. Similar to the cut function, we would be binning the continuous variable, but in qcut function, the bin size would be equal-sized based on rank or based on sample quantile. Quantile is basically a division technique to divide the continuous value in an equal way. For example, if we divide the continuous value into 4 parts; it would be called Quartile as shown below.

Let me show you as well with a code example.

```py
pd.qcut(x = mpg['mpg'], q = 4, labels = [1,2,3,4])
```

Above is the output of qcut function. Here I input the q parameter as 4 to divide the continuous value into Quartile and label them with 1,2,3, and 4. The result is different compared to the cut function because their calculation is already different. Let me put it as well into the DataFrame so we could see the result differences.

```py
mpg['mpg_qcut'] = pd.qcut(x = mpg['mpg'], q = 4, labels = [1,2,3,4])
mpg[['mpg', 'mpg_bin','mpg_qcut']]
```

### 04. get\_dummies

This function is used to convert the categorical variable into a numerical variable by One-Hot-Encode the categorical variable. For you who did not know what it One-Hot-Encode, it is a process to create a new column from our categorical variable where each category becomes a new column with the value are either 0 or 1 (0 represent not-present and 1 represents present).

Why do we want to convert the categorical variable into a numerical variable? It is because many of the statistical technique or machine learning equation only accepting numerical value instead of categorical value. Let me show you what I talk about with a code example.

Above is the ‘origin’ variable from the mpg dataset. It is a categorical variable with 3 cardinal (‘usa’, ‘europe’, and ‘japan’). Here I would use the get\_dummies function to One-Hot-Encode this variable.

```py
origin_dummies = pd.get_dummies(mpg['origin'])
origin_dummies
```

Just like that, we already get 3 new columns with each category become a new column and the value is either 0 or 1.

### 05. concat

My most often pandas function for data manipulation is concat function. This function is like what it called; it concatenates. Although, what did this function concatenate? It concatenates between pandas object (Series or DataFrame). Here, let me show you an example. Let’s say I just want the ‘mpg’ columns shown with the origin\_dummies variable I just created previously.

```py
pd.concat(objs = [mpg['mpg'], origin_dummies], axis = 1)
```

Using the concat function, I just combine 2 pandas object (Series and DataFrame) into 1 data frame. In the function, I specify the axis parameter as 1 because I want to combine the Pandas object so the columns look like glued side to side. This axis parameter only accepts 2 things; 0 or 1. Depend on how you want to concatenate the Pandas object, set it to 0 if you want to concat the pandas object like stacking the object (concat the object like adding new rows) in respect to the columns or 1 if you want the object side to side with respect to the index. Here is what happens if we set the axis into 0.

```py
pd.concat([mpg['mpg'], origin_dummies], axis = 0)
```

2『合并 dataframe，去研究下与 merge 函数有啥区别。』

We could see now that we have 796 rows and a lot of NaN objects in our data frame. It happens because we concatenate the Pandas object but as we set it so we stacked the object, not all the columns name are present in either object so it filled the columns which are not previously present with a NaN value.

## 20200502Putting-a-Laravel-app-into-production.md

When tinkering around with Laravel you usually won’t think about some practical considerations you should watch out for, when developing an application that will go live one day. I recently put a Laravel-written web application into production and I wish there was an article like this one that tells me about things I should do or use to make my life much easier.

Also — I’ve recently started a whole「Laravel in production」series. It starts off with an article about Laravel’s built-in rate limiting features and why you should consider putting the rate limiting on the edge of your web-server stack (e.g. at your load balancer).

3『

[Laravel Rate Limiting in Production - The Startup - Medium](https://medium.com/swlh/laravel-rate-limiting-in-production-926c4d581886)

[Tobias – Medium](https://medium.com/@tobiashn)

』

### Conclusion

These were my experiences and tipps I wanted to share with you regarding the task of putting a Laravel application into production. Here is the summary for the busy readers: 1) Use Version Control (e.g. Git) and CI/CD (e.g. GitLab & Docker) for automated testing and deployment. 2) Make use of Laravel’s Envoy when it comes to SSH-based tasks that need to be executed in order to get your application running on your live servers. 3) Reduce database queries and use caching where applicable. 4) Execute Laravel’s and Composer’s built-in optimisation commands. 5) Use queues whenever it would take too long to send a respond to your user or if you want to keep track of failed/successful jobs out of the box. 6) Enable logging and have a look at the log files.

### 01. Continuous Integration & Deployment

You may have heard of those terms「Continuous Integration」and「Continuous Deployment」. Let me outline why this is going to speed up your deployment process up. When going live with your production-ready Laravel app you are (hopefully) utilising Laravel’s awesome testing functions to make sure everything works as expected. By writing unit and integration tests for your application you’ll raise your code’s quality and lower the risk of malfunctions or security leaks. So if you are not writing tests, yet — start right now.

#### 1. Running your tests automatically

Continuous Integration (CI) will take your code when you push it to your version control system ( → e.g Git) and will execute all your tests in a pre-defined build environment to make sure everything is working as expected, not only on your development machine but also in a clear production-alike environment.

Example: Running unit tests on GitLab’s CI platform.

I’m using GitLab’s free and open source Community Edition to build up my own code management infrastructure. It features a completely configurable CI/CD platform including runners that execute your build tasks on demand.

When pushing my code into the master branch, GitLab automatically triggers the CI process. In my case GitLab is using a Docker container to set up an environment that exactly fits the needs of the Laravel application and executes all tests within it.

You may not only execute phpunit tests but also run every other toolchain on your code that may detect errors or unwanted behavior. When the GitLab runner detects any kind of failure it will cancel the test progress and report the results back to you.

#### 2. Deployment

Laravel’s ecosystem provides a pretty useful tool called Envoy. You can easily composer require it into your project. All of its magic takes place in a Envoy.blade.php in your project root where you can define SSH-based tasks and command that shall be ran upon execution. So if you want to cache your routes after pulling the latest code changes from your code repository you can just add the corresponsing php artisan route:cache command into your Envoy runner file. When you execute envoy run \$taskName the specified task will be executed on your pre-defined servers via SSH and everything should be fine.

3『 [Envoy Task Runner - Laravel - The PHP Framework For Web Artisans](https://laravel.com/docs/5.6/envoy) 』

But: You may not want to manually execute this command each time there were changes in your code and you waited for the CI system to report that your latest push was fine. So I warmly recommend you to utilise the Continuous Deployment (CD) system of GitLab as well.

Example: Deploy your Laravel app using GitLab’s CD in just a few seconds.

There is a well written documentation how to automatically deploy your Laravel application into production using GitLab’s CI/CD I want to refer to at this point. But when I read it the first time I had a few struggles understanding what the Docker-part in this tutorial is doing in detail.

So here’s a short explaination how GitLab, Docker and Laravel’s Envoy are working together to put your code at your web server. When pushing new commits to GitLab, it will instruct a CI/CD runner to spin up a new Docker container that is defined by the Dockerfile in your project’s root. In here a PHP 7.1 basic image is used, some packages (like Git) are installed and composer is downloaded. So basically everything that Laravel requires is in there. You could now do anything you want with your Laravel application. In the first step phpunit and other toolchains are executed to test your latest code inside the Docker container. If this job is successful the Docker environment is teared down and will build up again when you trigger the production job. Again thanks to the Dockerfile there will be all packages present you’ll need to push your app into production using the Laravel Envoy Task Runner. It relies on PHP and on some basic Composer packages and will execute all commands you need to get the latest code on your server.

So basically Docker provides a neutral place to run your application’s tests and deployment scripts into an environment that provides every dependency that is required.

Here are some further practical considerations according to my experiences: 1) Make sure you execute all necessary artisan commands in your Envoy.blade.php (database migrations, caching, queue worker restart, etc.). 2) Double-check whether your deployment user has sufficient rights to write to your httpdocs directory at your web server. Many problems I had came from problems with the directory permissions. 3) Lock your application (put it into maintenance mode) if you are running database migrations to ensure that no database inconsistency occures.

### 02. Optimise your code

When developing locally you may not waste a thought on optimised code at first. And it practially won’t even matter in your local environment. But now think about the consequences when putting your application into production. Not only you but many users — maybe hundreds or thousands — will use your application. At the same time. Now you can just scale up your server infrastructure to handle all the concurrent requests or you could optimise your code to allow your code to be executed more often on less performant infrastructure. This could save you a lot of money.

#### 1. Reduce database queries

Queries are putting a lot of load on your database servers. First step to optimise your code would be to simply reduce the amount of database queries your application executes. Grab yourself the Laravel Debugbar (One of the most useful Laravel packages — developed by Barry vd. Heuvel) and check your data intensive pages for the amount of queries. You will probably be suprised how many similar queries are actually executed more than once. There are a many ways to minify this amount of queries down to one or two. I won’t spend time on explaining the exact process of doing so when there’s already an outstanding video tutorial about exactly this thematic by Laracasts. Make sure to check it out.

3『

[barryvdh/laravel-debugbar: Laravel Debugbar (Integrates PHP Debug Bar)](https://github.com/barryvdh/laravel-debugbar)

[Let's Build A Forum with Laravel and TDD: From 56 Queries Down to 2](https://laracasts.com/series/lets-build-a-forum-with-laravel/episodes/20)

[Laracasts](https://laracasts.com/)

』

#### 2. Use caching

You also should consider the applicability of caching in your Laravel application. If you are developing a forum application where users can post threads in specific pre-defined channels you won’t need to fetch the channels out of database on every single page view. Just load it once and store it in Redis or Memcached until the administrator adds new ones. It’s so easy with Laravel and will save you a lot of queries and database server load.

#### 3. Use Laravel’s built-in code optimizers

Laravel provides a few artisan code-optimizing commands you should use. Just put them into your Envoy.blade.php to make sure they are executed every time you are putting a new version of your application on your production servers.

Route Caching: php artisan route:cache

Config Caching: php artisan config:cache

Composer Autoloader Optimisation: composer install --optimize-autoloader

### 03. Queues

Sometimes I have the feeling that queue-able Jobs and Notifications are the most underrated features in Laravel. But in fact they are pretty awesome. Think about the following situation: Your customer is placing an order at your Laravel-based web shop and clicked on the「Buy now」button. What is your application going to do? Probably a hell of things, like for example: 1） Sending a confirmation e-mail to the customer. 2) Sending a notification to your Slack channel. 3) Adding the order to the database. (and much more)

But while you are doing all this, your user expects to be redirected to a「Order has been placed」-page. Now think about the worst case: The page is loading and loading as there are problems with your e-mail server and after lots of waiting your customer gets a HTTP Error 500 due to a TimeoutException of the mailer class in your application. This would be pretty bad for your shop’s reputation. But even if you look at the normal case where it would take a few seconds to get connected to your SMTP server or to the Slack API your user is waiting those seconds.

Laravel’s queue system is designed to get a response to the user as quick as possible and let background workers do the time intensive stuff. And on top Laravel’s Horizon, which is an official open source add-on package for your Laravel app, gives you insight view at your queues and successful and failed jobs.

3『 [Laravel Horizon - Laravel - The PHP Framework For Web Artisans](https://laravel.com/docs/5.6/horizon) 』

Keep track of your queues and jobs in Laravel Horizon’s handy metrics dashboard.

So when something’s wrong with your queues you can directly check for the exceptions that have been thrown by your implementation. No time is wasted and your user won’t see that there is some trouble ongoing behind the scenes. Some e-mails may be delayed but for the user everything is loading rapidly as usual. So definitely make use of those awesome Queueables.

### 04. Logging

One last short pointer for you: Shit happens. But when it does, make sure that it will be logged and you can reproduce the error to work on it. Turn on logging, log relevant events and exceptions and check back on errors. And don’t display technical stuff to the user. Users usually don’t want to see stuff like this and sometimes even sensitive information may be leaked.

## 20200503Web-Scraping-of-10-Online-Shops-with-Python-and-Scrapy.md

In this post, I will explain my workflow of generating such a dataset. You will see how I handle automated web scraping of many websites without any manual intervention. I aim to generate a dataset for a Price Comparision WebApp. The product category I will be using as an example is hand-bags. For such an application, product and price information of hand-bags should be collected from different online-sellers daily. Although some sellers provide an API for you to access the required information, not all of them follow the same route. So, web scrapping is inevitable!

Throughout this example, I will generate web spiders for 10 different sellers using Python and Scrapy. Then, I will automate the process with Apache Airflow so that there is no need for manual interventions to carry out the whole process periodically.

### 01. Source Code and Live Demo Web App

You can find all the related source code in my GitHub repository. You can also visit the live web app which uses the data supplied by this web scrapping project.

3『

[eisbilen/FashionSearch: Angular Front End with Python&AirFlow Data Pipeline](https://github.com/eisbilen/FashionSearch)

[TrendVar - Moda Arama Motoru](https://fashionsearch-2cab5.web.app/)

已 forked 源码存入「2020017FashionSearch」。

』

## 20200503nine-JavaScript-Interview-Questions.md

2『 [Bret Cameron – Medium](https://medium.com/@bretcameron)，发现作者写了很多高质量有关 JS 的文章，抽空整理。』

### PART I: CURVEBALL QUESTIONS

It would seem pretty tough if any of the following questions cropped up in an interview. Nevertheless, these questions should still prove useful in preparation: they reveal some interesting quirks of JavaScript and they highlight some of the decisions that have to be made when coming up with a programming language in the first place. For more quirky JavaScript features, I recommend checking out https://wtfjs.com.

2『 [wtfjs - a little code blog about that language we love despite giving us so much to hate](https://wtfjs.com/)，GitHub 地址：[brianleroux/wtfjs: wtfjs.com!](https://github.com/brianleroux/wtfjs)，内容去爬取下来。』

### 1. Why is Math.max() smaller than Math.min()?

The fact that Math.max() > Math.min() returns false sounds wrong, but it actually makes a lot of sense. If no arguments are given, Math.min() returns infinity and Math.max() returns -infinity. This is simply part of the specification for the max() and min() methods, but there is good logic behind the choice. To understand why, take a look at the following code:

```js
Math.min(1) 
// 1

Math.min(1, infinity)
// 1

Math.min(1, -infinity)
// -infinity
```

If -infinity was considered the default argument of Math.min() , then every result would be -infinity , which is pretty useless! Whereas, if the default argument is infinity , the addition of any other argument would return that number — and that’s the behaviour we want.

### 2. Why does 0.1 + 0.2 === 0.3 return false?

In short, it’s to do with how accurately JavaScript can store floats in binary. If you type the following equations into Google Chrome’s console, you’ll get:

```js
0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.2
// 0.10000000000000003

0.1 + 0.7
// 0.7999999999999999
```

This is unlikely to cause problems if you’re performing simple equations without the need for a high degree of accuracy. But it can cause headaches even in simple applications if you need to test for equality. There are a few solutions to this.

#### 2.1 Fixed Point

For example, if you know the maximum precision you’ll need (for example, if you’re dealing with currencies), you can integer type to store the value. So instead of \$4.99 , you could store 499 and perform any equations on that. You could then display the result to the end-user using an expression like result = (value / 100).toFixed(2) , which returns a string.

#### 2.2 Binary Coded Decimals

If precision is really important, another option is to use the Binary Coded Decimals (BCD) format, which you can access in JavaScript using this BCD library. Every decimal value is stored separately in a single byte (8 bits). This is inefficient, as a byte can store 16 separate values and this system only uses values 0–9. However, if precision is important for your application, it may be worth the trade-off.

### 3. Why Does 018 Minus 017 Equal 3?

The fact that 018 - 017 returns 3 is a result of silent type conversion. In this case, we’re talking about octal numbers.

#### 3.1 A Quick Introduction to Octal Numbers

You’re likely aware of the use of binary (base-2) and hexadecimal (base-16) number systems in computing, but octal (base-8 ) also has a prominent place in the history of computers: in the late 1950s and 1960s, it was used to abbreviate binary, cutting material costs in what were highly expensive systems to manufacture!

Hexadecimal came shortly afterwards: The IBM 360 [released in 1965] took the definitive step from octal to hexadecimal. To those of us accustomed to octal, we were shocked at the extravagance! — Vaughan Pratt

#### 3.2 Octal Numbers Today

But what’s octal useful for in modern programming languages? Octal has an advantage over hexadecimal for some use cases because it doesn’t require any non-numerical digits (using 0–7 rather than 0–F). One common use is in file permissions for Unix systems, where there are exactly eight permission variations:

```
   4 2 1
0  - - - no permissions
1  - - x only execute
2  - x - only write
3  - x x write and execute
4  x - - only read
5  x - x read and execute
6  x x - read and write
7  x x x read, write and execute
```

For similar reasons, It is also used for digital displays.

#### 3.3 Back to the Question

In JavaScript, the prefix 0 will convert any number to octal. However, 8 is not used in octal, and any number containing an 8 will be silently converted to a regular decimal number. Therefore, 018 - 017 is in fact equivalent to the decimal expression 18 - 15 , because 017 is octal but 018 is decimal.

### PART II: COMMON QUESTIONS

In this section, we’ll look at some of the more common JavaScript interview questions. These are the kind of things that are easy to overlook when you’re first learning JavaScript, but knowledge of them could prove really useful when it comes to writing the best possible code.

### 4. How Does a Function Expression Differ from a Function Declaration?

A function declaration uses the keyword function , followed by the name of the function. By contrast, a function expression begins with var , let or const , followed by the name of the function and the assignment operator = . Here are some examples:

```js
// Function Declaration
function sum(x, y) {
  return x + y;
};

// Function Expression: ES5
var sum = function(x, y) {
  return x + y;
};
// Function Expression: ES6+
const sum = (x, y) => { return x + y };
```

In usage, the key difference is that function declarations are hoisted, while function expressions are not. That means function declarations are moved to the top of their scope by the JavaScript interpreter, and so you can define a function declaration and call it anywhere in your code. By contrast, you can only call a function expression in linear sequence: you have to define it before you call it.

1『哈哈，现在可以轻松理解了。函数声明在函数执行上下文的创建阶段里会被扫描，声明会存入词法环境里的「环境记录」里，这就是所谓的「提升」。（2020-04-23）』

There are a handful of reasons why, today, many developers prefer function expressions: 1) First and foremost, function expressions enforce a more predictable, structured codebase. Of course, a structured codebase is also possible with declarations; it’s just that declarations allow you to get away with messy code more easily. 2) Second, we can use ES6 syntax for function expressions: this is generally more concise, and let and const provide more control over whether a variable can be re-assigned or not, as we’ll see in the next question.

### 5. What are the differences between var, let and const?

I imagine this has been a pretty common interview question since the release of ES6, by those companies making full use of the more modern syntax. var was the variable declaration keyword from the very first release of JavaScript. But its disadvantages lead to the adoption of two new keywords in ES6: let and const . These three keywords have different approaches to assignment, hoisting and scope — so we’ll cover each one separately.

#### 5.1 Assignment

The most basic difference is that let and var can be re-assigned while const cannot. This makes const the best choice for variables that don’t need to change, and it will prevent mistakes such as accidental re-assignment. Note that const does allow for variable mutation, which means that if it represents an array or an object, these can change. You just can’t re-assign the variable itself.

Both let and var can be re-assigned, but — as the following points should make clear — let has significant advantages over var , making it a better choice in most, if not all circumstances where a variable needs to change.

#### 5.2 Hoisting

Similar to the difference between function declarations and expressions (discussed above), variables declared using var are always hoised to the top of their respective scope, while variables declared using const and let are hoisted, but if you try to access them before they’re declared, you will get a ‘temporal dead zone’ error. This is useful behaviour, since var can be more prone to errors, such as accidental re-assignment. Take the following example:

```js
var x = "global scope";
function foo() {
  var x = "functional scope";
  console.log(x);
}

foo(); // "functional scope"
console.log(x); // "global scope"
```

Here, the result of foo() and console.log(x) are as we expect. But what if we were to drop the second var ?

```js
var x = "global scope";
function foo() {
  x = "functional scope";
  console.log(x);
}

foo(); // "functional scope"
console.log(x); // "functional scope"
```

Despite being defined within a function, x = "functional scope" has overridden the global variable. We needed to repeat the keyword var to specify that the second variable x is scoped only to foo() .

1『上面的这个分析目前还没弄明白。（2020-04-23）』

#### 5.3 Scope

While var is function-scoped, let and const are block-scoped: in general, a block is any code within curly braces {} , including functions, conditional statements, and loops. To illustrate the difference, take a look at the following code:

```js
var a = 0; 
let b = 0;
const c = 0;
if (true) {
  var a = 1;
  let b = 1; 
  const c = 1;
}

console.log(a); // 1
console.log(b); // 0
console.log(c); // 0
```

Within our conditional block, the globally-scoped var a has been redefined, but the globally-scoped let b and const c have not. In general, making sure local assignments stay local will make for cleaner code and fewer mistakes.

### 6. What happens if you assign a variable without a keyword?

What if you define a variable without using a keyword at all? Technically, if x hasn’t already been defined, then x = 1 is shorthand for window.x = 1. I discussed this in a recent article on memory management in JavaScript, as it’s a common cause of memory leaks.

3『 [What JavaScript Developers Can Learn from C++ - Bret Cameron - Medium](https://medium.com/@bretcameron/what-javascript-developers-can-learn-from-c-3cdb93ab8658) 』

To prevent this shorthand altogether, you can use strict mode — introduced in ES5 — by writing use strict at the top of your document or a particular function. Then, when you try to declare a variable without a keyword, you’ll get an error: Uncaught SyntaxError: Unexpected indentifier.

### 7. What’s the difference between Object Oriented Programming (OOP) and Functional Programming (FP)?

JavaScript is a multi-paradigm language, meaning that it supports multiple different programming styles, including event-driven, functional and object-oriented. There are many different programming paradigms, but in contemporary computing two of the most popular styles are Functional Programming (FP) and Object-Oriented Programming (OOP) — and JavaScript can do both.

#### 7.1 Object-Oriented Programming

OOP is based around the concept of「objects」. These are data structures that contain data fields — known in JavaScript as「properties」— and procedures — known as「methods」. Some of JavaScript’s in-built objects include Math (used for methods such as random , max and sin ), JSON (used for parsing JSON data), and primitive data types like String , Array , Number and Boolean. Whenever you rely on in-built methods, prototypes or classes, you are essentially using Object-Oriented Programming.

#### 7.2 Functional Programming

FP is based around the concept of「pure functions」, which avoid shared state, mutable data and side-effects. This might seem like a lot of jargon, but chances are you’ve created written many pure functions in your code. Given the same inputs, a pure function always returns the same output. It does not have side effects: these are anything, such as logging to the console or modifying an external variable, beyond returning the result.

As for shared state, here’s a quick example of it state can change the output of a function, even if the input is the same. Let’s set out a scenario with two functions: one to add a number by 5, and one to multiply it by 5.

```js
const num = {
  val: 1
}; 
const add5 = () => num.val += 5; 
const multiply5 = () => num.val *= 5;
```

1『原来上面的就是函数式编程的风格，细细品品。』

If we call add5 first and multiply5 second, the overall result is 30 . But if we call the functions the other way around and log the result, we get something different: 10. This goes against the principle of functional programming, as the result of the functions differs depending on the context. We can re-write the above code so that the results are predictable:

```js
const num = {
  val: 1
};
const add5 = () => Object.assign({}, num, {val: num.val + 5}); 
const multiply5 = () => Object.assign({}, num, {val: num.val * 5});
```

Now, the value of num.val remains 1, and regardless of the context add5(num) and multiply5(num) will always produce the same result.

2『第二个场景里看到 assign() 函数了，去查下具体信息。』

### 8. What’s the difference between imperative and declarative programming?

We can also think about the difference between OOP and FP in terms of the difference between「imperative」and「declarative」programming. These are umbrella terms that describe shared characteristics between multiple different programming paradigms. FP is an example of declarative programming, while OOP is an example of imperative programming.

In a basic sense, imperative programming is concerned with how you do something. It spells out the steps in the most essential way, and is characterised by for and while loops, if and switch statements, and so on.

```js
const sumArray = array => {
  let result = 0;
  for (let i = 0; i < array.length; i++) { 
    result += array[i]
  }; 
  return result;
}
```

By contrast, declarative programming is concerned with what to do, and it abstracts away the how by relying on expressions. This often results in more concise code, but at scale, it can become more difficult to debug because it’s that much less transparent. Here’s a declarative approach to our sumArray() function, above.

```js
const sumArray = array => { return array.reduce((x, y) => x + y) };
```

### 9. What is Prototype-Based Inheritance?

Finally, we come to prototype-based inheritance. There are several different styles of Object-Oriented Programming, and the one JavaScript uses is Prototype-Based Inheritance. The system allows for repeated behaviour via the use of existing objects that serve as「prototypes」.

Even if the idea of prototypes is new to you, you will have encountered the prototype system by using in-built methods. For example, functions used to manipulate arrays such as map, reduce, splice and so on are all methods of the Array.prototype object. In fact, every instance of an array (defined using square brackets [], or — more unusually — using new Array()) inherits from Array.prototype , which is why methods like map, reduce and splice are available by default.

The same is true of virtually every other built-in object, such as strings and booleans: only a few, such as Infinity , NaN , null and undefined have no properties or methods. At the end of the prototype chain we find Object.prototype , and almost every object in JavaScript is an instance of Object.prototype: Array.prototype and String.prototype, for example, both inherit properties and methods from Object.prototype.

To add properties and methods to an object using prototype syntax, you can simply initiate the object as a function, and use the prototype keyword to add properties and methods:

```js
function Person() {};
Person.prototype.forename = "John";
Person.prototype.surname = "Smith";
```

#### 9.1 Should I Override or Extend the Behaviour of Prototypes?

It’s possible to change the behaviour of built-in prototypes in exactly the same way that we can create and extend our own prototypes, but most developers (and most companies) would advise against this. If you want several objects to share the same behaviour, you can always create a custom object (or define your own ‘class’ or ‘subclass’) that inherits from a built-in prototype without making any changes to the prototype itself. If you’re going to be working with other developers, they’ll have certain expectations about JavaScript’s default behaviour, and editing this default behaviour can easily lead to errors.

It’s worth noting, however, that not everyone shares this strong opposition to extending built-in prototypes. See, for example, this article from Brendan Eich, the creator of JavaScript. In this article (from 2005), Eich suggested that the prototype system in fact was built — in part — to make extensions possible!

3『

[JavaScript 1, 2, and in between – Brendan Eich](https://brendaneich.com/2005/06/javascript-1-2-and-in-between/)

Brendan Eich 的这篇文章一定要去读，同时去抓取他的博客。

』

Overall, I hope these questions have helped you better understand JavaScript — both its core features and its more unusual quirks — and that it helps you feel more prepared for your next interview.

## 20200526Presentational-and-Container-Components.md

Update from 2019: I wrote this article a long time ago and my views have since evolved. In particular, I don’t suggest splitting your components like this anymore. If you find it natural in your codebase, this pattern can be handy. But I’ve seen it enforced without any necessity and with almost dogmatic fervor far too many times. The main reason I found it useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division. This text is left intact for historical reasons but don’t take it too seriously.

There’s a simple pattern I find immensely useful when writing React applications. If you’ve been doing React for a while, you have probably already discovered it. This article explains it well, but I want to add a few more points.

You’ll find your components much easier to reuse and reason about if you divide them into two categories. I call them Container and Presentational components* but I also heard Fat and Skinny, Smart and Dumb, Stateful and Pure, Screens and Components, etc. These all are not exactly the same, but the core idea is similar.

My presentational components:

1. Are concerned with how things look.

2. May contain both presentational and container components** inside, and usually have some DOM markup and styles of their own.

3. Often allow containment via this.props.children.

4. Have no dependencies on the rest of the app, such as Flux actions or stores.

5. Don’t specify how the data is loaded or mutated.

6. Receive data and callbacks exclusively via props.

7. Rarely have their own state (when they do, it’s UI state rather than data).

8. Are written as functional components unless they need state, lifecycle hooks, or performance optimizations.

9. Examples: Page, Sidebar, Story, UserInfo, List.

My container components:

1. Are concerned with how things work.

2. May contain both presentational and container components** inside but usually don’t have any DOM markup of their own except for some wrapping divs, and never have any styles.

3. Provide the data and behavior to presentational or other container components.

4. Call Flux actions and provide these as callbacks to the presentational components.

5. Are often stateful, as they tend to serve as data sources.

6. Are usually generated using higher order components such as connect() from React Redux, createContainer() from Relay, or Container.create() from Flux Utils, rather than written by hand.

7. Examples: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.

I put them in different folders to make this distinction clear.

### 01. Benefits of This Approach

Better separation of concerns. You understand your app and your UI better by writing components this way.

Better reusability. You can use the same presentational component with completely different state sources, and turn those into separate container components that can be further reused.

Presentational components are essentially your app’s「palette」. You can put them on a single page and let the designer tweak all their variations without touching the app’s logic. You can run screenshot regression tests on that page.

This forces you to extract「layout components」such as Sidebar, Page, ContextMenu and use this.props.children instead of duplicating the same markup and layout in several container components.

Remember, components don’t have to emit DOM. They only need to provide composition boundaries between UI concerns. Take advantage of that.

### 02. When to Introduce Containers?

I suggest you to start building your app with just presentational components first. Eventually you’ll realize that you are passing too many props down the intermediate components. When you notice that some components don’t use the props they receive but merely forward them down and you have to rewire all those intermediate components any time the children need more data, it’s a good time to introduce some container components. This way you can get the data and the behavior props to the leaf components without burdening the unrelated components in the middle of the tree.

This is an ongoing process of refactoring so don’t try to get it right the first time. As you experiment with this pattern, you will develop an intuitive sense for when it’s time to extract some containers, just like you know when it’s time to extract a function. My free Redux Egghead series might help you with that too!

3『 [Redux Tutorial by Dan Abramov on egghead.io](https://egghead.io/courses/getting-started-with-redux) 』

### 03. Other Dichotomies

It’s important that you understand that the distinction between the presentational components and the containers is not a technical one. Rather, it is a distinction in their purpose. By contrast, here are a few related (but different!) technical distinctions:

1 Stateful and Stateless. Some components use React setState() method and some don’t. While container components tend to be stateful and presentational components tend to be stateless, this is not a hard rule. Presentational components can be stateful, and containers can be stateless too.

2 Classes and Functions. Since React 0.14, components can be declared both as classes and as functions. Functional components are simpler to define but they lack certain features currently available only to class components. Some of these restrictions may go away in the future but they exist today. Because functional components are easier to understand, I suggest you to use them unless you need state, lifecycle hooks, or performance optimizations, which are only available to the class components at this time.

3 Pure and Impure. People say that a component is pure if it is guaranteed to return the same result given the same props and state. Pure components can be defined both as classes and functions, and can be both stateful and stateless. Another important aspect of pure components is that they don’t rely on deep mutations in props or state, so their rendering performance can be optimized by a shallow comparison in their shouldComponentUpdate() hook. Currently only classes can define shouldComponentUpdate() but that may change in the future.

Both presentational components and containers can fall into either of those buckets. In my experience, presentational components tend to be stateless pure functions, and containers tend to be stateful pure classes. However this is not a rule but an observation, and I’ve seen the exact opposite cases that made sense in specific circumstances.

Don’t take the presentational and container component separation as a dogma. Sometimes it doesn’t matter or it’s hard to draw the line. If you feel unsure about whether a specific component should be presentational or a container, it might be too early to decide. Don’t sweat it!

### 04. Example

This gist [[JSX, a year in · GitHub](https://gist.github.com/chantastic/fc9e3853464dffdb1e3c)] by Michael Chan pretty much nails it.

### 05. Further Reading

[Redux Tutorial by Dan Abramov on egghead.io](https://egghead.io/courses/getting-started-with-redux)

[Mixins Are Dead. Long Live Composition - Dan Abramov - Medium](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750)

[Container Components - Learn React with chantastic - Medium](https://medium.com/@learnreact/container-components-c0e67432e005)

[Atomic Design | Brad Frost](https://bradfrost.com/blog/post/atomic-web-design/)

[Building The Facebook News Feed With Relay – React Blog](https://reactjs.org/blog/2015/03/19/building-the-facebook-news-feed-with-relay.html)

1『上面的那篇「原子设计」有时间看看。』

### 06. Footnotes

In an earlier version of this article I called them「smart」and「dumb」components but this was overly harsh to the presentational components and, most importantly, didn’t really explain the difference in their purpose. I enjoy the new terms much better, and I hope that you do too!

In an earlier version of this article I claimed that presentational components should only contain other presentational components. I no longer think this is the case. Whether a component is a presentational component or a container is its implementation detail. You should be able to replace a presentational component with a container without modifying any of the call sites. Therefore, both presentational and container components can contain other presentational or container components just fine.