## 记忆时间

## 目录

0109可变的数据不要让你的代码失控.md

0110变量声明与赋值分离普通的变量声明怎么也有坏味道.md

0111依赖混乱你可能还没发现问题代码就已经无法挽救了.md

0112不一致的代码为什么你的代码总被吐槽难懂.md

0113落后的代码风格使用新的语言特性和程序库升级你的代码.md

## 0109可变的数据不要让你的代码失控.md

### 总结时刻

今天我们又讲了一类与很多人编程习惯不符的坏味道：可变的数据。可变数据最直白的体现就是各种 setter。setter 一方面破坏了封装，另一方面它会带来不可控的修改，给代码增添许多问题。解决它的一种方式就是移除设值函数（Remove Setting Method），将变化限制在一定的范围之内。可变数据是《重构》第二版新增的坏味道，这其实反映了软件开发行业的一种进步，它背后的思想是函数式编程所体现的不变性。解决可变数据，一种方式是限制其变化，另一种方式是编写不变类。

在实践中，完全消除可变数据是很有挑战的。所以，一个实际的做法是，区分类的性质。值对象就要设计成不变类，实体类则要限制数据变化。函数式编程的本质是对于赋值进行了约束，我们甚至可以把赋值作为一种坏味道的提示。很多编程语言都引入了值类型，而让变量成为次优选项。如果今天的内容你只能记住一件事，那请记住：限制可变的数据。

### 9.0

最近几讲，我们讨论的坏味道挑战了很多人的编程习惯，明明很习惯的编码方式，如今却成了坏味道。这一讲，我们再来说一类这样的坏味道：可变的数据。

对于程序，最朴素的一种认知是「程序 = 数据结构 + 算法」，所以，数据几乎是软件开发最核心的一个组成部分。在一些人的认知中，所谓做软件，就是一系列的 CRUD 操作，也就是对数据进行增删改查。再具体一点，写代码就把各种数据拿来，然后改来改去。我们学习编程时，首先学会的，也是给变量赋值，写出类似 a = b + 1 之类的代码。改数据，几乎已经成了很多程序员写代码的标准做法。然而，这种做法也带来了很多的问题。这一讲，我们还是从一段问题代码开始。

### 9.1 满天飞的 Setter

还记得我们在开篇词里提到过的一个坏味道吗？我们复习一下：

```java
public void approve(final long bookId) {
  ...
  book.setReviewStatus(ReviewStatus.APPROVED);
  ...
}
```

这是一段对作品进行审核的代码，通过 bookId，找到对应的作品，接下来，将审核状态设置成了审核通过。我当时之所以注意到这段代码，就是因为这里用了 setter。setter 往往是缺乏封装的一种做法。对于缺乏封装的坏味道，我们上节课已经用了一讲的篇幅在说，我提到，很多人在写代码时，写完字段就会利用 IDE 生成 getter，实际情况往往是，生成 getter 的同时，setter 也生成了出来。setter 同 getter 一样，反映的都是对细节的暴露。这就意味着，你不仅可以读到一个对象的数据，还可以修改一个对象的数据。相比于读数据，修改是一个更危险的操作。

我在《软件设计之美》专栏里讲函数式编程的不变性时，曾经专门讨论过可变的数据会带来许多问题，简言之，你不知道数据会在哪里被何人以什么方式修改，造成的结果是，别人的修改会让你的代码崩溃。与之相伴的还有各种衍生出来的问题，最常见的就是我们常说的并发问题。

可变的数据是可怕，但是，比可变的数据更可怕的是，不可控的变化，而暴露 setter 就是这种不可控的变化。把各种实现细节完全交给对这个类不了解的使用者去修改，没有人会知道他会怎么改，所以，这种修改完全是不可控的。

缺乏封装再加上不可控的变化，在我个人心目中，setter 几乎是排名第一的坏味道。在开篇词里，我们针对代码给出的调整方案是，用一个函数替代了 setter，也就是把它用行为封装了起来：

```java
public void approve(final long bookId) {
  ...
  book.approve();
  ...
}
```

通过在 Book 类里引入了一个 approve 函数，我们将审核状态封装了起来。

```java
class Book {
  public void approve() {
    this.reviewStatus = ReviewStatus.APPROVED;
  }
}
```

作为这个类的使用者，你并不需要知道这个类到底是怎么实现的。更重要的是，这里的变化变得可控了。虽然审核状态这个字段还是会修改，但你所有的修改都要通过几个函数作为入口。有任何业务上的调整，都会发生在类的内部，只要保证接口行为不变，就不会影响到其它的代码。

setter 破坏了封装，相信你对这点已经有了一定的理解。不过，有时候你会说，我这个 setter 只是用在初始化过程中，而并不需要在使用的过程去调用，就像下面这样：

```java
Book book = new Book();
book.setBookId(bookId);
book.setTitle(title);
book.setIntroduction(introduction);
```

实际上，对于这种只在初始化中使用的代码，压根没有必要以 setter 的形式存在，真正需要的是一个有参数的构造函数：

```java
Book book = new Book(bookId, title, introduction);
```

消除 setter ，有一种专门的重构手法，叫做移除设值函数（Remove Setting Method）。总而言之，setter 是完全没有必要存在的。在今天的软件开发中，人们为了简化代码的编写做出了各种努力，用 IDE 生成的代码是一种，还有一种常见的做法就是，通过工具和框架生成相应代码的。在 Java 世界中，Lombok 就是这样的一种程序库，它可以在编译的过程中生成相应的代码，而我们需要做的，只是在代码上加上对应的 Annotation。它最大的优点是不碍眼，也就是不会产生大量可以看见的代码。因为它的代码是在编译阶段生成的，所以，那些生成的代码在源码级别上是不存在的。下面就是一个例子：

```java
@Getter
@Setter
class Book {
  private BookId bookId;
  private String title;
  private String introduction;
}
```

这里的 @Getter 表示为这个类的字段生成 getter，相应地，@Setter 表示生成 setter。也是因为这些 Annotation 的存在，让代码看上去清爽了不少。所以，像 Lombok 这样的程序库赢得了许多人的喜爱。不过，我想说的是，不写 setter 的代码并不代表没有 setter。因为 @Setter 的存在，其它代码还是可以调用这个类的 setter，存在的问题并不会改变。所以，一个更好的做法是禁用 @Setter。下面是 lombok.config 的配置，通过它，我们就可以禁用 @Setter 了：

```java
lombok.setter.flagUsage = error
lombok.data.flagUsage = error
```

你或许注意到了，这里除了 @Setter，我还禁用了 @Data，这是 Lombok 中另外一个 Annotation，表示的是同时生成 getter 和 setter。既然我们禁用 @Setter 是为了防止生成 setter，当然也要禁用 @Data 了。

### 9.2 可变的数据

我们反对使用 setter，一个重要的原因就是它暴露了数据，我们前面说过，暴露数据造成的问题就在于数据的修改，进而导致出现难以预料的 Bug。在上面的代码中，我们把 setter 封装成一个个的函数，实际上是把不可控的修改限制在一个有限的范围内。

那么，这个思路再进一步的话，如果我们的数据压根不让修改，犯下各种低级错误的机会就进一步降低了。没错，在这种思路下，可变数据（Mutable Data）就成了一种坏味道，这是 Martin Fowler 在新版《重构》里增加的坏味道，它反映着整个行业对于编程的新理解。

这种想法源自函数式编程这种编程范式。在函数式编程中，数据是建立在不改变的基础上的，如果需要更新，就产生一份新的数据副本，而旧有的数据保持不变。随着函数式编程在软件开发领域中的地位不断提高，人们对于不变性的理解也越发深刻，不变性有效地解决了可变数据产生的各种问题。

所以，Martin Fowler 在《重构》第二版里新增了可变数据作为一种坏味道，这其实反映了行业的理解也是在逐渐推进的。不过，Martin Fowler 对于可变数据给出的解决方案，基本上是限制对于数据的更新，降低其风险，这与我们前面提到的对 setter 的封装如出一辙。

解决可变数据，还有一个解决方案是编写不变类。我在《软件设计之美》专栏中已经讲过函数式编程的不变性，其中的关键点就是设计不变类。Java 中的 String 类就是一个不变类，比如，如果我们把字符串中的一个字符替换成另一个字符，String 类给出的函数签名是这样的：

```java
String replace(char oldChar, char newChar);
```

其含义是，这里的替换并不是在原有字符串上进行修改，而是产生了一个新的字符串。

那么，在实际工作中，我们怎么设计不变类呢？要做到以下三点：1）所有的字段只在构造函数中初始化；2）所有的方法都是纯函数；3）如果需要有改变，返回一个新的对象，而不是修改已有字段。

1-3『

目前感觉「纯函数」概念讲的最清楚的是「2021060Learning-React2EdR00.md」

```js
const frederick = {
  name: "Frederick Douglass",
  canRead: false,
  canWrite: false
};

const selfEducate = person => ({
  ...person,
  canRead: true,
  canWrite: true
});

console.log(selfEducate(frederick));
console.log(frederick);
// {name: "Frederick Douglass", canRead: true, canWrite: true}
// {name: "Frederick Douglass", canRead: false, canWrite: false}
```

Finally, this version of selfEducate is a pure function. It computes a value based on the argument that was sent to it: the person. It returns a new person object without mutating the argument sent to it and therefore has no side effects.

Pure functions are another core concept of functional programming.

They will make your life much easier because they will not affect your application's state. When writing functions, try to follow these three rules:

1 The function should take in at least one argument.

2 The function should return a value or another function.

3 The function should not change or mutate any of its arguments.

1-3『纯函数核心的三样东西，这节的信息比郑烨专栏里讲纯函数要细致丰富很多，反复去看。（2021-05-01）』

』

回过头来看我们之前改动的「用构造函数消除 setter」的代码，其实就是朝着这个方向在迈进。如果按照这个思路改造我们前面提到的 approve 函数，同样也可以：

```java
class Book {
  public void approve() {
    return new Book(..., ReviewStatus.APPROVED, ...);
  }
}
```

这里，我们创建出了一个「其它参数和原有 book 对象一模一样，只是审核状态变成了 APPROVED」的对象。在 JDK 的演化中，我们可以看到一个很明显的趋势，新增的类越来越多地采用了不变类的设计，比如，用来表示时间的类。原来的 Date 类里面还有各种 setter，而新增的 LocalDateTime 则一旦初始化就不会再修改了。如果要操作这个对象，则会产生一个新的对象：

```java
LocalDateTime twoDaysLater = now.plusDays(2);
```

就目前的开发状态而言，想要完全消除可变数据是很难做到的，但我们可以尽可能地编写一些不变类。一个更实用的做法是，区分类的性质。我《软件设计之美》中讲 DDD 的战术设计时提到过，我们最核心要识别的对象分成两种，实体和值对象。实体对象要限制数据变化，而值对象就要设计成不变类。

如果你还想进一步提升自己对于不变性的理解，我们可以回到函数式编程这个编程范式的本质，它其实是对程序中的赋值进行了约束。基于这样的理解，连赋值本身其实都会被归入到坏味道的提示，这才是真正挑战很多人编程习惯的一点。

不过，我们现在看到，越来越多的语言中开始引入值类型，也就是初始化之后便不再改变的值，比如，Java 的 Valhalla 项目，更有甚者，像 Rust 这样的语言中，缺省都是值类型，而如果你需要一个可以赋值的变量，反而要去专门的声明。Martin Fowler 在《重构》中还提到一个与数据相关的坏味道：全局数据（Global Data）。如果你能够理解可变数据是一种坏味道，全局数据也就很容易理解了，它们处理手法基本上是类似的，这里我就不再做过多的阐述了。

### 黑板墙

思考题：这一讲我们讲了可变的数据，你在实际工作遇到过因为数据变动而产生的问题吗？或者你设计过不变类吗？

对象如果需要构造的参数太多了怎么办？我能想到的就是用 builder 模式来重构。作者回复：正解。2021-01-19

前段时间，领导交代了一个任务。任务是将某某前端传进来的字段，存储到数据库里面。当时领导说这么简单的一个功能，就给你一天的时间解决。我足足花了两天时间。我后来复盘了一下，任务延期的原因就是可变的数据，失控的代码，需要修改的代码点里面逻辑，而且充斥着各种 set，当我在我自以为某个地方 set 了该字段之后，发现在代码的后面又有一个地方 set 了，在往后面又有地方 set，那种感觉，真的酸爽。学习了这篇文章之后，我自己后面一定要避免这种问题，如果不改，说不定后面坑到的还是我自己。作者回复：那种痛，经历过才懂。2021-01-19

嵌入式 C 程序员表示眼馋这些其他语言直接提供的封装方法……作者回复：其实，C 语言也是可以把代码写得很好的，我在《软件设计之美》中用过一个 Linux 文件系统的例子。只不过，花的精力比较多，很多人不愿意这么做而已。2021-01-27

我的理解使用不变性限制了大家一起改同一份数据的混乱，但同时又会引发多份副本数据的混乱，郑老师见过这样的情况么？作者回复：难道数据不存回去，只在内存里吗？那就得考虑事务性内存了。2021-01-19

汇总：1）现实情况下，@Setter 这个我去不掉啊。毕竟很多框架（dozer/mapstruct）都是基于生成 set 方法操作数据的。去掉的话，兼容性会受影响，开发工作量和风险也会增加（需要手动去维护新增字段的初始化）。2）基于 idea，我声明的变量都会带上 final。这一度倍受挑战，因为带上 final 代码自然就变长了，可读性算是变差了吧，毕竟有时因为多个 final 就得换行；包括 jdk 函数库在内，大部分好 demo 的代码部分都不会带上 final，所以当小伙伴拿这些例子质疑时挺无奈。3）为什么声明要带上 final，因为我也认为缺省变量应该是不可变的。只是受限于 java 语法特性，所以采用这种曲线的方式。4）提到 final 就谈谈不可变对象。一个对象一旦声明，内部的数值结构就不可变，任何对内部值的变更操作都会生成新的对象。这个其实我一直在想，如果语言层面提供一个备忘录模式或许会挺好的。使用者做变更时不用手动新建对象，回退时也可以基于 his 版本对象无需重新创建。并且我们也有回滚到变更前一个状态或者前多个状态的诉求，也会有打印出所有变更操作的诉求。

作者回复：用了 setter，习惯 setter，setter 才是去不掉的。程序库中优秀的地方也许就是潜在的语言特性，这在《软件设计之美》讲程序库的时候提到过：程序库设计就是语言设计，语言设计就是程序库设计。2021-01-24

在 Rust 中变量默认是不可变的，要想使其可变，需要在变量名前加 mut 关键字。这样不仅可以改变变量的值，而且也在告诉阅读代码的人，这个值在某个地方会被改变。另外，它的所有权机制和对可变引用的规则限制，会减少很多可变的数据这种坏味道的发生。对 Rust 理解的不深，不知道这样的理解对不对。作者回复：所有权机制，目的不是这个吧？2021-01-21

不可变对象在前端倒是很流行，一些状态管理甚至是基于这个前提的。作者回复：流行其实是有道理的。2021-03-13

这些算是基于充血模型的吗？可我做过的项目全是类似贫血模型。作者回复：你说得对，贫血模型本来就不是一个好的设计，只算把数据放到一起，谈不上封装。2021-02-25

作者，这个方法返回的应该是 Book 对象。还有个疑惑，这种修改对象状态并返回一个新对象的方式是主流的方式吗？我在我们的项目中还没见过有写过。作者回复：这是一个编写「不变对象」的示例，这种做法确实不多见，你可以看看 String 类的实现。关于不变性的分析，可以参考《软件设计之美》。2021-01-31

## 0110变量声明与赋值分离普通的变量声明怎么也有坏味道.md

### 总结时刻

今天我们继续挑战着很多人习惯的编程方式，讲了变量初始化带来的问题。变量的初始化包含变量的声明和赋值两个部分，一个编程的原则是「变量要一次性完成初始化」。这就衍生出一个坏味道：变量的声明和赋值是分离的。二者分离带来的问题就是，把赋值的过程与业务处理混杂在一起。发现变量声明与赋值分离一个做法就是在声明前面加上 final，用「不变性」约束代码。

我们还谈到了集合的初始化，传统的集合初始化方式是命令式的，而今天我们完全可以用声明式的方式进行集合的初始化，让初始化的过程一次性完成。再进一步，以声明式的标准来看代码，会帮助我们发现许多的坏味道。如果今天的内容你只能记住一件事，那请记住：一次性完成变量的初始化。

### 10.0

我们已经用连续几讲的篇幅在挑战很多人固有的编程习惯了，从各种控制语句，到 getter 和 setter，甚至连直接使用基本类型都已经成了坏味道，这一讲，我们再来挑战一个很多人习以为常的编程习惯：变量的声明与赋值。

我估计有人已经露出了惊讶的表情。你可能会想：要说前面几种坏味道可能确实是编码没有做好，该封装没封装，该返回没返回，一个变量声明怎么还会有坏味道啊？难道是变量声明都不让用了吗？诚然，变量声明是写程序不可或缺的一部分，我并不打算让你戒掉变量声明，严格地说，我们是要把变量初始化这件事做好。

### 10.1 变量的初始化

我们先来看一段代码：

```java
EpubStatus status = null;
CreateEpubResponse response = createEpub(request);
if (response.getCode() == 201) {
  status = EpubStatus.CREATED;
} else {
  status = EpubStatus.TO_CREATE;
}
```

这段代码在做的事情是向另外一个服务发请求创建 EPUB（一种电子书格式），如果创建成功，返回值是 HTTP 的 201，也就表示创建成功，然后就把状态置为 CREATED；而如果没有成功，则把状态置为 TO_CREATE。后面对于 TO_CREATE 状态的作品，还需要再次尝试创建。

这里，我们暂且把是否要写 else 放下，这是我们在前面已经讨论过的一个坏味道。

我们这次的重点在 status 这个变量上，虽然 status 这个变量在声明的时候，就赋上了一个 null 值，但实际上，这个值并没有起到任何作用，因为 status 的变量值，其实是在经过后续处理之后，才有了真正的值。换言之，从语义上说，第一行的变量初始化其实是没有用的，这是一次假的初始化。

按照我们通常的理解，一个变量的初始化是分成了声明和赋值两个部分，而我这里要说的就是，变量初始化最好一次性完成。这段代码里的变量赋值是在声明很久之后才完成的，也就是说，变量初始化没有一次性完成。

这种代码真正的问题就是不清晰，变量初始化与业务处理混在在一起。通常来说，这种代码后面紧接着就是一大堆更复杂的业务处理。当代码混在一起的时候，我们必须小心翼翼地从一堆业务逻辑里抽丝剥茧，才能把逻辑理清，知道变量到底是怎么初始化的。很多代码难读，一个重要的原因就是把不同层面的代码混在了一起。

这种代码在实际的代码库中出现的频率非常高，只不过，它会以各种变形的方式呈现出来。有的变量甚至是在相隔很远的地方才做了真正的赋值，完成了初始化，这中间已经夹杂了很多的业务代码在其中，进一步增加了理解的复杂度。

所以，我们编程时要有一个基本原则：变量一次性完成初始化。有了这个理解，我们可以这样来修改上面这段代码：

```java
final CreateEpubResponse response = createEpub(request);
final EpubStatus status = toEpubStatus(response);


private EpubStatus toEpubStatus(final CreateEpubResponse response) {
  if (response.getCode() == 201) {
    return EpubStatus.CREATED;
  }


  return EpubStatus.TO_CREATE;
}
```

在这段改进的代码中，我们提取出了一个函数，将 response 转成对应的内部的 EPUB 状态。

其实，很多人之所以这样写代码，一个重要的原因是很多人的编程习惯是从 C 语言来的。C 语言在早期的版本中，一个函数用到的变量必须在整个函数的一开始就声明出来。

在 C 语言诞生的年代，当时计算机能力有限内存小，编译器技术也处于刚刚起步的阶段，把变量放在前面声明出来，有助于减小编译器编写的难度。到了 C++ 产生的年代，这个限制就逐步放开了，所以，C++ 程序是支持变量随用随声明的。对于今天的大多数程序设计语言来说，这个限制早就不存在了，但很多人的编程习惯却留在了那个古老的年代。

还有一点不知道你注意到了没有，在新的变量声明中，我加上了 final，在 Java 的语义中，一个变量加上了 final，也就意味着这个变量不能再次赋值。对，我们需要的正是这样的限制。

上一讲，我们讲了可变的数据会带来怎样的影响，其中的一个结论是，尽可能编写不变的代码。这里其实是这个话题的延伸，尽可能使用不变的量。

如果我们能够按照使用场景做一个区分，把变量初始化与业务处理分开，你会发现，在很多情况下，变量只在初始化完成之后赋值，就足以满足我们的需求了，在一段代码中，需要使用可变量的场景并不多。

这个原则其实可以推广一下，在能够使用 final 的地方尽量使用 final，限制变量的赋值。

这里说的「能够使用」，不仅包括普通的变量声明，还包含参数声明，还有类字段的声明，甚至还可以包括类和方法的声明。当然，我们这里改进的考量主要还是在变量上。你可以尝试着调整自己现有的代码，给变量声明都加上 final，你就会发现许多值得改进的代码。

对于 Java 程序员来说，还有一个特殊的场景，就是异常处理的场景，强迫你把变量的声明与初始化分开，就像下面这段代码：

```java
InputStream is = null;

try {
  is = new FileInputStream(...);
  ...
} catch (IOException e) {
  ...
} finally {
  if (is != null) {
    is.close(); 
  }
}
```

之所以要把 InputStream 变量 is 单独声明，是为了能够在 finanlly 块里面访问到。其实，这段代码写成这样，一个重要的原因是 Java 早期的版本只能写成这样，而如果采用 Java 7 之后的版本，采用 try-with-resource 的写法，代码就可以更简洁了：

```java
try (InputStream is = new FileInputStream(...)) {
  ...
}
```

这样一来，InputStream 变量的初始化就一次性完成了，我们的原则就统一了，不需要在这种特殊的场景下纠结了。

### 10.2 集合初始化

接下来，我们在来看一段代码：

```java
List<Permission> permissions = new ArrayList<>();
permissions.add(Permission.BOOK_READ);
permissions.add(Permission.BOOK_WRITE);
check.grantTo(Role.AUTHOR, permissions);
```

这是一段给作者赋予作品读写权限的代码，逻辑比较简单，但这段代码中也存在一些坏味道。我们把注意力放在 permissions 这个集合上。之所以要声明这样一个 List，是因为 grantTo 方法要用到一个 List 作为参数。

我们来看这个 List 是怎样生成的。这里先给 permission 初始化成了一个 ArrayList，这个时候，permissions 虽然存在了，但我们并不会把它传给 grantTo 方法，它还不能直接使用，因为它还缺少必要的信息。然后，我们将 `BOOK_READ` 和 `BOOK_WRITE` 两个枚举对象添加了进去，这样，这个 permissions 对象才是我们真正需要的那个对象。

这种代码是非常常见的，声明一个集合，然后，调用一堆添加的方法，将所需的对象添加进去。我们不难发现，其实 permissions 对象一开始的变量声明，并没有完成这个集合真正的初始化，只有当集合所需的对象添加完毕之后，这个集合才是它应有的样子。换言之，只有添加了元素的集合才是我们需要的。

这样解释这段代码，你是不是就发现了，这和我们前面所说的变量先声明后赋值，本质上是一回事，都是从一个变量的声明到初始化成一个可用的状态，中间隔了太远的距离。之所以很多人习惯这么写，一个原因就是在早期的 Java 版本中，没有提供很好的集合初始化的方法。像这种代码，也是很多动态语言的支持者调侃 Java 啰嗦的一个靶子。现如今，Java 在这方面早已经改进了许多，各种程序库已经提供了一步到位的写法，我们先来看看 Java 9 之后的写法：

```java
List<Permission> permissions = List.of(
  Permission.BOOK_READ, 
  Permission.BOOK_WRITE
);
check.grantTo(Role.AUTHOR, permissions);
```

如果你的项目还没有升级 Java 9 之后的版本，使用 Guava（Google 提供的一个 Java 库）也是可以做成类似的效果：

```java
List<Permission> permissions = ImmutableList.of(
  Permission.BOOK_READ, 
  Permission.BOOK_WRITE
);
check.grantTo(Role.AUTHOR, permissions);
```

经过改进，这段代码是不是看上去就清爽多了！

不知道你注意到没有，第二段代码里的 List 用的是一个 ImmutableList，也就是一个不可变的 List，实际上，你查看第一段代码的实现就会发现，它也是一个不变的 List。这是什么意思呢？也就是说，这个 List 一旦创建好了，就是不能修改了，对应的实现就是各种添加、删除之类的方法全部都禁用了。

初看起来，这是限制了我们的能力，但我们对比一下代码就不难发现，很多时候，我们对于一个集合的使用，除了声明时添加元素之外，后续就只是把它当作一个只读的集合。所以，在很多情况下，一个不变集合对我们来说就够用了。

其实，这段代码，相对来说还是比较清晰的，稍微再复杂一些的，集合的声明和添加元素之间隔了很远，不注意的话，甚至不觉得它们是在完成一次初始化。

```java
private static Map<Locale, String> CODE_MAPPING = new HashMap<>();
...

static {
  CODE_MAPPING.put(LOCALE.ENGLISH, "EN");
  CODE_MAPPING.put(LOCALE.CHINESE, "CH");
}
```

这是一个传输时的映射方案，将不同的语言版本映射为不同的代码。这里 CODE_MAPPING 是一个类的 static 变量，而这个类的声明里还有其它一些变量。所以，隔了很远之后，才有一个 static 块向这个集合添加元素。如果我们能够用一次性声明的方式，这个单独的 static 块就是不需要的：

```java
private static Map<Locale, String> CODE_MAPPING = ImmutableMap.of(
  LOCALE.ENGLISH, "EN",
  LOCALE.CHINESE, "CH"
);
```

对比我们改造前后的代码，二者之间还有一个更关键的区别：前面的代码是命令式的代码，而后面的代码是声明式的代码。

命令式的代码，就是告诉你「怎么做」的代码，就像改造前的代码，声明一个集合，然后添加一个元素，再添加一个元素。而声明式的代码，是告诉你「做什么」的代码，改造后就是，我要一个包含了这两个元素的集合。

我在《软件设计之美》专栏中讲 DSL 时，曾经讲过二者的区别，声明式的代码体现的意图，是更高层面的抽象，把意图和实现分开，从某种意义上来说，也是一种分离关注点。

所以，用声明式的标准来看代码，是一个发现代码坏味道的重要参考。

回想一下今天讲的坏味道，无论是变量的声明与赋值分离，还是初始化一个集合的分步骤，其实反映的都是不同时代编程风格的烙印。变量的声明是 C 早期的编程风格，异常处理是 Java 早期的风格，而集合声明也体现出不同版本 Java 的影子。

我们学习编程不仅仅是要学习实现功能，编程的风格也要与时俱进。

### 黑板墙

思考题：变量初始化可能是一个很多人都没有注意过的坏味道，你可以回去翻翻自己的代码，用这个标准衡量一下，你能发现什么问题吗？

有一种当年读 Effective 系列从书的感觉。作者回复：这个比喻，我很欣慰。2021-01-21

刷新了认知，给我植入了「声明式」和「做什么」两个思想。作者回复：恭喜你，又进阶了。2021-01-21

说来惭愧，项目中从来没有一个同事用过 final。学到了用声明式的标准来看代码。作者回复：学到一招，就可以用起来。2021-01-21

response 和 status 没想明白在什么情况下会被改变，final 防止改变这两个变量的意图可以理解，但是是防止程序运行过程中被其他线程误改变值？还是防止其他开发的同事调用或修改这段代码的时候一不小心对变量进行了赋值？作者回复：不用考虑什么情况下会改变，设置成 final 就是告诉别人，它不会变。2021-01-28

这几天早上起床就来刷这个课，之前一直没有留言，但是昨天看了之前的一个代码，然后发现了很多前面几章讲的坏味道（比如过长的消息链等），今天又学到了变量声明，记起来之前代码也有这样的问题，今天就立马去改了，点赞这门课。2021-04-09

对 list 的初始化使用 Arrays.asList 是否也是可行的？作者回复：是可以的。2021-02-02

## 0111依赖混乱你可能还没发现问题代码就已经无法挽救了.md

### 总结时刻

今天我们讲了由于代码依赖关系而产生的坏味道，一种是缺少防腐层，导致不同代码糅合在一起，一种是在业务代码中出现了具体的实现类。缺少防腐层，会让请求对象传导到业务代码中，造成了业务与外部接口的耦合，也就是业务依赖了一个外部通信协议。一般来说，业务的稳定性要比外部接口高，这种反向的依赖就会让业务一直无法稳定下来，继而在日后带来更多的问题。解决方案自然就是引入一个防腐层，将业务和接口隔离开来。

业务代码中出现具体的实现类，实际上是违反了依赖倒置原则。因为违反了依赖倒置原则，业务代码也就不可避免地受到具体实现的影响，也就造成了业务代码的不稳定。识别一段代码是否属于业务，我们不妨问一下，看把它换成其它的东西，是否影响业务。解决这种坏味道就是引入一个模型，将业务与具体的实现隔离开来。

最后，我们还谈到了有些简单的依赖关系，可以通过工具来进行维护，比如 ArchUnit。如果今天的内容你只能记住一件事，那请记住：代码应该向着稳定的方向依赖。

### 11.0

我们前面已经讲了许多坏味道，无论是你很容易接受的，还是挑战你编程习惯的，它们都有相对直观的表现形式，属于你很容易一下子就看出来问题的。这一讲，我们要讲的坏味道就不属于一下子就能看出来的，需要你稍微仔细一点看代码才会发现问题，那就是依赖关系。

我前面在讲「大类」这个坏味道的时候曾经说过，为了避免同时面对所有细节，我们需要把程序进行拆分，分解成一个又一个的小模块。但随之而来的问题就是，我们需要把这些拆分出来的模块按照一定的规则重新组装在一起，这就是依赖的缘起。

一个模块要依赖另外一个模块完成完整的业务功能，而到底怎么去依赖，这里就很容易产生问题。

### 11.1 缺少防腐层

我们还是先来看一段代码：

```java
@PostMapping("/books")
public NewBookResponse createBook(final NewBookRequest request) {
  boolean result = this.service.createBook(request);
  ...
}
```

这段代码是创建一部作品的入口，也就是说，它提供了一个 REST 服务，只要我们对 /books 这个地址发出一个 POST 请求，就可以创建一部作品出来。那么，这段代码有问题吗？

按照一般代码的分层逻辑，一个 Resource （有的团队称之为 Controller）调用一个 Service，这符合大多数人的编程习惯，所以看起来，这段代码简直是正常得不能再正常了，这能有什么问题？

从 Resource 调用 Service，这几乎是行业里的标准做法，是没有问题的，但问题出在传递的参数上。请问，这个 NewBookRequest 的参数类应该属于哪一层，是 resource 层，还是 service 层呢？

一般来说，既然它是一个请求参数，通常要承载着诸如参数校验和对象转换的职责，按照我们通常的理解，它应该属于 resource 层。如果这个理解是正确的，问题就来了，它为什么会传递给 service 层呢？

按照通常的架构设计原则，service 层属于我们的核心业务，而 resource 层属于接口。二者相较而言，核心业务的重要程度更高一些，所以，它的稳定程度也应该更高一些。同样的业务，我们可以用 REST 的方式对外提供，也可以用 RPC 的方式对外提供。

说到这，你就会发现一个问题，NewBookRequest 这个本来应该属于接口层的参数，现在成了核心业务的一部分，也就是说，即便将来我们提供了 RPC 的接口，它也要知道 REST 的接口长什么样子，显然，这是有问题的。

既然 NewBookRequest 属于 resource 层是有问题的，那我们假设它属于 service 层呢？正如我们前面所说，一般请求都要承担对象校验和转化的工作。如果说这个类属于 service 层，但它用在了 resource 的接口上，作为 resource 的接口，它会承载一些校验和对象转换的角色，而 service 层的参数是不需要关心这些的。如果 NewBookRequest 属于 service 层，那校验和对象转换的职责到底由谁来完成呢？

还有更关键的一点是，有时候 service 层的参数和 resource 层的参数并不是严格地一一对应。比如，创建作品时，我们需要一个识别作者身份的用户 ID，而这个参数并不是通过客户端发起的请求参数带过来，而是根据用户登录信息进行识别的。所以，用 service 层的参数做 resource 层的参数，就存在差异的参数如何处理的问题。

你有没有发现，我们突然陷入了一种两难的境地，如此一个简单的参数，放到哪个层里都有问题。

这是一种非常常见的代码，你去翻看自己的代码仓库，也许就能找到类似的代码。不过，很有可能在学习到这一课之前，你根本没有想过这种代码也是有问题的。

那这个问题该如何解呢？

其实，之所以我们这么纠结，一个关键点在于，我们缺少了一个模型。

NewBookRequest 之所以弄得如此「里外不是人」，主要就是因为它只能扮演一个层中的模型，所以，我们只要再引入一个模型就可以破解这个问题。

```java
class NewBookParameter {
  ...
}


class NewBookRequest {
  public NewBookParameters toNewBookRequest() {
    ...
  }
}


@PostMapping("/books")
public NewBookResponse createBook(final NewBookRequest request) {
  boolean result = this.service.createBook(request.toNewBookParameter());
  ...
}
```

这里我们引入了一个 NewBookParameter 类，把它当作 service 层创建作品的入口，而在 resource 中，我们将 NewBookRequest 这个请求类的对象转换成了 NewBookParameter 对象，然后传到 service 层。

在这个结构中，NewBookParameter 属于 service 层，而 NewBookRequest 属于 resource 层，二者相互独立，我们之前纠结的问题也就不复存在了。

好，现在我们理解了，通过增加一个模型，我们就破解了依赖关系上的纠结。

也许你会说，虽然它们成了两个类，但是，它们两个应该长得一模一样吧。这算不算是一种重复呢？但我的问题是，它们两个为什么要一样呢？有了两层不同的参数，我们就可以给不同层次上的模型以不同的约定了。

比如，对于 resource 层的请求对象，因为它的主要作用是传输，所以，一般来说，我们约定请求对象的字段主要是基本类型。而 service 的参数对象，因为它已经是核心业务的一部分，就需要全部转化为业务对象。举个例子，比如，同样表示价格，在请求对象中，我们可以是一个 double 类型，而在业务参数对象中，它应该是 Price 类型。

我们再来解决 resource 层参数和 service 层参数不一致的情况，现在二者分开了，那我们就很清楚地知道，其实，就是在业务参数对象构造的时候，传入必需的参数即可。比如，如果我们需要传入 userId，可以这么做：

```java
class NewBookRequest {
  public NewBookParameters toNewBookRequest(long userId) {
    ...
  }
}


@PostMapping("/books")
public NewBookResponse createBook(final NewBookRequest request, final Authentication authentication) {
  long userId = getUserIdentity(authentication);
  boolean result = this.service.createBook(request.toNewBookParameter(userId));
  ...
}
```

我们之所以能注意到这个坏味道，就是从依赖关系入手发现的问题。我当初注意到这段代码，因为我团队内部的约定是，所有的请求对象都属于 resource 层，但在这段代码里，service 层出现了 resource 层的对象，它背离了我们对依赖关系设计的约定，所以，这个问题就浮出了水面。

实际上，这个问题也是一个典型的软件设计问题：缺少防腐层。我在《10x 程序员工作法》和《软件设计之美》两个专栏都讲到过防腐层的概念，只不过，讲防腐层的时候，我举的例子都是与外部系统集成，其中的观点就是通过防腐层将外部系统和核心业务隔离开来。

而很多人初见这个例子，可能压根想不到它与防腐层的关系，那只不过是因为你对这种结构太熟悉了。其实，resource 层就是外部请求和核心业务之间的防腐层。只要理解了这一点，你就能理解这里要多构建出一个业务参数对象的意义了。那下面这段代码，想必你也能轻易地发现问题：

```java
@Entity
@Table(name = "user")
@JsonIgnoreProperties(ignoreUnknown = true)
class User {
  ...
}
```

这是一个 User 类的声明，它有 @Entity 这个 Anntation，表示它是一个业务实体的对象，但它的上面还出现了 @JsonIgnoreProperties，这是就是处理 JSON 的一个 Annotation。JSON 会在哪用到，通常都是在传输中。业务实体和传输对象应该具备的特质在同一个类中出现，显然，这也是没有构建好防腐层的结果，把两个职责混在了一起。

### 11.2 业务代码里的具体实现

好，我们再来看一段代码：

```java
@Task
public void sendBook() {
  try {
    this.service.sendBook();
  } catch (Throwable t) {
    this.feishuSender.send(new SendFailure(t)));
    throw t;
  }
}
```

这是我们在「重复代码」那一讲中提到的一个发送作品信息的函数，这里的重点在于，一旦发送过程出了问题，要通过即时通信工具发送给相关人等，以防系统出现问题无人发觉。只不过，这里给出的是它最初的样子，也就是通过飞书进行消息发送。

因为需求是通过飞书发送，所以，这里就写了飞书发送。这看上去简直是一个合理得不能再合理的做法了。但是，请稍等！这是一种符合直觉的做法，然而，它却不符合设计原则，它违反了依赖倒置原则。

我曾经在《软件设计之美》中专门用了一讲的篇幅讲解依赖倒置原则，这里我们简单回顾一下：

高层模块不应依赖于低层模块，二者应依赖于抽象。

High-level modules should not depend on low-level modules. Both should depend on abstractions.

抽象不应依赖于细节，细节应依赖于抽象。

Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.

我之所以会注意到这段代码，因为在一段业务处理中出现了一个具体的实现，也就是这里的 feishuSender。

你需要知道，业务代码中任何与业务无关的东西都是潜在的坏味道。

在这里，飞书肯定不是业务的一部分，它只是当前选择的一个具体实现。换言之，是否选择飞书，与团队当前的状态是相关的，如果哪一天团队切换即时通信软件，这个实现就需要换掉。但是，团队是不可能切换业务的，一旦切换，那就是一个完全不同的系统了。

识别一个东西是业务的一部分，还是一个可以替换的实现，我们不妨问问自己，如果不用它，是否还有其它的选择？

就像这里，飞书是可以被其它即时通信软件替换的。另外，常见的中间件，比如，Kafka、Redis、MongoDB 等等，通常也都是一个具体的实现，其它中间件都可以把它替换掉。所以，它们在业务代码里出现，那一定就是一个坏味道了。既然我们已经知道了，这些具体的东西是一种坏味道，那该怎么解决呢？你可以引入一个模型，也就是这个具体实现所要扮演的角色，通过它，将业务和具体的实现隔离开来。

```java
interface FailureSender {
  void send(SendFailure failure);
}


class FeishuFailureSenderS implements FailureSender {
  ...
}
```

这里我们通过引入一个 FailureSender，业务层只依赖于这个 FailureSender 的接口就好，而具体的飞书实现可以通过依赖注入的方式注入进去。

依赖关系是软件开发中非常重要的一个东西，然而，很多程序员在写代码的时候，由于开发习惯的原因，常常会忽略掉依赖关系这件事本身。现在已经有一些工具，可以保证我们在写代码的时候，不会出现严重破坏依赖关系的情况，比如，像前面那种 service 层调用 resource 层的代码。

在 Java 世界里，我们就可以用 ArchUnit 来保证这一切。看名字就不难发现，它是把这种架构层面的检查做成了单元测试，下面就是这样的一个单元测试：

[Unit test your Java architecture - ArchUnit](https://www.archunit.org/)

```java
@Test
public void should_follow_arch_rule() {
  JavaClasses clazz = new ClassFileImporter().importPackages("...");
  ArchRule rule = layeredArchitecture()
        .layer("Resource").definedBy("..resource..")
        .layer("Service").definedBy("..service..")
        .whereLayer("Resource").mayNotBeAccessedByAnyLayer()
        .whereLayer("Service").mayOnlyBeAccessedByLayers("Resource");
        
   rule.check(clazz);       
}
```

在这里，我们定义了两个层，分别是 Resource 层和 Service 层，而且我们要求 Resource 层的代码不能被其它层访问，而 Service 层的代码只能由 Resource 层方法访问。这就是我们的架构规则，一旦代码里有违反这个架构规则的代码，这个测试就会失败，问题也就会暴露出来。

### 黑板墙

思考题：今天我们讲到了依赖关系，你可以用今天讲到的坏味道衡量一下自己的代码，看有哪些代码是有问题的。

对照 DDD，是否可以理解为接口层接收 DTO，转换为 DO 后传入业务层？那么缺少防腐层的问题也可能发生在业务层和持久化层之间，比如业务层直接操作持久化对象（PO）？相比把 DTO 当成 DO 用，把 PO 当 DO 用似乎更常见。除了违反单一职责原则之外，实际使用中似乎问题不大，因为很多系统都是从先从数据表开始设计的。郑老师对此怎么看？作者回复：严格地说，持久化对象也应该与业务对象分开，但在实际的项目中，一般来说，持久化对象和业务对象是合在一起的，这么做的主要原因就是，一般持久化都是一个系统在内部完成的，对于一个系统而言，是一种可控的变化。2021-01-23

老师，如果后期把飞书替换成别的消息发送，需要怎么做呢？假如换成 email 的话，新建一个继承那个 FailureSender 接口的 EmailFailureSenderImp 然后加上 @Service，再把飞书的那个服务的 @Service 注释或删除掉吗？作者回复：这是依赖注入怎么做的事，依赖注入的 bean 其实都是有名字的，可以指定一个名字就好了，也就是 Qulifier。2021-01-28

汇总：1）所以说，按 ddd 的分层。应用层不能接收 dto，应当新建一个参数类（这样工厂类的实现不依赖 dto 倒是很好保证了）？那么这个参数类归属什么？感觉不属于实体也不属于值对象。2）dto 转 pojo 感觉还是不好。虽然从职责分配的角度看，dto 能满足 pojo 创建的诉求，所以归属到 dto 做 pojo 的工厂方法。但这样 dto 就依赖了 pojo，而这个依赖是非强必要的，所以减少依赖可能更好，借助工具单独实现一个 dto 转 pojo 的转换器。作者回复：参数类属于业务层，不用纠结它属于什么，它就是一个参数。具体的转换其实就是一个工厂方法，放到 Request 里面而不是单独放置，就不用多谢一个额外的类了。2021-01-26

看了 bob 大叔的干净架构后就改成这样了。作者回复：你基本上已经理解了 Clean Code。2021-01-25

提供稳定的接口，去除不稳定的实现。作者回复：接口要稳定，实现可以变。2021-01-25

## 0112不一致的代码为什么你的代码总被吐槽难懂.md

### 总结时刻

今天我们讲了因为不一致导致的一些问题，对于一个团队来说，一致是非常重要的，是降低集体认知成本的重要方式。我们分别见识了：1）命名中的不一致；2）方案中的不一致；3）代码中的不一致。

我们知道了，类似含义的代码应该有类似的命名，不一致的命名表示不同的含义，需要给出一个有效的解释。方案中的不一致，一方面是由于代码长期演化造成的，另一方面是项目中存在完成同样功能的程序库。无论是哪种原因，都需要团队先统一约定，保证所有人按照同一种方式编写代码。代码中的不一致常常是把不同层次的代码写在了一起，最典型的就是把业务层面的代码和实现细节的代码混在一起。解决这种问题的方式，就是通过提取方法，把不同层次的代码放到不同的函数里，而这一切的前提还是是分离关注点，这个代码问题的背后还是设计问题。如果今天的内容你只能记住一件事，那请记住：保持代码在各个层面上的一致性。

### 12.0

上一讲，我们讲了从依赖关系引申出来的坏味道，从代码本身看，这些坏味道并不如之前讲的那些，有非常明显的标识，一眼就能看出问题，但它们都属于问题高发的地带，一不小心就陷入其中，却不知所以。对于这类的问题，我们需要额外打起精神来发现问题。

今天，我们再来看一类需要你打起精神的坏味道，它们的出发点也是来自同一个根源：一致性。

大多数程序员都是在一个团队中工作，对于一个团队而言，一致性是非常重要的一件事。因为不一致会造成认知上的负担，在一个系统中，做类似的事情，却有不同的做法，或者起到类似作用的事物，却有不同的名字，这会让人产生困惑。所以，即便是不甚理想的标准，也比百花齐放要好。

大部分程序员对于一致性本身的重要性是有认知的。但通常来说，大家理解的一致性都表现在比较大的方面，比如，数据库访问是叫 DAO 还是叫 Mapper，抑或是 Repository，在一个团队内，这是有统一标准的，但编码的层面上，要求往往就不是那么细致了。所以，我们才会看到在代码细节上呈现出了各种不一致。我们还是从一段具体的代码来分析问题。

### 12.1 命名中的不一致

有一次，我在代码评审中看到了这样一段代码：

```java
enum DistributionChannel {
  ​WEBSITE
  ​KINDLE_ONLY
  ​ALL
}
```

这段代码使用标记作品的分发渠道，从这段代码的内容上，我们可以看到，目前的分发渠道包括网站（WEBSITE）、只在 Kindle（KINDLE_ONLY），还是全渠道（ALL）。

面对这段代码，我有些疑惑，于是我提了一个问题：

我：这里的 WEBSITE 和 KINDLE_ONLY 分别表示的是什么？

同事：WEBSITE 表示作品只会在我们自己的网站发布，KINDLE_ONLY 表示这部作品只会在 Kindle 的电子书商店里上架。

我：二者是不是都表示只在单独一个渠道发布？

同事：是啊！

我：既然二者都有只在一个平台上架发布的含义，为什么不都叫 XXX 或者 XXX_ONLY？

同事：呃，你说得有道理。

我之所以会注意到这里的问题，一个主要的原因就是，在这里 WEBSITE 和 KINDLE_ONLY 两个名字的不一致。

按照我对一致性的理解，表示类似含义的代码应该有一致的名字，比如，很多团队里都会把业务写到服务层，各种服务的命名也通常都是 XXXService，像 BookService、ChapterService 等等。而一旦出现了不一致的名字，通常都表示不同的含义，比如，对于那些非业务入口的业务组件，它们的名字就会不一样，会更符合其具体业务行为，像 BookSender ，它表示将作品发送到翻译引擎。

一般来说，枚举值表示的含义应该都有一致的业务含义，一旦出现不同，我就需要确定不同的点到底在哪里，这就是我提问的缘由。

显然，这段代码的作者给这两个枚举值命名时，只是分别考虑了它应该起什么名字，却忽略了这个枚举值在整体中扮演的角色。

理解这一点，改动是很容易，后来，代码被统一成了一个形式：

```java
enum DistributionChannel {
  ​WEBSITE
  ​KINDLE
  ​ALL
}
```

### 12.2 方案中的不一致

还是在一次代码评审中，我看到了这样一段代码：

```java
public String nowTimestamp() {
  DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  Date now = new Date();
  return format.format(now);
}
```

这是一段生成时间戳的代码，当一个系统向另外一个系统发送请求时，需要带一个时间戳过去，这里就是把这个时间戳按照一定格式转成了字符串类型，主要就是传输用，便于另外的系统进行识别，也方便在开发过程中进行调试。

我先声明一下，这段代码本身的实现是没有问题的。它甚至考虑到了 SimpleDateFormat 这个类本身存在的多线程问题，所以，它每次去创建了一个新的 SimpleDateFormat 对象。

[代码之丑（十二）—— 无状态方法-InfoQ](https://www.infoq.cn/article/2012/06/ugly-code-12)

那我为什么还说它是有问题的呢？因为这种写法是 Java 8 之前的写法，而我们用的 Java 版本是 Java 8 之后的。

在很长的一段时间里，Java 的日期时间解决方案一直是一个备受争议的设计，它的问题很多，有的是概念容易让人混淆（比如：Date 和 Calendar 什么情况下该用哪个），有的是接口设计的不直观（比如：Date 的 setMonth 参数是从 0 到 11），有的是实现容易造成问题（比如：前面提到的 SimpleDateFormat 需要考虑多线程并发的问题，需要每次构建一个新的对象出来）。

这种乱象存在了很长时间，有很多人都在尝试解决这个问题（比如 Joda Time）。从 Java 8 开始，Java 官方的 SDK 借鉴了各种程序库，引入了全新的日期时间解决方案。这套解决方案与原有的解决方案是完全独立的，也就是说，使用这套全新的解决方案完全可以应对我们的所有工作。

[Joda-Time - Home](https://www.joda.org/joda-time/)

我们现在的这个项目是一个全新的项目，我们使用的版本是 Java 11，这就意味着我们完全可以使用这套从 Java 8 引入的日期时间解决方案。所以，我们在项目里的约定就是所有的日期时间类型就是使用这套新的解决方案。

现在你可能已经知道我说的问题在哪里了，在这个项目里，我们的要求是使用新的日期时间解决方案，而这里的 SimpleDateFormat 和 Date 是旧解决方案的一部分。所以，虽然这段代码本身的实现是没有问题的，然而，放在项目整体中，这却是一个坏味道，因为它没有和其它的部分保持一致。

后来，同事用新的解决方案改写了原来的代码：

```java
public String nowTimestamp() {
  ​LocalDateTime now = LocalDateTime.now()
  return now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
}
```

之所以会出现这样的问题，主要是因为一个项目中，应对同一个问题出现了多个解决方案，如果没有一个统一的约定，项目成员会根据自己写代码时的感觉随机选择一个方案，这样的结果就是出现方案上的不一致。

为什么一个项目中会出现多个解决方案呢？一个原因就是时间。随着时间流逝，人们会意识到原有解决方案存在的各种问题，于是，有人就会提出新的解决方案，像我们这里提到的 Java 日期时间的解决方案，就是 JDK 本身随时间演化造成的。有的项目时间比较长，也会出现类似的问题，尤其是像 C/C++ 这种自造轮子的重灾区。我曾经在 InfoQ 上讲过一个例子，在一段代码里同时出现了两种字符串类型。

有时，程序员也会因为自己的原因引入不一致。比如，在代码中引入做同一件事情类似的程序库。像判断字符串是否为空或空字符串，Java 里常用的程序库就有 Guava 和 Apache 的 Commons Lang，它们能做类似的事情，所以，程序员也会根据自己的熟悉程度选择其中之一来用，造成代码中出现不一致。

3『

[代码之丑（八）—— 不一致的困惑-InfoQ](https://www.infoq.cn/article/2010/12/ugly-code-8)

[StringUtils (Apache Commons Lang 3.12.0 API)](http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html)

[Strings (Guava: Google Core Libraries for Java HEAD-jre-SNAPSHOT API)](https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Strings.html)

』

这两个程序库是很多程序库的基础，经常因为引入了其它程序库，相应的依赖就出现在我们的代码中。所以，我们必须约定，哪种做法是我们在项目中的标准做法，以防出现各自为战的现象。比如，在我的团队中，我们就选择 Guava 作为基础库，因为相对来说，它的风格更现代，所以，团队就约定类似的操作都以 Guava 为准。

### 12.3 代码中的不一致

我们再来看一段代码：

```java
public void createBook(final List<BookId> bookIds) throws IOException {
  ​List<Book> books = bookService.getApprovedBook(bookIds)
  ​CreateBookParameter parameter = toCreateBookParameter(books)
  ​HttpPost post = createBookHttpRequest(parameter)
  ​httpClient.execute(post)
}
```

这是一段在翻译引擎中创建作品的代码。首先，根据要处理的作品 ID 获取其中已经审核通过的作品，然后，发送一个 HTTP 请求在翻译引擎中创建出这个作品。

这么短的一段代码有什么问题吗？问题就在于这段代码中的不一致。你可能会想：「不一致？不一致体现在哪里呢？」答案就是，这些代码不是一个层次的代码。

通过了解这段代码的背景，你可能已经看出一些端倪了。首先是获取审核通过的作品，这是一个业务动作，接下来的三行其实是在做一件事，也就是发送创建作品的请求。具体到代码上，这三行代码分别是创建请求的参数，根据参数创建请求，最后，再把请求发送出去。这三行代码合起来完成了一个发送创建作品请求这么一件事，而这件事才是一个完整的业务动作。

所以，我说这个函数里的代码并不在一个层次上，有的是业务动作，有的是业务动作的细节。理解了这一点，我们就可以把这些业务细节的代码提取到一个函数里：

```java
public void createBook(final List<BookId> bookIds) throws IOException {
  ​List<Book> books = bookService.getApprovedBook(bookIds)
  ​createRemoteBook(books)
}


private void createRemoteBook(List<Book> books) throws IOException {
  ​CreateBookParameter parameter = toCreateBookParameter(books)
  ​HttpPost post = createBookHttpRequest(parameter)
  ​httpClient.execute(post)
}
```

从结果上看，原来的函数（createBook）里面全都是业务动作，而提取出来的函数（createRemoteBook）则都是业务动作的细节，各自的语句都是在一个层次上了。

能够分清楚代码处于不同的层次，基本功还是分离关注点，这一点，我在《软件设计之美》这个专栏里已经多次强调了。

一旦我们将不同的关注点分解出来，我们还可以进一步调整代码的结构。像前面拆分出来的这个方法，我们已经知道它的作用是发出一个请求去创建作品，本质上并不属于这个业务类的一部分。所以，我们还可以通过引入一个新的模型，将这个部分调整出去：

```java
public void createBook(final List<BookId> bookIds) throws IOException {
  List<Book> books = this.bookService.getApprovedBook(bookIds);
  this.translationEngine.createBook(books);
}


class TranslationEngine {
  public void createBook(List<Book> books) throws IOException {
    ​CreateBookParameter parameter = toCreateBookParameter(books)
    ​HttpPost post = createBookHttpRequest(parameter)
    ​httpClient.execute(post)
  ​
  ​..
}
```

我估计，这段代码的调整，超出了很多人对于「代码应该怎么写」的认知范围。一说到分层，大多数人想到的只是模型的分层，很少有人会想到在函数的语句中也要分层。各种层次的代码混在一起，许多问题也就随之而来了，最典型莫过于我们之前讲过的长函数。

从本质上说，我们在做的依然是模型的分层，只不过，这次的出发点是函数的语句。这也是我一直强调的「分离关注点，越小越好」的意义所在。观察代码的粒度足够小，很多问题自然就会暴露出来。

这里我顺便说一个与测试相关的话题，程序员开始写测试时，有一个典型的问题：如何测试一个私有方法。有人建议用一些特殊能力（比如反射）去测试。我给这个问题的答案是，不要测私有方法。

之所以有测试私有方法的需求，一个重要的原因就是分离关注点没有做好，把不同层次的代码混在了一起。前面这段代码，如果要测试前面那个 createRemoteBook 方法还是有一定难度的，但调整之后，引入了 TranslationEngine 这个类，这个方法就变成了一个公开方法，我们就可以按照一个公开方法去测试了，所有的问题迎刃而解。

很多程序员纠结的技术问题，其实是一个软件设计问题，不要通过奇技淫巧去解决一个本来不应该被解决的问题。

### 黑板墙

思考题：对于一致性的认知，我相信大家都有。但是，对于不同层次的代码混在一起可能是很多人都没有注意过的，你可以查看一下自己的代码，看看有哪些不同层次的代码混在了一起。欢迎在留言区写下你看到的代码，你身边要是有人写出了不一致的代码。

把每一件事做细致，做扎实，做到极致，不能有一丝的懈怠，专业力自然就呈现出来了，省力要看长期，当下花的功夫，收益要到需求有变化时才能充分体现出来。作者回复：这种想法我很认同，只是能坚持的人太少了。2021-01-26

看了之后反思，再去读原先代码，用新的指导去小规模重构代码，虽然进度会慢些，但是稳。作者回复：加油！2021-01-27

很多程序员纠结的技术问题，其实是一个软件设计问题。好经典的描述。2021-01-31

## 0113落后的代码风格使用新的语言特性和程序库升级你的代码.md

### 总结时刻

今天我们讲了「新」风格对于代码的改善。每一种有生命力的语言都会在自己的生命周期中不断地对语言本身进行改进，无论是引入新的语言特性，还是引入新的程序库，都会对代码的编写产生或多或少的影响。这一讲，我们用来讲解的例子是 Java 8 引入的 Optional 和函数式编程。

Optional 是一个对象容器，它的出现是为了规避空对象带来的各种问题。Optional 的引入可以减少由于程序员的忽略而引发对空对象的问题。团队内部可以约定，所有可能返回空对象的地方，都要返回 Optional，以此降低犯错的几率。

函数式编程是一个影响代码整体风格的重要编程范式，然而，对于很多 Java 程序员来说，Java 8 引入的函数式编程支持，只是引入了一些新的程序库。缺乏对于函数式编程的理解，尤其是对于列表转换思维的理解，让我们虽然有了很多很好的工具，却完全无法发挥其功效。

懂得列表转换思维，首先要懂得最基本的几个操作：map、filter 和 reduce，然后，就可以把大部分的集合操作转换成列表转换。想要使用这种思维写好代码，一方面，要懂得声明式代码的重要性，另一方面，要懂得写出短小的函数，不要在 lambda 中写过多的代码。

作为一个精进的程序员，我们要不断地学习「新」的代码风格，改善自己的代码质量，不要故步自封，让自己停留在上一个时代。如果今天的内容你只能记住一件事，那请记住：不断学习「新」的代码风格，不断改善自己的代码。

### 13.0

上一讲，我们讲的是因为代码不一致造成的坏味道，其中我提到的「方案不一致」，是因为随着时间的流逝，总会有一些新的方案产生，替换原有的方案。这其中，最明显的一个例子就是程序设计语言。没有哪门语言是完美的，所以，只要有一个活跃的社区，这门语言就会不断地演进。

从 C++ 11 开始，C++ 开始出现了大规模的演化，让之前学习 C++ 的人感觉自己就像没学过这门语言一样；Python 2 与 Python 3 甚至是不兼容的演化；Java 也是每隔一段时间就会出现一次大的语言演进。也正是因为语言本身的演化，在不同时期接触不同版本的程序员写出来的程序，甚至不像是在用同一门语言在编程。所以，我们有机会看到在同一个代码库中，各种不同时期风格的代码并存。

通常来说，新的语言特性都是为了提高代码的表达性，减少犯错误的几率。所以，在实践中，我是非常鼓励你采用新的语言特性写代码的。

这一讲，我们就以 Java 为例，讲讲如何使用「新」语言特性让代码写得更好。其实，这里的「新」只是相对的，我准备讨论的是 Java 8 的语言特性，按照官方的标准，这是一个已经到了生命周期终点的版本，只不过，从语言特性上来说，Java 8 是最近有重大变更的一个版本，而很多程序员的编码习惯停留在更早的版本。

### 13.1 Optional

我们先来看一段代码：

```java
String name = book.getAuthor().getName();
```

这是我们在讲「缺乏封装」时用到的一个例子，我们这里暂且不考虑缺乏封装的问题。即便如此，严格地说，这段代码依然是有问题的。因为它没有考虑对象可能为 null 的场景。

所以，这段代码更严谨的写法是这样：

```java
Author author = book.getAuthor();
String name = (author == null) ? null : author.getName();
```

然而，在很多真实的项目中，这种严格的写法却是稀有的，所以，在实际的运行过程中，我们总会惊喜地发现各种空指针异常。如果你要问程序员为什么不写对象为 null 的判断，答案很可能出乎你意料：他们忘了。

是的，忘了，就是这么简单得令人发指的理由。不用过于责备这些程序员缺乏职业素养，因为这不是个体问题，而是行业整体的问题，IT 行业每年都会因此造成巨大的损失。空指针的发明者 Tony Hoare 将其称为「自己犯下的十亿美元错误」。

对于这个如此常见的问题，Java 8 中已经给出了一个解决方案，它就是 Optional。Optional 提供了一个对象容器，你需要从中「取出」（get）你所需要的对象，但在取出之前，你需要判断一下这个对象容器中是否真的存在一个对象。用这个思路可以这样改写这段代码：

```java
class Book {
  public Optional<Author> getAuthor() {
    return Optioanl.ofNullable(this.author);
  }
  ...
}


Optional<Author> author = book.getAuthor();
String name = author.isPresent() ? author.get().getName() : null;
```

这种做法和之前做法的最大差别在于，你不会忘掉判断对象是否存在的过程，因为你需要从 Optional 这个对象容器中取出存在里面的对象。正是这多出来的一步，减少了「忘了」的概率。也是因为多了 Optional 这个类，这段代码其实还有更简洁的写法：

```java
Optional<Author> author = book.getAuthor();
String name = author.map(Author::getName).orElse(null);
```

有了 Optional，我们可以在项目中做一个约定，所有可能为 null 的返回值，都要返回 Optional，以此减少犯错的几率。关于 Optional，我在《软件设计之美》中花了专门的篇幅进行了介绍，你有兴趣的话，不妨进一步了解一下。

事实上，鉴于空对象是一个普遍存在的问题，一些程序设计语言甚至为此专门设计了语法，比如，类似的代码用 Kotlin 或 Groovy 写出来的话，应该是这下面这样：

```java
val author = book.author
val name = author?.name
```

### 13.2 函数式编程

Optional 是 Java 8 引入的新特性，它的出现改变了编写 Java 代码的习惯用法。接下来，我们来看看另外一个改变我们代码习惯用法的特性。

在讲「滥用控制语句」那一讲时，我留下了一个尾巴，说循环语句本身就是一个坏味道。接下来，我们就来说一下这个问题。我们还是先从一段代码开始：

```java
public ChapterParameters toParameters(final List<Chapter> chapters) {
  List<ChapterParameter> parameters = new ArrayList<>();
  for (Chapter chapter : chapters) {
    if (chapter.isApproved()) {
      parameters.add(toChapterParameter(chapter));
    }
  }
  
  return new ChapterParameters(parameters);
}
```

这是一段向翻译引擎发送章节信息前准备参数的代码，这里首先筛选出审核通过的章节，然后，再把章节转换成与翻译引擎通信的格式，最后，再把所有得到的单个参数打包成一个完整的章节参数。

如果按照 Java 8 之前的版本理解，这段代码是一段很正常的代码。当 Java 的时代进入到 8 之后，这段代码就成了有坏味道的代码。

Martin Fowler 在《重构》的第二版中新增的坏味道就包括了循环语句（Loops）。之所以循环语句成了坏味道，一个重要的原因就是函数式编程的兴起。不是我们不需要遍历集合，而是我们有了更好的遍历集合的方式。

我在《软件设计之美》讲函数式编程的组合性时曾经提到过，函数式编程的一个重要洞见就是，大部分操作都可以归结成列表转换，其中，最核心的列表转换就是 map、filter 和 reduce。在函数式编程日益重要的今天，列表转换已经成为了每个程序员应该必备的基本功。

了解了这些，你就知道为什么循环语句是坏味道了，因为大部分循环语句都是在对一个元素集合进行操作，而这些操作基本上都可以用列表操作进行替代。

再者，一般来说，采用列表转换写出来的代码相较于传统的循环语句写出来的代码，表达性更好，因为它们都是描述做什么，而传统的循环语句是在描述怎么做。我在这个专栏已经多次说过了，这是两种不同的抽象层次，描述做什么比怎么做的代码，在表达性上要好得多。

有了这些基础，我们再来看这段代码。这段代码中有一个循环语句，正如前面所说，这个循环语句在处理的是一个集合中的元素，所以，这个循环语句是可以用列表转换的方式代替的。

具体怎么做呢？其实，这里的行为我们在前面已经分析过了，就是先筛选出审核通过的章节，这个过程对应着 filter，然后，把筛选出来的章节转换成通信中的参数，这个过程对应着 map，最后，把转换的结果搜集起来，这个过程对应着 reduce。所以，这段代码可以改写成这样：

```java
public ChapterParameters toParameters(final List<Chapter> chapters) {
  List<ChapterParameter> parameters = chapters.stream()
    .filter(Chapter::isApproved)
    .map(this::toChapterParameter)
    .collect(Collectors.toList());
  return new ChapterParameters(parameters);
}
```

经过这样的改造，一个循环语句就彻底被一个列表转换的操作替换掉了（这里的 collect 函数对应着 reduce 操作）。在这段代码中，我们用到了 Java 8 提供的一些基础设施，比如，Stream、lambda 和方法引用等等。

或许有人会说，这段代码看着还不如我原来的循环语句简单。不过，你要知道，两种写法根本的差别是侧重点不同，循环语句是在描述实现细节，而列表转换的写法是在描述做什么，二者的抽象层次不同。

对于理解这段代码的人来说，二者提供的信息量是完全不同的，循环语句必须要做一次「阅读理解」知晓了其中的细节才能把整个场景拼出来，而列表转换的写法则基本上和我们用语言叙述的过程一一对应。所以，理解的难度是完全不同的。这段代码只是为了说明问题，而选择了简单的代码，但在实际工作中，需求会比这复杂得多。而且，如果要添加新的需求，循环语句里的代码会随之变得越来越复杂，原因就是循环语句里都是细节，而列表转换则是一段一段的描述，就像在阅读一篇文章。

很多人之所以更喜欢使用循环语句而不是列表转换，一个重要原因是对于列表转换的基础还不了解。只要多写几次 filter、map 和 reduce，理解它们就会像理解选择语句和循环语句一样自然。

到这里有人会说：「你说得有点道理，但为什么我的感觉和你不一样，在实践中，我也使用了这种风格，为什么写出来的代码感觉更难理解了？」对于这一点，一个常见的原因就是，你在列表转换过程中写了太多代码。

自从 Java 里引入了 lambda，因为写起来实在是太容易了，很多人就直接在列表转换过程中写 lambda。lambda 本身相当于一个匿名函数，所以，很多人在写函数中犯的错误在 lambda 里也一样出现了，最典型的当然就是长函数。

在各种程序设计语言中，lambda 都是为了写短小代码提供的便利，所以，lambda 中写出大片的代码，根本就是违反 lambda 设计初衷的。最好的 lambda 应该只有一行代码。

那如果一个转换过程中有很多操作怎么办呢？很简单，提取出一个函数，就像前面代码中的 toChapterParameter，它负责完成从 Chapter 到 ChapterParameter 的转换。这样一来，列表转换的本身就完全变成了一个声明，这样的写法才是能发挥出列表转换价值的写法。

在这一讲中，我们以 Optional 和函数式编程为例，讲解了用「新」的代码风格改进代码，其实，我们在前面的内容中也已经讲了不少「新」的代码风格，比如，使用 Java 8 的时间日期类型、try-with-resource 等等。在讲解的过程中，我也提到过不少的编码风格实际上是停留在过去，比如，变量初始化的习惯。

你可以看到，代码风格有一个逐步演化的过程，每个程序员对此的理解程度都有所差异，所以，如果我们不加注意的话，各种代码风格会并存于代码之中，加剧代码的理解难度，这就是我们上一讲讲到的坏味道：不一致。

一种编程风格会过时，本质上是因为它存在问题，新代码风格就是用更好的方案解决它，就像今天讲到的 Optional。所以，我们要不断学习新引入的语言特性，了解它们给语言带来的「新」风格，而不要停留在原地。

### 黑板墙

思考题：这一讲，我们讲到了不同的代码风格，你有体验过不同的代码风格对于代码库的影响吗？对于团队来说，逐步将统一将语言特性和程序库统一到新的风格上是一件很重要的事。

感觉多写了 Optional ，代码变得更加累赘了？毕竟这是一种实现细节，如果混在业务代码里面，是不是也是一种坏味道呢？作者回复：看你怎么评价什么算是累赘了，这是一种减少犯错几率的做法，另外，Optional 本身有很多方法可以简化代码的编写。Optional 也是一种需要习惯的构造块，和函数式编程的其它内容是一样的，需要适应一下，适应之后，它就是和 if、for 之类一样的东西。2021-01-28

我认为 Stream 语言设计上有疏忽。问题： Stream 的语意表示一次数据流，或者说一次循环。所以不管是 map 还是 filter 都是在这一次循环中每个元素执行的一个 job。然而 stream 却有 `.parallel()` 和 `.sequential()` 的语意，感觉起来就像是可以随意改变当前这一次数据流的执行方式，但实际上一次数据流只能有一种执行方式。结论：应该是 get 出并行的 `parallelStream()` 或者 get 出串行的 `sequentiaStream()`，这样在语意上会更明确些。毕竟执行方式在 stream 中是一个排他项，他不该被变更。作者回复：`.parallel()` 和 `.sequential()`，除非明确地知道执行结果，否则，不要使用。2021-01-31

```java
Optional<Author> author = book.getAuthor();
String name = author.orElse(null);
-> String name = author.map(Author::getName).orElse(null);
```

原理：因为 Optional 内部做了判空处理。好处：更语意化的表达。个人见解：这里 `author.map(Author::getName).orElse (null);` 刚开始用时，会觉得 map 里面会报空指针的问题，因为在执行 map 时感觉就会抛出异常。个人认为这有违常规 java 开发的心智模型。因为 java 开发习惯了 null 的存在，因而在 map 中做空判断，就像是在 map 中偷偷多做了一件事，有点超出预期？作者回复：多谢提示，已经修改。心智模型就是要不断提升的。2021-01-31

lambda 表达式虽然简洁，但是在代码出现 bug 的时候，不好调试。也许是集合中某个参数问题，但是通过 lambda 的 debug 时，没办法精确定位到。作者回复：现在的 IDE 可以在 lambda 里设置断点，也还好，不过，还是写测试更好。2021-01-28

对于 Optional，在 Ruby 上早期会用 try，后来版本升级改为 &. 写起来很方便。写 Ruby 的那会儿，有很多程序员是从其它语言转过去的，写出来的代码有很多前一种语言的「烙印」，团队 Leader 会要求大家时常翻看 Ruby 的代码规范，规范里有明确要求的严格按照规范来，这样尽量保持代码风格统一。作者回复：这是对的，统一风格很重要，这是上一讲的主题。2021-01-28

我是写 C＃的，像这个列表转换在 C＃中的体现就是 Linq 吧，不过一些复杂查询我都写的很长。作者回复：不完全是，Linq 的目标是构建一种查询的方式。2021-01-28

我觉得应该是把 Optional 给封装到一个模型中，然后模型标记可能 @Nullable。一来我认为隐藏了于业务无关的空判断，二来，其他调用者不用再写一个相同的判断语句。作者回复：如果有更好的 Optional 解决方案，可能是语法的改进，就像 Groovy 和 Kotlin 那样。2021-02-08