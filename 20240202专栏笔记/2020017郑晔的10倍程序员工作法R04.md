## 记忆时间

## 目录

0401懒惰应该是所有程序员的骄傲.md

0402一个好的项目自动化应该是什么样子的.md

0403程序员怎么学习运维知识.md

0404持续交付有持续集成就够了吗.md

0405如何做好验收测试.md

0406你的代码是怎么变混乱的.md

0407总是在说 MVC 分层架构但你真的理解分层吗.md

0408为什么总有人觉得 5 万块钱可以做一个淘宝.md

0409先做好 DDD 再谈微服务.md

0410答疑解惑持续集成持续交付然后呢.md

0411加餐你真的了解重构吗.md

## 0400自动化.md

1、将你的工作过程自动化。

2、请谨慎地将工作自动化。

3、有体系地学习运维知识。

4、将部署纳入开发的考量。

5、将验收测试自动化。

6、把函数写短。

7、构建好你的领域模型。服务端三层架构的来龙去脉；分层架构实际是一种设计上的分解，将不同的内容放在不同的地方，降低软件开发和维护的成本。分层，更关键的是，提供抽象。这种分层抽象在计算机领域无处不在，无论是编程语言，还是网络协议，都体现着分层抽象的价值。有了分层抽象，人们才能更好地在抽象的基础上构建更复杂的东西；应该把精力重点放在构建自己的领域模型上，因为它才是工作最核心、不易变的东西。

9、学习领域驱动设计。

10、锤炼你的重构技能。重构，本质上就是一堆微操作。重构这个实践的核心，就是将调整代码的动作分解成一个一个的小动作，如果不能理解这一点，你就很难理解重构本身的价值。既然重构的核心也是分解，它就需要大量的锤炼。就像之前提到任务分解原则一样，我在重构上也下了很大的功夫做了专门的练习，才能让自己一小步一小步地去做。

程序员的三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris），小心 NIH 综合症（Not Invented Here Syndrome）；写好构建脚本，做好项目自动化；参照 Java 知识体系，学习运维知识；软件设计最基础的原则是「高内聚、低耦合」。分层架构是一种设计上的分解。不同业务量的系统本质上不是一个系统；采用简单技术解决问题，直到问题变复杂。

一些重点内容汇总：

1、持续交付。将生产部署纳入了开发的考量。持续交付的基础设施通常包含持续集成环境、测试环境、预生产环境和生产环境。构建流水线保证到了下游的交付物一定是通过上游验证的。随着 Docker 的诞生，交付由发布包变成了 Docker 镜像。

2、DevOps。将开发和运维结合到一起。环境配置工具上的进步，让基础设施即代码成了行业共识。

3、验收测试。验收测试要站在业务的角度编写。BDD 是一种编写验收测试的方式。Given…When…Then… 的描述给了一个描述业务的统一方式。写好验收测试，需要构建测试模型。

4、SOLID 原则。设计模式背后的道理。单一职责原则（Single responsibility principle，SRP）、开放封闭原则（Open–closed principle，OCP）、Liskov 替换原则（Liskov substitution principle，LSP）、接口隔离原则（Interface segregation principle，ISP）、依赖倒置原则（Dependency inversion principle，DIP）。用好单一职责原则，前提条件是看待问题颗粒度要小。

5、DDD。它将思考的起点拉到了业务上。DDD 分为战略设计和战术设计。

6、微服务。做好微服务的前提是划分好限界上下文。微服务的第一步，不要划分微服务。

7、一些额外收获：1）持续集成的延伸。a）持续集成完成系统集成。b）持续交付完成可部署上线。c）「持续验证」完成产品想法验证。2）AB 测试，用一个软件的多个版本验证想法。3）Selenium 用以完成浏览器的自动化。4）熟练使用快捷键。

留言精选汇总：

在讲到「懒惰」应该是所有程序员的骄傲时，jxin 同学提到：有价值的事并不局限性于事情本身。做自动化很重要，写代码很重要。但根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解。权衡跟设计是件很艺术的事情，令人着迷。

另外，关于持续交付，Jxin 同学也提出了自己的理解：分而治之是解决复杂问题的一大利器。持续交互就像重构中小步快走（每次微调后运行测试代码验证），都能保证大工程的稳步前进。同时由于单元小了，所以也灵活了，持续交互可以结合最小产品的理念，以小成本做 test，收集数据后，即时调整产品发展方向。

关于软件设计，毅同学分享了自己的感悟：我们常说任务到手不要着急去做，要从设计入手，把时间多花在前面。工作中发现大家都是思考了才动手的，那为什么越往后偏差越大呢？共性原因有二：一是全局观不够，用咱们课里的话说就是上下文局限和反馈延迟（看到问题不提，直到代码写到那绕不过去了再沟通）；二是没有领域的概念和有意识地去实践（纸上谈兵），尤其是做流程型任务，都喜欢先把表结构定义出来，再去生成实体，所以从领域层面来看这些实体就很不合适了。结果必然是用面向对象的工具写出了面向过程的代码，既然是面向过程那 OO 设计原则就鲜有用武之地了。这两点也是我个人理解要做好软件设计的两个必要条件。

讲到分层架构时，desmond 同学提到：学了 REST 和 DDD，感觉两者有相通的地方：两者都以数据（一个是资源，另外一个是领域对象）为中心，并制定一套标准的数据操作（一个是 HTTP Verb，另外一个我项目主要用 JPA 这一套）；而核心是业务建模。

对于微服务的理解，风翱同学提到：公司说我们的开发方式是敏捷开发，实际上只是使用了一些敏捷开发的方法，只有遵守敏捷开发的价值观和原则，才能算是敏捷开发。微服务也是一样，不是说拆分成多个服务去部署，就叫做微服务。也不是采用市面上常用的微服务框架，就是微服务了。

对于一个好的项目自动化应该是什么样子这个问题，西西弗与卡夫卡同学提到：设想过这样的情景（还没实现，打算实践一把）：我们新招一名比较熟练的程序员，从 TA 入职拿到机器，到开发示意代码，再提交 SCM，然后 CI/CD，再发布到线上交付给用户，整个过程可以在入职当天的午饭之前完成。这不光要求构建和集成自动化，甚至要求从入职开始的各个环节都能提前准备好，包括机器、开发环境、线上环境等，甚至连示范的需求都要能及时传递给 TA。理想情况下，程序员只需要开发好程序，保证质量，提交到 SCM 即可，其他事情都应该交给机器。要知道程序员都很贵，越早给用户交付价值越好。

对于自动化验收测试，shniu 同学分享了他的学习感悟：自动化验收测试确实是很好的东西，比如在回归测试，省去了很多的重复工作。但我理解 BDD 的初衷是驱动产品、业务、开发、测试等去深入讨论沟通需求，在还没有真的写代码的时候去实例化 story，并一起定义验收用例，让每个人对需求的理解都很透彻，当然特别注意的是要从统一的业务角度去描述，可见，真的做好 BDD 是需要不断的尝试和总结的。

对于「5 万块做淘宝」这个话题，enjoylearning 同学提到：做一个淘宝那样的，客户指的是业务类似，但用户量多少，需要多少并发数，搜索性能等如何都是需要跟客户沟通后才能决定技术选型的。现实中我们的有些系统已经满足了业务需求，就没有必要为了追求技术复杂度而去拆分了，只有面向问题技术选型才会有成效。

关于运维知识，hua168 同学对文章内容进行了补充：现在运维流行 DevOps，高级一点就是 AI，其中一篇文章《DevOps 详解》不错，链接如下：[DevOps 详解 - InfoQ](https://www.infoq.cn/article/detail-analysis-of-devops)；《DevOps 知识体系与标准化的构建》也不错，下载地址：[DevOps 知识体系与标准化的构建 - 下载频道 - 云栖社区](https://yq.aliyun.com/download/778)；运维知识体系：[运维知识体系 v3.1「赵班长」](https://www.unixhot.com/page/ops)；Web 缓存知识体系：[缓存知识体系 v3.0「赵班长」](https://www.unixhot.com/page/cache)。

## 0410答疑解惑持续集成持续交付然后呢.md

「自动化」模块落下了帷幕，这是四个工作原则中最为「技术化」的一个，也应该是程序员们最熟悉的主题。我从软件外部的自动化 —— 工作流程讲起，让你能够把注意力专注于写好代码；讲到了软件内部的自动化 —— 软件设计，选择恰当的做法，不贪图一时痛快，为后续的工作挖下深坑。既然是一个大家都熟悉的话题，同学们自然也有很多经验分享，也有很多人看到了与自己不同的做法，提出了各种各样的问题。在今天的答疑中，我选出了几个很有意思的问题，让大家可以在已有内容上再进一步延伸。

问题 1：持续交付是否可以再做扩展？毅同学提到：为达到有效交付的目标，用户能够尽早参与，我觉得也是比较重要的一环。从生产环境获得结果，是否可再做扩展，将用户也作为一个独立节点？西西弗与卡夫卡同学提到：持续交付可以是持续交付最大价值，那范围就不仅限于软件，还可以进一步延伸到运营，比如说结合 ABTest，自动选择最有效的运营策略，为用户交付最大价值。

两位同学能提出这样的想法，说明真的是已经理解了持续集成和持续交付，所以，才能在这个基础上继续延伸，思考进一步的扩展。我在专栏中一直在强调，别把自己局限在程序员这个单一的角色中，应该了解软件开发的全生命周期。在前面的内容中，我讲了不少做产品的方法，比如，MVP、用户测试等等。如果只把自己定位在一个写代码的角色上，了解这些内容确实意义不大，但你想把自己放在一个更大的上下文中，这些内容就是必须要了解的。

回到两位同学的问题上，如果说我们一开始把持续集成定义成编写代码这件事的完成，那持续交付就把这个「完成」向前再推进了一步，只有上线的代码才算完成。但放在整个软件的生命周期来说，上线并不是终点。把系统送上线，不是最终目的。那最终目的是什么呢？回到思考的起点，我们为什么要做一个软件？因为我们要解决一个问题。那我们是不是真正的解决了问题呢？其实，我们还不知道。

在《06 | 精益创业：产品经理不靠谱，你该怎么办？》这篇文章中，我给你讲了做产品的源头。如果是采用精益创业的模式工作，我们构建产品的目的是为了验证一个想法，而怎么才算是验证了我们的想法呢？需要搜集各种数据作为证据。所以，我曾经有过这样的想法，精益创业实际上是一种持续验证，验证想法的有效性，获得经过验证的认知（Validated Learning）。

现在有一些获取验证数据的方式，比如，西西弗与卡夫卡同学提到的 AB 测试。AB 测试是一种针对两个（或多个）变体的随机试验，常常用在 Web 或 App 的界面制作过程中，分别制作两个（或多个）版本，让两组（或多组）成分相同的用户随机访问不同版本，收集数据，用以评估哪个版本更好。每次测试时，最好只有一个变量。因为如果有多个变量，你无法确认到底是哪个变量在起作用。

AB 测试的概念在其他领域由来已久。2000 年，Google 的工程师率先把它应用在了软件产品的测试中，时至今日，它已经成为很多产品团队常用的做事方式。AB 测试的前提是用户数据搜集。我在《09 | 你的工作可以用数字衡量吗？》这篇文章给你介绍了在开发过程中，用数字帮助我们改善工作。在产品领域实际上更需要用数字说话，说到这里，我「插播」一个例子。

很多产品经理喜欢讲理念、讲做法，偏偏不喜欢讲数字。用数字和产品经理沟通其实是更有说服力的。我就曾经遇到过这样的事情，在一个交易平台产品中，一个产品经理创造性地想出一种新的订单类型，声称是为了方便用户，提高资金利用率。如果程序员接受这个想法，就意味着要对系统做很大的调整。

我问了他几个问题：第一，你有没有统计过系统中现有的订单类型的使用情况？第二，你有没有了解过其他平台是否支持这种订单类型呢？产品经理一下子被我问住了。我对第一个问题的答案是，除了最基础的订单类型之外，其他的订单类型用得都很少，之前做的很多号称优化的订单类型，实际上没有几个人在用。第二个问题我的答案是，只有极少数平台支持类似的概念。换句话说，虽然我们想得很美，但教育用户的成本会非常高，为了这个可能存在的优点，对系统做大改造，实在是一件投资大回报小的事，不值得！

再回到我们的问题上，一旦决定了要做某个产品功能，首先应该回答的是如何搜集用户数据。对于前端产品，今天已经有了大量的服务，只要在代码里嵌入一段代码，收集数据就是小事一桩。前端产品还好，因为用户行为是比较一致的，买服务就好了，能生成标准的用户行为数据。对于后端的数据，虽然也有各种服务，但基本上提供的能力都是数据的采集和展示，一些所谓的标准能力只是 CPU、内存、JVM 之类基础设施的使用情况。对于应用来说，具体什么样的数据需要搜集，还需要团队自己进行设计。

1『收获到一个知识点，前端用户的行为比较一致，买服务就可以实现标准的用户行为数据，所以可以通过买服务来收集数据。（2020-11-20）』

说了这些，我其实想说的是，持续验证虽然是一个好的想法，但目前为止，还不如持续集成和持续交付这些已经有比较完整体系做支撑。想做到「持续」，就要做到自动化，想做到自动化，就要有标准化支撑，目前这个方面还是「八仙过海各显神通」的状态，没法上升到行业最佳实践的程度。其实道理上也很简单，从一无所有，到持续集成、再到持续交付，最后到持续验证，每过一关，就会有大多数团队掉队。所以，真正能达到持续交付的团队都少之又少，更别提要持续验证了。

问题 2：Selenium 和 Cucumber 的区别是什么？没有昵称同学提到：Selenium 跟 Cucumber 有区别吗？

这是一个经常有人搞混的问题。为了让不熟悉的人理解，我先讲一点背景。Selenium 是一个开源项目，它的定位是浏览器自动化，主要用于 Web 应用的测试。它最早是 Jason Huggins 在 2004 年开发出来的，用以解决 Web 前端测试难的问题。之所以取了 Selenium 这个名字，主要是用来讽刺其竞争对手 Mercury 公司开发的产品。我们知道，Mercury 是水银，而 Selenium 是硒，硒可以用来解水银的毒。又一个程序员的冷幽默！

Cucumber 的兴起伴随着 Ruby on Rails 的蓬勃发展，我们在之前的内容中提到过，Ruby on Rails 是一个改变了行业认知的 Web 开发框架。所以，Cucumber 最初主要就是用在给 Web 应用写测试上，而 Selenium 刚好是用来操作浏览器的，二者一拍即合。于是，你会在很多文章中看到，Cucumber 和 Selenium 几乎是同时出现的，这也是很多人对于二者有点傻傻分不清楚的缘由。

讲完了这些背景，结合我们之前讲的内容，你就不难理解了。Cucumber 提供的是一层业务描述框架，而它需要有自己对应的步骤实现，以便能够对被测系统进行操控；而 Selenium 就是在 Web 应用测试方面实现步骤定义的一个非常好的工具。

问题 3：IntelliJ IDEA 怎么学？hua168 同学提到：IDEA 怎么学呢？是用到什么功能再学？还是先看个大概，用到时再仔细看？

一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。遇到问题就去找相应的解决方案。如果说在 IDEA 上下过功夫，应该是在快捷键上。我最早写代码时的风格应该是鼠标与键盘齐飞，实话说，起初也没觉得怎么样。加入 ThoughtWorks 之后，看到很多人把快捷键运用得出神入化，那不是在写一行代码，而是在写一片代码。我当时有一种特别震惊的感觉。

我自以为在写代码上做得已经相当好了，然而，有人却在你很擅长的一件事上完全碾压了你，那一瞬间，我感觉自己这些年都白学了。这种感觉后来在看到别人能够小步重构时又一次产生了。看到差距之后，我唯一能做的，就是自己下来偷偷练习。幸好，无论是快捷键也好，重构也罢，都是可以单独练习的。花上一段时间就可以提高到一定的水平。后来，别人看我写代码时也会有类似的感觉，我会安慰他们说，不要紧，花点时间练习就好。

其实，也有一些辅助的方法可以帮助我们练习，比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，如果你用鼠标操作，它会给你提示，帮你记住快捷键。有一段时间，我已经练习到「看别人写代码，脑子里能够完全映射出他在按哪个键」的程度。写代码是个手艺活，要想打磨手艺，需要看到高手是怎么工作的，才不致于固步自封。如果你身边没有这样的人，不如到网上搜一些视频，看看高手在写代码时是怎么做的，这样才能找到差距，不断提高。

### 黑板墙

学习使用一个工具时，除了多练习之外，个人还有一个经验是，先明白这个工具涉及到的一些概念，比如 idea 的 module，gradle 的 source set 等，这样看帮助文档的时候，不至于不知所云，同时也方便从全局认识这个工具，只有这样，每一个功能才不是离散的，减少脑子里的混乱感。作者回复：很好的补充。2019-04-19

现在我准备在项目组实践持续集成，jenkins 环境搭建好了，我们的项目是 java+maven。但是自动化测试这个环节我不是很清楚怎么落地，我大概网上查了一下。我的理解是这样的：1）使用测试框架先写单元测试用例，例如 Junit。2）搭建 jenkins 环境，并安装 junit 相关插件。3）使用 jenkins 拉取代码，然后通过 junit 插件运行单元测试。4）最后打包部署。我这个理解对吗？作者回复：按照我在专栏中的介绍，单元测试应该在本地运行，在构建脚本里面配置好。你可以把持续集成和持续交付的几篇好好再读一遍，体会一下。2020-03-25

老师能分享一个你们发给新员工的 IDEA 快捷键卡片么？借鉴一下。作者回复：正方形的小卡片，正面是操作名称，比如提取方法，背面是快捷键，比如 option+command+M。2019-04-09

## 0411加餐你真的了解重构吗.md

重构是一个让人误解太多的概念，大家经常认为调整代码就是在做重构。重构，本质上就是一堆微操作。重构这个实践的核心，就是将调整代码的动作分解成一个一个的小动作，如果不能理解这一点，你就很难理解重构本身的价值。不过，对于我们专栏的读者而言，因为大家已经学过了「任务分解」模块，理解起这个概念，难度应该降低了很多。既然重构的核心也是分解，它就需要大量的锤炼。就像之前提到任务分解原则一样，我在重构上也下了很大的功夫做了专门的练习，才能让自己一小步一小步地去做。但一个有追求的软件工匠不就应该这样锤炼自己的基本功吗？如果今天的内容你只记住一件事，那请记住：锤炼你的重构技能。

Martin Fowler 《重构》第二版的中文版正式发布。在专栏里，我只是在谈 TDD 的时候提到了重构，并没有把它作为一个专门的话题来讲，于是，我决定给我的专栏读者加餐，专门谈谈重构，毕竟重构是几乎每个程序员都会用到的词汇。但你真的了解重构吗？

2『已下载书籍「2019030重构1-2Ed | 2019030Refactoring1-2Ed」』

1、每个程序员都要做的事。作为程序员，我们都希望自己的代码是完美的。但没有代码是完美的，因为只要你的代码还有生命力，一定会有新的需求进来，而新的需求常常是你在编写这段代码之初始料未及的。很多人直觉的选择是，顺着既有的代码结构继续写下去，这里添一个 if，那里加一个标记位，长此以往，代码便随时间腐坏了。如果用一个物理学术语描述这种现象，那就是「熵增」，这也就是大名鼎鼎的热力学第二定律。如果没有外部干预，系统会朝着越来越混乱的方向发展。对抗熵增的一个办法就是引入负熵，让系统变得更加有序。而在代码中引入负熵的过程就是「重构」。

调整代码这件事是程序员都会有的习惯，但把这件事做到比较系统，上升为「重构」这个值得推广的实践是从一个小圈子开始的，这个小圈子的核心就是我们在专栏里前面提到过的两位大师级程序员：Ward Cunningham 和 Kent Beck。而真正让这个概念走出小圈子，来到大众面前的，则是 Martin Fowler 在 1999 年写下那本软件行业的名著《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code）。Martin Fowler 的本事就在于他极强的阐述能力，很多名词经过他的定义就会成为行业的流行语（Buzzword），重构就是其中之一。重构这个说法可比「调整代码」听上去高级多了。时至今日，很多人都会把重构这个词挂在嘴边：「这个系统太乱了，需要重构一下。」但遗憾的是，很多程序员对重构的理解是错的。

2、重构是一种微操作。你理解的重构是什么呢？就以前面那句话为例：这个系统太乱了，需要重构一下。如果我们接着问，你打算怎么重构呢？一些人就会告诉你，他们打算另立门户，重新实现这套系统。对不起，你打算做的事叫重写（rewrite），而不是重构（refactoring）。

《重构》是一本畅销书，但以我的了解，很少有人真正读完它，因为 Martin Fowler 是按照两本书（Duplex Book）来写的，这是他常用写书的风格，前半部分是内容讲解，后半部分是手册。让这本书真正声名鹊起的就是前半部分，这部分写出了重构这件事的意义，而后半部分的重构手册很少有人会看完。很多人以为看了前半部分就懂了重构，所以，在他们看来，重构就是调整代码。调整代码的方法我有很多啊，重写也是其中之一。

如果真的花时间去看这本书的后半部分，你多半会觉得很无聊，因为每个重构手法都是非常细微的，比如，变量改名，提取方法等等。尤其是在今天，这些手法已经成了 IDE 中的菜单。估计这也是很多人就此把书放下，觉得重构不过如此的原因。所以，行业里流传着各种关于重构的误解，多半是没有理解这些重构手法的含义。

重构，本质上就是一个「微操作」的实践。如果你不能理解「微操作」的含义，自然是无法理解重构的真正含义，也就不能理解为什么说「大开大合」的重写并不在重构的范畴之内。我在《大师级程序员的工作秘笈》这篇文章中曾经给你介绍过「微操作」，每一步都很小，小到甚至在很多人眼里它都是微不足道的。重构，也属于微操作的行列，与我们介绍的任务分解结合起来，你就能很好地理解那些重构手法的含义了：你需要把做的代码调整分解成若干可以单独进行的「重构」小动作，然后，一步一步完成它。比如，服务类中有一个通用的方法，它并不适合在这个有业务含义的类里面，所以，我们打算把它挪到一个通用的类里面。你会怎么做呢？

大刀阔斧的做法一定是创建一个新的通用类，然后把这个方法复制过去，修复各种编译错误。而重构的手法就会把它做一个分解：1）添加一个新的通用类，用以放置这个方法；2）在业务类中，添加一个字段，其类型是新添加的通用类；3）搬移实例方法，将这个方法移动到新的类里面。

得益于现在的 IDE 能力的增强，最后一步，按下快捷键，它就可以帮我们完成搬移和修改各处调用的工作。在这个分解出来的步骤里，每一步都可以很快完成，而且，每做完一步都是可以停下来的，这才是微操作真正的含义。这是大刀阔斧做法做不到的，你修改编译错误的时候，你不知道自己需要修改多少地方，什么时候是一个头。当然，这是一个很简单的例子，大刀阔斧的改过去也无伤大雅。但事实上，很多稍有规模的修改，如果不能以重构的方式进行，常常很快就不知道自己改到哪了，这也是很多所谓「重写」项目面临的最大风险，一旦开始，不能停止。你现在理解了，重构不仅仅是一堆重构手法，更重要的是，你需要有的是「把调整代码的动作分解成一个个重构小动作」的能力。

3、重构地图。下面我准备给你提供一张关于重构的知识地图，帮你了解它与周边诸多知识之间的关系，辅助你更好地理解重构。学习重构，先要知道重构的定义。关于这点，Martin Fowler 给出了两个定义，一个名词和一个动词。1）重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。2）重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

之所以要了解重构的定义，因为重构的知识地图就是围绕着这个定义展开的。首先，我们要对软件的内部结构进行调整，第一个要回答的问题是，我们为什么要调整。Martin Fowler 对于这个问题的回答是：代码的坏味道。代码的坏味道，在我看来，是这本书给行业最重要的启发。很多人常常是无法嗅到代码坏味道的，因此，他们会任由代码腐坏，那种随便添加 if 或标记的做法就是嗅不出坏味道的表现。

我经常给人推荐《重构》这本书，但我也常常会补上一句，如果你实在没有时间，就去看它的第三章《代码的坏味道》。顺便说一下，对比两版的《重构》，你会发现它们在坏味道的定义上有所差异，在新版的《重构》中，可变数据（Mutable Data）、循环语句（Loops）都定义成了坏味道，如果你不曾关注近些年的编程发展趋势，这样的定义着实会让人为之震惊。但只要了解了函数式编程的趋势，就不难理解它们的由来了。换句话说，函数式编程已然成为时代的主流。如果你还不了解，赶紧去了解。

1『再次看到上面的信息感触和之前完全不一样，可变数据和循环语句都是坏味道，循环语句现在基本不写了，把操作列表（数组）子项的算法封装为一个函数，函数传递进去（map）。可变数据这点目前做的不好，总感觉还没抓住其核心的「数据不变性」。（2020-11-20）』

我们接着回到重构的定义上，重构是要不改变软件的可观察行为。我们怎么知道是不是改变了可观察行为，最常见的方式就是测试。关于测试，我在「任务分解」模块已经讲了很多，你现在已经可以更好地理解重构、TDD 这些概念是怎样相互配合一起的了吧！再来，重构是要提高可理解性，那重构到什么程度算是一个头呢？当年重构讨论最火热的时候，有人给出了一个答案：重构成模式（Refactoring to Patterns）。当然，这也是一本书的名字，有兴趣的话，可以找来读一读。

我个人有个猜想，如果这个讨论可以延续到 2008 年，等到 Robert Martin 的《Clean Code》出版，也许有人会提「重构成 Clean Code」也未可知。所以，无论是设计模式，亦或是 Clean Code，都是推荐你去学习的。至此，我把重构的周边知识整理了一番，让你在学习重构时，可以做到不仅仅是只见树木，也可看见森林。当然，重构的具体知识，还是去看 Martin Fowler  的书吧！

2『已下载书籍「2019032代码整洁之道 | 2019032Clean-Code」和「2020110重构与模式 | 2020110Refactoring-to-Patterns」』

### 黑板墙

函数式编程有什么推荐书籍吗？作者回复：有几本可以了解一下，《计算机程序的解释与构造》（Structure and Interpretation of Computer Programs，SICP），还有《Haskell 趣学指南》（Learn You a Haskell for Great Good），《函数式编程思维》（Functional Thinking）。

2『已下载书籍「2020167Structure-and-Interpretation-of-Computer-Programs | 2020167Structure-and-Interpretation-of-Computer-Programs-JS」，前面的一本是 1996 版在 2002 年修整了一下，后面的是 2019 出的用 JS 写的代码。「2020168Learn-You-a-Haskell-for-Great-Good | 2020168Haskell趣学指南」、「2020169Functional-Thinking」。』

重构不仅是愿景（名词），也不仅是行为（动词），还应该成为程序员必备的习惯和工作方式。但要成为习惯，甚至是深入骨髓的那种，是需要有积极意识和大量练习的。有程序员会说，先把功能实现了，后面我再去重构，但后来的情况往往是不重构，或是债务过多重构代价太大，原因也大多是之前课程中提到的诸如任务分解不到位，微操作缺失，缺乏合理有效的单元测试等等，所以程序员的自我修养也是要体系化的，所谓功到自然成。与诸君共勉之！

## 0401懒惰应该是所有程序员的骄傲.md

Perl 语言的发明人 Larry Wall 曾经说过，优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。想要成为一个优秀的程序员，就要让机器为自己很好地工作，而这需要对自动化有着很好地理解。我们学习自动化，先要知道哪些东西不要自动化，尽最大的努力不做浪费时间的事。一方面，我们要从需求上规避那些没必要做的事；另一方面，我们也从自身防止 NIH 综合症（Not Invented Here Syndrome），争取做一个懒惰的程序员。对于要自动化的事，我们需要反思一下，在为别人打造自动化工具的同时，我们自己的工作过程有没有很好地自动化。而如果我们想拥有打造良好的自动化工具，我们需要对软件设计有着充分地理解。如果今天的内容你只能记住一件事，那请记住：请谨慎地将工作自动化。

经过前面几个模块的学习，我们的专栏终于进入到程序员看上去最熟悉的一个主题：自动化。每每提及自动化，我就会想起 Perl 语言的发明人 Larry Wall 一个经典叙述：优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。

有人甚至为此专门打造了一个三大美德的网站，阐释这个初看起来匪夷所思的说法。1）懒惰，是一种品质，它会使你花很大力气去规避过度的精力消耗，敦促你写出节省体力的程序，别人也能很好地利用，你还会为此写出完善的文档，以免别人来问问题。2）急躁，是计算机偷懒时，你会感到的一种愤怒。它会促使你写出超越预期的程序，而不只是响应需求。3）傲慢，极度自信，写出（或维护）别人挑不出毛病的程序。

不知道你是否感受到，程序员独有的幽默和透露出的那种骄傲：我做的东西就应该是最好的。之所以要从 Larry Wall 的这段话开启「自动化」这个模块，因为只要一说到自动化，我就会情不自禁地联想到「偷懒」这个词。是的，我们程序员的工作，本质上就是打造各种自动化的工具，让人们从各种繁复的工作中解脱出来，让人有机会「偷懒」。不过，我也知道，从机器那里偷来的「懒」很快就被更多的工作填满了。但 Larry Wall 的这段话却可以鼓励我们不断地打造出更好的工具。

作为程序员，你当然知道「自动化」这件事的价值，在日常工作中，也实实在在地践行着打造自动化工具的任务，但很多人对自动化的理解可能有些单薄。今天，我就从一个你可能会忽略的主题开始讨论：不要自动化。

### 1.1 不要自动化

我先给你讲一个让我印象深刻的「不自动化」的例子。之前在 ThoughtWorks 工作时，我们有一项工作是，帮助其他公司启动一些新产品。有一次，我的两个同事被一个公司请去启动一个视频网站的项目。那时候还不像如今的市场，已经由几大视频网站瓜分完毕，当时不少公司看到了视频网站的苗头，觉得自己有机会。这个来请我们的公司也不例外，觉得自己也能分一杯羹。

两个星期之后，我的两个同事回来了。我们饶有兴趣地去问项目的进展，因为项目启动之后，通常会有后续的开发合作，但结果令我们很意外，这个项目停止了。「出了什么状况吗？」我们问。「是我们建议用户停掉这个项目的。」他们回答到。

我们「恨恨地」问他们为什么丢掉了一个这么重要的机会。这两个同事的回答也很直白，他们结合着客户的想法算了一笔账：这个项目需要大量的资金投入，投入规模之大，是超出客户想象的，按照现有的规划投入，这个项目肯定会亏本。要么重新规划，要么取消这个项目。客户认真研究了一番，最终决定取消项目。

这件事大约发生在 10 年前，今天我们都看到各大视频网站在烧钱上的投入，以那个公司的实力，想要参加这场比拼，确实还差太多。这件事之所以给我留下深刻印象，因为它是我职业生涯中见到的第一个通过「主动取消项目」获取项目成功的案例。

或许你不能理解我这里所说的「项目成功」。在我看来，做有价值的事是重要的，这里面的有价值，不仅仅是「做」了什么，通过「不做」节省时间和成本也是有价值的。我的两个同事阻止了客户的浪费，所以，我将这个项目视为成功。

对于开发来说，也遵循同样的道理。程序员这个群体技术能力实在太强，做一个技术方案简直是太符合直觉的做法，我们就是忠实地把一个个需求做出来，把「全世界」都自动化了。但事实上，这个世界太多的浪费就是做了不该做的东西。在我们的专栏里，我反复地说，我们要多问问题，目的就是为了不做那些不该做的事。

### 1.2 小心 NIH 综合症

你可以从需求的角度判断哪些工作是可以不做的，但我们也要防止程序员自己「加戏」，我再给你讲一个技术人员普遍存在的问题：NIH 综合症（Not Invented Here Syndrome）。

NIH 是什么意思？就是有人特别看不上别人做的东西，非要自己做出一套来，原因只是因为那个东西不是我做的，可能存在各种问题。这种现象在开源之前尤为流行，很多公司都要做自己的中间件，做自己的数据库封装。虽然很多公司因此有了自己特色的框架，但是因为水平有限，做出来的东西通常极为难用，很多人一边骂，一边还要继续在上面开发。

开源运动兴起之后，我以为这种现象会好一些，但事实证明，我想多了。比如，这种乱象在前端领域也出现了，各种各样的框架，让很多前端程序员哭诉，实在学不动了。再比如，我曾经面试过一个接触 Go 比较早的程序员，他就是恨不得把所有框架都自己写。因为他学 Go 的时候，确实框架比较少，但问题是，如今的 Go 已经不是他学习时的那个 Go 了，现在各种框架已经很丰富了，不需要什么都自己做。当时我问他，如果有一天你离开了，公司怎么办呢？实际上，他从来没考虑过这个问题。

说了这么多，无非就是想说明一件事，写代码之前，先问问自己真的要做吗？能不做就不做，直到你有了足够的理由去做。对应到 Larry Wall 的说法，你要懒惰，花大力气去规避精力消耗。

### 1.3 做好自动化

说完了不要自动化的部分，再来说说要自动化的部分。我还是先从你可能会忽略的问题入手，你的日常工作是给别人打造自动化，但你自己的工作够自动化吗？还是问一个更具体的问题吧！如果你写的代码要上线，会经过怎样的过程？

我先给你看一个极其糟糕的例子。刚开始工作不久，我有一次出差到客户现场。临近下班时，我发现了程序的一个 Bug。在那个年代，我们的程序是按照官方推荐做法编写的 EJB（Enterprise JavaBean），今天很多年轻的程序员可能不了解了，它只有部署到应用服务器才能运行。

我的解决方案就是加上一些打印语句，然后部署到应用服务器上，看输出的结果，再加上另外一些语句，再部署，如此往复。那时我们完全是手工打包上传，每次至少要十几分钟。最终，定位到了问题，只修改了一行代码。但几个小时的时间就这样被无谓的消耗了。

那之后，我花了很长时间研究怎么做自动化的增量部署，最终让这个过程简化了下来。但这件事对我的影响很大，这是我第一次认识到一个部署过程可能对开发造成的影响，也让我对自动化在开发过程内的应用有了属于自己的认识。相比于我刚开始工作那会。现在在工具层面做类似的事已经容易很多了，在后面的内容中，我会结合着具体的场景介绍一下现在的最佳实践。

### 1.4 你要懂得软件设计

最后，我们再来说说我们的本职工作，给别人打造自动化工具中需要的能力：软件设计。

软件设计，是很多人既熟悉又陌生的一个词，说熟悉，很多人都知道，做软件要设计，还能顺嘴说出几个设计模式的名字；说陌生，是因为在我的职业生涯中，遇到真正懂软件设计的程序员少之又少。大多数人都是混淆了设计和实现。

举个例子。有一次，我要在两个系统之间做一个连接器，让上游系统向下游系统发消息，或许你一听就知道了，这里需要的是一个消息队列。但实际上，我们需要的能力要比消息队列更丰富一些，比如，要将重复的消息去除。一个同事给我推荐了 Kafka 当作这个连接器的基础，我欣然地接受了。不过，在后续设计的讨论中，我们就经常出现话语体系的分歧。我说，这个连接器要有怎样的能力，他会说 Kafka 能够如何如何。究其根因，我在讨论的是设计，而他说的是实现，所以，我们两个很难把问题讨论到一起。

为什么我会如此看重设计呢？在软件开发中，其它的东西都是易变的，唯有设计的可变性是你可以控制的。同样以前面的讨论为例，尽管 Kafka 在当下比较火热，但是我不敢保证 Kafka 在未来不会被我换掉。因为就在几年前，消息队列还是传统中间件的强项，现在也渐渐被人淡忘了。

我不想让我的设计随着某一个技术选型而不断摇摆。如果工作许多年，知识体系只能靠各种新框架新工具支撑，我们做程序员就只剩下疲于奔命了。不懂软件设计，只专注各种工具，其结果一定是被新技术遗弃，这也是很多人经常抱怨 IT 行业变化快的重要原因。

回到 Larry Wall 的说法上，你要想写出一个别人挑不出毛病的程序，你先要懂得软件设计。幸运的是，软件设计这些年的变化真不大，掌握了软件设计再来看很多框架和工具，学习起来就会容易很多。在这个模块的后半部分，我会与你探讨软件设计的话题，降低自己给自己挖坑的概率。

### 黑板墙

你现在是怎样理解自动化的呢？

从老师这学到一个很喜欢的思想。有价值的事并不局限性于事情本身。做自动化很重要，写代码很重要。但根据根据现有情况判断是否需要自动化，是否需要写代码也很重要。有的放矢，任务分解。权衡跟设计是件很艺术的事情，令人着迷。作者回复：以现在大家的努力程度，少做点事是需要锻炼的技能。2019-03-18

最近确实感觉追随快速迭代技术追得自己挺迷茫的，也一直在思考到我究竟缺了什么。之前偶然看了软件工程相关的，才意识到算法、分析、设计等基础重要性，看到郑老师这一篇，让我更加坚信了这一点！作者回复：追变的东西，永远追不完，追不变的东西，就那么点东西。2019-03-20

面试的时候，常常听到应聘者提起换工作的原因之一是手头任务重复性高，都是增删查改，代码粘帖复制。我就会问，你有没有想过把工作变得不那么重复，不要粘帖复制代码。有不少人就没什么话说了。其实还是有很多可做的。比如自动生成增删查改的管理功能和页面，集成好缓存、搜索等服务。懒惰真的是程序员的优秀品质，只是有些人理解成思想上的懒惰了。作者回复：动手的人多，动脑的人少。2019-03-18

做值得做的事确实很重要，否则你忙活半天项目失败了，可能你也能赚一部分钱，或者技术得到了提升，但对客户却是损失，明知不可为还要去干就是不职业了。另外就是变中求不变，注重软件设计很重要，就像有些公司面试只考算法，根本不关注你用什么框架和语言，因为技术很多都是想通的，所有的 Orm 框架不能说完全相同，但设计思想总是想通的吧。可是国内有些单位在筛选人简历时就是看你用过的框架和语言，我招的是 java, 你简历中项目用的 c#, 所以不合适直接过滤掉。其实一个合格的程序员又怎么会被语言和框架固化住呢，只不过是不同的场景选择最适合的就是最好的。2019-03-27

郑老师提到的那个问题，其实还有另外种解决方案：远程调试。当然这也无法避免部署的活，但是可以大幅减少部署的次数。有次出现了开发环境无法复现，只有测试环境才能复现的问题，就是通过远程调试解决的，当初使用的中间件是 WebSphere（估计很多童鞋都不知道了）。作者回复：远程调试，是一种重量级的工具，能不用就不用。2019-03-18

## 0402一个好的项目自动化应该是什么样子的.md

今天我们通过一个具体的例子展示了一个最基本的项目自动化，包括了：1）生成 IDE 工程；2）编译；3）打包；4）运行测试；5）代码风格检查；6）测试覆盖率；7）数据库迁移；8）运行应用。但这就是自动化的全部了吗？显然不是，我这里给出的只是一个最基本的示例。实际上，几乎每个重复的工作或是繁琐的工作，都应该自动化。我们不应该把时间和精力浪费在那些机器可以很好地替我们完成的工作上。今天的基础设施已经让我们的自动化工作变得比以往容易了很多，比如，可执行 JAR 包就比从前部署到应用服务器上简化太多了。Gradle 也让订制构建脚本的难度降低了很多。这里提到的项目自动化也是持续集成的基础，在持续集成服务上执行的命令，就应该是我们在构建脚本中写好的，比如：./gradlew build。

2011 年，我在 InfoQ 上发表了一篇《软件开发地基》，讨论的就是一个项目的构建脚本应该是什么样子。虽然其中用到的工具今天已经不再流行，但一些基础内容今天看来，依然是有效的。如果有兴趣，你也可以看一下。如果今天的内容你只能记住一件事，那请记住：将你的工作过程自动化。

2『[软件开发地基 - InfoQ](https://www.infoq.cn/article/zy-software-development-foundation)，去把他博客里的文章都消化一下。』

进入自动化这个模块，我准备从程序员的日常工作开始。介绍「迭代 0」时，我提到构建脚本是项目准备的一个重要组成部分，但在那一讲中，我并没有具体说构建脚本长成什么样。今天，我们以一个典型的 Java REST 服务为例，介绍一下最基本的构建脚本应该做到什么样子。这里我采用的 Java 技术中最为常见的 Spring Boot 作为基础框架，而构建工具，我选择了 Gradle（[Gradle Build Tool](https://gradle.org/)）。

估计很多 Java 程序员心中的第一个问题就是，为什么用 Gradle，而不是 Maven？Maven 明明是 Java 社区最经典的构建工具。答案是因为 Maven 不够灵活。你可以回想一下，你有多少次用 Maven 实现过特定需求？估计大部分人的答案都是没有。随着持续集成、持续交付的兴起，构建脚本的订制能力会变得越来越重要，Maven 则表现得力有不逮。其实，早在 2012 年，ThoughtWorks 技术雷达就将 Maven 放到了 暂缓（HOLD）里面，也就是说，能不用就不用。

为了配合这次的讲解，我写了一个 Demo，放在了 Github 上。它的功能非常简单：1）通过向 /users POST 一个请求，实现用户注册；2）访问 /users，查看已注册的用户。如果方便的话，你最好把这个项目 clone 下来，以便参考。这里我主要是讲解自动化要做成什么样子，如果你想了解具体是怎么实现的，可以参考 Demo 里的代码。

### 2.1 基础准备

先把这个项目从 Github 上 clone 下来。

```
git clone  https://github.com/dreamhead/geektime-zero.git
```

然后，进入到项目所在的目录中。

```
cd geektime-zero
```

当你准备就绪，我们就开始进一步了解这个项目。一般我们了解一个项目，都会用用一个 IDE 打开这个项目，这里我推荐使用 IntelliJ  IDEA，这是目前行业中最好的 Java IDE。自从它的社区版免费之后，它就成为了我向他人推荐的首选。

我知道，开发工具是除了程序设计语言之外，另外一个容易引起「宗教战争」的话题，如果你喜欢其他的 IDE，那就用你最喜欢的 IDE 打开好了，只不过，需要调整一下构建脚本中的配置。怎么打开这个项目呢？我们先用 Gradle 命令生成一个 IDEA 工程。

```
./gradlew idea
```

这个命令会生成一个.ipr 文件，这就是 IDEA 的工程文件，用 IDEA 打开即可。这里有两点需要说明一下。1）这里用的 gradlew，它是 Gradle 命令的一个封装，它会自动下载一个构建这个项目所需的 Gradle，重点是通过这个命令锁定了 Gradle 的版本，避免因为构建脚本的差异，造成「你成功我失败」的情况。2）IDE 工程是生成的。很多人直觉的做法是用 IDE 直接打开。有一些团队的项目里有好多个构建文件，究竟用哪个打开，不去问人是根本不知道的，这对项目的新人是非常不友好的。

生成的做法与前面 Gradle 封装是类似的，它可以避免因为本地安装不同版本 IDE 造成各种问题。另外，因为 IDE 的工程是生成的，如果项目里一旦增加了新的程序库依赖，你只需重新执行一次上面的命令就好了，现在的 IDE 都有很好的自动加载能力，当它检测到工程文件的变化，就会重新加载。好，现在你可以用 IDE 打开，我们就可以进一步了解这个项目了。

### 2.2 初见项目

我们先来了解一点 Gradle 的配置文件，它也是我们做项目自动化的重点。1）build.gradle，它是 Gradle 的配置文件。因为 Gradle 是由 Groovy 编写而成，build.gradle 本质上就是一个 Groovy 的脚本，其中的配置就是 Groovy 代码，这也是 Gradle 能够灵活订制的基础。2）settings.gradle，这也是一个 Gradle 配置文件，用以支持多模块。如果说一个项目的每个模块都可以有一个 build.gradle，那整个项目只有一个 settings.gradle。

在 Gradle 里，许多能力都是以插件的形式提供的，比如，前面生成 IDEA 工程就是配置文件中的一句话。

```
apply plugin: 'idea'
```

所以，如果你是其他 IDE 的死忠粉，你可以把这句话，换成你喜欢的 IDE。（注：这个项目采用 Lombok 简化代码，为了能让代码在你的 IntelliJ IDEA 编译运行，你可以安装 Lombok 插件，然后，在「Build, Execution, Deployment」->「Compiler」->「Annotation Processors」中，选中 Enable annotation processing。）

好，有了基础知识之后，我们来了解一下代码组织。首先是分模块。除非你的代码库规模非常小，否则，分模块几乎是一种必然。一种恰当的划分方式是根据业务划分代码。比如，把用户相关的内容放到一个模块里，把交易订单信息放到一个模块里，把物流信息放到另一个模块里。如果你未来打算做微服务，那每一个模块就可以成为一个独立的服务。

在我们的项目里，我示例性地划分了两个模块：1）zero-identity，是用户信息的模块；2）zero-bootstrap，是多个模块打包成一个可部署应用的模块。这两个模块的信息都配置在 settings.gradle 中。

```
include 'zero-bootstrap'
include 'zero-identity'
```

再来是目录结构。具体要怎么样组织代码，在 Java 世界里已经是一件约定俗成的事情了。src/main/java 下放着你的源代码，src/main/resources 下放配置文件，src/test/java 放测试代码。这是约定优于配置（Convention over Configuration）思想的体现。如果你用的工具没有约定，你只能自己定好，让其他人遵守。

### 2.3 检查

在自动化过程中，一个最基本的工作是检查。检查的工作在我们的项目中通过一个 check 任务来执行。

```
./gradlew check
```

这个检查会检查什么呢？这取决于配置。在这个项目里，我们应用了 Java 插件，它就可以编译 Java 文件，检查代码是否可以正常编译，运行测试，检查代码是否功能正常等等。但我要求更多。讲「迭代 0」时，我说过，最基本的代码风格检查要放在构建脚本中，这里我用了 CheckStyle 来做这件事。缺省情况下，你只要应用 Checkstyle 插件即可。

```
apply plugin: 'checkstyle'
```

在这个项目里，我做了一些订制，比如，指定某些文件可以不做检查。

```
style.excludePackages = [
]

style.excludeClasses = [
]
```

测试覆盖率也应该加入到构建脚本中，这里我用了 JaCoCo。同样，缺省情况下，只要应用 JaCoCo 插件即可。

```
apply plugin: 'jacoco'
```

我依然是做了一些订制，比如，生成结果的 HTML 报表，还有可以忽略某些文件不做检查。

```
coverage.excludePackages = [
]

coverage.excludeClasses = [
]
```


这里最特别的地方是，我将测试覆盖率固定在 1.0，也就是 100% 的测试覆盖。这是我做新项目的缺省配置，也是我对团队的要求。如果一个新项目，能把这几个检查都通过，腐坏的速度应该就不会那么快了。当然，你也可以根据自己的需要，添加更多的检查。

### 2.4 数据库迁移

讲「迭代 0」时，我还提到了数据库迁移，也就是怎样修改数据库。在示例项目中，我选择的数据库迁移工具是 Flyway（[Flyway by Redgate • Database Migrations Made Easy.](https://flywaydb.org/)）。

```
plugins {
    id "org.flywaydb.flyway" version "5.2.4"
}
```

下面先要做一些基本的配置，保证可以连接到数据库。（注：如果你想直接使用这里的配置，可以在本机的 MySQL 数据库上，创建一个 zero 的用户，密码是 geektime，然后，再创建一个 zero_test 的数据库。）

```
flyway {
    url = 'jdbc:mysql://localhost:3306/zero_test?useUnicode=true&characterEncoding=utf-8&useSSL=false'
    user = 'zero'
    password = 'geektime'
    locations = ["filesystem:$rootDir/gradle/config/migration"]
}
```

那修改数据库会怎么做呢？先添加一个数据库迁移文件，比如，在示例项目中，我创建一个迁移文件（gradle/config/migration/V2019.02.15.07.43\_\_Create\_user\_table.sql），在其中创建了一个 User 表。

```
CREATE TABLE zero_users(
    id bigint(20) not null AUTO_INCREMENT,
    name varchar(100) not null unique,
    password varchar(100) not null,
    primary key(id)
);
```

这里的迁移文件版本，我选择了以时间戳的方式进行命名，还有一种方式是以版本号的方式，比如 V1、V2。时间戳命名方式的好处是，不同的人可以同时开发，命名冲突的几率很小，而采用版本号命名的方式，命名冲突的概率会大一些。添加好数据库迁移文件之后，只要执行下面这个命令就好：

```
./gradlew flywayMigrate
```

这样，对数据库的修改就在数据库里了，你可以打开数据库查看一下。

### 2.5 构建应用

做好了最基本的检查，数据库也准备就绪，接下来，我们就应该构建我们的应用了。首先是生成构建产物，它只要一个命令。

```
./gradlew build
```

这个命令会在 zero-bootstrap/build/libs 下生成一个可执行 JAR 包，它就是我们最终的构建产物。此外，build 任务会依赖于 check 任务，也就是说，构建之前，会先对代码进行检查。从前 Java 程序只是打出一个可部署的包，然后，部署到应用服务器上。感谢现在基础设施的进步，我们可以省去部署的环节，这个包本身就是一个可执行的。我们可以通过命令执行将 JAR 执行起来。

```
java -jar zero-bootstrap/build/libs/zero-bootstrap-*-boot.jar
```

在开发过程中，并不需要每次都将 JAR 包打出来，我们还可以直接通过 Gradle 命令将应用运行起来。

```
./gradlew bootRun
```

不过，我估计你更常用的方式是，在 IDE 中找到 Bootstrap 这个入口类，然后，直接运行它。既然程序已经运行起来，我们不妨测试一下。我们通过一些工具，比如 Postman 或者 Curl，把下面的内容 POST 到 http://localhost:8080/users。

```
{
  "username": "foo",
  "password": "bar"
}
```

然后，通过浏览器访问 http://localhost:8080/users。

我们就可以看见我们刚刚注册的这个用户了。

### 黑板墙

在日常开发工作中，你还把哪些过程自动化了呢？

设想过这样的情景（还没实现，打算实践一把）：我们新招一名比较熟练的程序员，从 TA 入职拿到机器，到开发示意代码，再提交 SCM，然后 CI/CD，再发布到线上交付给用户，整个过程可以在入职当天的午饭之前完成。这不光要求构建和集成自动化，甚至要求从入职开始的各个环节都能提前准备好，包括机器、开发环境、线上环境等，甚至连示范的需求都要能及时传递给 TA。理想情况下，程序员只需要开发好程序，保证质量，提交到 SCM 即可，其他事情都应该交给机器。要知道程序员都很贵，越早给用户交付价值越好。作者回复：是这个意思，后面继续谈如何往线上送。2019-03-20

对于 Gradle 的特性了解还是比较少…… 感觉学习中会有这样的一个现象：对与技术是干什么用的其实是知道的，但是对于细节的把握总是容易遗忘，之前就拿实战 Gradle 这本书基本上通读了一遍，但是遗忘的确实有点快！我感觉这应该是大多数程序员的通病吧，老师能否给出一些建议？抑或是这种学习方式本身就是低效或者是错误的。作者回复：我的学习方式是，我先要知道构建脚本要做哪些事情，就像这篇文章中写到的这些内容，然后看怎么样用对应工具如何完成，这样看起手册来就有针对性了。2019-05-03

我一般会在需要专有的构建工具之上再定义一个 Makrfile 封装，通用的 test build deploy 操作，统一各语言构建工具差异，比如 maven gradle npm。作者回复：我也做过类似的事情，用 shell 脚本去封装。2019-03-20

郑老师是否可以分享一下自己在模块划分上面的经验呢？作者回复: 《敏捷软件开发：原则、实践与模式》、《架构整洁之道》中都有关于模块划分的内容。2019-03-20

有时候感觉流程比技术更重要。之前有一个经历，就是本来想写个自动化的脚本把在做的事情自动化，但是我的一个同事直接改变了流程，让整个流程更加简化了的。原来脚本所要做的事压根都不存在了。确实像老师所说的，写程序是最高的成本，在着手写程序之前，一切都要考虑清楚。2019-06-12

有个细节问题想咨询一下，现在用 Spring boot 做一个新项目，由于是前期阶段，短时间内要上线，选择了 Spring boot，用业务划分模块的方式来进行开发，就像您文中提到划分模块，现在有个疑问的地方是模块之间会产生一些调用，比如用户的金币数据在用户模块里，游戏模块需要用到某个用户的金币数据，有比较好的做法吗？如果是让游戏模块依赖用户模块，然后注入用户的 service，感觉跟之前没什么区别。作者回复：不要直接依赖于服务，要用接口的方式进行隔离，哪怕是接口和原来服务一模一样，也要隔离。必须明确的一点，这两个业务模块之间是服务相互调用的关系，不是程序库的关系。2019-04-23

我有个疑问。公司最近有个技术老大说不准用 lombok 这个小工具，一定要我们手写 set get？lombok 真的那么差吗？作者回复：我不清楚具体的情况。我凭一般认知回答一下，有一种可能是，你老大觉得 getter/setter 就不应该写，需要做更好的领域建模；另一种情况是，对于这种生成代码的机制有担心。lombok 本身不是问题，很多人乱用才是问题。2019-03-23

老师，以后用 idea 导向建立 Spring Boot，我是不是把默认的 maven 改为 gradle？自动化：gitlab CI/CD+jenkins 的 gradle+docker，其中 docker 是把脚本放在 jenkins，根据 tag，如果是稳定版本就用 makeFile 生成 docker 镜像，这样可以吧？作者回复：我的建议是用构建脚本生成 IDE 工程。2019-03-20

自动化在持续交付中得到了非常充分的体现，把频繁的打包、单测、集成测试、部分验收测试、镜像构建和发布、CI 环境更新、服务可用性验证等过程全部流水线化，极大的提升了构建发布效率，当然自动化的意义不仅于此；同时，把一切自动化是思维的转变，高效工作的有利工具。作者回复：没错，我们下面就会谈到持续交付。2019-03-20

idea 没有直接集成 gradle 吧？我看 maven 就直接有，好不容易学完 maven，就淘汰了。有 gradle 方面的书吗？idea 方面的呢？看官方教程？idea 是不是用到什么功能再学？还是先看过大概，用到再仔细看？还是最好都看一遍？目前 idea 只会一些基础的…...作者回复：理解错了，IDEA 提供了很好的 Gradle 支持。我的建议是生成 IDE 工程，maven 同样适用。我学 Gradle 和 IDEA 这种工具都是看官方文档。IDEA 的学习，别的不说，先熟练适用快捷键。2019-03-20

我想问下 PHP 有类似构建脚本的工具吗？还没开始学习 JAVA。作者回复：我并不擅长 PHP，你不妨用 PHP build tool 为关键词搜索一下。2019-03-20

运维现在也有很多工具支持了。都是显示了配置化。作者回复：显示是一个 view，需要先把 model 做好。2019-03-24

想问下老师，文章中把项目分成了 zero-bootstrap 和 zero-identity 两个模块。在实际工程中我们有必要遵循这种方式吗，把与业务关系不大的基础的启动工程，或者基础框架单独提取成模块。作者回复：这是我习惯的做法，当你有了多个模块，不同的业务模块之间就是隔离的。遵循与否，可以结合自己项目的实际情况来决定。2020-07-25

修正下mysql 8.0版本兼容问题：需要在 url 后面添加 serverTimezone 字段保证处于同一时区，不然会出现异常：

```
The server time zone value '???ú±ê×??±??' is unrecognized or represents more
```

作者回复：提一个 PR，在 github 等你。2020-01-16

## 0403程序员怎么学习运维知识.md

我们今天的关注点在于，将开发过程产生的构建产物部署起来。部署过程要依赖于运维知识，每个程序员都应该学习运维知识，保证我们对软件的运行有更清楚地认识，而且部署工作是非常适合自动化的。但是，对运维工具的学习是非常困难的，因为我们遇到的很多工具是非常零散的，缺乏体系。这里，我给你介绍了一个运维的知识体系，这个体系借鉴自 Java 的知识体系，包括了编程语言、核心库、第三方库、开发框架、单机部署和集群部署等诸多方面。我把今天提到的各种技术整理成一个表格列在下面，你可以参考它更好地理解运维知识。如果今天的内容你只能记住一件事，那请记住：有体系地学习运维知识。

| 类别 | JAVA | 运维 |
|:-------------|:-------------|:-----|
| 语言 | JAVA 语言 | Shell |
| 核心库 |  JDK   | Unix/Linux 核心命令 |
| 第三方库 | 第三方程序库，比如：Google Guava、SLF4J | 第三方命令，如 rsync、curl 等 |
| 开发框架 | 开发框架，比如 Spring | 配置管理工具，如 Chef、Puppet、Ansible 等 |
| 单机部署 | 应用服务器，比如 Tomcat、Jetty | 部署环境，如虚拟机、Docker 等 |
| 集群部署 | 企业级应用服务器，比如 IBM Websphere、Oracle Weblogic、Server、JBoss EnterPrise、Application Platform | 云服务，如 Amazon AWS、Openstack、阿里云等；Docker 集群，比如 Kubernates、Docker Swarm 等 |

在上一讲中，我们讲到了开发过程的自动化，我们的关注点在于如何构建出一个有效的部署包，这个包最终是要上线部署的，那接下来，我们就来关心一下部署的相关工作。

### 3.1 零散的运维知识

在一些稍具规模的公司，为部署工作设置了一个专有职位，称之为运维。当然，这个岗位的职责远不止部署这一件事，还要维护线上系统的稳定。不过，如果你的团队规模不大，或是项目处于初始阶段，这些工作往往也要由程序员自行完成。对于一个程序员来说，了解自己的程序怎么部署上线，是非常重要的。我们既要了解一个软件的逻辑，也要知道它的物理部署。只有这样，出了问题才知道怎么修复。更重要的是，我们在设计时，才能尽量规避部署带来的问题。而部署，恰恰也是最适合发挥自动化本领的地方。

好，即便下定决心准备学习运维相关知识，你准备怎么学呢？我先来问你个问题，提到运维，你会想到什么？如果你是一个刚刚步入这个行业的程序员，你或许会想到 Docker（[Empowering App Development for Developers | Docker](https://www.docker.com/)），想到 Kubernetes（[Production-Grade Container Orchestration - Kubernetes](https://kubernetes.io/)）；如果再早一点入行，你或许还会想到 Chef（[Chef: Enabling the Coded Enterprise through Infrastructure, Security and Application Automation](https://www.chef.io/)）、Puppet（[Powerful infrastructure automation and delivery | Puppet | Puppet.com](https://puppet.com/)）、Ansible；更早一些入行的话，你会想到 Shell 脚本。没错，这些东西都是与运维相关的。那我就这么一个一个地都学一遍吗？

就我个人的学习经验而言，如果所有的知识都是零散的，没有一个体系将它们贯穿起来，你原有的知识无法帮助你学习新知识，这种学习方式效率极低，过程也极其痛苦。如果是有结构的知识，所谓的学习新知识不过是在学习增量，真正要理解的新东西并不多，学习效率自然会大幅度提高。所以，想学好运维知识，首先你要建立起一个有效的知识体系。

你可能会问，这些运维知识看上去就是一个一个独立的工具啊？我曾经也为此困惑了许久，虽然我对各个工具已经有了不少的了解，但依然缺乏一个有效的知识体系，将它们贯穿起来，直到我上了一堂课。感谢 Odd-e 的柴锋，有一次，他给我上了一堂 DevOps 课，他对运维知识的讲解让我茅塞顿开，从此，我的运维知识有了体系。准确地说，他的这堂课就是讲给程序员的运维课。今天，我就把这个体系按照我的理解，重新整理一遍分享给你，也算是完成一次知识输出。

3『[DevOps 技术栈 | 三分热度：柴锋](https://chaifeng.com/devops-tech-stack/)』

### 3.2 Java 知识体系

正如我前面所说，学习一个新东西，最好的办法是学习增量，如果能够找到它与已有知识体系的联系，我们就可以把已有知识的理解方式借鉴过去。作为程序员，我们其实已经有了一个完善的知识体系，这就是我们对于程序设计的理解，而理解运维的知识体系，刚好可以借鉴这个体系。怎么理解这句话呢？

以最常见的 Java 开发为例，如果要成为一个合格的 Java 程序员，我应该知道些什么呢？

首先肯定是 Java 语言，我需要了解 Java 语言的各种语法特性。不过，只了解语法是写不出什么像样程序的，我们还需要掌握核心库。对于 Java 来说，就是 JDK 中的各种类，比如，最常见的 String、List、Map 等等。理论上来说，掌握了基本的语法和核心库，你就可以开发任何程序了。但在实践中，为了避免重新发明「轮子」，减少不必要的工作量，我们还会用到大量的第三方类库，比如，Google Guava、SLF4J 等等。

除了功能实现，还有一些结构性的代码也会反复出现。比如说，在常见的 REST 服务中，我们要将数据库表和对象映射到一起，要将结果转换成 JSON，要将系统各个组件组装到一起。为了减少结构上的代码重复，于是，开发框架出现了，在 Java 中最常见的开发框架就是 Spring。至此，你就可以完成基本的代码编写，但这还不够。在 Java 中，你不会从底层完成所有事情，比如，虽然你写 REST 服务，但你很少会接触到最底层的 HTTP 实现，因为这些工作由运行时环境承担了。我们要做的只是把打好的包部署到这些运行时环境上，在 Java 的世界里，这是 Tomcat、Jetty 之类的容器承担的职责。

如果你刚刚加入这一行，上来就用 Spring Boot 之类的框架写代码，你可能并没有碰到这样的部署过程，因为这些框架已经把容器封装其中，简化了部署过程。Tomcat、Jetty 往往还只是在一台机器上部署，在现实的场景中，一台机器通常是不够用的，我们可能需要的是一个集群。

你可能会想到用 Nginx 来做一个负载均衡，但如果用原生的 Java 解决方案，这时候就轮到企业级的应用服务器登场了，比如：IBM WebSphere、Oracle WebLogic Server、JBoss Enterprise Application Platform 等等。至此，一套完整的 Java 应用解决方案已经部署起来了。但我们知道了这些，和我们运维知识有什么关系呢？我们可以用同样的体系去理解运维知识。

### 3.3 运维知识体系

首先，要理解运维体系的语言。运维的语言是什么呢？是 Shell，人们最熟悉的应该是 Bash。我们通过操作系统与计算机打交道，但我们无法直接只用操作系统内核，Shell 为我们提供了一个接口，让我们可以访问操作系统内核提供的服务。

你可能会以为我这里用的是比喻，将 Shell 比喻成语言，但还真不是，Shell 本身就是一门编程语言。绝大多数人都知道 Shell 可以编程，但几乎没有人把 Shell 当成一门编程语言来学习，基本上都是在需要的时候，搜一下，然后照猫画虎地将代码复制上去。这样造成的结果就是，一旦写一个脚本，就要花费大量的时间与语法做斗争，只是为了它能够运行起来。

有了语言，再来就是核心库了。运维的核心库是什么？就是 Shell 提供的各种 Unix/Linux 的核心命令，比如：ls、cd、ps、grep、kill、cut、sort、uniq 等等，它们几乎与操作系统绑定在一起，随着操作系统一起发布。

了解了核心的部分，还需要了解一些第三方库，运维知识的第三方库就是那些不属于操作系统核心命令的命令，比如：rsync、curl 等等。Java 有框架可用，运维也有框架吗？你可以想一下，Java 的框架提供的是一些通用的能力，在运维工作中，也是有一些通用能力的，比如：在安装某个包之前，要检查一下这个包是否已经安装了；在启动一个服务前，要检查这个服务是否启动了，等等。所以，能够帮我们把这些工作做好的工具，就是我们的运维框架。到这里，你应该已经明白了，我在说的运维框架其实就是像 Chef、Puppet、Ansible 之类的配置管理工具。它们做的事就是把那些繁琐的工作按照我们的定义帮我们做好。

有了对软件环境的基本配置，接下来，就要找一个运行时的环境将软件跑起来了。这时候，我们要了解像虚拟机、Docker 之类的技术，它们帮我们解决的问题就是在单机上的部署。一般来说，了解了这些内容，我们就可以构建出一个开发环境或测试环境。除非用户非常少，我们可以在生产环境考虑单机部署，否则，我们迄今为止讨论的各种技术还都是在开发环节的。

如果我们需要一个集群或是高可用环境，我们还需要进一步了解其他技术，这时候，就轮到一些更复杂的技术登场了，比如，云技术，Amazon AWS、OpenStack，包括国内的阿里云。如果你采用的是 Docker 这样的基础技术，就需要 Kubernetes、Docker Swarm 之类的技术。至此，一个相对完整的运维知识体系已经建立起来了，现在你有了一张知识地图，走在运维大陆上，应该不会轻易地迷失了。希望你可以拿着它，继续不断地开疆拓土。

### 黑板墙

现在运维流行 DevOps，高级一点就是 AI，其中一篇文章《DevOps 详解》不错，链接如下：[DevOps详解 - InfoQ](https://www.infoq.cn/article/detail-analysis-of-devops)。《DevOps 知识体系与标准化的构建》也不错。运维知识体系：[运维知识体系v3.1【赵班长】](https://www.unixhot.com/page/ops)。Web 缓存知识体系：[缓存知识体系v3.0【赵班长】](https://www.unixhot.com/page/cache)。

运维技能：1）懂网络，一般要求 CCNA（最好 CCNP）或同等水平。2）懂系统，懂得主流的 linux 系统操作（Centos、ubuntu、debian 等），操作命令、维护、性能优化、故障排查。3）简单安全，一些简单的安全知识。4）半个 DBA，一般中小公司前期没有 DBA，需要运维做，最起码会 SQL 语句、主从、群集：redis、mysql、MongoDB 等。5）会运维开发，一般用于开发运维工具、运维系统（如 CMDB、ELK 日志系统等）；运维主要语言是 shell、python/Go；python web 框架：Django、tonado 等；Go web 框架：Beego、Gin、Iris 等；有的还会用 PHP 及框架（TP、YII、Laravel 做 web 前端）。中小公司运维一般都没有专职的前端，需要运维兼职所以要学前端知识。6）懂点开发，一般都懂一点本公司开发的语言，如公司用 PHP 需要学习、如公司用 java web 也需要学习一下，目标：a）更好的维护网站，排错。b）运维自动化、DevOps，因 DevOps 是基于敏捷开发，极限编程的思想，所以得懂一点软件工程。7）主职：各种环境的搭建：LAMP、LNMP、负载均衡（nginx、haproxy、VLS 等）、web 群集、数据库群集、主流的 docker [必会]；排错 [必会]；批量安装系统安装：Cobbler [少]；部署工具：Ansible/SaltStack [重要]；主流的部署方案：如云、docker、k8s 等 [必会]；监控系统：zabbix、Open-Falcon [至少掌握其中一种]；自动化：gitlab CI/CD、jenkins 结合 ansible/salt、docker [必会]；运维流程的制定；减少背锅的次数：运维是出名的「背锅侠」，制定明确的责任可以减少背锅。等等。8）会点构架，一般中小公司没有构架师，所以当业务增大出现瓶颈，运维得给出解决方案和开发讨论如何扩展。总结：在中小公司运维工作就是一件很杂的工作，什么都要求会一点。2019-03-22

1『运维知识体系，这个图谱好 NB。』

还有性能分析和调优，比如 Java 有 JVM 内存模型和运行参数调优，运维有单 CPU 多 CPU 的硬件模型和操作系统参数优化。作者回复：这个类比很不错！2019-03-22

可视化监控衍生出的网络协议、网络与安全设备、软硬件性能指标等相关方面的知识与工具也是运维工作需要关注的。2019-03-25

如何系统学习呢？就是按照上面的表格类比，类比思维？作者回复：一层一层地了解，至少要了解基本的用法。还有一种极致的方式，联系柴锋老师去上他的课。2019-03-22

我有一个困惑：「我开发完成之后，现在提测。提测需要发送测试邮件，然后把代码上传到 svn。再由编译人员拉下代码，编译部署。」但是在这过程中发生了几个问题：1）部署涉及三个服务器环境，但是其中有两个环境的服务（包括数据库）挂掉了，而且我们实现并不知晓。2）编译人员并不知道，他所负责环境下的项目服务器的用户名和密码还有数据库的用户名和密码。3）项目经理坦言这几个环境不归他管理，但是对应的服务必须由他开启。然后我们并没有服务开启的文档，只能从百度上一点一点的尝试。那现在的问题是，这一些都需要我去串联。作者回复：你工作在二三十年前，辛苦了。如果过程不做改变，你一个人很难改变。所以，可以建议调整流程。2019-10-14

我看完这篇文章的收获，可能和老师写这篇文章的初衷有所不同，老师写这篇文章的初衷是写给那些想学习运维知识的程序员，通过 Java 的框架来类比于运维的框架。而对于我来说，我本身是运维，目前正在学习 Java 语言，所以反而能让我从运维的视角，更好的理解和学习 Java 语言这门工具。2019-06-13

## 0404持续交付有持续集成就够了吗.md

我们延续了前两讲的内容，在准备好发布包和部署的基础设施之后，我们顺着持续集成的思路，将部署过程也加了进来，这就是持续交付。持续交付，是一种让软件随时处于可以部署到生产环境的能力。让软件具备部署到生产环境的能力，这里面有两个关键点：验证发布包和部署。1）验证发布包，不仅是功能上的验证，还包括与环境结合在一起的验证。所以，通常会用几个不同的环境验证，每一个环境都是一个单独的阶段，一个阶段不通过，是不能进入下一阶段的，这种按照不同阶段组织构建的方式，称之为构建流水线（Build Pipeline）。2）与部署相关的一个重要概念是 DevOps，也就是将开发和运维结合起来。DevOps 包含了很多方面，对程序员最直接的影响是各种工具的发展，这些工具推动着另一个理念的发展：基础设施即代码（Infrastructure as code） 。有赖于这些工具的发展，今天定义交付，就不再是一个发布包，而是一个可以部署的镜像。如果今天的内容你只能记住一件事，那请记住：将部署纳入开发的考量。

在前面两讲，我给你讲了开发过程的自动化，将我们的程序打成发布包；然后讲了部署过程的自动化，通过各种工具将发布包部署起来。有了这些基础，我们就可以考虑在每次开发完之后，将程序打包部署到环境中。开发完就自动打包，然后自动部署，听起来很像持续集成是不是？

关于持续集成，我在专栏里已经讲过两次，分别讨论了「为什么要做持续集成」和「怎么做好持续集成」。但持续集成的讨论只停留在开发环节。有了前面两讲的准备，我们就可以把这个过程再进一步延伸。聪明的你或许已经听出来了，这次我要讲的主题是持续交付。

### 4.1 持续交付

让持续交付这个概念广为人知的是一本书，Jez Humble 和 Dave Farley 的《持续交付》（Continuous Delivery）。前面讲持续集成的发展历史时，我提到了 CruiseControl，它是持续集成服务器的鼻祖。因为持续集成的不断发展，2007 年，我的老东家 ThoughtWorks 公司有意以 CruiseControl 为基础，提供企业级服务，于是成立了一个团队，打造一个更好的持续集成服务器，Jez Humble 就是在这个团队中工作的。同样在这个团队工作的还有一个人，乔梁，他是《持续交付》这本书的中文版译者，而且在这本书出版近十年后，他自己写了《持续交付 2.0》，把自己多年来关于持续交付的新理解整理了进去。

2『已下载书籍「2020131持续交付 | 2020131Continuous-Delivery」以及购买了纸版书籍「2020144持续交付2.0」』

那么，什么叫更好的持续集成服务器呢？当时我的理解很浅薄，只是希望它有更好的界面，更快的构建速度，而 Jez Humble 他们对于这个产品的构想远远超过了我当时的想象，他们将生产环境也纳入了考量。

什么是持续交付？简言之，它就是一种让软件随时处于可以部署到生产环境的能力。从一个打好的发布包到部署到生产环境可用，这中间还差了什么呢？那就是验证发布包，部署到环境中。

验证发布包，你或许会想，这不是测试的事吗？这不是已经在持续集成阶段完成的吗？不尽然。在持续集成阶段验证的包，往往缺少了环境的支持。因为持续集成的环境往往是单机的，主要强调功能验证，而一些与生产环境相关的测试往往是欠缺的。所以，这里就引出了持续交付中一个需要关注的点：环境。

一般来说，在构建持续交付的基础设施时，会有下面几个不同的环境。1）持续集成环境，持续集成是持续交付的前提，这个过程主要是执行基本的检查，打出一个可以发布的包。2）测试环境（Test），这个环境往往是单机的，主要负责功能验证，这里运行的测试基本上都是验收测试级别的，而一般把单元测试和集成测试等执行比较快的测试放到持续集成环境中执行。3）预生产环境（Staging），这个环境通常与生产环境配置是相同的，比如，负载均衡，集群之类的都要有，只是机器数量上会少一些，主要负责验证部署环境，比如，可以用来发现由多机并发带来的一些问题。4）生产环境（Production），这就是真实的线上环境了。

你也看出来了，每个环境的作用是有差异的，所以，通常不会将所有的验证放在一起执行，而是要分阶段的去执行，一个阶段不通过，是不能进入下一阶段的，这种按照不同阶段组织构建的方式，称之为构建流水线（Build Pipeline）。

一旦通过了各种验证，就会到构建流水线的最后一个阶段，生产发布。通常来说，生产发布这个过程不是自动化的。我们说，持续交付的关注点在于，让软件具备随时可以发布的能力，但并不等于它要立刻上线，所以，最后这一下，还要由人来决定，到底是不是要上线。

如果把由人决定的是否上线变成自动化的，就成了另外一个实践：持续部署。但通常人们都会比较谨慎，最后这一下还是由人拍板比较稳妥，所以，持续交付是现在的主流。至此，我们讨论了持续交付的第一个方面，验证发布包。接下来，我们再来看看另外一个重要部分：部署。

### 4.2 DevOps

早期人们做部署都是自己编写 Shell 脚本完成的，但在上一讲中，我提到的一些工具，比如：Chef、Puppet、Ansible 等等，大幅度地简化了部署脚本的编写。这些工具在业界的兴起与一个概念息息相关：DevOps。

DevOps 是一种软件交付的理念和方法，目的是增强软件的可靠性。从名字便不难发现，DevOps 是将开发（Development）和运维（Operations）组合在了一起。在传统的 IT 公司中，开发和运维往往是井水不犯河水的两个职位，甚至是两个不同的部门，由此带来了很多问题，比如，开发人员修改了配置，但没有通知运维，造成了新代码不能运行。

DevOps 提倡的就是将二者融合起来，打破壁垒。2009 年，Flickr 做了一个分享《每天部署 10 次》，整个行业受到了极大的冲击，从此 DevOps 运动风起云涌。DevOps 给这个行业带来的理念冲击是很大的，想要做好 DevOps，需要在文化、流程和工具等诸多方面不断改善。但对我们程序员的日常工作来说，最直接的影响是体现在各种工具上。Chef、Puppet、Ansible 这些工具基本上都是在那之后，兴起或广为人知的。

3『 [10+ Deploys Per Day: Dev and Ops Cooperation at Flickr](https://www.slideshare.net/jallspaw/10-deploys-per-day-dev-and-ops-cooperation-at-flickr) 』

在上一讲中，我给你讲了这些配置管理工具在运维体系中的角色，它们相当于提供了一个框架。但对于行业来说，这些工具给行业带来了部署的规范。从前写 Shell 的方式，那就是各村有各村的高招。你在 A 公司学会的东西，到 B 公司是没法用的，甚至在很多人的印象中，部署这件事就应该属于某个特定的场景，换台机器脚本都要重新写过。这种形势就如同 Spring 出现之前，几乎所有的公司都在写自己的框架一样。

Spring 的出现打破这一切，让你的 Java 技能从归属于一个公司变成了行业通用。同样，运维体系中这些配置工具也起到了这样的作用。它们甚至带来了一个新的理念：基础设施即代码（Infrastructure as code），将计算机的管理与配置变成了代码。一旦成了代码，就可以到处运行，可以版本管理，那种强烈依赖于「英雄」的机器配置工作终于可以平民化了。这在从前是想都不敢想的事。

这些工具采用的都是声明式接口，从 Shell 那种描述怎么做，到描述做什么，抽象程度上了一个台阶，让开发者或系统管理员从琐碎的细节中脱身，把更多的注意力用于思考应该把机器配置成什么样子。如果这些配置管理工具还需要有一台具体的机器去部署，放在持续交付中，也只能扮演一个部署环境的次要角色，那 Docker 的出现则彻底地改变最终交付物。

我在上一讲说过，Docker 相当于是一台机器。Docker 非常好的一点是，它是一台可以用代码描述的机器，在 Docker 配置文件中描述的就是我们预期中那台机器的样子，然后，生成镜像，部署到具体的机器上。

既然是要描述机器的样子，我们就可以在 Docker 的配置文件中使用前面提到的配置工具，如此一来，我们的配置工作就简单了。那既然我们在讨论持续交付，还可以通过配置工具将我们的发布包也部署到最终的镜像中。这样一来，最终生成的镜像就是包含了我们自己应用的镜像。你或许已经知道我要说什么了，结合着这些工具，我们的生成产物就由一个发布包变成了一个 Docker 镜像。

Docker 在开发中扮演的角色，是一个构建在我们应用与具体机器之间的中间层。对应用而言，它就是机器，但对机器而言，它只是一个可以部署的镜像，统一了各种应用千奇百怪的部署差异，让部署本身变得更简单了。

到这里，我给你介绍了持续交付中最基础的东西，让你有了一个基本的框架理解持续交付。当然，如果你关注这个领域，就会发现，它早已超出了一个实践的层面，有更多组织、文化的内容。Jez Humble 写《持续交付》时就已经想到如此完整的一个体系，受限于当时的环境，书中介绍的自动化还比较宽泛，不像今天有更加完善的工具支撑。

只可惜，虽然当时他对持续交付的理解已经到达如此高度，他所在的团队也做出了一个颇具先锋气质的持续交付工具，但是受限于产品推广策略，这个工具并没有成为主流，即便后来开源了。（如果你想了解一下这个工具，可以点击链接「[Open Source Continuous Delivery and Release Automation Server | GoCD](https://www.gocd.org/)」去查看）

### 黑板墙

分而治之是解决复杂问题的一大利器。持续交互就像重构中小步快走（每次微调后运行测试代码验证），都能保证大工程的稳步前进。同时由于单元小了，所以也灵活了，持续交互可以结合最小产品的理念，以小成本做 test，收集数据后，即使调整产品发展方向。作者回复：任务分解，小步快跑，你能看到不同实践的联系，就说明理解了。2019-03-25

问您一个题外的问题，就是您觉得运维监控这是一个可以单独发展的职业方向吗？比如像 ELK 等监控日志分析应用的使用。作者回复：评判标准是，有没有人花钱请你做这件事。2019-06-14

我理解的持续交付，是可以快速向用户交付价值；传统的开发方式下，开发、测试、上线，需要较长的流程以及时间，交付是间隔的，用户需要去等待；而通过持续集成，开发有了持续交付的能力，可以今天开发、今天上线，不敢想象。作者回复：持续交付是以自动化为基础的，没有自动化，那还真不敢想象。2019-03-25

持续交付，就是持续向用户交付价值，即刻获得反馈，即时调整，再次交付。再进一步说，持续交付可以是持续交付最大价值，那范围就不仅限于软件，还可以进一步延伸到运营，比如说结合 ABTest，自动选择最有效的运营策略，为用户交付最大价值。脑洞一下，终极目标甚至可以是 C2C，即 Code to Customer。作者回复：这个问题还真是我思考过的问题，结合着精益创业的理念，再往前延伸，应该是持续验证，因为精益创业就是在不断验证新的想法。2019-03-25

请教老师一个问题：那是不是可以这么理解，现在的开发人员一定要具备进行持续部署时所涉及的技术，例如 docker，k8s 等？作者回复：没有一定，只是作为一个优秀程序员，最好有完整的知识体系。2019-05-05

终于理解了持续集成、持续交付和持续部署的区别…… 目前公司还处在持续集成和持续交付的混合阶段，离持续部署还有很大一段距离。不过因为公司比较大，部门众多，管理生产环境的有专门的 Unix 团队，估计这个持续部署还很难做到。2019-06-14

可不可以说 DevOps 是为满足持续交付的需求而诞生的啊。作者回复：并不是，二者独立发展，殊途同归。2019-04-18

老师我问个很 low 的问题，什么是集成，包括那些环节？它是包括「代码编写 --> 提交 --> 构建 --> 测试 --> 显示结果」吗，还是文章中提到的 CI 框中只包括「构建 --> 测试 --> 结果」？作者回复：集成，实际上就是把你所有的代码放在一起跑。这里所说的是持续集成，想要做好它，才需要包含那么多环节。图里显示的，只是在 CI 服务器上运行的部分。你可以先回顾前面两篇文章，对持续集成有更多的了解。2019-03-26

交付作为集成的后续，为达到有效交付的目标，用户能够尽早参与我觉得也是比较重要的一环。文中插图从程序员视角出发，从生产环境获得结果，是否可再做扩展，将用户也作为一个独立节点？形成更加全面的闭环，架起人与人之间互动的桥梁。在公司内部讨论中，谈到过在交付物中引入用户体验收集的模块，提供用户常用反馈功能如图文，这样程序员除了功能、数据等验证外，也第一时间知道用户关注优先解决，原因是发现程序员和用户的关注有时相去甚远，而且在现场没有实施人员时也能很大提高沟通效率，降低编解码误差。作者回复：理想是好的，我也曾经想过怎么把持续交付进一步延伸，比如，怎么把用户反馈纳入其中。想持续做，能够自动化是前提，用户反馈怎么自动化呢，这是一个需要回答的问题。目前这个方面还没有形成完整的体系。2019-03-26

感觉只有把持续集成做得很好。才能够有持续交付的可能性。持续集成感觉就是质量的一个基础保障，以及持续交付的根基。作者回复：你理解得没错。2020-03-29

持续集成不是不断集成的意思吗？在极限编程里，不断集成不就是持续集成吗？持续集成不是不断重复集成的环节吗？问题是我连集成是什么，包括什么环节都不懂，所以先搞懂什么是集成。作者回复：先回到前面搞懂集成和持续集成，再来看持续交付。2019-03-27

是的，如果要做 AB 测试，这个持续交付又将怎么做呢，构建 pipeline 是什么样的。另外持续集成中如果前后端分离是要分两个 agent 跑，还是就用一个 agent 比较合适，我好像是倒序看作者的专栏，也不知前面有否讲过，只是看到这篇文章后有此困惑。2019-03-27

持续交付，我的理解就是快速将想法变为实现的能力，结合敏捷开发，提升企业的交付能力。老师，我对持续交付跟 DevOps 这两个概念一直很模糊，感觉就是一个东西，他们的区别在哪里？作者回复：你可以先看一下文中的解释，DevOps 和持续交付是相辅相成的，二者在部署自动化是重叠的。DevOps 更多关注在 Dev 和 Ops 的融合上，而持续交付则更多关注在产品交付上。2019-03-26

## 0405如何做好验收测试.md

和你分享了自动化验收测试的话题。验收测试（Acceptance Testing），是确认应用是否满足设计规范的测试。验收测试是技术交付必经的环节，只不过，各个团队实践水平有所差异，有的靠人工，有的用简单自动化，一些做得比较好的团队才有完善的自动化。自动化验收测试也是一个逐步发展的过程，从最开始的各自为战，到后来逐渐形成了一个完整的自动化验收测试的体系。今天，我以行为驱动开发（Behavior Driven Development，BDD）为核心，给你介绍了一种自动化验收测试的方式。这个在 2003 年由 Dan North 提出的概念已经成为了一套比较完善的体系，尤其是一些 BDD 框架的发展，让人们可以自己的项目中实践 BDD。我以 Cucumber 为样例，给你介绍了 BDD 验收用例的编写方式，你知道「Given…When…Then」的基本格式，也知道了要编写步骤定义（Step Definition）将测试用例与实现连接起来。我还给你介绍了编写 BDD 测试用例的最佳实践：用业务的视角描述测试用例。在编写步骤定义时，还要考虑设计自己的业务测试模型。其实，验收测试的方法不止 BDD 一种，像实例化需求（Specification by Example，SbE）也是一种常见的方法。验收测试框架也不止 BDD 框架一类，像 Concordion 这样的工具甚至可以让你把一个验收用例写成一个完整的参考文档。如果你有兴趣，可以深入地去了解。无论哪种做法，都是为了缩短业务人员与开发团队之间的距离，让开发变得更加高效。如果今天的内容你只能记住一件事，那请记住：将验收测试自动化。

经过前面三讲的讲解，相信你对一个项目自动化应该是什么样子有了一个相对完整的认识：程序员写好程序，用构建脚本执行检查，提交代码，在服务器上打出一个发布镜像，部署到各个环境进行检查，检查好了，随时可以发布上线。

我们在前面的内容中只说了该检查，但怎么检查呢？这就轮到测试发挥作用了。在「任务分解」的模块，我给你完整地介绍了一下开发者测试的概念，但在那个部分讲解的测试基本上还停留在单元测试和集成测试的范畴。对于整个应用该怎么测，我们并没有仔细讨论。今天我们就来说说应用测试的话题：验收测试。

### 5.1 验收测试

验收测试（Acceptance Testing），是确认应用是否满足设计规范的测试。这种测试往往是站在用户的角度，看整个应用能否满足业务需求。从名字上来看，验收应该是业务人员的事，但业务人员能做的最多只是验收，测试是他们无论如何也不太可能做仔细的。所以，验收测试这件事，往往还是由技术团队自己完成，而且在很多公司，这就是测试人员的事。时至今日，很多测试团队都拥有自动化的能力。所以，自动化验收测试自然是重点的考虑对象。今天，我们的重点就是怎么做好自动化的验收测试。

其实，验收测试应该是人们最早想到的自动化测试，早在单元测试还不流行的年代，人们就开始了对自动化验收测试的探索。有不少团队甚至还构建了自己的框架，只不过，这种框架不是我们今天理解的测试框架，而是针对着一个应用的测试框架。

比如，我曾经见过有人为通信软件构建的一套完整的测试框架，甚至构建了属于自己的语言，测试人员的工作就是用这种特定的语言，对系统进行设置、运行，看它是否满足自己的预期。相对来说，他们的这种做法已经非常成熟了。但更多团队的现实情况是，自己把对应用的访问做一个简单的封装，然后，写测试就是编写代码调用这个封装。

让验收测试从各自为战的混乱中逐渐有了体系的是行为驱动开发（Behavior Driven Development）这个概念的诞生，也就是很多人知道的 BDD。

### 5.2 行为驱动开发

行为驱动开发中的行为，指的是业务行为。BDD 希望促进业务人员与开发团队之间的协作，换句话说，如果你想做 BDD，就应该用业务语言进行描述。这与我们传统上理解的系统测试有着很大的差别，传统意义上的系统测试是站在开发团队的角度，所以，更多的是在描述系统与外部系统之间的交互，用的都是计算机的术语。而 BDD 则让我们换了一个视角，用业务语言做系统测试，所以，它是一个更高级别的抽象。

BDD 是 2003 年由 Dan North 提出了来的。Dan North 不仅仅提出了概念，为了践行他的想法，他还创造了第一个 BDD 的框架：JBehave（[What is JBehave?](https://jbehave.org/)）。后来又改写出基于 Ruby（[Ruby Programming Language](http://www.ruby-lang.org/en/)）的版本 RBehave（[Introducing rbehave | Dan North & Associates](https://dannorth.net/2007/06/17/introducing-rbehave/)），这个项目后来被并到 RSpec（[RSpec: Behaviour Driven Development for Ruby](http://rspec.info/)）中。

今天最流行的 BDD 框架应该是 Cucumber（[BDD Testing & Collaboration Tools for Teams | Cucumber](https://cucumber.io/)），它的作者就是 RSpec 的作者之一 Aslak Hellesøy。Cucunber 从最开始的 Ruby BDD 框架发展成今天支持很多不同程序设计语言的 BDD 测试框架，比如，常见的 Java、JavaScript、PHP 等等。

BDD 框架给我们最直观的感受就是它给我们提供的一套语言体系，供我们描述应用的行为，下面是一个例子，它描述了一个交易场景，应用需要根据交易结果判定是否要发出警告。你可以感受一下：

```
Scenario:  trader is not alerted below threshold
 
Given a stock of symbol STK1 and a threshold of 10.0
When the stock is traded at 5.0
Then the alert status should be OFF

Scenario:  trader is alerted above threshold
 
Given a stock of symbol STK1 and a threshold of 10.0
When the stock is traded at 11.0
Then the alert status should be ON
```

我们在这里的关注点是这个例子的样子，首先是描述格式：「Given…When…Then」，这个结构对应着这个测试用例中的执行步骤。Given 表示的一个假设前提，When 表示具体的操作，Then 则对应着这个用例要验证的结果。

还记得我们讲过的测试结构吗？前置准备、执行、断言和清理，这刚好与「Given…When…Then」做一个对应，Given 对应前置条件，When 对应执行，Then 则对应着断言。至于清理，它会做一些资源释放，属于实现层面的内容，在业务层面上意义不大。

了解了格式，我们还要关心一下内容。你会看到这里描述的行为都是站在业务的角度进行叙述的，而且 Given、When、Then 都是独立的，可以自由组合。也就是说，一旦基础框架搭好了，我们就可以用这些组成块来编写新的测试用例，甚至可以不需要技术人员参与。

不过，这些内容都是站在业务角度的描述，没有任何实现的内容，那实现的内容放在哪呢？我们还需要定义一个胶水层，把测试用例与实现联系起来的胶水层，在 Cucumber 的术语里，称之为步骤定义（Step Definition）。这里我也给出了一个例子，你可以参考一下：

```java
public class TraderSteps implements En {
    private Stock stock;

    public TraderSteps() {
        Given("^a stock of symbol {string} and a threshold of {double}", (String symbol, double threshold) -> {
            stock = new Stock(symbol, threshold);
        });

        When("^the stock is traded at {double}$", (double price) -> {
            stock.tradeAt(price);
        });

        Then("the alert status should be {string}", (String status) -> {
            assertThat(stock.getStatus().name()).isEqualTo(status);
        })
    }
}
```

### 5.3 写好验收测试用例

有了对 BDD 框架的基本了解，接下来的问题就是，怎么用好 BDD 框架。我们举个简单的例子，如果我们要写一个登录的测试用例，你会怎么写呢？有一种写法是这样的，为了方便叙述，我把它转成了中文描述的格式，Cucumber 本身是支持本地化的，你可以使用自己熟悉的语言编写用例：

```
假定 张三是一个注册用户，其用户名密码是分别是 zhangsan 和 zspassword
当 在用户名输入框里输入 zhangsan，在密码输入框里输入 zspassword
并且 点击登录
那么 张三将登录成功
```

这个用例怎么样呢？或许你会说，这个用例挺好的。如果你这么想，说明你是站在程序员的视角。我在前面已经说过了，BDD 需要站在业务的角度，而这个例子完全是站在实现的角度。如果登录方式有所调整，用户输完用户名密码自动登录，不需要点击，那这个用例是不是需要改呢？下面我换了一种方式描述，你再感受一下：

```
假定 张三是一个注册用户，其用户名密码是分别是 zhangsan 和 zspassword
当 用户以用户名 zhangsan 和密码 zspassword 登录
那么 张三将登录成功
```

这是一个站在业务视角的描述，除非做业务的调整，不用用户名密码登录了，否则，这个用例不需要改变，即便实现的具体方式调整了，需要改变的也是具体的步骤定义。所以，想写好 BDD 的测试用例，关键点在用业务视角描述。

编写验收测试用例的步骤定义时，还有一个人们经常忽略的点：业务测试的模型。很多人的第一直觉是，一个测试要啥模型？还记得我们讲好测试应该具备的属性吗？其中一点就是 Professional，专业性。想要写好测试，同写好代码是一样的，一个好的模型是不可或缺的。

这方面一个可以参考的例子是，做 Web 测试常用的一个模型：Page Object。它把对页面的访问封装了起来，即便你在写的是步骤定义，你也不应该在代码中直接操作 HTML 元素，而是应该访问不同的页面对象。以前面的登录为例，我们可能会定义这样的页面对象：

```java
public class LoginPage {
    public boolean login(String name, String password) {
      ...
    }
}
```

如此一来，在步骤定义中，你就不必关心具体怎么定位到输入框，会让代码的抽象程度得到提升。当然，这只是一个参考，面对你自己的应用时，你要考虑构建自己的业务测试模型。

### 黑板墙

之前团队就有人自己开发了一套 DSL 用来描述验收测试用例，自己跑各种测试，从构建依赖环境，启动虚拟机，到运行测试，不亦乐乎。我发现真有一类人迷恋这种做法，愿意把代码和测试代码以及验收测试代码写得很好，即便开始的时候要花比较多时间，他们非常享受测试通过后的绿色 bar。虽然过于迷恋未必有利于项目，但据我观察大多有这样工作习惯的技术人员都很出色。作者回复：我很喜欢一个说法，软件工匠，把写代码这件事当做手艺活来不断打磨。2019-03-27

如果在理想状态下，单元测试、持续集成和系统测试等都做的很好，那么验收测试一把过是不是就顺理成章了甚至不需要了？它们几个在软件生命周期里侧重些什么？验收测试作为一个主题单独讲解是不是说明前几个还不能保证足够完善或者需要从别的视角对它们做出修正呢？作者回复：你都说了「理想状态」下，现实情况是，理想状态不存在。验收测试就是站在业务的视角看待系统的一个过程，而其它几个都是站在软件本身的角度在看。以我对开发做测试这件事的理解来看，开发人员在测试用例设计上，与测试人员还是有很大差距的，测试人员总是可以探索出不同的角度打败你。2019-03-31

类似 BDD 这种行为驱动开发相关的内容，包括其已有的框架 Concordion 是第一次了解到，长见识了。不过在我的了解中，能够践行这种验收测试的公司应该很少吧？作者回复：做测试的程序员不多，做 BDD 的人就更少，所以，只要学会这些东西，就比业界大部分程序员水平高了。2019-05-05

验收测试和常规的集成测试有什么区别？作者回复：一般说集成测试，还是站在内部的角度，也就是技术的角度在说，而验收测试应该是站在业务的角度，没做好的另当别论。2019-03-27

自动化验收测试确实是很好的东西，比如在回归测试，省去了很多的重复工作。但我理解 BDD 的初衷是驱动产品、业务、开发、测试等去深入讨论沟通需求，在还没有真的写代码的时候去实例化 story，并一起定义验收用例，让每个人对需求的理解都很透彻，当然特别注意的是要从统一的业务角度去描述，可见，真的做好 BDD 是需要不断的尝试和总结的。作者回复：你的理解很对，BDD 不太可能一蹴而就，需要各方不断磨合。2019-03-27

请教老师，有真实项目中的一些验收测试的例子吗？有 github 上的项目可借鉴的吗？作者回复：我还真不知道哪个开源项目这么做，我都是在内部项目上这么做的。2019-03-27

公司老项目，没有测试代码，更别说 bdd 自动化验收代码了。不过我在尝试为核心的一些业务补充测试代码。刚好可以研究下。有价值的活动不仅仅是写需求，如果只是验收需求，整成自动化验收成本是比较高的，业务不见个愿意买单。但如果说成减少测试队友重复工作，提高需求开发速度和项目可扩展性与健壮性（利于重构，而重构能产生以上价值），并给出大概的量化指标，大部分业务都会再斟酌下的。作者回复：关于遗留系统的讨论正在不远处等着你。2019-03-27

作者给出的参考链接和一些参考书名都很好，国内项目实施 BDD 的很少吧，可能客户觉得这很浪费时间，或者他们觉得开发做这个他们要承受一些成本。作者回复：不做的理由有一万个，做的理由有一个就够了！2019-03-27

验收测试是不是针对业务需求的测试？作者回复：对，应该是这样的。2019-03-27

老师，selenium 跟 Cucumber，端到端测试跟验收测试，有区别吗？作者回复：对比这里的例子，Selenium 是用来实现这里的步骤定义的。2019-03-27

我没有明白举那个例子的意义，配置文件写了几段话，程序里写胶水代码去支持，这个感觉也不动态啊，这不是绑死了吗？作者回复：这里面在业务层需要组合的代码是 Given...When...Then 的部分。当你有了足够的基础描述之后，就可以任意组合这些语句了。至于胶水层代码，它本来就是为了支持每一个 Given/When/Then 的实现，不需要更多的能力。2019-03-27

我的团队在做一个 web 项目，随着业务复杂，一个迭代开发完成后，经常会发现系统某些隐藏的功能用例不在了，除了前面所讲项目中增加单元测试，code-review 外，如果从自动化验收测试角度，该如何检查出这样的问题。我们团队测试一般针对当前迭代功能需求进行人工验收测试。很难做不到把系统所有用例都进行一番测试。所有很是一个头疼事，每次迭代都存在风险。2019-03-27

## 0406你的代码是怎么变混乱的.md

讲的内容是软件设计，很多代码的问题就是因为对设计思考得不足导致的。许多程序员学习设计是从设计模式起步的，但这种学法往往会因为缺乏结构，很难有效掌握。设计原则，是一个更好的体系，掌握设计原则之后，才能更好地理解设计模式这些招式。Robert Martin 总结出的「SOLID」是一套相对完整易学的设计原则。我以「SOLID」中的单一职责原则为例，给你稍做展开，更多的内容可以去看 Robert Martin 的书。不过，我也给你补充了一些维度，尤其是从「小」的角度告诉你，你能看到多小，就能发现代码里多少的问题。如果今天的内容你只能记住一件事，那请记住：把函数写短。

前面几讲，我给你讲了开发过程的各种自动化，从构建、验证到上线部署，这些内容都是站在软件外部看的。从这一讲开始，我准备带领大家进入到软件内部。今天的话题就从写代码开始说起。

### 6.1 逐步腐化的代码

代码是程序员改造世界最直接的武器，却也是程序员抱怨最多的东西。为什么程序员会对代码如此不满呢？你会抱怨写一段代码吗？你肯定不会，毕竟这是你养家糊口的本领，最基本的职业素养我们还是有的。那抱怨的是什么呢？是维护一段代码。为什么维护代码那么难？因为通常来说，你维护的这段代码是有一定年龄的，所以，你总会抱怨前人没有好好写这段代码。

好，现在你拿到了一个新的需求，要在这段代码上添加一个新功能，你会怎么做呢？很多人的做法是，在原有的代码上添加一段新的逻辑，然后提交完工。发现问题了吗？你只是低着头完成了一项任务，而代码却变得更糟糕了。如果我问你，你为什么这么做？你的答案可能是：「这段代码都这样了，我不敢乱改。」或者是：「之前就是这么写的，我只是遵循别人的风格在写。」

行业里有一个段子，对程序员最好的惩罚是让他维护自己三个月前写的代码。你一不小心就成了自己最讨厌的人。从前，我也认为很多程序员是不负责任，一开始就没有把代码写好，后来，我才知道很多代码其实只是每次加一点。你要知道，一个产品一旦有了生命力，它就会长期存在下去，代码也就随着时间逐渐腐烂了。而几乎每个程序员的理由都是一样的，他们也很委屈，因为他们只改了一点点。

这样的问题有解吗？一个解决方案自然就是我们前面说过的重构，但重构的前提是，你得知道代码驶向何方。对于这个问题，更好的答案是，你需要了解一些软件设计的知识。

### 6.2 SOLID 原则

提到软件设计，大部分程序员都知道一个说法「高内聚、低耦合」，但这个说法如同「期待世界和平」一样，虽然没错，但并不能很好地指导我们的具体工作。人们尝试着用各种方法拆解这个高远的目标，而比较能落地的一种做法就是 Robert Martin 提出的面向对象设计原则：SOLID（[ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)），这其实是五个设计原则的缩写，分别是：1）单一职责原则（Single responsibility principle，SRP）。2）开放封闭原则（Open–closed principle，OCP）。3）Liskov 替换原则（Liskov substitution principle，LSP）。4）接口隔离原则（Interface segregation principle，ISP）。5）依赖倒置原则（Dependency inversion principle，DIP）。

3『 The OLD Object Mentor blog site: [FrontPage](http://butunclebob.com/FrontPage) 』

早在 1995 年，Robert Martin 就提出了这些设计原则的雏形，然后在他的《敏捷软件开发：原则、实践与模式》这本书中，比较完整地阐述了这五个原则。后来，他有把这些原则进一步整理，成了今天的「SOLID」。

学习这些设计原则有什么用呢？今天的程序员学习软件设计多半是从设计模式入门的，但不知道你是否有这样的感觉，在学习设计模式的时候，有几个设计模式看上去如此相像，如果不是精心比较，你很难记得住它们之间的细微差别。而且，真正到了工作中，你还能想得起来的可能就剩下几个最简单的模式了，比如工厂方法、观察者等等。另外，有人常常「为赋新词强说愁」，硬去使用设计模式，反而会让代码变得更加复杂了。你会有一种错觉，我是不是学了一个假的设计模式，人人都说好的东西，我怎么就感受不到呢？

初学设计模式时，我真的就被这个问题困扰了好久。直到我看到了 Robert Martin 的《敏捷软件开发：原则、实践与模式》。这是一本被名字糟蹋了的好书。这本书出版之际，敏捷软件开发运动正风起云涌，Robert Martin 也不能免俗地蹭了热点，将「敏捷」挂到了书名里。其实，这是一本讲软件设计的书。当我看到了 SOLID 的五个原则之后，我终于想明白了，原来我追求的方向错了。如果说设计模式是「术」，设计原则才是「道」。设计模式并不能帮你建立起知识体系，而设计原则可以。

当我不能理解「道」的时候，「术」只能死记硬背，效果必然是不佳的。想通这些之后，我大大方方地放弃了对于设计模式的追求，只是按照设计原则来写代码，结果是，我反而是时常能重构出符合某个设计模式的代码。至于具体模式的名字，如果不是有意识地去找，我已经记不住了。

当然，我并不是说设计模式不重要，之所以我能够用设计原则来写代码，前提条件是，我曾经在设计模式上下过很多功夫。道和术，是每个程序员都要有的功夫，在「术」上下过功夫，才会知道「道」的价值，「道」可以帮你建立更完整的知识体系，不必在「术」的低层次上不断徘徊。

### 6.3 单一职责原则

好，下面我就单拿 SOLID 中单一职责原则稍微展开讲一下，虽然这个原则听上去是最简单的，但也有很多误解存在。首先，什么是单一职责原则呢？如果读过《敏捷软件开发：原则、实践与模式》，你对单一职责的理解应该是，一个模块应该仅有一个修改的原因。

2017 年，Robert Martin 出版了《架构整洁之道》（Clean Architecture），他把单一职责原则的定义修改成「一个模块应该仅对一类 actor 负责」，这里的 actor 可以理解为对系统有共同需求的人。不管是哪个定义，初读起来，都不是那么好理解。我举个例子，你就知道了。我这里就用 Robert Martin 自己给出的例子：

在一个工资管理系统中，有个 Employee 类，它里面有三个方法：1）calculatePay()，计算工资，这是财务部门关心的。2）reportHours()，统计工作时长，这是人力部门关心的。3）save()，保存数据，这是技术部门关心的。

之所以三个方法在一个类里面，因为它们的某些行为是类似的，比如计算工资和统计工作时长都需要计算正常工作时间，为了避免重复，团队引入了新的方法：regularHours()。

接下来，财务部门要修改正常工作时间的统计方法，但人力部门不需要修改。负责修改的程序员只看到了 calculatePay() 调用了 regularHours()，他完成了他的工作，财务部门验收通过。但上线运行之后，人力部门产生了错误的报表。这是一个真实的案例，最终因为这个错误，给公司造成了数百万的损失。

如果你问程序员，为什么要把 calculatePay() 和 reportHours() 放在一个类里，程序员会告诉你，因为它们都用到了 Employee 这个类的数据。但是，它们是在为不同的 actor 服务，所以，任何一个 actor 有了新的需求，这个类都需要改，它也就很容易就成为修改的重灾区。更关键的是，很快它就会复杂到没人知道一共有哪些模块与它相关，改起来会影响到谁，程序员也就越发不愿意维护这段代码了。

我在专栏「开篇词」里提到过，人的大脑容量有限，太复杂的东西理解不了。所以，我们唯一能做的就是把复杂的事情变简单。我在「任务分解」模块中不断强调把事情拆小，同样的道理在写代码中也适用。单一职责原则就是给了你一个指导原则，可以按照不同的 actor 分解代码。

上面这个问题，Robert Martin 给了一个解决方案，就是按照不同的 actor 将类分解，我把分解的结果的类图附在了下面：

### 6.4 编写短函数

好，你已经初步了解了单一职责原则，但还有一点值得注意。我先来问个问题，你觉得一个函数多长是合适的？曾经有人自豪地向我炫耀，他对代码要求很高，超过 50 行的函数绝对要处理掉。我在专栏中一直强调「小」的价值，能看到多小，就可以在多细的粒度上工作。单一职责这件事举个例子很容易，但在真实的工作场景中，你能看到一个模块在为多少 actor 服务，就完全取决于你的分解能力了。

回到前面的问题上，就我自己的习惯而言，通常的函数都在十行以内，如果是表达能力很强的语言，比如 Ruby，函数会更短。所以，你可想而知我听到「把 50 行代码归为小函数」时的心情。我知道，「函数长短」又是一个非常容易引起争论的话题，不同的人对于这个问题的答案，取决于他看问题的粒度。所以，不讨论前提条件，只谈论函数的长短，其实是没有意义的。

单一职责原则可以用在不同的层面，写一个类，你可以问问这些方法是不是为一类 actor 服务；写方法时，你可以问问这些代码是不是在一个层面上；甚至一个服务，也需要从业务上考虑一下，它在提供是否一类的服务。总之，你看到的粒度越细，也就越能发现问题。

### 黑板墙

想起有人说过一句话，大意是如果语言支持，就不需要设计模式。换个角度理解，其实讲的就是设计模式背后的设计原则更重要更本质，是道，而设计模式只是设计原则在具体场景下的派生，是术。张三丰问张无忌：这套拳法你可记得住了？张无忌答：刚开始记得七七八八，现在已经忘得差不多了。张三丰听后满意地抚须而笑作者回复：对，是这个意思。2019-03-29

这么些课跟下来，发现课程从多个角度来阐述。但是拆解这件事一直贯穿在其中。仔细一想都是相通的。小了才会更可控，小了才会更能发现问题。因为有了在动手写之前拆解发现了问题才能保证后面写起来更顺畅。作者回复：嗯，你理解得很到位。2019-03-29

我们常说任务到手不要着急去做，要从设计入手，把时间多花在前面。工作中发现大家都是思考了才动手的，那为什么越往后偏差越大呢？共性原因有二：一是全局观不够，用咱们课里的话说就是上下文局限和反馈延迟（看到问题不提，直到代码写到那绕不过去了再沟通）；二是没有领域的概念和有意识地去实践（纸上谈兵），尤其是做流程型任务，都喜欢先把表结构定义出来，再去生成实体，所以从领域层面来看这些实体就很不合适了。结果必然是用面向对象的工具写出了面向过程的代码，既然是面向过程那 OO 设计原则就鲜有用武之地了。这两点也是我个人理解要做好软件设计的两个必要条件。作者回复：很好的补充！2019-03-31

我呆过的中小公司的开发，基本上不用什么设计模式，SOLID 五个选择挺简单的，但看设计模式感觉比较难，复杂化了……20 多个设计模式一定要学吗？感觉上用到的少，是不是需要再学？另外想问下开发一定要学算法吗？都说算法是程序的灵魂，我看很多开发不不怎么懂算法…也是用到再学？作者回复：算法、数据结构是基本功，至少要懂得常用的数据结构怎么用，知道算法怎么分析。设计是进阶一点的东西，你不学的话，组织代码的能力就差一些。这些东西都要学，没人会强制你用，但不学，你就缺少了一个思考的维度，就很难上台阶。学习是自己的事，越基础的东西越要学好。2019-03-30

老师，案例中将三个方法放在三个类中职责是单一了，但是如果计算正常的工作时间的方法一样的时候，这样不是又出现重复代码的问题了吗？作者回复：这三个类应该自己写自己的，就不应该有共用的代码，甚至不在一个工程里，它们属于不同的限界上下文，后面讲 DDD 会再次提到。2019-03-29

shell 脚本的编写是否也可以遵守这个原则呢？我这两天有个案例，就是我在写一个 shell 脚本，原本是传两个参数，但是发现有另一种特殊情况是两个参数中的一个是固定的，也就是可以不用传，其他功能都一样。像这样的情况您觉得是写两个单独的脚本比较好，还是在同一个脚本里再写一个 switch 判断呢？作者回复：这还是简单的场景，怎么做都好。但有一点，shell 脚本也是源代码，需要按照同样的方式进行维护。2019-06-18

有道无术，术尚可求也；有术无道，至于术。关于设计模式，《重构》《设计模式》《重构与模式》这三本书结合看，我自己理解的更深刻了，并且能够很自然的应用。关于函数长短，我觉得，像人的体温，函数太长，肯定就是发烧了，特别长，会把人烧坏的。作者回复：这个比喻，赞！2019-04-02

我以前一直以为软件设计就是用 UML 画出类图，理清类之间的关系就是设计，现在感觉类图只是对业务的正确理解，设计要体现在代码中，体现在软件架构的整体风格中，不知道我的理解对不对？作者回复：设计可以简单理解成组织代码的方式。类图往往只有实体，还有一部分内容是动作，往往通过服务体现出来。在 Robert Martin 看来，没有什么架构，都是设计。2019-03-29

说到设计，最近三个月体会特别深，三个月之前拿到一个很大的项目，我基于拿结果，就一直操心实现和开工的问题，跟我合作的同事看我这么急慌慌的，节奏也不一致。后来我们促膝长谈，我了解到了一个点：越是复杂的项目、越是要做长做好的项目，越要在前期舍得投精力去做设计，这样才不至于在后面导出救火。在经历了几年成长后，我的职场述求早已经从刚毕业时候的「活下来」变更了「活得好」，那么相对应的标准也要提高。最近一段时间，我已经收到了一些前提投入时间做设计的好处了，养成了重视设计的习惯，在做旧系统的集成的时候，我也花了几天时间设计、想清楚了才动的手。作者回复：恭喜进化！2020-02-21

1）人需要负债而行。一开始过度设计，尤其在能力不足，需求全貌不足时，问题严重。2）solid 尊重原则。道于术，虚与实。基于原则去思考问题，理解问题。3）作为常年评审同事代码的人，代码长度，看了下自己的，一般也在 15 行一下，复杂的 30 左右。我觉得大量的只用一次，且分解足够，很便于测试的，30 行是可以的。过度拆解 10 行以下，照样有弊端。属滥用行为。作者回复：代码长度以清晰可理解为目标。2019-11-18

## 0407总是在说MVC分层架构但你真的理解分层吗.md

构建好你的领域模型。从最常见的服务端三层架构入手，给你讲了它们的来龙去脉。分层架构实际是一种设计上的分解，将不同的内容放在不同的地方，降低软件开发和维护的成本。分层，更关键的是，提供抽象。这种分层抽象在计算机领域无处不在，无论是编程语言，还是网络协议，都体现着分层抽象的价值。有了分层抽象，人们才能更好地在抽象的基础上构建更复杂的东西。在日常工作中，我们应该把精力重点放在构建自己的领域模型上，因为它才是工作最核心、不易变的东西。

作为程序员，你一定听说过分层，比如，最常见的 Java 服务端应用的三层结构，在《15 | 一起练习：手把手带你分解任务》中，我曾提到过：1）数据访问层，按照传统的说法，叫 DAO（Data Access Object，数据访问对象），按照领域驱动开发的术语，称之为 Repository；2）服务层，提供应用服务；3）资源层，提供对外访问的资源，采用传统做法就是 Controller。这几乎成为了写 Java 服务的标准模式。但不知道你有没有想过，为什么要分层呢？

### 7.1 设计上的分解

其实，分层并不是一个特别符合直觉的做法，符合直觉的做法应该是直接写在一起。在编程框架还不是特别流行的时候，人们就是直接把页面和逻辑混在一起写的。如果你有机会看看写得不算理想的 PHP 程序，这种现象还是大概率会出现的。即便像 Java 这个如此重视架构的社区，分层也是很久之后才出现的，早期的 JSP 和 PHP 并没有什么本质区别。

那为什么要分层呢？原因很简单，当代码复杂到一定程度，人们维护代码的难度就急剧上升。一旦出现任何问题，在所有一切都混在一起的代码中定位问题，本质上就是一个「大海捞针」的活。前面讲任务分解的时候，我不断在强调的观点就是，人们擅长解决的是小问题，大问题怎么办？拆小了就好。分层架构，实际上，就是一种在设计上的分解。

回到前面所说的三层架构，这是行业中最早普及的一种架构模式，最开始是 MVC，也就是 Model、View 和 Controller。MVC 的概念起源于 GUI （Graphical User Interface，图形用户界面）编程，人们希望将图形界面上展示的部分（View）与 UI 的数据模型（Model）分开，它们之间的联动由 Controller 负责。这个概念在 GUI 编程中是没有问题的，但也仅限于在与 UI 有交互的部分。很多人误以为这也适合服务端程序，他们就把模型部分误解成了数据库里的模型，甚至把它理解成数据库访问。于是，你会看到有人在 Controller 里访问数据库。

不知道你是不是了解 Ruby on Rails，这是当年改变了行业认知的一个 Web 开发框架，带来很多颠覆性的做法。它采用的就是这样一种编程模型。当年写 Rails 程序的时候我发现，当业务复杂到了一定规模，代码就开始难以维护了。我想了好久，终于发现，在 Rails 的常规做法中少了服务层（Service）的设计。这个问题在 Java 领域，爆发得要比 Rails 里早，因为 Ruby 语言的优越性，Rails 实现的数据访问非常优雅。正是因为 Rails 的数据访问实在太容易了，很多服务实际上写到 Model 层里。在代码规模不大时，代码看上去是不复杂的，甚至还有些优雅。

1『 laravel 的基本框架就是参考 Ruby on Rails 的，那么 laravel 应该也没有服务层。回复：是的，所以最开始很多简单的逻辑我这边是直接写在数据库模型 Model 文件里的，后来做数据流开发的时候，由于业务逻辑变得比较复杂了，开始把业务逻辑单独放到了一系列 Logic 文件里，相当于自己构建出了一个 Service 层。（2020-11-20）』

而那时的 Java 可是要一行一行地写数据访问，所以，代码不太可能放在 Model 层，而放在 Controller 里也会让代码变复杂，于是，为业务逻辑而生的 Service 层就呼之欲出了。至此，常见的 Java 服务端开发的基础就全部成型了，只不过，由于后来 REST 服务的兴起，资源层替代了 Controller 层。到这里，我给你讲了常见的 Java 服务三层架构的来龙去脉。但实际上，在软件开发中，分层几乎是无处不在的，因为好的分层往往需要有好的抽象。

### 7.2 无处不在的分层

作为程序员，我们几乎每天都在与分层打交道。比如说，程序员都对网络编程模型很熟悉，无论是 ISO 的七层还是 TCP/IP 的五层。但不知道你有没有发现，虽然学习的时候，你要学习网络有那么多层，但在使用的时候，大多数情况下，你只要了解最上面的那层，比如，HTTP。

很多人对底层的协议的理解几乎就停留在「学过」的水平上，因为在大多数情况下，除非你要写协议栈，不然你很难用得到。即便偶尔用到，90% 的问题靠搜索引擎就解决了，你也很少有动力去系统学习。之所以你可以这么放心大胆地「忽略」底层协议，一个关键点就在于，网络模型的分层架构实现得太好了，好到你作为上层的使用者几乎可以忽略底层。而这正是分层真正的价值：构建一个良好的抽象。这种构建良好的抽象在软件开发中随处可见，比如，你作为一个程序员，每天写着在 CPU 上运行的代码，但你读过指令集吗？你之所以可以不去了解，是因为已经有编译器做好了分层，让你可以只用它们构建出的「抽象」—— 编程语言去思考问题。比如，每天写着 Java 程序的程序员，你知道 Java 程序是如何管理内存的吗？这可是令很多 C/C++ 程序员寝食难安的问题，而你之所以不用关心这些，正是托了 Java 这种「抽象」的福。对了，你甚至可能没有注意到编程语言也是一种抽象。

### 7.3 有抽象有发展

只有构建起抽象，人们才能在此基础上做出更复杂的东西。如果今天的游戏依然是面向显示屏的像素编程，那么，精彩的游戏视觉效果就只能由极少数真正的高手来开发。我们今天的大部分游戏应该依然停留在《超级玛丽》的水准。同样，近些年前端领域风起云涌，但你是否想过，为什么 Web 的概念早就出现了，但前端作为一个专门的职位，真正的蓬勃发展却是最近十年的事？2009 年，Ryan Dahl 发布了 Node.js，人们才真正认识到，原来 JavaScript 不仅仅可以用于浏览器，还能做服务器开发。于是，JavaScript 社区大发展，各种在其他社区已经很流行的工具终于在 JavaScript 世界中发展了起来。正是有了这些工具的支持，人们才能用 JavaScript 构建更复杂的工程，前端领域才能得到了极大的发展。如今，JavaScript 已经发展成唯一一门全平台语言，当然，发展最好的依然是在它的大本营：前端领域。前端程序员才有了今天幸福的烦恼：各种前端框架层出不穷。在这里，Node.js 的出现让 JavaScript 成为了一个更好的抽象。

### 7.4 构建你的抽象

理解了分层实际上是在构建抽象，你或许会关心，我该怎么把它运用在自己的工作中。构建抽象，最核心的一步是构建出你的核心模型。什么是核心模型呢？就是表达你业务的那部分代码，换句话说，别的东西都可以变，但这部分不能变。这么说可能还是有点抽象，我们回到前面的三层架构。

在前面介绍三层架构的演变时，提到了一个变迁：REST 服务的兴起，让 Controller 逐渐退出了历史舞台，资源层取而代之。换句话说，访问服务的方式可能会变。放到计算机编程的发展中，这种趋势就更明显了，从命令行到网络，从 CS（Client-Server） 到 BS（Browser-Server），从浏览器到移动端。所以，怎么访问不应该是你关注的核心。同样，关系型数据库也不是你关注的核心，它只是今天的主流而已。从前用文件，今天还有各种 NoSQL。

如此说来，三层架构中的两层重要性都不是那么高，那重要的是什么？答案便呼之欲出了，没错，就是剩下的部分，我们习惯上称之为服务层，但这个名字其实不能很好地反映它的作用，更恰当的说法应该可以叫领域模型（Domain Model）。它便是我们的核心模型，也是我们在做软件设计时，真正应该着力的地方。为什么叫「服务层」不是一个好的说法呢？这里会遗漏领域模型中一个重要的组成部分：领域对象。

很多人理解领域对象有一个严重的误区，认为领域对象属于数据层。数据存储只是领域对象的一种用途，它更重要的用途还是用在各种领域服务中。由此还能引出另一个常见的设计错误，领域对象中只包含数据访问，也就是常说的 getter 和 setter，而没有任何逻辑。如果只用于数据存储，只有数据访问就够了，但如果是领域对象，就应该有业务逻辑。比如，给一个用户修改密码，用户这个对象上应该有一个 changePassword 方法，而不是每次去 setPassword。严格地说，领域对象和存储对象应该是两个类，只不过它俩实在太像了，很多人经常使用一个类，这还是个小问题。但很多人却把这种内部方案用到了外部，比如，第三方集成。

为数不少的团队都在自己的业务代码中直接使用了第三方代码中的对象，第三方的任何修改都会让你的代码跟着改，你的团队就只能疲于奔命。解决这个问题最好的办法就是把它们分开，你的领域层只依赖于你的领域对象，第三方发过来的内容先做一次转换，转换成你的领域对象。这种做法称为防腐层。当我们把领域模型看成了整个设计的核心，看待其他层的视角也会随之转变，它们只不过是适配到不同地方的一种方式而已，而这种理念的推广，就是一些人在说的六边形架构。

怎么设计好领域模型是一个庞大的主题，推荐你去了解一下领域驱动设计（Domain Driven Design，DDD），这个话题我们后面还会再次提到。讨论其实还可以继续延伸下去，已经构建好的领域模型怎么更好地提供给其他部分使用呢？一个好的做法是封装成领域特定语言（Domain Specific Language，DSL）。当然，这也是一个庞大的话题，就不继续展开了。

### 黑板墙

分层或模型，实质是因为人的认知能力有限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单的开关，实现所有逻辑运算。逻辑运算层次之上，就是我们所知道的 CPU 模型。再往上，就是我们所熟悉的信息世界。

best practices 其实在不同时期有不同的理解，有时候甚至变化很大，我自己也有迷惑的时候。我是做 ror 出身的，rails 就是标准的 MVC，再加上一个 helper 目录；初入行时候接触的项目，controller 都很臃肿，后来，提倡的是 thin controller、fat model，于是大家又把逻辑搬到 model 里面；于是 model 又变得非常臃肿，里面包括了很多业务逻辑，耦合太高，写起测试来非常痛苦；另外，原本 helper 只应该放关于 view 的 method，却很快变成了垃圾桶，很多不是 view 相关的方法都扔在了 helper 目录下，甚至很多 controller 要 include 其他 controller 对应的 helper，只是因为那里定义了一个可以用到的方法。再后来，有了 presenter 的概念，helper 目录基本就不用了；每个 controller 都有对应都 presenter，再有，就是建立了 service 的目录，把业务逻辑从 model 里面抽离处理；这样的结构稍微清洁了一点，测试也好写了很多。但是在我看来，我们项目 presenter/services 这种分层没有什么标准，有些同事还是把这种分层当作万能垃圾桶，什么都建一个，甚至业务/运算都扔在 presenter 里面；services 的分层也是一个问题，很多只是根据 model 的来分，而不是业务； 最近有看了一下 elixir 对应的 phoenix ，它引入了 context 的概念，更偏重于业务划分，我感觉这是一个比 rails 更合理的分层。

老师提到的直接把第三方类库的字段直接使用，导致 bug 层出不穷，这个真的是深受其害，线上程序莫名 bug，原来是第三方修改或者擅自把字段等出现问题，改来改去，最后还是用类似老师提出那种转化本地对象再使用，最后做了类似一个防腐层那种解决问题。实际才出的坑总结到这么个东西，就是类似老师提出的模型概念。作者回复：道理很简单，痛过才知道。

请问老师，在 jdk 的集合框架中常常会在实现类内部维护一个内部类，比如 HashMap 内部有个 Node 内部类，这算领域对象么？作者回复：在通常的讨论中，这是不算的。

学了 REST 和 DDD，感觉两者有相通的地方：两者都以数据（一个是资源，另外一个是领域对象）为中心，并制定一套标准的数据操作（一个是 HTTP Verb，另外一个我项目主要用 JPA 这一套）；而核心是业务建模。

2『这个有些感触，因为学习做 api 时有接触过 REST 模型，REST 和 DDD 的类比做一张计算机卡片。』

我将界面逻辑层（界面数据显示）、业务逻辑层（具体业务逻辑功能实现）分出来后，但像支持这些业务的一些服务，比如通讯服务，数据缓存服务，这些算是工具，还是说也可以分为一些单独的层，还有像界面显示的数据我需要给界面单独提供一些界面显示的数据结构，还是直接使用逻辑层里面的数据结构，还是说这些数据结构单独拆分出来也可以作为一层。作者回复：看六边形架构的图，通信服务属于六边形架构的适配器。

对项目中变化代码和稳定代码的拆分。按特性归类成变化层和稳定层，中间用门面或适配器对接。针对变化层提炼出抽象层用装饰者模式或抽象工厂实现多态。作者回复：学习 DDD，建立模型概念，你就不纠结于这里的设计模式了。

分层是为了更好的抽象，区分出程序中的不变点与与易变点，集中精力优化抽象不变点，以便更好的复用不变点逻辑。尽可能的快速添加和修改易变逻辑响应业务变更需求。个人认为：分层设计有点像代码设计模式里的模板设计模式。但分层设计更像是代码组织的模板，功能和交互层面的分组的模板。分层设计不但做到代码的分层也促进了分工合作，从而达到快速，简单，高效开发的目的。

文章有些地方看不懂，不太懂领域对象什么的。作者回复：核心模型，就是当你的软件去掉它，就不是这个软件了。比如，如果没有商品和订单，电商就玩不转了，但如果它不支持高并发，其实没什么影响。

很多技术都是吧，都是为了把一些通用的基础的功能抽象出来，Robot 框架也是，提供了很多实现基础功能的类库，通过这些基础的关键字可以组成新的关键字，再由关键字组成更复杂的关键字，我们只用关心怎么实现功能，而这些关键字怎么调用，编译，log 和结果怎么一层层展示，这些都由框架实现了。

跟过一段时间微软的 silverlight，一开始听说是 wpf 的子集，后来又有人辟谣说除了使用 xaml 等形似之处外差别很大的。自己也看过两者的源码，就抽象能力和程度看还是正宗 wpf 强大，虽然不是业务框架，但从开发工具角度来看，它的基于自身定位及领域的体系设计还是值得称道的。曾经有一段时间里 java 和 .net 相互 diss 的厉害，现在看来在道的层面是可以和谐共处的，只是术上各有各的呈现罢了。

微服务中的数据访问层，有可能跟访问数据库一点关系都没有，而只是一层调用 http 请求去访问其他微服务的封装，但它的原理其实跟传统的分层结构应该是一致的。

产品，开发，测试，运维，运营等岗位也属于分层，不同技术栈的人，组成完备技术体系。

## 0408为什么总有人觉得5万块钱可以做一个淘宝.md

我以淘宝的系统为例，给你介绍了一个系统逐渐由简单变复杂的发展历程，希望你能认清不同业务量级的系统本质上就不是一个系统。一方面，有人会因为对业务量级理解不足，盲目低估其他人系统的复杂度；另一方面，也有人会盲目应用技术，给系统引入不必要的复杂度，让自己陷入泥潭。作为拥有技术能力的程序员，我们都非常在意个人技术能力的提升，但却对在什么样情形下，什么样的技术更加适用考虑得不够。采用恰当的技术，解决当前的问题，是每个程序员都应该仔细考虑的问题。如果今天的内容你只能记住一件事，那请记住：用简单技术解决问题，直到问题变复杂。

我们从软件行业的一个段子说起。甲方想要做个电商网站，作为乙方的程序员问：「你要做个什么样的呢？」甲方说：「像淘宝那样就好。」程序员问：「那你打算出多少钱？」甲方想了想，「5 万块钱差不多了吧！」这当然是个调侃客户不懂需求的段子，但你有没有想过，为什么在甲方看来并不复杂的系统，你却觉得困难重重呢？因为你们想的根本不是一个东西。

在客户看来，我要的不就是一个能买东西的网站吗？只要能上线商品，用户能看到能购买不就好了，5 万块钱差不多了。而你脑中想的却是，「淘宝啊，那得是多大的技术挑战啊，每年一到双 11，那就得考虑各种并发抢购。淘宝得有多少程序员，5 万块你就想做一个，门都没有。」

如果放在前面「沟通反馈」的模块，我可能会讲双方要怎么协调，把想法统一了。但到了「自动化」的模块，我想换个角度讨论这个问题：系统是怎么变复杂的。

### 8.1 淘宝的发展历程

既然说到了淘宝，我们就以一些公开资料来看看淘宝的技术变迁过程。2013 年，子柳出版了一本《淘宝技术这十年》，这本书里讲述了淘宝是怎么一步步变化的。按照书中的说法，第一个淘宝是「买来的」，买的是一个叫做 PHPAuction 的系统，即便选择了最高配，也才花了 2000 美元左右。这是一个采用 LAMP 架构的系统，也就是 Linux + Apache + MySQL + PHP，这在当年可是典型的开源架构。

1『已下载书籍「2020145淘宝技术这十年」。』

团队所做的主要就是一些订制化工作，最大的调整就是将单一数据库的读写进行了拆分，变成了一个主库和两个从库。这种结构在今天来看，依然是很多团队做调整的首选。当访问量和数据量不断提升，MySQL 数据库率先抗不住了。当年的 MySQL 默认采用的是 MyISAM 引擎，写数据的时候会锁住表，读也会被卡住，当然，这只是诸多问题中的一个。

2003 年底，团队将 MySQL 换成了 Oracle。由于 Oracle 的性能要好上许多，主从的数据库架构又改回了单一数据库。但由于 PHP 访问数据库的缺省方案没有连接池，只好找了开源的 SQL Relay，这也为后续的改进埋下了伏笔。

当数据量继续加大，本地存储就已经无法满足了，只能通过引入网络存储解决问题。数据量进一步增大之后，存储节点一拆再拆，依然不能解决问题，淘宝就踏上了购买小型机的道路。IBM 的小型机、Oracle 的数据库和 EMC 的存储，这个阶段就踏上了 IOE 之路。

2004 年初，SQL Relay 已经成了一个挥之不去的痛点，于是，只能从更根本的方案上动脑筋：更换程序设计语言。作为当时的主流，Java 成了不二之选。替换的方案就是给业务分模块，一块一块地替换。老模块只维护，不增加新功能，新功能只在新模块开发，新老模块共用数据库。新功能上线，则关闭老模块对应功能，所有功能替换完毕，则老模块下线。

淘宝的数据量继续增长，单台 Oracle 很快到了上限，团队采用了今天常见的「分库分表」模式，但「分库分表」就会带来新的问题，跨数据库的数据怎么整合？于是，打造出了一个 DBRoute，用以处理分库的数据。但是，这种做法也带来了一个新的问题，同时连接多个数据库，任何一个数据库出了问题，都会导致整个网站的故障。

当淘宝的数据量再次增长，每次访问都到了数据库，数据库很难承受。一个解决方案就是引入缓存和 CDN（Content Delivery Network，内容分发网络），这样，只读数据的压力就从数据库解放了出来。当时的缓存系统还不像今天这么成熟，于是，团队基于一个开源项目改出了一个。他们用的 CDN 最开始是一个商用系统，但流量的增加导致这个系统也支撑不住了，只好开始搭建自己的 CDN。后来，因为 CDN 要消耗大量的服务器资源，为了降低成本，淘宝又开始研发自己的低功耗服务器。

随着业务的不断发展，开发人员越来越多，系统就越来越臃肿，耦合度也逐渐提升，出错的概率也逐渐上升。这时，不得不对系统进行分解，将复用性高的模块拆分出来，比如，用户信息。业务继续发展，拆分就从局部开始向更大规模发展，底层业务和上层流程逐渐剥离，并逐渐将所有业务都模块化。有了一个相对清晰地业务划分之后，更多的底层业务就可以应用于不同的场景，一个基础设施就此成型，新的业务就可以使用基础设施进行构建，上层业务便如雨后春笋一般蓬勃发展起来。

在这个过程中，有很多技术问题在当时还没有好的解决方案，或者是不适于他们所在的场景。所以，淘宝的工程师就不得不打造自己的解决方案，比如：分布式文件系统（TFS）、缓存系统（Tair）、分布式服务框架（HSF）等等。还有一些技术探索则是为了节省成本，比如，去 IOE 和研发低功耗服务器等等。

我这里以淘宝网站的发展为例，做了一个快速的梳理，只是为了让你了解一个系统的发展，如果你有兴趣了解更多细节，不妨自己找出这本书读读。当然，现在的淘宝肯定比这更加完整复杂。

### 8.2 同样的业务，不同的系统

为什么我们要了解一个系统的演化过程呢？因为作为程序员，我们需要知道自己面对的到底是一个什么样的系统。回到我们今天的主题上，5 万块钱可以不可以做一个淘宝？答案是，取决于你要的是一个什么样的系统。最开始买来的「淘宝」甚至连 5 万块钱都不用，而今天的淘宝和那时的淘宝显然不是一个系统。

从业务上说，今天的淘宝固然已经很丰富了，但最核心的业务相差并不大，无非是卖家提供商品，买家买商品。那他们的本质差别在哪呢？回顾上面的过程，你就可以看到，每次随着业务量的增长，原有技术无法满足需要，于是，就需要用新的技术去解决这个问题。这里的关键点在于：不同的业务量。

一个只服务于几个人的系统，单机就够了，一个刚刚入行的程序员也能很好地实现这个系统。而当业务量到达一台机器抗不住的时候，就需要用多台机器去处理，这个时候就必须考虑分布式系统的问题，可能就要适当地引入中间件。而当系统变成为海量业务提供服务，就没有哪个已经打造好的中间件可以提供帮助了，需要自己从更底层解决问题。

虽然在业务上看来，这些系统是一样的，但在技术上看来，在不同的阶段，一个系统面对的问题是不同的，因为它面对业务的量级是不同的。更准确地说，不同量级的系统根本就不是一个系统。只要业务在不断地发展，问题就会不断出现，系统就需要不断地翻新。我曾听到一个很形象的比喻：把奥拓开成奥迪。

### 8.3 你用对技术了吗？

作为一个程序员，我们都知道技术的重要性，所以，我们都会努力地去学习各种各样的新技术。尤其是当一个技术带有大厂光环的时候，很多人都会迫不及待地去学习。我参加过很多次技术大会，当大厂有人分享的时候，通常都是人山人海，大家都想学习大厂有什么「先进」技术。知道了，然后呢？

很多人就想迫不及待地想把这些技术应用在自己的项目中。我曾经面试过很多程序员，给我讲起技术来滔滔不绝，说什么自己在设计时考虑各种分布式的场景，如果系统的压力上来时，他会如何处理。我就好奇地问了一个问题，「你这个系统有多少人用？」结果，他做的只是一个内部系统，使用频率也不高。为了技术而技术的程序员不在少数，过度使用技术造成的结果就是引入不必要的复杂度。即便用了牛刀杀鸡，因为缺乏真实场景检验，也不可能得到真实反馈，对技术理解的深度也只能停留在很表面的程度上。

在前面的例子中，淘宝的工程师之所以要改进系统，真实的驱动力不是技术，而是不断攀升的业务量带来的问题复杂度。所以，评估系统当前所处的阶段，采用恰当的技术解决，是我们最应该考虑的问题。

也许你会说，我做的系统没有那么大的业务量，我还想提高技术怎么办？答案是到有好问题的地方去。现在的 IT 行业提供给程序员的机会很多，找到一个有好问题的地方并不是一件困难的事，当然，前提条件是，你自己得有解决问题的基础能力。

### 黑板墙

刚入职的时候做过一个社交系统，想着将来数据量会很大，就做了分库分表。扩展性是大了，但因为是按 id 分的表，导致不少需求不容易实现，比如按标题搜索等。要么拒绝需求，要么再搭一套转用于搜索的系统。结果在用户量不大的时候，就把系统弄得比较复杂，迭代慢。而实际上在数据量不到预设的十万分之一的时候，该产品就因为种种原因下线了。作者回复：现身说法，惨痛教训。2019-04-03

前公司开发负责人，不知道是不是为了显示开发能力牛，做了一个资讯系统，一个人用了 Go、PHP、java 3 种语言 + rabbitMQ + ES + mongoDB 等，安装所需要软件花了 2 小时，我心里那个郁闷… 而且经常挂……因为 Go 是复制其他项目模版，写 shell 监控，发现相关进程挂了用 start 居然报错，起不来！非要手工打 start，我心里想，你写出来爽了，想过我们运维的感受吗？！作者回复：以后可以质问为什么要把系统做这么复杂。2019-04-03

关于淘宝，我看的是《企业 it 架构转型之道》。以上其实阐述了架构设计的三原则。适用优于业内领先，演变好过贪大求全，简单优于复杂。负责的项目花了三个月重构了，由原负责人操刀做的。主要是将业务梳理提高可读性。但大佬说了要灵活应用设计模式。然后就牵强使用设计模式，原有业务代码全部复制，原负责人做完后主流程常规场景能过。但各种业务块都有缺漏。所以今年来一负责，bug 层出不穷，找个问题要兼看新老两个服务的日志。看部分遗传的业务代码，原本历史遗传就杂乱得很，现在迁移加套设计可读性反而更差了。2019-04-03

做一个淘宝那样的，客户指的是业务类似，但用户量多少，需要多少并发数，搜索性能等如何都是需要跟客户沟通后才能决定技术选型的。现实中我们的有些系统已经满足了业务需求，就没有必要为了追求技术复杂度而去拆分了，只有面向问题技术选型才会有成效。作者回复：能够把握度就是程序员技术成熟的标志。2019-04-03

那又有个问题，就是我们如何在解决眼前问题和规划未来方向之间平衡呢？如果只关注当下问题，而不为未来留余地，会不会给自己的未来挖坑呢？这中间的度需要如何把握呢？作者回复：领域模型一定要建好，这是不会变的东西，但实现有可能有无数种做法，只选择当前最合适的一种。要分清楚什么是设计，哪个是实现。2019-09-10

头份工作里有个印象比较深的，过度使用多线程技术追求并发，还弄了个所谓框架，却经常把主线程搞挂，后来一查发现，所谓框架净在主线程里玩并发了。2019-04-06

我们的环境，是用一个 vpc 连实验室的 server，通过这个 server 建立 ssh 隧道连硬件设备，我真的不明白为什么这么弄，硬件设备每次又不能多人一起用，而且硬件设备本身就连很多其他设备够复杂的了，又加了个隧道整的每个操作都要先建隧道，不但使环境变得复杂，还带来了隧道关的不干净后面建立不起来等其他问题。而且我一直觉得隧道很脆弱容易中断，虽然中断的问题倒没有碰到。真的神烦。2019-09-17

## 0409先做好DDD再谈微服务.md

微服务是很多团队的努力方向，然而，现在市面上对于微服务的介绍多半只停留在技术层面上，很多人看到微服务的好，大多数是结果，到自己团队实施起来却困难重重。想要做好微服务，关键在于服务的划分，而划分服务，最好先学习 DDD。

Eric Evans 2003 年写了《领域驱动设计》，向行业介绍了 DDD 这套方法论，立即在行业中引起广泛的关注。但实话说，Eric 在知识传播上的能力着实一般，这本 DDD 的开山之作写作质量难以恭维，想要通过它去学好 DDD，是非常困难的。所以，在国外的技术社区中，有很多人是通过各种交流讨论逐渐认识到 DDD 的价值所在，而在国内 DDD 几乎没怎么掀起波澜。

2013 年，在 Eric Evans 出版《领域驱动设计》十年之后，DDD 已经不再是当年吴下阿蒙，有了自己一套比较完整的体系。Vaughn Vernon 将十年的精华重新整理，写了一本《实现领域驱动设计》，普通技术人员终于有机会看明白 DDD 到底好在哪里了。所以，你会发现，最近几年，国内的技术社区开始出现了大量关于 DDD 的讨论。再后来，因为《实现领域驱动设计》实在太厚，Vaughn Vernon 又出手写了一本精华本《领域驱动设计精粹》，让人可以快速上手 DDD，这本书也是我向其他人推荐学习 DDD 的首选。

即便你学了 DDD，知道了限界上下文，也别轻易使用微服务。我推荐的一个做法是，先用分模块的方式在一个工程内，让服务先演化一段时间，等到真的觉得某个模块可以「毕业」了，再去开启微服务之旅。如果今天的内容你只能记住一件事，那请记住：学习领域驱动设计。

在「自动化」模块的最后，我们来聊一个很多人热衷讨论却没做好的实践：微服务。在今天做后端服务似乎有一种倾向，如果你不说自己做的是微服务，出门都不好意思和人打招呼。一有技术大会，各个大厂也纷纷为微服务出来站台，不断和你强调自己公司做微服务带来的各种收益，下面的听众基本上也是热血沸腾，摩拳擦掌，准备用微服务拯救自己的业务。

我就亲眼见过这样的例子，几个参加技术大会的人回到公司，跟人不断地说微服务的好，说服了领导，在接下来大的项目改造中启用了微服务。结果呢？一堆人干了几个月，各自独立开发的微服务无法集成。最后是领导站出来，又花了半个月时间，将这些「微服务」重新合到了一起，勉强将这个系统送上了线。人家的微服务那么美，为什么到你这里却成了烂摊子呢？因为你只学到了微服务的形。

### 9.1 微服务

大部分人对微服务的了解源自 James Lewis 和 Martin Fowler 在 2014 年写的一篇文章（[Microservices](https://www.martinfowler.com/articles/microservices.html)），他们在其中给了微服务一个更清晰的定义，把它当做了一种新型的架构风格。但实际上，早在这之前的几年，很多人就开始用「微服务」这个词进行讨论了。

「在企业内部将服务有组织地进行拆分」这个理念则脱胎于 SOA（Service Oriented Architecture，面向服务的架构），只不过，SOA 诞生自那个大企业操盘技术的年代，自身太过于复杂，没有真正流行开来。而微服务由于自身更加轻量级，符合程序员的胃口，才得以拥有更大的发展空间。

谈到微服务，你会想起什么呢？很多人对微服务的理解，就是把一个巨大的后台系统拆分成一个一个的小服务，再往下想就是一堆堆的工具了。所以，市面上很多介绍微服务的内容，基本上都是在讲工具的用法，或是一些具体技术的讨论，比如，用 Spring Boot 可以快速搭建服务，用 Spring Cloud 建立分布式系统，用 Service Mesh 技术作为服务的基础设施，以及怎么在微服务架构下保证事务的一致性，等等。

确实，这些内容在你实现微服务时，都是有价值的。但必须先回答一个问题，我们为什么要做微服务？对这个问题的标准回答是，相对于整体服务（Monolithic）而言，微服务足够小，代码更容易理解，测试更容易，部署也更简单。

这些道理都对，但这是做好了微服务的结果。怎么才能到达这个状态呢？这里面有一个关键因素，怎么划分微服务，也就是一个庞大的系统按照什么样的方式分解。这是在很多关于微服务的讨论中所最为欠缺的，也是很多团队做「微服务」却死得很难看的根本原因。

不了解这一点，写出的服务，要么是服务之间互相调用，造成整个系统执行效率极低；要么是你需要花大力气解决各个服务之间的数据一致性。换句话说，服务划分不好，等待团队的就是无穷无尽的偶然复杂度泥潭。只有正确地划分了微服务，它才会是你心目中向往的样子。那应该怎么划分微服务呢？你需要了解领域驱动设计。

### 9.2 领域驱动设计

领域驱动设计（Domain Driven Design，DDD）是 Eric Evans 提出的从系统分析到软件建模的一套方法论。它要解决什么问题呢？就是将业务概念和业务规则转换成软件系统中概念和规则，从而降低或隐藏业务复杂性，使系统具有更好的扩展性，以应对复杂多变的现实业务问题。这听上去很自然，不就应该这么解决问题吗？并不然，现实情况可没那么理想。在此之前，人们更多还是采用面向数据的建模方式，时至今日，还有许多团队一提起建模，第一反应依然是建数据库表。这种做法是典型的面向技术实现的做法。一旦业务发生变化，团队通常都是措手不及。

DDD 到底讲了什么呢？它把你的思考起点，从技术的角度拉到了业务上。贴近业务，走近客户，我们在这个专栏中已经提到过很多次。但把这件事直接体现在写代码上，恐怕还是很多人不那么习惯的一件事。DDD 最为基础的就是通用语言（Ubiquitous Language），让业务人员和程序员说一样的语言。

这一点我在《21 | 你的代码为谁而写？》中已经提到过了。使用通用语言，等于把思考的层次从代码细节中拉到了业务层面。越高层的抽象越稳定，越细节的东西越容易变化。有了通用语言做基础，然后就要进入到 DDD 的实战环节了。DDD 分为战略设计（Strategic Design）和战术设计（Tactical Design）。

战略设计是高层设计，它帮我们将系统切分成不同的领域，并处理不同领域的关系。我在前面的内容中给你举过「订单」和「用户」的例子。从业务上区分，把不同的概念放到不同的地方，这是从根本上解决问题，否则，无论你的代码写得再好，混乱也是不可避免的。而这种以业务的角度思考问题的方式就是 DDD 战略设计带给我的。

战术设计，通常是指在一个领域内，在技术层面上如何组织好不同的领域对象。举个例子，国内的程序员喜欢用 myBatis 做数据访问，而非 JPA，常见的理由是 JPA 在有关联的情况下，性能太差。但真正的原因是没有设计好关联。

如果能够理解 DDD 中的聚合根（Aggregate Root），我们就可以找到一个合适的访问入口，而非每个人随意读取任何数据。这就是战术设计上需要考虑的问题。战略设计和战术设计讨论的是不同层面的事情，不过，这也是 Eric Evans 最初没有讲清楚的地方，导致了人们很长时间都无法理解 DDD 的价值。

### 9.3 走向微服务

说了半天，这和微服务有什么关系呢？微服务真正的难点并非在于技术实现，而是业务划分，而这刚好是 DDD 战略设计中限界上下文（Bounded Context）的强项。

虽然通用语言打通了业务与技术之间的壁垒，但计算机并不擅长处理模糊的人类语言，所以，通用语言必须在特定的上下文中表达，才是清晰的。就像我们说过的「订单」那个例子，交易的「订单」和物流的「订单」是不同的，它们都有着自己的上下文，而这个上下文就是限界上下文。

它限定了通用语言自由使用的边界，一旦出界，含义便无法保证。正是由于边界的存在，一个限界上下文刚好可以成为一个独立的部署单元，而这个部署单元就可以成为一个服务。所以要做好微服务，第一步应该是识别限界上下文。

你也看出来了，每个限界上下文都应该是独立的，每个上下文之间就不应该存在大量的耦合，困扰很多人的微服务之间大量相互调用，本身就是一个没有划分好边界而带来的伪命题，靠技术解决业务问题，事倍功半。有了限界上下文就可以做微服务了吧？且慢！

Martin Fowler 在写《企业应用架构模式》时，提出了一个分布式对象第一定律：不要分布对象。同样的话，在微服务领域也适用，想做微服务架构，首先是不要使用微服务。如果将一个整体服务贸然做成微服务，引入的复杂度会吞噬掉你以为的优势。你可能又会说了，「我都把限界上下文划出来了，你告诉我不用微服务？」

还记得我在《30 | 一个好的项目自动化应该是什么样子的？》中提到的分模块吗？如果你划分出了限界上下文，不妨先按照它划分模块。以我拙见，一次性把边界划清楚并不是一件很容易的事。大家在一个进程里，调整起来会容易很多。然后，让不同的限界上下文先各自独立演化。等着它演化到值得独立部署了，再来考虑微服务拆分的事情。到那时，你也学到各种关于微服务的技术，也就该派上用场了！

### 黑板墙

多谢老师推荐的书单，之前直接看《领域驱动设计》没看明白。作者回复：有了骨架统筹起来，再来学一遍。2019-04-05

领域驱动设计中把术语在不同领域中的差异提到了比较高的程度。这其实是日常工作中非常常见的问题，同一个名词，不同人的理解是不同的，在不同业务中的含义也不同。最近正在构建组织架构服务，不同人想的就不一样。行政 / HR 想的是在企业 IM 里看到的是组织架构，实际上是按业务线划分。财务想的是，凭证进财务系统的时候，需要按照不同公司，这又是一个组织架构。业务团队之间会产生协作，比如都是为用户增长，参与协作的人又会形成某种组织架构。在限界上下文中统一术语的认识，而不是花更多精力让所有参与者都统一术语，其实是非常务实的做法。2019-04-05

又一篇解答了我疑惑的一篇好文章！ 我之前也是抱着「TDD 其实不实用」的观念，老师 TDD 的章节让我明白了 TDD 的本质在于架构设计，而架构设计是从具体任务分解而来；关于微服务，我对其理解一直放在 ops/tools 方面，现在才明白其本质也是软件结构问题，服务的划分通过 DDD，ops/tools 只是服务的 implementation。另外提一下 2017 年 Domain-Driven Design Distilled 出了 Vaughn Vernon 讲解的视频版，现在积极补课中，上一个链接：[Domain-Driven Design Distilled [Video]](https://www.oreilly.com/library/view/domain-driven-design-distilled/9780134593449/)。2019-04-10

我是今年年初的时候接触到领域驱动设计的，看 Eric 的《领域驱动设计》确实给了我非常大的启发，给我目前工作中遇到的问题指明了方向。DDD 改变了我思考问题的方式，让我把关注点回归业务，而不是一开始就去考虑技术的是实现问题。尤其是限界上下文的概念，让我明白了一直在搞，却总是搞不好的微服务到底是哪儿出了问题。但是目前的困境是：想在公司内推行 DDD，阻力真的很大，首先是很多人对 DDD 没概念，需要一定的学习成本，二是团队间相互隔离，沟通成本很高，起码的通用语言都很难达成。在上次迭代中，很多时间都花在弥补因为沟通不畅导致的扯皮中了，最后就是功能虽然实现了，代码却早已经改成了大泥球。还有就是不顾长远的赶进度，实现功能是首要的，领域模型就成了没有人去做，也没有时间去做事情。作者回复：不要推 DDD，推行一个概念总是困难的。用具体问题来说事，推行人心目中有目标就好，具体问题大家总是接受的，把问题解决了，再来和大家介绍思路。2019-04-05

1『这个思路很好，不要直接推某个概念，你特定的场景下你去把问题解决了，然后再跟大家分享思路的时候把这个概念分享出去。』

说的好，领域驱动设计确实是进入微服务的前置条件，除了设置边界上下文，还要划分子域，实现领域驱动设计那本书看了后，其实还是要看一下 Eric 的那本书，一个是道，一个是术。作者回复：你已经有了基础，可以发力了！2019-04-05

公司说我们的开发方式是敏捷开发，实际上只是使用了一些敏捷开发的方法，只有遵守敏捷开发的价值观和原则，才能算是敏捷开发。微服务也是一样，不是说拆分成多个服务去部署，就叫做微服务。也不是采用市面上常用的微服务框架，就是微服务了。作者回复：招数好学，内涵难成。2019-04-06

感触很深，之前我们在开发一个新项目中，3 个人拆了 10+ 个微服务，维护、排查问题都很麻烦；之后服务减少到 3 个才好很多；微服务很好，但是我们要明白为什么要微服务，以及微服务会带来哪些问题，千万不要一上来就微服务。血淋淋的教训！作者回复：知其然，不知所以然，是陷入深坑的开始。2019-04-05

一个很重要的点是，即便没有 DDD 的概念，我们自己的系统也一定需要有自己的业务模型，任何需求的变化一定都是需要在这个业务模型上最先体现变化出来，外部和我们系统的交互，一定是先翻译转换为我们自己的内部模型，然后再进行逻辑处理，否则外部依赖源一旦增多，很多转换会把整个系统代码污染到不想再维护的。作者回复：核心模型是关键，DDD 是方法。2019-04-17

老师说的很有道理，我们经常会忽视基本面去谈理想和目标。DDD 是一套思维体系，虽然市面上有很好的资料给予我们借鉴，但怎么去定义自己的领域、子域的边界及彼此的交互关联不一而足。周围也有人为微服务而微服务，真要是落在纸面上却无从入手，背后是抽象能力还不足以支撑期望。另一方面是避免过度设计，就如上讲所说淘宝也是演进来的，DDD 也不是一步到位的，需求在变要求在变，设计也就需要跟着变。总的说来我觉得就是需要提升抽象能力和做好持续改进的准备，不能操之过急也不能局限于眼下。2019-04-06

如果是使用 hibernate ，实施起 DDD，会容易一些。但是互联网公司大部分用 mybatis，毕竟 sql 得完全自己控制才好。作者回复：这种思路就是典型的被工具绑架的思路，一个正常的做法是按照 DDD 建模，然后用 mybatis 实现这些定义好的接口。2019-06-23

有个问题请教下：微服务应该不应该共享一个所谓的公共二方库 common。比如一些枚举类，工具类，DTO 类放入这个 common 库中。如果用 common 类，那么就增加了服务之间的耦合度，如果不使用，那么又会出现同一个类重复定义的问题。作者回复：有公共的包我同意，但这个公共的包里面放什么是一个值得讨论的问题。如果放一些与任何系统无关的代码，比如，基础类，没问题。如果放的是有任何业务含义的东西，这就会牵扯到耦合。通信协议的部分可以单独定义在一个包里，由不同的模块引用，但业务对象绝对要各个服务单独写。如果你要问业务对象有重复怎么办，那是设计问题了，限界上下文没有做好。2019-10-31