## 记忆时间

## 目录

0201 HTML 语义：div 和 span 不是够用了吗？

语义化的三个明确应用场景：1）自然语言表达能力的补充；2）文章标题摘要；3）适合机器阅读的整体结构。

0202 HTML 语义：如何运用语义类标签来呈现 Wiki 网页？

HTML 工作组对语义标签的增加是非常谨慎和保守的。实际上，HTML 这种语言，并不像严谨的编程语言一样，有一条非此即彼的线。一些语义的使用其实会带来争议，建议尽量只用自己熟悉的语义标签，并且只在有把握的场景引入语义标签。这样，我们才能保证语义标签不被滥用，造成更多的问题。

0203 CSS语法：除了属性和选择器，你还需要知道这些带 @ 的规则。

CSS 的语法总体结构是由两种规则列表构成，一种是 at 规则，另一种是普通规则。在 at 规则中列举了 13 个以上的例子，并逐个进行了简单的介绍。而在普通规则的部分中介绍了选择器和声明区块。并且，我给出了一个（不太严谨）的选择器语法结构，声明区块则由属性和值构成，这一部分我们重点介绍了函数。

0204 HTML 元信息类标签：你知道 head 里一共能写哪几种标签吗？

所谓元信息，是指描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签，它们通常出现在 head 标签中，一般都不会在页面被显示出来（与此相对，其它标签，如语义类标签，描述的是业务）。元信息多数情况下是给浏览器、搜索引擎等机器阅读的，有时候这些信息会在页面之外显示给用户，有时候则不会。

0205 CSS 选择器：如何选中 svg 里的 a 元素？

介绍了 CSS 选择器的整体结构，并且介绍了一系列简单选择器。它们包括了下面这些内容。1）类型选择器：根据一个元素的标签名来选中元素。2）全体选择器：与类型选择器类似，选择任意元素。3）id 选择器：# 后面跟随 id 名。4）class 选择器：. 后面跟随 class 名。5）伪类选择器：一系列由 CSS 规定好的选择器，它们以冒号开头，伪类有普通型和函数型。

0206 CSS 选择器：伪元素是怎么回事儿？

CSS 选择器的三种机制：选择器的组合、选择器优先级、以及伪元素。

## 0201. HTML 语义：div 和 span 不是够用了吗？

本篇中我们介绍了一些基本原则和 HTML 文档的整体结构，从整体上了解了 HTML 语义。至此，我们可以回答是否要语义化的问题：我们应该分开一些场景来看语义，把它用在合适的场景下，可以获得额外的效果。本篇文中，我们至少涉及了三个明确的场景：1）自然语言表达能力的补充；2）文章标题摘要；3）适合机器阅读的整体结构。

在我看来，HTML 并不简单，它是典型的「入门容易，精通困难」的一部分知识。深刻理解 HTML 是成为优秀的前端工程师重要的一步。上一篇文章中讲到了，HTML 的标签可以分为很多种，比如 head 里面的元信息类标签，又比如 img、video、audio 之类的替换型媒体标签。我今天要讲的标签是：语义类标签。

语义类标签是什么，使用它有什么好处？语义类标签也是大家工作中经常会用到的一类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如大家会经常见到的 section、nav、p，这些都是语义类的标签。语义是我们说话表达的意思，多数的语义实际上都是由文字来承载的。语义类标签则是纯文字的补充，比如标题、自然段、章节、列表，这些内容都是纯文字无法表达的，我们需要依靠语义标签代为表达。

在讲语义之前，我们来说说为什么要用语义。现在我们很多的前端工程师写起代码来，多数都不用复杂的语义标签，只靠 div 和 span 就能走天下了。这样做行不行呢？毫无疑问答案是行。那这样做好不好呢？按照正确的套路，我应该说不好，但是在很多情况下，答案其实是好。这是因为在现代互联网产品里，HTML 用于描述「软件界面」多过于「富文本」，而软件界面里的东西，实际上几乎是没有语义的。比如说，我们做了一个购物车功能，我们一定要给每个购物车里的商品套上 ul 吗？比如说，加入购物车这个按钮，我们一定要用 Button 吗？

实际上我觉得没必要，因为这个场景里面，跟文本中的列表，以及表单中的 Button，其实已经相差很远了，所以，我支持在任何「软件界面」的场景中，直接使用 div 和 span。不过，在很多工作场景里，语义类标签也有它们自己无可替代的优点。正确地使用语义标签可以带来很多好处。1）语义类标签对开发者更为友好，使用语义类标签增强了可读性，即便是在没有 CSS 的时候，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。2）除了对人类友好之外，语义类标签也十分适宜机器阅读。它的文字表现力丰富，更适合搜索引擎检索（SEO），也可以让搜索引擎爬虫更好地获取到更多有效信息，有效提升网页的搜索量，并且语义类还可以支持读屏软件，根据文章可以自动生成目录等等。

不过，不恰当地使用语义标签，反而会造成负面作用。这里我们举一个常见的误区作为例子。我们都知道 ul 是无序列表，ol 是有序列表，所以很多接触过语义这个概念，半懂不懂的前端工程师，特别喜欢给所有并列关系的元素都套上 ul。实际上，ul 是长成下面的这种样子的（以下来自 HTML 标准）。

I have lived in the following countries: 1) Switzerland. 2) Norway. 3) United Kingdom. 4) United States.

ul 多数出现正在行文中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用 ul，会造成大量冗余标签。错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给 CSS 编写加重负担。所以，对于语义标签，我的态度是：「用对」比「不用」好，「不用」比「用错」好。当然了，我觉得有理想的前端工程师还是应该去追求「用对」它们。与 JavaScript 这样严格的编程语言相比，HTML 中语义标签的使用更接近我们平常说话用的自然语言。我们说话并没有唯一的标准措辞，语义标签的使用也是一样。下面，我挑选了几种（我认为）比较重要的语义标签使用场景，来为你介绍一下。

1、作为自然语言延伸的语义类标签。其实语义问题不仅仅属于理科，它还是个文科问题。所以我们这里讲语义标签的使用的第一个场景，也是最自然的使用场景，就是：作为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。

我们先来看看「表达一定的结构」这个场景。在日语中，有一个语法现象叫做：ルビ，它的读音是 ruby（著名的 ruby 语言就是据此命名的），它中文的意思大约类似于注音或者意思的注解，它的形式可以看下图；图中的例子选自动画片《某科学的超电磁炮》第二季第一话。图中把 teleport 放在空间移动上方的用法，就是日文中 ruby 的用法。「空间移动」是动画中白井黑子的技能，这里动画字幕上写的是「空间移动」，动画里的台词则用了英文发音「Teleport」，这里就形成了一个使用 ruby 的场景。

ruby 的这个形式，在中国的网友中间最近被玩出了新花样，比如表情包。有时候微信聊天，不能用 ruby 这样的东西真的是好急啊，只好用括号代替，效果真是差了不少。在 HTML5 中，就引入了这个表示 ruby 的标签，它由 ruby、rt、rp 三个标签来实现。所以说，这些情况里存在的语义，其实原本就存在了，只是我们用纯文字是没法表达的，HTML 作为一种「超文本」语言，支持这些文字表达就是必要的了。

还有一种情况是，HTML 的有些标签实际上就是必要的，甚至必要的程度可以达到：如果没有这个标签，文字会产生歧义的程度。这里我们可以介绍一下 em 标签。

今天我吃了一个苹果。

我们看看这句话，看上去它很清楚，但是实际上，这句话放到不同上下文中，可能表达完全不同的意思。

昨天我吃了一个香蕉。

今天我吃了一个苹果。

再比如：

昨天我吃了两个苹果。

今天我吃了一个苹果。

试着读一读，这两段里面的「今天我吃了一个苹果」，你是不是发现读音不自觉地发生了变化？实际上，不仅仅是读音，这里的意思也发生了变化。前一段中，表示我今天吃的是苹果，而不是别的什么东西，后一段中，则表示我今天只吃了一个苹果，没有多吃。当没有上下文时，如何消除歧义呢？这就要用到我们的 em 标签了。em 表示重音：

```html
今天我吃了一个 <em> 苹果 </em>。
今天我吃了 <em> 一个 </em> 苹果。
```

通过 em 标签，我们可以消除这样的歧义。一些文章常常会拿 em 和 strong 做对比，实际上，我们只要理解了 em 的真正意思，它和 strong 可谓天差地别，并没有任何混淆的可能。

2、作为标题摘要的语义类标签。介绍完自然语言的语义场景后，我想介绍的另一个语义重要使用场景，就是文章的结构。中国古代小说就形成了「章 - 回」的概念，西方的戏剧也有幕的区分，所以人类的自然语言作品也是如出一辙。HTML 也应该支持这样的需求。HTML 语义标签中，有不少是用于支持这样的结构的标签。

语义化的 HTML 能够支持自动生成目录结构，HTML 标准中还专门规定了生成目录结构的算法，即使我们并不打算深入实践语义，也应该尽量在大的层面上保证这些元素的语义化使用。首先我们需要形成一个概念，一篇文档会有一个树形的目录结构，它由各个级别的标题组成。这个树形结构可能不会跟 HTML 元素的嵌套关系一致。例如：

```html
<h1>HTML语义</h1>
<p>balah balah balah balah</p>
<h2>弱语义</h2>
<p>balah balah</p>
<h2>结构性元素</h2>
<p>balah balah</p>
......
```

这段 HTML 几乎是平铺的元素，但是它的标题结构是：

```html
HTML 语义
    弱语义
    结构性元素
    ……
```

h1-h6 是最基本的标题，它们表示了文章中不同层级的标题。有些时候，我们会有副标题，为了避免副标题产生额外的一个层级，我们使用 hgroup 标签。我们来看下有 / 无 hgroup 的对比：

```html
<h1>JavaScript对象</h1>
<h2>我们需要模拟类吗？</h2>
<p>balah balah</p>
......
```

此段生成以下标题结构：

```html
JavaScript 对象
    我们需要模拟类吗？
    …
```

```html
<hgroup>
<h1>JavaScript对象</h1>
<h2>我们需要模拟类吗？</h2>
</hgroup>
<p>balah balah</p>
......
```

这一段生成以下标题结构：

```html
JavaScript 对象 —— 我们需要模拟类吗？
    …
```

我们通过两个效果的对比就可以知道，在 hgroup 中的 h1-h6 被视为同一标题的不同组成部分。从 HTML 5 开始，我们有了 section 标签，这个标签可不仅仅是一个「有语义的 div」，它会改变 h1-h6 的语义。section 的嵌套会使得其中的 h1-h6 下降一级，因此，在 HTML5 以后，我们只需要 section 和 h1 就足以形成文档的树形结构：

```html
<section>
    <h1>HTML语义</h1>
    <p>balah balah balah balah</p>
    <section>
        <h1>弱语义</h1>
        <p>balah balah</p>
    </section>
    <section>
        <h1>结构性元素</h1>
        <p>balah balah</p> 
    </section>
......
</section>
```

这段代码同样会形成前面例子的标题结构：

```html
HTML 语义
    弱语义
    结构性元素
    ……
```

3、作为整体结构的语义类标签。我们想介绍的最后一个场景是，随着越来越多的浏览器推出「阅读模式」，以及各种非浏览器终端的出现，语义化的 HTML 适合机器阅读的特性变得越来越重要。应用了语义化结构的页面，可以明确地提示出页面信息的主次关系，它能让浏览器很好地支持「阅读视图功能」，还可以让搜索引擎的命中率提升，同时，它也对视障用户的读屏软件更友好。我们正确使用整体结构类的语义标签，可以让页面对机器更友好。比如，这里一个典型的 body 类似这样：

```html
<body>
    <header>
        <nav>
            ……
        </nav>
    </header>
    <aside>
        <nav>
            ……
        </nav>
    </aside>
    <section>……</section>
    <section>……</section>
    <section>……</section>
    <footer>
        <address>……</address>
    </footer>
</body>
```

在 body 下面，有一个 header，header 里面是一个 nav，跟 header 同级的有一个 aside，aside 里面也有一个 nav。接下来是文章的整体，也就是一个一个的 section。section 里面可能还有嵌套，但是我们就不管了，最后是一个 footer，这个 footer 里面可能有 address 这样的内容。

除此之外，还有 article，article 是一种特别的结构，它表示具有一定独立性质的文章。所以，article 和 body 具有相似的结构，同时，一个 HTML 页面中，可能有多个 article 存在。一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。

```html
<body>
    <header>……</header>
    <article>
        <header>……</header>
        <section>……</section>
        <section>……</section>
        <section>……</section>
        <footer>……</footer>
    </article>
    <article>
        ……
    </article>
    <article>
        ……
    </article>
    <footer>
        <address></address>
    </footer>
</body>
```

body 里面有自己的 header 和 footer，然后里面是竖篇的 article，每一个 article 里面都有自己的 header、section、footer。这是一个典型的多文章结构。在这个结构里，我们看到了一些新标签，我也来逐个介绍一下。1）header，如其名，通常出现在前部，表示导航或者介绍性的内容。2）footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等。header 和 footer 一般都是放在 article 或者 body 的直接子元素，但是标准中并没有明确规定，footer 也可以和 aside，nav，section 相关联（header 不存在关联问题）。

aside 表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。aside 很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是 aside，aside 不一定是侧边栏。aside 和 header 中都可能出现导航（nav 标签），二者的区别是，header 中的导航多数是到文章自己的目录，而 aside 中的导航多数是到关联页面或者是整站地图。最后 footer 中包含 address，这是个非常容易被误用的标签。address 并非像 date 一样，表示一个给机器阅读的地址，而是表示「文章（作者）的联系方式」，address 明确地只关联到 article 和 body。

## 0202. HTML 语义：如何运用语义类标签来呈现 Wiki 网页？

上一篇文章解释了正确使用语义类标签的好处和一些场景。那么，哪些场景适合用到语义类标签呢，又如何运用语义类标签呢？不知道你还记不记得在大学时代，你被导师逼着改毕业论文格式的情景，如果你回想一下，你在论文中使用的那些格式，你会发现其实它们都是可以用 HTML 里的语义标签来表示的。这正是因为 HTML 最初的设计场景就是「超文本」，早期 HTML 工作组的专家都是出版界书籍排版的专家。所以，在这一部分，我们找了个跟论文很像的案例：Wikipedia 文章，这种跟论文相似的网站比较适合用来学习语义类标签。通过分析一篇 Wiki 的文章用到的语义类标签，来进一步帮你理解语义的概念。

原本的 Wikipedia 网站中，也是大量使用了 div 和 span 来完成功能。在这里，我们来尝试分析一下，应该如何用语义类标签来呈现这样的一个页面 / 文章。

1）首先我们来看下，左侧侧边栏，根据上一篇文章中提到的语义定义，这里属于 aside 内容。是导航性质的工具内容。2）我们来到文章主体部分，因为主体部分具有明确的独立性，所以可以用 article 来包裹。3）在语义的上一篇文章中，我们介绍过 hgroup 和 h1-h6 的作用，hgroup 是标题组，h1 是一级标题，h2 是二级标题。这里，World Wide Web 是文章的大标题，适合 h1 元素。接下来出现了一个副标题。From Wikipedia, the free encyclopedia。这个地方适合使用 h2，跟 h1 组成一个 hgroup，所以代码可能是类似这样的。

4）标签表示缩写。考虑到 WWW 是 World Wide Web 的缩写，所以文中所有出现的 WWW，都应该使用 abbr 标签。5）细心的同学会发现，在 Wiki 的界面中，出现了一条很长的横线，大家都知道 hr 标签表示横向分隔线，那么这个地方是不是应该用 hr 呢？答案是不用。我们读一下标准的定义就知道了，hr 表示故事走向的转变或者话题的转变，显然此处两个标题并非这种关系，所以我们应该使用 CSS 的 border 来把它当作纯视觉效果来实现，所以这里是不需要用 hr 的。6）接下来一段，我们看到了三段「note」，也就是注记。它在文章中用作额外注释。HTML 中并没有 note 相关的语义，所以，我们用普通的 p 标签，加上 class="note" 来实现。后面的多数自然段都是普通的段落，我们用 p 标签来实现。

7）注意，这里「World Wide Web」（WWW)）和「the Web」使用了黑体呈现，从上下文来看，这里表示这个词很重要，所以我们使用 strong 标签。8）接下来我们看到了一个论文中很常见的用法「引述」。注意看这里的 [1]，当我们把鼠标放上去的时候，出现了引述的相关信息；在 HTML 中，有三个跟引述相关的标签，blockquote 表示段落级引述内容，q 表示行内的引述内容，cite 表示引述的作品名。这里的作品名称「What is the difference between the Web and the Internet?」，应当使用 cite 标签。在文章的结尾处，有对应的 References 一节，这一节中所有的作品名称也应该加入 cite 标签。这里我们看看引用的原文就可以知道，Wiki 文章中的信息并非直接引用，如果是直接引用的内容，那么，我们还应该加上 blockquote 或者 q 标签。9）这里除了引用的文章外，还出现了日期，为了让机器阅读更加方便，可以加上 time 标签。

1『不要滥用 hr 标签，可以用 css 里的 border 来实现相同的视觉效果。』

```html
<cite>"What is the difference between the Web and the Internet?"</cite>. W3C Help and FAQ. W3C. 2009. Archived from the original on 9 July 2015. Retrieved 16 July 2015.

<cite>"What is the difference between the Web and the Internet?"</cite>. W3C Help and FAQ. W3C. 2009. Archived from the original on <time datetime="2015-07-09">9 July 2015</time>. Retrieved <time datetime="2015-07-16">16 July 2015</time>.
```

10）我们注意一下文章的右侧，出现了几张图片，这种出现在文中的图片，不仅仅是一个 img 标签，它和下面的文字组成了一个 figure 的语法现象，figure 也是我们的一种标签（用于表示与主文章相关的图像、照片等流内容）。这种插入文章中的内容，不仅限图片，代码、表格等，只要是具有一定自包含性（类似独立句子）的内容，都可以用 figure。这里面，我们用 figcaption 表示内容的标题，当然，也可以没有标题。11）然后我们继续往下看，来注意这一句；这里分别定义了 Internet 和 World Wide Web，我们应该使用 dfn 标签。代码中你可以看见，你需要在你要定义的词前后放上 dfn 标签，所以我们知道了，dfn 标签是用来包裹被定义的名词。

```html
<figure>
 <img src="https://.....440px-NeXTcube_first_webserver.JPG"/>
 <figcaption>The NeXT Computer used by Tim Berners-Lee at CERN.</figcaption>
</figure>

The terms Internet and World Wide Web are often used without much distinction. However, the two are not the same. 
The <dfn>Internet</dfn> is a global system of interconnected computer networks.
In contrast, the <dfn>World Wide Web</dfn> is a global collection of documents and other resources, linked by hyperlinks and URIs. 
```

12）接下来，几个普通的段落之后，我们看到了文章的目录。这里的目录链接到文章的各个章节，我们可以使用 nav 标签。因为这里的目录顺序不可随意变化，所以我们这里使用多级的 ol 结构。我们这里必须要指出，ol 和 ul 的区分是内容是否有顺序关系，每一项的前面不论是数字还是点，都不会影响语义的判断。所以，你可以注意一下这里，不要因为视觉表现效果，而改变语义的使用。

```html
<nav>
  <h2>Contents</h2>
  <ol>
    <li><a href="...">History</a></li>
    <li><a href="...">Function</a>
      <ol>
        <li><a href="...">Linking</a></li>
        <li><a href="...">Dynamic updates of web pages</a></li>
        ...
      </ol>
    </li>
    ...
  </ol>
</nav>
```

13）pre, samp, code。继续往下，我们来到了这里，我们看见这篇文章有一个很重要的特色，文章中嵌入了一些代码和一些预先编写好的段落。我们看到在「Function」小节中有一段背景色是灰色的文字。

```html
GET /home.html HTTP/1.1
Host: www.example.org
```

这是一段 HTTP 协议的内容描述，因为这段内容的换行是非常严格的，所以我们不需要浏览器帮我们做自动换行，因此我们使用了 pre 标签，表示这部分内容是预先排版过的，不需要浏览器进行排版。又因为这是一段计算机程序的示例输出，所以我们可以使用 samp 标签：

```html
<pre><samp>
GET /home.html HTTP/1.1
Host: www.example.org
</samp></pre>
```

接下来 Wiki 中的内容出现了一段 HTML 代码，我们同样不希望浏览器做自动换行。

```html
<html>
  <head>
    <title>Example.org – The World Wide Web</title>
  </head>
  <body>
    <p>The World Wide Web, abbreviated as WWW and commonly known ...</p>
  </body>
</html>
```

在后面的代码中，还有一些在行内的 code，比如 title 和 p 括起来的内容，这些也都应该使用 code 标签。

### 黑板墙

你最擅长使用哪些语义标签，会把它们用在哪些场景里呢？

就擅长 div span a 标签。进入 wiki 点开控制台，发现很多地方 wiki 本身并没有严格地按照 win 大说的来，大部分也是 div、span 一把梭，有顺序的 nav 直接用的 ul，文中说的 code、sample 这些也都没有用。是不是可以理解成其实很多时候我们为了实现样式的完全控制，降低了对 HTML 本身语义化的要求； 或者说在大部分条件下，快速还原设计稿比语义化本身更重要。

由于项目的关系，大部分时候是制作品牌网站和软件界面的场景，因此我最擅长的语义标签是「作为整体结构」的语义类标签。在这两个场景中，一般不会有大段的阅读文字（即使是 FAQ，也避免大段文字，毕竟没人喜欢读字）。深度了解语义类标签使用的一个技巧，就是去了解爬虫是如何理解自己的网站，从而逆向理解标签是否使用得当。这篇文章最大的收获，就是认识到自己对「自然语言延伸」和「标题摘要」的语义类标签理解不足。比如 pre 和 samp，让我有「居然是这样使用」的感觉。现在知道，如果遇到内容网站的场景（比如博客），我就应该复习一次「自然语言延伸」和「标题摘要」的语义类标签文档，确保正确使用。

## 0203. CSS语法：除了属性和选择器，你还需要知道这些带 @ 的规则

在这里（[All Standards and Drafts - W3C](https://www.w3.org/TR/?title=css)），我们一共看到了 98 份 CSS 相关的标准，它们各自从一些角度规定了 CSS 的特性。这里我们暂且去掉 Working Draft 状态的标准，可以得到 22 份候选标准和 6 份推荐标准。既然我们的专栏内容强调去系统性学习 CSS，于是，面对这 22+6 份标准，我们就又需要一条线索，才能把这些离散的标准组织成易于理解和记忆的形式。

在这样的需求下，我找到的线索就是 CSS 语法，任何 CSS 的特性都必须通过一定的语法结构表达出来，所以语法可以帮助我们发现大多数 CSS 特性。CSS 语法的最新标准，你可以戳这里查看：[CSS Syntax Module Level 3](https://www.w3.org/TR/css-syntax-3/)。

这篇文档的阅读体验其实是非常糟糕的，它对 CSS 语法的描述使用了类似 LL 语法分析的伪代码，而且没有描述任何具体的规则。这里你就不必自己去阅读了，我来把其中一些有用的关键信息抽取出来描述一下，我们一起来看看。

我们拿到这份标准可以看到，去除空格、HTML 注释等无效信息，CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。at-rule 由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。这些 at-rule 在开发中使用机会远远小于普通的规则，所以它的大部分内容，你可能会感觉很陌生。这些 at 规则正是掌握 CSS 的一些高级特性所必须的内容。qualified rule 则是指普通的 CSS 规则，也就是我们所熟识的，由选择器和属性指定构成的规则。

### 3.1 at 规则

好了，现在我们已经知道了，CSS 语法的整体结构，接下来我们要做的是一个体力活，从所有的 CSS 标准里找到所有可能的 at-rule（不用谢，我已经帮你找好了，如果页面定位不准，你可以打开页面搜索关键字）。这里的每一种 @规则背后，都是一组 CSS 的知识。在我们的课程中，有些会重点介绍，不过，为了先给你建立起一个整体的认知，我们这里会给所有的 @规则提供一些简单的例子和介绍。

1、@charset ： [CSS Syntax Module Level 3](https://www.w3.org/TR/css-syntax-3/)。@charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。

```css
@charset "utf-8";
```

2、@import ：[CSS Cascading and Inheritance Level 4](https://www.w3.org/TR/css-cascade-4/)。@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。通过代码，我们可以看出，import 还支持 supports 和 media query 形式。

```css
@import "mystyle.css";
@import url("mystyle.css");

@import [ <url> | <string> ]
        [ supports( [ <supports-condition> | <declaration> ] ) ]?
        <media-query-list>? ;
```

3、@media ：[CSS Conditional Rules Module Level 3](https://www.w3.org/TR/css3-conditional/)。media 就是大名鼎鼎的 media query 使用的规则了，它能够对设备的类型进行一些判断。在 media 的区块内，是普通规则列表。

```css
@media print {
    body { font-size: 10pt }
}
```

4、@page ： [CSS Paged Media Module Level 3](https://www.w3.org/TR/css-page-3/)。page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。

```css
@page {
  size: 8.5in 11in;
  margin: 10%;

  @top-left {
    content: "Hamlet";
  }
  @top-right {
    content: "Page " counter(page);
  }
}
```

5、@counter-style ：[CSS Counter Styles Level 3](https://www.w3.org/TR/css-counter-styles-3/)。counter-style 产生一种数据，用于定义列表项的表现。

```css
@counter-style triangle {
  system: cyclic;
  symbols: ‣;
  suffix: " ";
}
```

6、@keyframes ：[CSS Animations Level 1](https://www.w3.org/TR/css-animations-1/)。keyframes 产生一种数据，用于定义动画关键帧。

```css
@keyframes diagonal-slide {

  from {
    left: 0;
    top: 0;
  }

  to {
    left: 100px;
    top: 100px;
  }

}
```

7、@fontface ：[CSS Fonts Module Level 3](https://www.w3.org/TR/css-fonts-3/)。fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。

```css
@font-face {
  font-family: Gentium;
  src: url(http://example.com/fonts/Gentium.woff);
}

p { font-family: Gentium, serif; }
```

8、@supports ：[CSS Conditional Rules Module Level 3](https://www.w3.org/TR/css3-conditional/)。support 检查环境的特性，它与 media 比较类似。

9、@namespace ：[CSS Namespaces Module Level 3](https://www.w3.org/TR/css-namespaces-3/)。用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。

10、@viewport。用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 HTML 的 meta 代替。

11、其它。除了以上这些，还有些目前不太推荐使用的 at 规则。1）@color-profile 是 SVG1.0 引入的 CSS 特性，但是实现状况不怎么好。2）@document 还没讨论清楚，被推迟到了 CSS4 中。3）@font-feature-values 。

### 3.2 普通规则

接下来我们进入 qualified rule，也就是普通规则的部分，看看这里有什么需要我们记住的内容。qualified rule 主要是由选择器和声明区块构成。声明区块又由属性和值构成。我在下面的列表中，介绍了这部分语法的组成要点。

普通规则：1）选择器。2）声明列表，包括属性和值（值的类型、函数）。

1、选择器。选择器有一份独立的标准，我们可以参考这个网址：[Selectors Level 4](https://www.w3.org/TR/selectors-4/)。这份标准不在我们前面的过滤条件中，它属于 CSS 和 HTML 共用的标准。关于选择器的叠加规则等知识我们后文会专门的一节课程来讲，这里我们就从语法的角度介绍一下选择器。

在选择器标准的最后，附有一张选择器的语法表，从这份语法表，我们可以理清楚记忆选择器的思路。我们从语法结构可以看出，任何选择器，都是由几个符号结构连接的：空格、大于号、加号、波浪线、双竖线，这里需要注意一下，空格，即为后代选择器的优先级较低。然后对每一个选择器来说，如果它不是伪元素的话，由几个可选的部分组成，标签类型选择器，id、class、属性和伪类，它们中只要出现一个，就构成了选择器。如果它是伪元素，则在这个结构之后追加伪元素。只有伪类可以出现在伪元素之后。我在下面用一个列表（不太严谨地）整理了选择器的语法结构：

Complex-selector 包括 combinator 和 compound-selector，combinator 包含：空格、>、+、~、||，compound-selector 包含：type-selector、subclass-selector（id、class、attribute、pseudo-class ）和 pseudo-element。

我们在这里可以参考一个示例图：

1『原文里的图好好消化。』

看完了选择器，我们继续来看看声明部分的语法。

3『「2020128CSS世界」

各连接符的意义如下：1）空格连接。后代选择器：选择所有合乎规则的后代元素。2）> 连接。相邻后代选择器：仅仅选择合乎规则的儿子元素，孙子、重孙元素忽略，因此又称「子选择器」。3）~ 连接。兄弟选择器：选择当前元素后面的所有合乎规则的兄弟元素。4）+ 连接。相邻兄弟选择器：仅仅选择当前元素相邻的那个合乎规则的兄弟元素。

』

2、声明：属性和值。声明部分是一个由「属性：值」组成的序列。属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。

在 CSS Variables 标准（[CSS Custom Properties for Cascading Variables Module Level 1](https://www.w3.org/TR/css-variables/)）中，以双中划线开头的属性被当作变量，与之配合的则是 var 函数：

```css
:root {
  --main-color: #06c;
  --accent-color: #006;
}
/* The rest of the CSS file */
#foo h1 {
  color: var(--main-color);
}
```

值的部分，主要在标准 [CSS Values and Units Module Level 4](https://www.w3.org/TR/css-values-4/)，根据每个 CSS 属性可以取到不同的值，这里的值可能是字符串、标识符。

CSS 属性值可能是以下类型。1）CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。2）字符串：比如 content 属性。3）URL：使用 url () 函数的 URL 值。4）整数 / 实数：比如 flex 属性。5）维度：单位的整数 / 实数，比如 width 属性。6）百分比：大部分维度都支持。7）颜色：比如 background-color 属性。8）图片：比如 background-image 属性。9）2D 位置：比如 background-position 属性。10）函数：来自函数的值，比如 transform 属性。

这里我们要重点介绍一下函数。一些属性会要求产生函数类型的值，比如 easing-function 会要求 cubic-bezier() 函数的值：

CSS 支持一批特定的计算型函数：1）calc() 函数是基本的表达式计算，它支持加减乘除四则运算。在针对维度进行计算时，calc() 函数允许不同单位混合运算，这非常的有用。例如：

```css
section {
  float: left;
  margin: 1em; 
  border: solid 1px;
  width: calc(100%/3 - 2*1em - 2*1px);
}
```

2）max()、min() 和 clamp() 则是一些比较大小的函数，max() 表示取两数中较大的一个，min() 表示取两数之中较小的一个，clamp() 则是给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。3）toggle() 函数在规则选中多于一个元素时生效，它会在几个值之间来回切换，比如我们要让一个列表项的样式圆点和方点间隔出现，可以使用下面代码：

```css
ul { list-style-type: toggle(circle, square); }
```

1『原来 max() 表示取两数中较大的一个，几个项目里看到过。』

4）attr() 函数允许 CSS 接受属性值的控制。

### 黑板墙

CSS 的函数有很多，本文也提到了不少，请你也一起查阅资料，试着总结一下，你能找到多少种 CSS 函数？

1、在网站上搜索了一下，发现 css 函数有不少，尤其是近三年，增加的函数几乎超过过去的总和。按照功能，分成以下 5 个类别（可能并不完全准确）：1）图片。2）图形绘制。3）布局。4）变形/动画。5）环境与元素。

2、推荐一下《css世界》这本书，有理论基础也有实战应用和常遇坑。

## 0204. HTML 元信息类标签：你知道 head 里一共能写哪几种标签吗？

一些元信息标签可以产生实际的行为，掌握它们对于我们编写代码是必须的。另一些元信息仅仅是对页面的描述，掌握它们可以使我们编写的页面跟各种浏览器、搜索引擎等结合地更好。主要包括下面这些内容。1）head：元信息的容器。2）title：文档标题。3）base：页面的基准 URL。4）meta：元信息通用标签。我们还展开介绍了几种重要的 meta 标签，charset 表示页面编码，http-equiv 表示命令，还介绍了一些有约定的 meta 名称。

### 4.1 head 标签

首先我们先来了解一下 head 标签，head 标签本身并不携带任何信息，它主要是作为盛放其它语义类标签的容器使用。head 标签规定了自身必须是 html 标签中的第一个标签，它的内容必须包含一个 title，并且最多只能包含一个 base。如果文档作为 iframe，或者有其他方式指定了文档标题时，可以允许不包含 title 标签。

### 4.2 title 标签

title 标签表示文档的标题，从字面上就非常容易理解。这里我就讲讲需要注意的地方。你还记得吗，我们的语义类标签中也有一组表示标题的标签：h1-h6。heading 和 title 两个英文单词意义区分十分微妙，在中文中更是找不到对应的词汇来区分。但是实际使用中，两者确实有一定区别。

在 HTML 标准中，特意讨论了这个问题。我们思考一下，假设有一个介绍蜜蜂跳舞求偶仪式的科普页面，我们试着把以下两个文字分别对应到 title 和 h1。1）蜜蜂求偶仪式舞蹈。2）舞蹈。

在听 / 看正确答案前，你不妨先想想，自己的答案是什么呢？为什么？好了，思考之后，我们来看看正确答案。正确答案是「蜜蜂求偶仪式舞蹈」放入 title，「舞蹈」放入 h1。

我来讲一讲为什么要这样放呢？这主要是考虑到 title 作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以 title 应该是完整地概括整个网页内容的。而 h1 则仅仅用于页面展示，它可以默认具有上下文，并且有链接辅助，所以可以简写，即便无法概括全文，也不会有很大的影响。

### 4.3 base 标签

base 标签实际上是个历史遗留标签。它的作用是给页面上所有的 URL 相对地址提供一个基础。base 标签最多只有一个，它改变全局的链接地址，它是一个非常危险的标签，容易造成跟 JavaScript 的配合问题，所以在实际开发中，我比较建议你使用 JavaScript 来代替 base 标签。

### 4.4 meta 标签

meta 标签是一组键值对，它是一种通用的元信息表示标签。在 head 中可以出现任意多个 meta 标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。它基本用法是下面这样的，你也可以自己动手尝试一下：

```html
  <meta name=application-name content="lsForums">
```

这个标签表示页面所在的 web-application，名为 IsForums。这里的 name 是一种比较自由的约定，HTTP 标准规定了一些 name 作为大家使用的共识，也鼓励大家发明自己的 name 来使用。除了基本用法，meta 标签还有一些变体，主要用于简化书写方式或者声明自动化行为。下面我就挑几种重点的内容来分别讲解一下。

1『发现 head 标签里的子标签都没收闭合标签元素 \</>，跟 img 标签一样。』

#### 4.4.1 具有 charset 属性的 meta

从 HTML5 开始，为了简化写法，meta 标签新增了 charset 属性。添加了 charset 属性的 meta 标签无需再有 name 和 content。

```html
  <meta charset="UTF-8" >
```

charset 型 meta 标签非常关键，它描述了 HTML 文档自身的编码形式。因此，我建议这个标签放在 head 的第一个。

```html
<html>
<head>
<meta charset="UTF-8">
……
```

这样，浏览器读到这个标签之前，处理的所有字符都是 ASCII 字符，众所周知，ASCII 字符是 UTF-8 和绝大多数字符编码的子集，所以，在读到 meta 之前，浏览器把文档理解多数编码格式都不会出错，这样可以最大限度地保证不出现乱码。一般情况下，HTTP 服务端会通过 http 头来指定正确的编码方式，但是有些特殊的情况如使用 file 协议打开一个 HTML 文件，则没有 http 头，这种时候，charset meta 就非常重要了。

#### 4.4.2 具有 http-equiv 属性的 meta

具有 http-equiv 属性的 meta 标签，表示执行一个命令，这样的 meta 标签可以不需要 name 属性了。例如，下面一段代码，相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式。

```html
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
```

除了 content-type，还有以下几种命令：1）content-language 指定内容的语言；2）default-style 指定默认样式表；3）refresh 刷新；4）set-cookie 模拟 http 头 set-cookie，设置 cookie；5）x-ua-compatible 模拟 http 头 x-ua-compatible，声明 ua 兼容性；6）content-security-policy 模拟 http 头 content-security-policy，声明内容安全策略。

#### 4.4.3 name 为 viewport 的 meta

实际上，meta 标签可以被自由定义，只要写入和读取的双方约定好 name 和 content 的格式就可以了。我们来介绍一个 meta 类型，它没有在 HTML 标准中定义，却是移动端开发的事实标准：它就是 name 为 viewport 的 meta。这类 meta 的 name 属性为 viewport，它的 content 是一个复杂结构，是用逗号分隔的键值对，键值对的格式是 key=value。例如：

```html
<meta name="viewport" content="width=500, initial-scale=1">
```

这里只指定了两个属性，宽度和缩放，实际上 viewport 能控制的更多，它能表示的全部属性如下：1）width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。2）height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。3）initial-scale：初始缩放比例。4）minimum-scale：最小缩放比例。5）maximum-scale：最大缩放比例。6）user-scalable：是否允许用户缩放。

对于已经做好了移动端适配的网页，应该把用户缩放功能禁止掉，宽度设为设备宽度，一个标准的 meta 如下：

```html
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
```

#### 4.4.4 其它预定义的 meta

在 HTML 标准中，还定义了一批 meta 标签的 name，可以视为一种有约定的 meta，我在这里列出来，你可以简单了解一下。1）application-name：如果页面是 Web application，用这个标签表示应用名称。2）author：页面作者。3）description：页面描述，这个属性可能被用于搜索引擎或者其它场合。4）generator：生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。5）keywords：页面关键字，对于 SEO 场景非常关键。6）referrer：跳转策略，是一种安全考量。7）theme-color：页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。

### 黑板墙

你还见过哪些 meta 标签的用法？

```html
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<!-- 默认使用最新浏览器 -->
<meta http-equiv="Cache-Control" content="no-siteapp">
<!-- 不被网页(加速)转码 -->
<meta name="robots" content="index,follow">
<!-- 搜索引擎抓取 -->
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
<meta name="apple-mobile-web-app-capable" content="yes">
<!-- 删除苹果默认的工具栏和菜单栏 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- 设置苹果工具栏颜色 -->
```

我平时还见过以下三种（组）标签：1）Open Graph 的标签组，包括 title, type, URL, site_name, description 和 image，是为 Facebook 分享提供信息；2）Twitter 的标签组，包括 card, title, description 和 image，是为 Twitter 分享提供信息；3）msapplication 的标签组，包括 TileColor 和 TileImage，是为 Windows 8 以及以上系统识别 favicons 用的。

## 0205. CSS 选择器：如何选中 svg 里的 a 元素？

首先要对选择器有一个整体的认识。选择器是什么，选择器是由 CSS 最先引入的一个机制（但随着 document.querySelector 等 API 的加入，选择器已经不仅仅是 CSS 的一部分了）。我们今天这一课，就重点讲讲 CSS 选择器的一些机制。

选择器的基本意义是：根据一些特征，选中元素树上的一批元素。我们把选择器的结构分一下类，那么由简单到复杂可以分成以下几种。1）简单选择器：针对某一特征判断是否选中元素。2）复合选择器：连续写在一起的简单选择器，针对元素自身特征选择单个元素。3）复杂选择器：由「空格」「>」「~」「+」「||」等符号连接的复合选择器，根据父元素或者前序元素检查单个元素。4）选择器列表：由逗号分隔的复杂选择器，表示「或」的关系。

我们可以看到，选择器是由简单选择器逐级组合而成的结构，那么我们就来首先看一下简单选择器。我们在前面说过，简单选择器是针对某一特征判断是否为选中元素。今天我会为你介绍一系列常见的简单选择器，我们把相似的简单选择器放在一起，这样更易于你去记忆。

### 5.1. 类型选择器和全体选择器

我们要介绍的第一个简单选择器就是类型选择器，它根据一个元素的标签名来选中元素。比如：

```html
div {

}
```

这看上去非常简单，但是实际上，我们还必须要考虑 HTML 或者 XML 元素的命名空间问题。比如我们的 svg 元素，实际上在： http://www.w3.org/2000/svg 命名空间之下。svg 和 HTML 中都有 a 元素，我们若要想区分选择 svg 中的 a 和 HTML 中的 a，就必须用带命名空间的类型选择器。

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JS Bin</title>
</head>
<body>
<svg width="100" height="28" viewBox="0 0 100 28" version="1.1"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <desc>Example link01 - a link on an ellipse
  </desc>
  <a xlink:href="http://www.w3.org">
    <text y="100%">name</text>
  </a>
</svg>
<br/>
<a href="javascript:void 0;">name</a>
</body>
</html>
```

```css
@namespace svg url(http://www.w3.org/2000/svg);
@namespace html url(http://www.w3.org/1999/xhtml);
svg|a {
  stroke:blue;
  stroke-width:1;
}

html|a {
  font-size:40px
}
```

这里有一个特殊的选择器，就是「*」，它称为全体选择器，可以选中任意元素。它的用法跟类型选择器是完全一致的，这里就把它们放到一起介绍了。

### 5.2 id 选择器与 class 选择器

id 选择器和 class 选择器都是针对特定属性的选择器。id 选择器是「#」号后面跟随 id 名，class 选择器是「.」后面跟随 class 名。我们来看看基本用法：

```css
#myid {
  stroke:blue;
  stroke-width:1;
}

.mycls {
  font-size:40px
}
```

这两个选择器都是在属性选择器之前就设计出来的选择器，属性选择器出来了以后，理论上可以一定程度上替代它们。但是要注意，class 选择器识别的是：用空格分隔的 class 语法。

```css
<a class="a b c">xxx</a>
.a {
    color:red;
}
```

在这个例子中，我们使用了用空格分隔的 class 属性，使用「.a」「.b」或者「.c」都能够选中元素，也可以使用多个 class 选择器来要求元素具有多个类。

### 5.3 属性选择器

属性选择器根据 HTML 元素的属性来选中元素。属性选择器有四种形态。

第一种，[att]。直接在方括号中放入属性名，是检查元素是否具有这个属性，只要元素有这个属性，不论属性是什么值，都可以被选中。

第二种，[att=val]。精确匹配，检查一个元素属性的值是否是 val。

第三种，[att~=val]。多种匹配，检查一个元素的值是否是若干值之一，这里的 val 不是一个单一的值了，可以是用空格分隔的一个序列。

第四种，[att|=val]。开头匹配，检查一个元素的值是否是以 val 开头，它跟精确匹配的区别是属性只要以 val 开头即可，后面内容不管。

有些 HTML 属性含有特殊字符，这个时候，可以把 val 用引号括起来，形成一个 CSS 字符串。CSS 字符串允许使用单双引号来规避特殊字符，也可以用反斜杠转义，这样，就可以表示出任意属性值啦。

### 5.4 伪类选择器

接下来我们开始介绍伪类选择器，伪类选择器是一系列由 CSS 规定好的选择器，它们以冒号开头。伪类选择器有普通型和函数型两种。我们首先来介绍一下伪类中最常用的部分：树结构关系伪类。

#### 5.4.1. 树结构关系伪类选择器

1）:root 伪类表示树的根元素，在选择器是针对完整的 HTML 文档情况，我们一般用 HTML 标签即可选中根元素。但是随着 scoped css 和 shadow root 等场景出现，选择器可以针对某一子树来选择，这时候就很需要 root 伪类了。2）:empty 伪类表示没有子节点的元素，这里有个例外就是子节点为空白文本节点的情况。3）:nth-child 和 :nth-last-child 这是两个函数型的伪类，CSS 的 An+B 语法设计的是比较复杂的，我们这里仅仅介绍基本用法。:nth-last-child 的区别仅仅是从后往前数。:first-child :last-child 分别表示第一个和最后一个元素。:only-child 按字面意思理解即可，选中唯一一个子元素。4）of-type 系列，是一个变形的语法糖，S:nth-of-type (An+B) 是 :nth-child (|An+B| of S) 的另一种写法。以此类推，还有 nth-last-of-type、first-of-type、last-of-type、only-of-type。

#### 5.4.2 链接与行为伪类选择器

链接与行为是第一批设计出来的伪类，也是最常用的一批。1）:any-link 表示任意的链接，包括 a、area 和 link 标签都可能匹配到这个伪类。2）:link 表示未访问过的链接，:visited 表示已经访问过的链接。3）:hover 表示鼠标悬停在上的元素。4）:active 表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态。5）:focus 表示焦点落在这个元素之上。6）:target 用于选中浏览器 URL 的 hash 部分所指示的元素。

在 Selector Level 4 草案中，还引入了 target-within、focus-within 等伪类，用于表示 target 或者 focus 的父容器。

#### 5.4.3 逻辑伪类选择器

我们这里介绍一个逻辑伪类 —— :not 伪类。这个伪类是个函数型伪类，它的作用时选中内部的简单选择器命中的元素。

```css
*|*:not(:hover)
```

选择器 3 级标准中，not 只支持简单选择器，在选择器 4 级标准，则允许 not 接受一个选择器列表，这意味着选择器支持嵌套，仅靠 not 即可完成选择器的一阶真值逻辑完备，但目前还没有看到浏览器实现它。在 Selector Level 4 草案中，还引入了 :is :where :has 等逻辑伪类，但是它们有一些违背了选择器匹配 DOM 树不回溯的原则，所以这部分设计最终的命运如何还不太确定。

#### 5.4.4 其它伪类选择器

还有一些草案中或者不常用的选择器，你仅做大概了解即可。1）国际化：用于处理国际化和多语言问题（dir、lang）。2）音频 / 视频：用于区分音视频播放状态（play、pause）。3）时序：用于配合读屏软件等时序性客户端的伪类（current、past、future）。4）表格：用于处理 table 的列的伪类（nth-col、nth-last-col）。

伪类是很大的一类简单选择器，它是选择器能力的一种补充。在实际使用中，我还是建议你尽量通过合适的 id 和 class 来标识元素，约束伪类的使用。最好只在不得不使用伪类的场景使用伪类，这对于 CSS 代码的性能和可读性都有好处。

### 黑板墙

用 JavaScript 实现一个能够处理所有简单选择器的 querySelector（行为伪类除外）。

老师这儿描述有点问题。属性选择器第四种 [attr|=value]，应该是表示带有以 attr 命名的属性的元素，属性值为「value」或是以「value-」为前缀（"-" 为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。[attr^=value]，表示带有以 attr 命名的属性，且属性值是以 "value" 开头的元素。出处：[属性选择器 - CSS（层叠样式表） | MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors)。

选择器描述：1）[attribute] 用于选取带有指定属性的元素。2）[attribute=value] 用于选取带有指定属性和值的元素。3）[attribute~=value] 用于选取属性值中包含指定词汇的元素。4）[attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。5）[attribute^=value] 匹配属性值以指定值开头的每个元素。6）[attribute\$=value] 匹配属性值以指定值结尾的每个元素。7）[attribute*=value] 匹配属性值中包含指定值的每个元素。

## 0206. CSS 选择器：伪元素是怎么回事儿？

CSS 选择器的三种机制：选择器的组合、选择器优先级、以及伪元素。在选择器组合这一部分，我们讲到了，选择器的连接方式像四则运算一样有优先级。第一优先级是无连接符号；第二优先级是：「空格」「~」「+」「>」「||」；第三优先级是「,」。然后我们又介绍了选择器优先级的计算方式。最后我们介绍了伪元素，我们逐次讲解了：::first-line、::first-letter、::before、::after 四种伪元素。伪元素的语法跟伪类相似，但是实际产生的效果是把不存在的元素硬选出来。这一点就与伪类不太一样了。结合上一节课我们讲的简单选择器，对它们灵活运用，就能够满足大部分 CSS 的使用场景的需求了。

### 6.1 选择器的组合

在 CSS 规则中，选择器部分是一个选择器列表。选择器列表是用逗号分隔的复杂选择器序列；复杂选择器则是用空格、大于号、波浪线等符号连接的复合选择器；复合选择器则是连写的简单选择器组合。

根据选择器列表的语法，选择器的连接方式可以理解为像四则运算一样有优先级。1）第一优先级，无连接符号。2）第二优先级，「空格」、「~」、「+」、「>」、「||」。3）第三优先级，「,」。例如以下选择器：

```css
.c,.a>.b.d {
    /*......*/
}
```

我们应该理解为这样的结构。

```
.c,.a>.b.d
.c
.a>.b.d
.a
.b.d
.b
.d
```

复合选择器表示简单选择器中「且」的关系，例如，例子中的「.b.d」，表示选中的元素必须同时具有 b 和 d 两个 class。复杂选择器是针对节点关系的选择，它规定了五种连接符号。1）「空格」：后代，表示选中所有符合条件的后代节点，例如「.a .b」表示选中所有具有 class 为 a 的后代节点中 class 为 b 的节点。2）「>」：子代，表示选中符合条件的子节点，例如「.a>.b 」表示：选中所有「具有 class 为 a 的子节点中，class 为 b 的节点」。3）「~」: 后继，表示选中所有符合条件的后继节点，后继节点即跟当前节点具有同一个父元素，并出现在它之后的节点，例如「.a~.b」表示选中所有具有 class 为 a 的后继中，class 为 b 的节点。4）「+」：直接后继，表示选中符合条件的直接后继节点，直接后继节点即 nextSlibling。例如「.a+.b」表示选中所有具有 class 为 a 的下一个 class 为 b 的节点。5）「||」：列选择器，表示选中对应列中符合条件的单元格。

我们在实际使用时，比较常用的连接方式是「空格」和「>」。工程实践中一般会采用设置合理的 class 的方式，来避免过于复杂的选择器结构，这样更有利于维护和性能。

空格和子代选择器通常用于组件化场景，当组件是独立开发时，很难完全避免 class 重名的情况，如果为组件的最外层容器元素设置一个特别的 class 名，生成 CSS 规则时，则全部使用后代或者子代选择器，这样可以有效避免 CSS 规则的命名污染问题。

逗号表示「或」的关系，实际上，可以把它理解为「两条内容一样的 CSS 规则」的一种简写。如我们开头的例子，可以理解成与下面的代码等效：

```css
.c {
    /*......*/
}
.a>.b.d {
    /*......*/
}
```

到这里，我们就讲完了如何用简单选择器组合成复合选择器和复杂选择器，形成选择器列表，这能够帮助我们应对各种复杂的需求。CSS 选择器是基于规则生效的，同一个元素命中多条规则是非常常见的事情。不同规则指定同一个属性为不同值时，就需要一个机制来解决冲突。这个机制，就是接下来我们要讲的选择器优先级。

### 6.2 选择器的优先级

CSS 标准用一个三元组 (a, b, c) 来构成一个复杂选择器的优先级。1）id 选择器的数目记为 a；2）伪类选择器和 class 选择器的数目记为 b；3）伪元素选择器和标签选择器数目记为 c；4）「*」不影响优先级。

CSS 标准建议用一个足够大的进制，获取「a-b-c」来表示选择器优先级。即：

```css
specificity = base * base * a + base * b + c
```

其中，base 是一个「足够大」的正整数。关于 base，历史中有些趣闻，早年 IE6 采用 256 进制，于是就产生「256 个 class 优先级等于一个 id」这样的奇葩问题，后来扩大到 65536，基本避免了类似的问题。现代浏览器多采用了更大的数量，我们正常编写的 CSS 规则数量不太可能达到数万，因此我们可以认为这样的 base 就足够大了。

行内属性的优先级永远高于 CSS 规则，浏览器提供了一个「口子」，就是在选择器前加上「!import」。这个用法非常危险，因为它相当于一个新的优先级，而且此优先级会高于行内属性。同一优先级的选择器遵循「后面的覆盖前面的」原则，我们可以看一个例子：

```css
<div id="my" class="x y">text<div>

.x {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}
```

调换「.x」和「.y」我们可以得到不同的显示效果。选择器的优先级是针对单条规则的，多条规则的选择器同时命中元素，优先级不会发生叠加。

```css
<div id="my" class="x y z">text<div>

.x {
    background-color:lightblue;
}
.z {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}
```

在这个例子中，「.x」和「.z」都指定了背景色为浅蓝色，但是因为「.y」规则在最后，所以最终显示结果为浅绿色。另外一个需要注意的是，选择器的优先级是针对复杂选择器的优先级，选择器列表不会合并计算优先级。我们看一个例子：

```css
<div id="my" class="x y z">text<div>

.x, .z {
    background-color:lightblue;
}
.y {
    background-color:lightgreen;
}
```

这里选择器列表「.x, .z」命中了 div，但是它的两项分别计算优先级，所以最终优先级仍跟「.y」规则相同。以上就是选择器优先级的相关规则了，虽然我们这里介绍了详细的计算方式，但是我认为选择器的使用上，如果产生复杂的优先级计算，代码的可读性一定是有问题的。所以实践中，建议你「根据 id 选单个元素」「class 和 class 的组合选成组元素」「tag 选择器确定页面风格」这样的简单原则来使用选择器，不要搞出过于复杂的选择器。

2『使用选择器的原则：根据 id 选单个元素、class 和 class 的组合选成组元素、tag 选择器确定页面风格。做一张金句卡片。』

### 6.3 伪元素

在上一课，我们有意忽略了一种重要的简单选择器：伪元素。我之所以没有把它放在简单选择器中，是因为伪元素本身不单单是一种选择规则，它还是一种机制。所以本节课，我就来讲一讲伪元素机制。伪元素的语法跟伪类相似，但是实际产生的效果却是把不存在的元素硬选出来。

目前兼容性达到可用的伪元素有以下几种。1）::first-line。2）::first-letter。3）::before。4）::after。下面我们就来分别讲讲它们。

::first-line 和 ::first-letter 是比较类似的伪元素，其中一个表示元素的第一行，一个表示元素的第一个字母。我们可以看一个示例：

```css
<p>This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.</p>


p::first-line { 
    text-transform: uppercase 
}
```

这一段代码把段落的第一行字母变为大写。注意这里的第一行指的是排版后显示的第一行，跟 HTML 代码中的换行无关。

::first-letter 则指第一个字母。首字母变大并向左浮动是一个非常常见的排版方式。

```css
<p>This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.</p>


p::first-letter { 
    text-transform: uppercase;
    font-size:2em;
    float:left; 
}
```

虽然听上去很简单，但是实际上，我们遇到的 HTML 结构要更为复杂，一旦元素中不是纯文本，规则就变得复杂了。CSS 标准规定了 first-line 必须出现在最内层的块级元素之内。因此，我们考虑以下代码。

```css
<div>
  <p id=a>First paragraph</p>
  <p>Second paragraph</p>
</div>


div>p#a {
    color:green;
}

div::first-line { 
    color:blue; 
}
```

这段代码最终结果第一行是蓝色，因为 p 是块级元素，所以伪元素出现在块级元素之内，所以内层的 color 覆盖了外层的 color 属性。如果我们把 p 换成 span，结果就是相反的。

```css
<div>
  <span id=a>First paragraph</span><br/>
  <span>Second paragraph</span>
</div>


div>span#a {
    color:green;
}

div::first-line { 
    color:blue; 
}
```

这段代码的最终结果是绿色，这说明伪元素在 span 之外。

::first-letter 的行为又有所不同，它的位置在所有标签之内，我们把前面的代码换成::first-letter。

```css
<div>
  <span id=a>First paragraph</span><br/>
  <span>Second paragraph</span>
</div>

div>span#a {
    color:green;
}

div::first-letter { 
    color:blue; 
}
```

执行这段代码，我们可以看到，首字母变成了蓝色，这说明伪元素出现在 span 之内。CSS 标准只要求 ::first-line 和 ::first-letter 实现有限的几个 CSS 属性，都是文本相关，这些属性是下面这些。

接下来我们说说 ::before 和 ::after 伪元素。这两个伪元素跟前面两个不同的是，它不是把已有的内容套上一个元素，而是真正的无中生有，造出一个元素。

::before 表示在元素内容之前插入一个虚拟的元素，::after 则表示在元素内容之后插入。这两个伪元素所在的 CSS 规则必须指定 content 属性才会生效，我们看下例子：

```css
<p class="special">I'm real element</p>

p.special::before {
    display: block;
    content: "pseudo! ";
}
```

这里要注意一点，::before 和 ::after 还支持 content 为 counter，如：

```css
<p class="special">I'm real element</p>
p.special::before {
    display: block;
    content: counter(chapno, upper-roman) ". ";
}
```

这对于实现一些列表样式是非常有用的。

::before 和 ::after 中支持所有的 CSS 属性。实际开发中，这两个伪元素非常有用，有了这两个伪元素，一些修饰性元素，可以使用纯粹的 CSS 代码添加进去，这能够很好地保持 HTML 代码中的语义，既完成了显示效果，又不会让 DOM 中出现很多无语义的空元素。

### 黑板墙

如果是注重复用的开发，一般采用组件化的形式，给组件一套命名空间；如果是页面较少的网页开发，不太在意复用和扩展，一般采用 BEM 的规则。「根据 id 选单个元素，class 和 class 的组合选择成组元素，tag 选择器确定页面风格。」从这个原则中收获很大。

## 0207. HTML 链接：除了 a 标签，还有哪些标签叫链接？

### 1. 逻辑脉络

介绍了几种链接类型。在 HTML 中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。我们逐次讲到了 link 标签、a 标签和 area 标签，link 标签一般用于看不见的链接，它可能产生超链接或者外部资源链接，a 和 area 一般用于页面上显示的链接，它们只能产生超链接。

### 2. 摘录及评论

链接也是一类 HTML 元素，这种元素可以说是占据了整个互联网。也正是因为无处不在的超链接，才让我们的万维网如此繁荣。没有了超链接的 HTML，最多可以称为富文本，没法称作超文本（hyper text）。除了肉眼可见的这些链接，其实 HTML 里面还规定了一些不可见链接的类型，这节课就来给你介绍链接家族的全员，让你对它们有一个完整的认识。

链接是 HTML 中的一种机制，它是 HTML 文档和其它文档或者资源的连接关系，在 HTML 中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。链接的家族中有 a 标签、area 标签和 link 标签。

### 7.1 link 标签

提到链接，我们都知道 a 标签可以成为超链接，但是我们今天的内容，要从一个大家不太熟悉的标签开始，也就是 link 标签。我们已经介绍过元信息类标签。实际上，我们并没有介绍完全，有些 link 标签也是元信息类标签的一种。

我们已经讲过，HTML 标准并没有规定浏览器如何使用元信息，我们还讲到了元信息中有不少是被设计成「无需被浏览器识别，而是专门用于搜索引擎看的」。link 标签也是元信息的一种，在很多时候，它也是不会对浏览器产生任何效果的，这也是很多人会忽略 link 标签学习的原因。

link 标签会生成一个链接，它可能生成超链接，也可能生成外部资源链接。一些 link 标签会生成超链接，这些超链接又不会像 a 标签那样显示在网页中。这就是超链接型的 link 标签。这意味着多数浏览器中，这些 link 标签不产生任何作用。但是，这些 link 标签能够被搜索引擎和一些浏览器插件识别，从而产生关键性作用。比如，到页面 RSS 的 link 标签，能够被浏览器的 RSS 订阅插件识别，提示用户当前页面是可以 RSS 订阅的。

另外一些 link 标签则会把外部的资源链接到文档中，也就是说，会实际下载这些资源，并且做出一些处理，比如我们常见的用 link 标签引入样式表。除了元信息的用法之外，多数外部资源型的 link 标签还能够被放在 body 中使用，从而起到把外部资源链接进文档的作用。

link 标签的链接类型主要通过 rel 属性来区分，在本篇文章中，我们提到 xx 型 link 即表示属性 rel 为 xx 的 link，其代码类似下面：

```html
<link rel="xx" ...>
```

下面我们先来看看超链接型 link 标签。

### 7.2 超链接类 link 标签

超链接型 link 标签是一种被动型链接，在用户不操作的情况下，它们不会被主动下载。link 标签具有特定的 rel 属性，会成为特定类型的 link 标签。产生超链接的 link 标签包括：具有 rel="canonical" 的 link、具有 rel="alternate" 的 link、具有 rel="prev" rel="next" 的 link 等等。

#### 7.2.1 canonical 型 link

这种 link 的代码写法是这样：

```html
<link rel="canonical" href="...">
```

这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个 link 会提示搜索引擎保留哪一个 URL。

#### 7.2.2 alternate 型 link

这种 link 的代码写法是这样：

```html
<link rel="alternate" href="...">
```

这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种 link 通常也是提供给搜索引擎来使用的。alternate 型的 link 的一个典型应用场景是，页面提供 rss 订阅时，可以用这样的 link 来引入：

```html
<link rel="alternate" type="application/rss+xml" title="RSS" href="...">
```

除了搜索引擎外，很多浏览器插件都能识别这样的 link。

#### 7.2.3 prev 型 link 和 next 型 link

在互联网应用中，很多网页都属于一个序列，比如分页浏览的场景，或者图片展示的场景，每个网页是序列中的一个项。这种时候，就适合使用 prev 和 next 型的 link 标签，来告诉搜索引擎或者浏览器它的前一项和后一项，这有助于页面的批量展示。因为 next 型 link 告诉浏览器「这是很可能访问的下一个页面」，HTML 标准还建议对 next 型 link 做预处理，在本课后面的内容，我们会讲到预处理类的 link。

#### 7.2.3 其它超链接类的 link

其它超链接类 link 标签都表示一个跟当前文档相关联的信息，可以把这样的 link 标签视为一种带链接功能的 meta 标签。1）rel="author" 链接到本页面的作者，一般是 mailto: 协议。2）rel="help" 链接到本页面的帮助页。3）rel="license" 链接到本页面的版权信息页。4）rel="search" 链接到本页面的搜索页面（一般是站内提供搜索时使用）。

到这里，我们已经讲完了所有的超链接类的 link 标签用法了。接下来我们讲讲外部资源类 link 标签。

### 7.3 外部资源类 link 标签

外部资源型 link 标签会被主动下载，并且根据 rel 类型做不同的处理。外部资源型的标签包括：具有 icon 型的 link、预处理类 link、modulepreload 型的 link、stylesheet、pingback。下面我们来一一介绍它们。

#### 7.3.1 icon 型 link

这类链接表示页面的 icon。多数浏览器会读取 icon 型 link，并且把页面的 icon 展示出来。icon 型 link 是唯一一个外部资源类的元信息 link，其它元信息类 link 都是超链接，这意味着，icon 型 link 中的图标地址默认会被浏览器下载和使用。

如果没有指定这样的 link，多数浏览器会使用域名根目录下的 favicon.ico，即使它并不存在，所以从性能的角度考虑，建议一定要保证页面中有 icon 型的 link。只有 icon 型 link 有有效的 sizes 属性，HTML 标准允许一个页面出现多个 icon 型 link，并且用 sizes 指定它适合的 icon 尺寸。

#### 7.3.2 预处理类 link

我们都知道，导航到一个网站需要经过 dns 查询域名、建立连接、传输数据、加载进内存和渲染等一系列的步骤。预处理类 link 标签就是允许我们控制浏览器，提前针对一些资源去做这些操作，以提高性能（当然如果你乱用的话，性能反而更差）。

下面我来列一下这些 link 类型：1）dns-prefetch 型 link 提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。2）preconnect 型 link 提前对一个服务器建立 tcp 连接。3）prefetch 型 link 提前取 href 指定的 url 的内容。4）preload 型 link 提前加载 href 指定的 url。5）prerender 型 link 提前渲染 href 指定的 url。

#### 7.3.3 modulepreload 型的 link

modulepreload 型 link 的作用是预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。这里的所谓加载，是指完成下载并放入内存，并不会执行对应的 JavaScript。

```html
<link rel="modulepreload" href="app.js">
<link rel="modulepreload" href="helpers.js">
<link rel="modulepreload" href="irc.js">
<link rel="modulepreload" href="fog-machine.js">
<script type="module" src="app.js">
```

这个例子来自 HTML 标准，我们假设 app.js 中有 import「irc」和 import「fog-machine」, 而 irc.js 中有 import「helpers」。这段代码使用 moduleload 型 link 来预加载了四个 js 模块。尽管，单独使用 script 标签引用 app.js 也可以正常工作，但是我们通过加入对四个 JS 文件的 link 标签，使得四个 JS 文件有机会被并行地下载，这样提高了性能。

#### 7.3.4 stylesheet 型 link

样式表大概是所有人最熟悉的 link 标签用法了。它的样子是下面这样的。

```html
<link rel="stylesheet" href="xxx.css" type="text/css">
```

基本用法是从一个 CSS 文件创建一个样式表。这里 type 属性可以没有，如果有，必须是 "text/css" 才会生效。rel 前可以加上 alternate，成为 rel="alternate stylesheet"，此时必须再指定 title 属性。这样可以为页面创建一份变体样式，一些浏览器，如 Firefox 3.0，支持从浏览器菜单中切换这些样式，当然了，大部分浏览器不支持这个功能，所以仅仅从语义的角度了解一下这种用法即可。

#### 7.3.5 pingback 型 link

这样的 link 表示本网页被引用时，应该使用的 pingback 地址，这个机制是一份独立的标准，遵守 pingback 协议的网站在引用本页面时，会向这个 pingback url 发送一个消息。

以上就是 link 标签的所有用法了。接下来我们来介绍一下最熟悉的 a 标签，当然了，也可能你学过了本节课以后，觉得自己其实也没那么熟悉。

### 7.4 a 标签

a 标签是「anchor」的缩写，它是锚点的意思，所谓锚点，实际上也是一种比喻的用法，古代船舶用锚来固定自己的位置，避免停泊时被海浪冲走，所以 anchor 标签的意思也是标识文档中的特定位置。a 标签其实同时充当了链接和目标点的角色，当 a 标签有 href 属性时，它是链接，当它有 name 时，它是链接的目标。具有 href 的 a 标签跟一些 link 一样，会产生超链接，也就是在用户不操作的情况下，它们不会被主动下载的被动型链接。

重点的内容是，a 标签也可以有 rel 属性，我们来简单了解一下，首先是跟 link 相同的一些 rel，包括下面的几种：alternate、author、help、license、next、prev、search。

1『原来 a 也有 ref 属性，一直以为它的链接属性只有 href。』

这些跟 link 语义完全一致，不同的是，a 标签产生的链接是会实际显示在网页中的，而 link 标签仅仅是元信息。除了这些之外，a 标签独有的 rel 类型：1）tag 表示本网页所属的标签；2）bookmark 到上级章节的链接。

a 标签还有一些辅助的 rel 类型，用于提示浏览器或者搜索引擎做一些处理：1）nofollow 此链接不会被搜索引擎索引；2）noopener 此链接打开的网页无法使用 opener 来获得当前页面的窗口；3）noreferrer 此链接打开的网页无法使用 referrer 来获得当前页面的 url；4）opener 打开的网页可以使用 window.opener 来访问当前页面的 window 对象，这是 a 标签的默认行为。

a 标签基本解决了在页面中插入文字型和整张图片超链接的需要，但是如果我们想要在图片的某个区域产生超链接，那么就要用到另一种标签了 ——area 标签。

### 7.5 area 标签

area 标签与 a 标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。area 标签支持的 rel 与 a 完全一样，这里就不多说了。

area 是整个 html 规则中唯一支持非矩形热区的标签，它的 shape 属性支持三种类型。1）圆形：circle 或者 circ，coords 支持三个值，分别表示中心点的 x, y 坐标和圆形半径 r。2）矩形：rect 或者 rectangle，coords 支持两个值，分别表示两个对角顶点 x1，y1 和 x2，y2。3）多边形：poly 或者 polygon，coords 至少包括 6 个值，表示多边形的各个顶点。

因为 area 设计的时间较早，所以不支持含有各种曲线的路径，但是它也是唯一一个支持了非矩形触发区域的元素，所以，对于一些效果而言，area 是必不可少的。area 必须跟 img 和 map 标签配合使用。使用示例如下（例子来自 html 标准）。

```html
<p>
 Please select a shape:
 <img src="shapes.png" usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.">
 <map name="shapes">
  <area shape=rect coords="50,50,100,100"> <!-- the hole in the red box -->
  <area shape=rect coords="25,25,125,125" href="red.html" alt="Red box.">
  <area shape=circle coords="200,75,50" href="green.html" alt="Green circle.">
  <area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle.">
  <area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star.">
 </map>
</p>
```

这个例子展示了在一张图片上画热区并且产生链接，分别使用了矩形、圆形和多边形三种 area。

### 黑板墙

有几点困惑：

1. 基本数据类型存放于栈空间中，对象存放于堆空间中，堆空间在内存里的存放是以链表的形式吗，物理地址不连续，但是逻辑地址是连续的？

2. 声明一个基本数据类型，存放于栈空间，但是使用的时候，又把它进行一次对象的转化，例如：var a="1"，实际操作的时候它又创建了一个 String 对象，那么这个基本数据类型 a 字符串去哪了，它就没有用了吗？

3. JavaScript 中的 null，是一个值还是一个地址，如果是值的话，那 null 是否有很多个，是地址的话，那说明 null 是指向一个唯一的一个地方？

4. 原型链中的 prototype 和 \_\_proto\_\_，它们是指针吗，我认为它是指针，但是有前端小伙伴说它是一块连续的空间，每次声明一个变量都从 object 开始开辟一整套的空间，也就是说堆空间中可能会有很多的 object。

5. 最后一个问题是 js 垃圾回收机制标记清除算法中，它说从根节点出发进行可达节点遍历标记，那么这个根节点是从什么地方开始呢？是从全局的 window 或者 global 出发吗？如果 null 是一个唯一的空间，那么清除一个对象其实是把对象的值指向这块空间吗？

## 0208. CSS 排版：从毕升开始，我们就开始用正常流了

### 1. 逻辑脉络

可以用一句话来描述「正常流」的排版行为，那就是：依次排列，排不下了换行。这也是理解它最简单最源头的方式。我们将正常流的知识分成了三个部分。1）正常流的行为部分，我们从一些感性认知出发，帮助你从思路和源头上理解正常流的行为。2）正常流的原理部分，我用更严格的描述方式，给你讲解了 CSS 标准中规定的正常流排版逻辑。3）最后的正常流应用部分，我以两个经典布局问题等分布局和自适应宽为例，为你讲解了正常流实际使用的一些技巧。

### 2. 摘录及评论

我想，在 CSS 中，大家最讨厌的大概就是排版部分了。因为早年的 CSS 设计上不能够很好地支持软件排版需求，导致大家需要使用很多黑科技，让很多新人望而却步。现在 CSS 提供了很多种排版方式，我们有很多选项可以选择自己适合的那一种，然而，正常流却是我们绕不开的一种排版。

我们能够在网上看到关于正常流的各种资料，比如：块级格式化上下文、margin 折叠等等…… 这一系列的概念光是听起来就令人非常头痛。所以我相信很多同学一定会奇怪：正常流到底正常在哪里。事实上，我认为正常流本身是简单和符合直觉的东西。我们之所以会觉得它奇怪，是因为如果我们从严苛的 CSS 标准角度去理解正常流，规定排版的算法，就需要引入上述那些复杂的概念。但是，如果我们单纯地从感性认知的层面去理解正常流，它其实是简单的。下面，就让我们先抛弃掉所有的已知概念，从感性认知的角度出发，一起去理解一下正常流。

### 8.1 正常流的行为

首先，我们先从词源来讲一讲排版这件事。在毕昇发明活字印刷之前，排版这项工作是不存在的，相应的操作叫做「雕版」。人们要想印刷书籍，就需要依靠雕版工人去手工雕刻印版。活字印刷的出现，将排版这个词引入进来，排版是活字印刷的 15 道工序之一，不论是古代的木质活字印刷，还是近代的铅质活字印刷，排版的过程是由排版工人一个字一个字从字架捡出，再排入版框中。实际上，这个过程就是一个流式处理的过程。

从古代活字印刷开始，到现代的出版行业，再到今天的 Web，排版过程其实并没有什么本质的变化，只不过，今天在我们的 CSS 中，排版需要处理的内容，不再是简单的大小相同的木字或者铅字，而是有着不同字体和字号的富文本，以及插入在富文本中大小不等的盒。并且，在这些过程中，都会有一个正常流的存在。那么，正常流是什么样的呢？

我们可以用一句话来描述正常流的排版行为，那就是：依次排列，排不下了换行。这个操作很简单吧，我想，任何一个不懂排版的人都会将其作为排版时的第一反应。

理解了正常流的基本概念，剩下的功能只需要在它的基础上延伸一下就好。在正常流基础上，我们有 float 相关规则，使得一些盒占据了正常流需要的空间，我们可以把 float 理解为「文字环绕」。

我们还有 vertical-align 相关规则规定了如何在垂直方向对齐盒。vertical-align 相关规则看起来复杂，但是实际上，基线、文字顶 / 底、行顶 / 底都是我们正常书写文字时需要用到的概念，只是我们平时不一定会总结它们。下图展示了在不同的 vertical-align 设置时，盒与文字是如何混合排版的。为了方便你理解，我们用代码给大家标注了基线、文字顶 / 底、行顶 / 底等概念。

除此之外，margin 折叠是很多人非常不理解的一种设计，但是实际上我们可以把 margin 理解为「一个元素规定了自身周围至少需要的空间」，这样，我们就非常容易理解为什么 margin 需要折叠了。

### 8.2 正常流的原理

我们前面描述了正常流的行为，接下来我们要切换一下模式，用比较严谨的姿势来理解一下正常流。在 CSS 标准中，规定了如何排布每一个文字或者盒的算法，这个算法依赖一个排版的「当前状态」，CSS 把这个当前状态称为「格式化上下文」（formatting context）。

我们可以认为排版过程是这样的：格式化上下文 + 盒 / 文字 = 位置（formatting context + boxes/charater = positions）。

我们需要排版的盒，是分为块级盒和行内级盒的，所以排版需要分别为它们规定了块级格式化上下文和行内级格式化上下文。与正常流一样，如果我们单纯地看格式化上下文，规则其实是非常简单的。

块级格式化上下文顺次排列元素；行内级格式化上下文顺次排列元素。（原文的图中一个块级的自上而下，行内级的自左到右。）

注意，块级和行内级元素的排版，受文字书写方向的影响，这里我们讲上下左右只是为了方便你直观理解。当我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理。

1、当遇到块级盒：排入块级格式化上下文。

2、当遇到行内级盒或者文字：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。

3、遇到 float 盒（文字环绕）：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据 float 的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。

1『第 3 步目前理解不了。（2020-05-05）』

我们以上讲的都是一个块级格式化上下文中的排版规则，实际上，页面中的布局没有那么简单，一些元素会在其内部创建新的块级格式化上下文，这些元素有：1）浮动元素；2）绝对定位元素；3）非块级但仍能包含块级元素的容器（如 inline-blocks、table-cells、table-captions）；4）块级的能包含块级元素的容器，且属性 overflow 不为 visible。

这里的最后一条比较绕，实际上，我个人喜欢用另一种思路去理解它：自身为块级，且 overflow 为 visible 的块级元素容器，它的块级格式化上下文和外部的块级格式化上下文发生了融合，也就是说，如果不考虑盒模型相关的属性，这样的元素从排版的角度就好像根本不存在。

好了，到这里我们已经讲完了正常流的排版详细规则，但是理解规则仅仅是基础，我们还需要掌握一些技巧。

### 8.3 正常流的使用技巧

现在，我们就一起来动手用实际的例子来研究一下。我们今天来看看等分布局和自适应宽，从这两种经典布局问题入手，一起来探索一下正常流的使用技巧。

#### 8.3.1 等分布局问题

横向等分布局是一个很常见的需求，按照一般的思路，我们可以使用百分比宽度来解决，我们参考以下代码：

```css
<div class="outer">
    <div class="inner"></div>
    <div class="inner"></div>
    <div class="inner"></div>
</div>

.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}
```

在这段 HTML 代码中，我们放了三个 div，用 CSS 给它们指定了百分比宽度，并且指定为 inline-block。但是这段代码执行之后，效果跟我们预期不同，我们可以发现，每个 div 并非紧挨，中间有空白，这是因为我们为了代码格式加入的换行和空格被 HTML 当作空格文本，跟 inline 盒混排了的缘故。解决方案是修改 HTML 代码，去掉空格和换行：

```html
<div class="outer"><div class="inner"></div><div class="inner"></div><div class="inner"></div></div>
```

但是这样做影响了源代码的可读性，一个变通的方案是，改变 outer 中的字号为 0。

```css
.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
    font-size:30px;
}
.outer {
    font-size:0;
}
```

1『竟然还可以这样操作，这个小知识点记一下。』

在某些浏览器中，因为像素计算精度问题，还是会出现换行，我们给 outer 添加一个特定宽度：

```css
.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}
.outer {
    width:101px
}
```

这个代码在某些旧版本浏览器中会出现换行。为了保险起见，我们给最后一个 div 加上一个负的右 margin：

```css
.outer {
    width:101px
}

.inner {
    width:33.33%;
    height:300px;
    display:inline-block;
    outline:solid 1px blue;
}

.inner:last-child {
    margin-right:-5px;
}
```

1『原来之前很多地方看到负值 margin 是这种用途。另外，经试验，如果 display 只是 inline 的话，width 和 height 是没法设置的，这就体现了 inline-block 的妙处，外在盒子是内联级而内部盒子是块级。』

这样就可以解决旧版本浏览器的问题了。除了使用 inline-block，float 也可以实现类似的效果，但是 float 元素只能做顶对齐，不如 inline-block 灵活。

#### 8.3.2 自适应宽

我们再来说说自适应宽。在 IE6 统治浏览器市场的旧时代，自适应宽（一个元素固定宽度，另一个元素填满父容器剩余宽度）是个经典的布局问题，我们现在就看一下如何使用正常流来解决。我们首先来看一下问题。

```css
<div class="outer">
    <div class="fixed"></div>
    <div class="auto"></div>
</div>

.fixed {
    width:200px;
}
.fixed, .auto {
    height:300px;
    outline:solid 1px blue;
}
```

这里 fixed 这个 div 宽度已经被指定好，我们需要添加 css 代码尝试让 .auto 填满剩余宽度。使用正常流解决这个问题的思路是，利用负 margin：

```css
.fixed {
    display:inline-block;
    vertical-align:top;
}
.auto {
    margin-left:-200px;
    width:100%;
    display:inline-block;
    vertical-align:top;
}
```

但是，这样做会导致 auto 中的内容位置不对，所以我们还需要使用 padding 把内容挤出来，最终完整代码如下：

```css
.fixed {
    display:inline-block;
    vertical-align:top;
}
.auto {
    margin-left:-200px;
    padding-left:200px;
    box-sizing:border-box;
    width:100%;
    display:inline-block;
    vertical-align:top;
}
```

这样就给 auto 添加了 padding-left 和 box-sizing 两个属性。

总的来说，正常流布局主要是使用 inline-block 来作为内容的容器，利用块级格式化上下文的纵向排布和行内级格式化上下文的横向排布来完成布局的，我们需要根据需求的横向和纵向排布要求，来选择元素的 display 属性。

### 黑板墙

试了一下，发现上面第二个例子的代码并不能实现想要的效果。首先，因为 hmtl 代码的换行使得在 inline-block 的布局下两个盒子不能被放在一行这个通过父级 font-size:0 可解决。第二，由于 auto 在 html 的上的顺序是比 fixed 后面的，想像中的层级是高于 fixed 的，当 auto 是一个有背景的盒子，fixed 就被完全遮挡了，可以通过 transform: translateZ(0) 把它提起来。

## 0209. HTML 替换型元素：为什么 link 一个 CSS 要用 href，而引入 js 要用 src 呢？

### 1. 逻辑脉络

又认识了一组 HTML 元素：替换型元素。它们的特点是，引入一个外部资源来进入页面，替换掉自身的位置。我们通过对 script、img、picture、audio、video、iframe 几个标签的讲解，了解了不同的资源引入方式：1）src 属性；2）srcset 属性；3）source 标签；4）srcdoc 属性。这中间，我们也介绍了一些小技巧，比如 src 属性的好朋友：data uri，这在实际开发中非常有用。

### 2. 摘录及评论

我们都知道一个常识，一个网页，它是由多个文件构成的，我们在之前的课程中，已经学过了一种引入文件的方案：链接。这节课我们要讲的替换型元素，就是另一种引入文件的方式了。替换型元素是把文件的内容引入，替换掉自身位置的一类标签。我们首先来看一种比较熟悉的标签：script 标签。

### 9.1 script

我们之所以选择先讲解 script 标签，是因为 script 标签是为数不多的既可以作为替换型标签，又可以不作为替换型标签的元素。我们先来看看 script 标签的两种用法：

```html
<script type="text/javascript">
console.log("Hello world!");
</script>

<script type="text/javascript" src="my.js"></script>

```

这个例子中，我们展示了两种 script 标签的写法，一种是直接把脚本代码写在 script 标签之间，另一种是把代码放到独立的 js 文件中，用 src 属性引入。这两种写法是等效的。我想这种等效性可以帮助你理解替换型元素的「替换」是怎么一回事。

这里我们就可以回答标题中的问题了：凡是替换型元素，都是使用 src 属性来引用文件的，而我们之前的课程中已经讲过，链接型元素是使用 href 标签的。虽然我不知道当初是怎么设计的，但是 style 标签并非替换型元素，不能使用 src 属性，这样，我们用 link 标签引入 CSS 文件，当然就是用 href 标签啦。接下来我们再看看别的替换型元素，先来了解一下 img 标签。

1『凡是替换型元素，都是使用 src 属性来引用文件的。相关知识做一张任意卡。』

### 9.2 img

毫无疑问我们最熟悉的替换型标签就是 img 标签了，几乎每个前端都会日常使用 img 标签。img 标签的作用是引入一张图片。这个标签是没有办法像 script 标签那样作为非替换型标签来使用的，它必须有 src 属性才有意义。如果一定不想要引入独立文件，可以使用 data uri，我们来看个实际的例子：

```html
 <img src='data:image/svg+xml;charset=utf8,<svg version="1.1" 
 xmlns="http://www.w3.org/2000/svg"><rect width="300" height="100" 
 style="fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)"/></svg>'/>
```

这个例子中我们使用了 data uri 作为图片的 src，这样，并没有产生独立的文件，客观上做到了和内联相同的结果，这是一个常用的技巧。img 标签可以使用 width 和 height 指定宽度和高度。也可以只指定其中之一。我们看个例子：

```html
 <img src='data:image/svg+xml;charset=utf8,<svg width="600" height="400" version="1.1"
xmlns="http://www.w3.org/2000/svg"><ellipse cx="300" cy="150" rx="200" ry="80"
style="fill:rgb(200,100,50);
stroke:rgb(0,0,100);stroke-width:2"/></svg>' width="100"/>
```

这个例子中，为了方便你理解，我们把图片换成了椭圆，我们可以看到，当我们指定了宽度后，图片被等比例缩放了。这个特性非常重要，适用于那种我们既要限制图片尺寸，又要保持图片比例的场景。如果从性能的角度考虑，建议你同时给出图片的宽高，因为替换型元素加载完文件后，如果尺寸发生变换，会触发重排版（这个概念我们在浏览器原理部分已经讲过，可以复习一下）。

此处要重点提到一个属性，alt 属性，这个属性很难被普通用户感知，对于视障用户非常重要，可以毫不夸张地讲，给 img 加上 alt 属性，已经做完了可访问性的一半。img 标签还有一组重要的属性，那就是 srcset 和 sizes，它们是 src 属性的升级版（所以我们前面讲 img 标签必须有 src 属性，这是不严谨的说法）。这两个属性的作用是在不同的屏幕大小和特性下，使用不同的图片源。下面一个例子也来自 MDN，它展示了 srcset 和 sizes 的用法。

```html
<img srcset="elva-fairy-320w.jpg 320w,
             elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w"
     sizes="(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px"
     src="elva-fairy-800w.jpg" alt="Elva dressed as a fairy">
```

srcset 提供了根据屏幕条件选取图片的能力，但是其实更好的做法，是使用 picture 元素。

### 9.3 picture

picture 元素可以根据屏幕的条件为其中的 img 元素提供不同的源，它的基本用法如下：

```html
<picture>
  <source srcset="image-wide.png" media="(min-width: 600px)">
  <img src="image-narrow.png">
</picture>
```

picture 元素的设计跟 audio 和 video 保持了一致（稍后我会为你讲解这两个元素），它跟 img 搭配 srcset 和 sizes 不同，它使用 source 元素来指定图片源，并且支持多个。这里的 media 属性是 media query，跟 CSS 的 @media 规则一致。

### 9.4 video

在 HTML5 早期的设计中，video 标签跟 img 标签类似，也是使用 src 属性来引入源文件的，不过，我想应该是考虑到了各家浏览器支持的视频格式不同，现在的 video 标签跟 picture 元素一样，也是提倡使用 source 的。下面例子是一个古典的 video 用法：

```html
<video controls="controls" src="movie.ogg">
</video>
```

这个例子中的代码用 src 来指定视频的源文件。但是因为一些历史原因，浏览器对视频的编码格式兼容问题分成了几个派系，这样，对于一些兼容性要求高的网站，我们使用单一的视频格式是不合适的。现在的 video 标签可以使用 source 标签来指定接入多个视频源。

```html
<video controls="controls" >
  <source src="movie.webm" type="video/webm" >
  <source src="movie.ogg" type="video/ogg" >
  <source src="movie.mp4" type="video/mp4">
  You browser does not support video.
</video>
```

从这个例子中，我们可以看到，source 标签除了支持 media 之外，还可以使用 type 来区分源文件的使用场景。

video 标签的内容默认会被当做不支持 video 的浏览器显示的内容吗，因此，如果要支持更古老的浏览器，还可以在其中加入 object 或者 embed 标签，这里就不详细展开了。

video 中还支持一种标签：track。track 是一种播放时序相关的标签，它最常见的用途就是字幕。track 标签中，必须使用 srclang 来指定语言，此外，track 具有 kind 属性，共有五种。1）subtitles：就是字幕了，不一定是翻译，也可能是补充性说明。2）captions：报幕内容，可能包含演职员表等元信息，适合听障人士或者没有打开声音的人了解音频内容。3）descriptions：视频描述信息，适合视障人士或者没有视频播放功能的终端打开视频时了解视频内容。4）chapters：用于浏览器视频内容。5）metadata：给代码提供的元信息，对普通用户不可见。

一个完整的 video 标签可能会包含多种 track 和多个 source，这些共同构成了一个视频播放所需的全部信息。

### 9.5 audio

接下来我们来讲讲 audio，跟 picture 和 video 两种标签一样，audio 也可以使用 source 元素来指定源文件。我们看一下例子：

```html
<audio controls>
  <source src="song.mp3" type="audio/mpeg">
  <source src="song.ogg" type="audio/ogg">
  <p>You browser does not support audio.</p>
</audio>
```

但比起 video，audio 元素的历史问题并不严重，所以使用 src 也是没有问题的。

### 9.6 iframe

最后我们来讲一下 iframe，这个标签能够嵌入一个完整的网页。不过，在移动端，iframe 受到了相当多的限制，它无法指定大小，里面的内容会被完全平铺到父级页面上。同时很多网页也会通过 http 协议头禁止自己被放入 iframe 中。

iframe 标签也是各种安全问题的重灾区。opener、window.name、甚至 css 的 opacity 都是黑客可以利用的漏洞。因此，在 2019 年，当下这个时间点，任何情况下我都不推荐在实际开发中用以前的 iframe。当然，不推荐使用是一回事，因为没人能保证不遇到历史代码，我们还是应该了解一下 iframe 的基本用法：

```html
<iframe src="http://time.geekbang.org"></iframe>
```

这个例子展示了古典的 iframe 用法。在新标准中，为 iframe 加入了 sandbox 模式和 srcdoc 属性，这样，给 iframe 带来了一定的新场景。我们来看看例子：

```html
<iframe sandbox srcdoc="<p>Yeah, you can see it <a href="/gallery?mode=cover&amp;amp;page=1">in my gallery</a>."></iframe>
```

这个例子中，使用 srcdoc 属性创建了一个新的文档，嵌入在 iframe 中展示，并且使用了 sandbox 来隔离。这样，这个 iframe 就不涉及任何跨域问题了。

## 0210. HTML 小实验：用代码分析 HTML 标准

### 1. 逻辑脉络

完成了一个小实验：利用工具分析 Web 标准文本，来获得元素的信息。通过这个实验，我希望能够传递一种思路，代码能够帮助我们从 Web 标准中挖掘出来很多想要的信息，编写代码的过程，也是更深入理解标准的契机。我们前面的课程中把元素分成了几类来讲解，但是这些分类只能大概地覆盖所有的标签，我设置课程的目标也是讲解标签背后的知识，而非每一种标签的细节。具体每一种标签的属性和细节，可以留给大家自己去整理。这一节课的产出，则是「绝对完整的标签列表」，也是我学习和阅读标准的小技巧，通过代码我们可以从不同的侧面分析标准的内容，挖掘需要注意的点，这是一种非常好的学习方法。

### 2. 摘录及评论

前面的课程中，我们已经讲解了大部分的 HTML 标签。然而，为了突出重点，我们还是会忽略一些标签类型。比如表单类标签和表格类标签，我认为只有少数前端工程师用过，比如我在整个手机淘宝的工作生涯中，一次表格类标签都没有用到，表单类则只用过 input，也只有几次。那么，剩下的标签我们怎么样去了解它们呢？当然是查阅 HTML 标准。由于阅读标准有一定门槛，需要了解一些机制，这节课，我为你设计了一个小实验，用 JavaScript 代码去抽取标准中我们需要的信息。

### 10.1 HTML 标准

我们采用 WHATWG 的 living standard 标准，我们先来看看标准是如何描述一个标签的，这里我们看到，有下面这些内容。

```html
Categories:
    Flow content.
    Phrasing content.
    Embedded content.
    If the element has a controls attribute: Interactive content.
    Palpable content.
Contexts in which this element can be used:
    Where embedded content is expected.
Content model:
    If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
    If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
Tag omission in text/html:
    Neither tag is omissible.
Content attributes:
    Global attributes
    src — Address of the resource
    crossorigin — How the element handles crossorigin requests
    poster — Poster frame to show prior to video playback
    preload — Hints how much buffering the media resource will likely need
    autoplay — Hint that the media resource can be started automatically when the page is loaded
    playsinline — Encourage the user agent to display video content within the element's playback area
    loop — Whether to loop the media resource
    muted — Whether to mute the media resource by default
    controls — Show user agent controls
    width — Horizontal dimension
    height — Vertical dimension
DOM interface:
    [Exposed=Window, HTMLConstructor]
    interface HTMLVideoElement : HTMLMediaElement {
      [CEReactions] attribute unsigned long width;
      [CEReactions] attribute unsigned long height;
      readonly attribute unsigned long videoWidth;
      readonly attribute unsigned long videoHeight;
      [CEReactions] attribute USVString poster;
      [CEReactions] attribute boolean playsInline;
    };
```

我们看到，这里的描述分为 6 个部分，有下面这些内容。1）Categories：标签所属的分类。2）Contexts in which this element can be used：标签能够用在哪里。3）Content model：标签的内容模型。4）Tag omission in text/html：标签是否可以省略。5）Content attributes：内容属性。6）DOM interface：用 WebIDL 定义的元素类型接口。

这一节课，我们关注一下 Categories、Contexts in which this element can be used、Content model 这几个部分。我会带你从标准中抓取数据，做一个小工具，用来检查 X 标签是否能放入 Y 标签内。

### 10.2 代码角度分析 HTML 标准

HTML 标准描述用词非常的严谨，这给我们抓取数据带来了巨大的方便，首先，我们打开单页面版 HTML 标准：[HTML Standard](https://html.spec.whatwg.org/)。在这个页面上，我们执行一下以下代码：

```js
Array.prototype.map.call(document.querySelectorAll(".element"), e=>e.innerText);
```

这样我们就得到了所有元素的定义了，现在有 107 个元素。不过，比较尴尬的是，这些文本中并不包含元素名，我们只好从 id 属性中获取，最后代码类似这样：

```js
var elementDefinations = Array.prototype.map.call(document.querySelectorAll(".element"), e => ({
  text:e.innerText,
  name:e.childNodes[0].childNodes[0].id.match(/the\-([\s\S]+)\-element:/)?RegExp.$1:null}
));
```

1『上面的代码跑出来是 undefined，现在还没能力修正。（2020-04-30）』

接下来我们用代码理解一下这些文本。首先我们来分析一下这些文本，它分成了 6 个部分，而且顺序非常固定，这样，我们可以用 JavaScript 的正则表达式匹配来拆分六个字段。我们这个小实验的目标是计算元素之间的包含关系，因此，我们先关心一下 categories 和 contentModel 两个字段。

```js
for(let defination of elementDefinations) {

  console.log(defination.name + ":")
  let categories = defination.text.match(/Categories:\n([\s\S]+)\nContexts in which this element can be used:/)[1].split("\n");
  for(let category of categories) {
      console.log(category);
  }
    

/*
  let contentModel = defination.text.match(/Content model:\n([\s\S]+)\nTag omission in text\/html:/)[1].split("\n");
  for(let line of contentModel)
    console.log(line);
*/
}
```

接下来我们来处理 category。首先 category 的写法中，最基本的就是直接描述了 category 的句子，我们把这些不带任何条件的 category 先保存起来，然后打印出来其它的描述看看：

```js
for(let defination of elementDefinations) {

  //console.log(defination.name + ":")
  let categories = defination.text.match(/Categories:\n([\s\S]+)\nContexts in which this element can be used:/)[1].split("\n");
  defination.categories = [];
  for(let category of categories) {
    if(category.match(/^([^ ]+) content./))
      defination.categories.push(RegExp.$1);
    else
      console.log(category)  
  }
    

/*
  let contentModel = defination.text.match(/Content model:\n([\s\S]+)\nTag omission in text\/html:/)[1].split("\n");
  for(let line of contentModel)
    console.log(line);
*/
}
```

这里我们要处理的第一个逻辑是带 if 的情况。然后我们来看看剩下的情况：

```js
 None.
 Sectioning root.
 None.
 Sectioning root.
 None.
 Form-associated element.
 Listed and submittable form-associated element.
 None.
 Sectioning root.
 None.
 If the type attribute is not in the Hidden state: Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
 If the type attribute is in the Hidden state: Listed, submittable, resettable, and autocapitalize-inheriting form-associated element.
 Listed, labelable, submittable, and autocapitalize-inheriting form-associated element.
 Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
 None.
 Listed, labelable, submittable, resettable, and autocapitalize-inheriting form-associated element.
 Listed, labelable, resettable, and autocapitalize-inheriting form-associated element.
 Labelable element.
 Sectioning root.
 Listed and autocapitalize-inheriting form-associated element.
 None.
 Sectioning root.
 None.
 Sectioning root.
 Script-supporting element.
```

这里出现了几个概念：None、Sectioning root、Form-associated element、Labelable element、Script-supporting element。如果我们要真正完美地实现元素分类，就必须要在代码中加入正则表达式来解析这些规则，这里作为今天的课后问题，留给你自己完成。接下来我们看看 Content Model，我们照例先处理掉最简单点的部分，就是带分类的内容模型：

```js
for(let defination of elementDefinations) {

  //console.log(defination.name + ":")
  let categories = defination.text.match(/Categories:\n([\s\S]+)\nContexts in which this element can be used:/)[1].split("\n");
  defination.contentModel = [];
  let contentModel = defination.text.match(/Content model:\n([\s\S]+)\nTag omission in text\/html:/)[1].split("\n");
  for(let line of contentModel)
    if(line.match(/^([^ ]+) content./))
      defination.contentModel.push(RegExp.$1);
    else
      console.log(line)
}

```

好了，我们照例看看剩下了什么：

这有点复杂，我们还是把它做一些分类，首先我们过滤掉带 If 的情况、Text 和 Transparent。

```js
for(let defination of elementDefinations) {
  //console.log(defination.name + ":")
  let categories = defination.text.match(/Categories:\n([\s\S]+)\nContexts in which this element can be used:/)[1].split("\n");
  defination.contentModel = [];
  let contentModel = defination.text.match(/Content model:\n([\s\S]+)\nTag omission in text\/html:/)[1].split("\n");
  for(let line of contentModel)
    if(line.match(/([^ ]+) content./))
      defination.contentModel.push(RegExp.$1);
    else if(line.match(/Nothing.|Transparent./));
    else if(line.match(/^Text[\s\S]*.$/));
    else
      console.log(line)
}
```

这时候我们再来执行看看：

```js
A head element followed by a body element.
One or more h1, h2, h3, h4, h5, h6 elements, optionally intermixed with script-supporting elements.
Zero or more li and script-supporting elements.
Either: Zero or more groups each consisting of one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.
Or: One or more div elements, optionally intermixed with script-supporting elements.
If the element is a child of a dl element: one or more dt elements followed by one or more dd elements, optionally intermixed with script-supporting elements.
See prose.
Otherwise: Text, but must match requirements described in prose below.
Zero or more source elements, followed by one img element, optionally intermixed with script-supporting elements.
Zero or more param elements, then, transparent.
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
If the element has a src attribute: zero or more track elements, then transparent, but with no media element descendants.
If the element does not have a src attribute: zero or more source elements, then zero or more track elements, then transparent, but with no media element descendants.
In this order: optionally a caption element, followed by zero or more colgroup elements, followed optionally by a thead element, followed by either zero or more tbody elements or one or more tr elements, followed optionally by a tfoot element, optionally intermixed with one or more script-supporting elements.
If the span attribute is absent: Zero or more col and template elements.
Zero or more tr and script-supporting elements.
Zero or more td, th, and script-supporting elements.
Zero or more option, optgroup, and script-supporting elements.
Or: Zero or more option and script-supporting elements.
Zero or more option and script-supporting elements.
If the element has a label attribute but no value attribute: Text.
If the element has no label attribute and is not a child of a datalist element: Text that is not inter-element whitespace.
If the element has no label attribute and is a child of a datalist element: Text.
When scripting is disabled, in a head element: in any order, zero or more link elements, zero or more style elements, and zero or more meta elements.
When scripting is disabled, not in a head element: transparent, but there must be no noscript element descendants.
Otherwise: text that conforms to the requirements given in the prose.
```

这下剩余的就少多了，我们可以看到，基本上剩下的都是直接描述可用的元素了，如果你愿意，还可以用代码进一步解析，不过如果是我的话，会选择手工把它们写成 JSON 了，毕竟只有三十多行文本。好了，有了 contentModel 和 category，我们要检查某一元素是否可以作为另一元素的子元素，就可以判断一下两边是否匹配啦，首先，我们要做个索引：

```js
function check(parent, child) {
  for(let category of child.categories)
    if(parent.contentModel.categories.conatains(category))
      return true;
  if(parent.contentModel.names.conatains(child.name))
      return true;
  return false;
}
```

### 黑板墙

这种「通过简单的文本分析，快速提炼出自己感兴趣的部分」的方法是非常值得借鉴的，我平时也会用这种方法去网页中做一些快速的统计和信息筛选。不过，通过这样的文本分析去完成一个「检查一个元素是否能够放置在另一个元素内部」的小程序还是有点「把问题复杂化」的感觉（尽管这个过程中也可以锻炼一些能力），况且文档是会更新的，指不定有一天那些 check 分支就 hold 不住新的 case 了。

在我看来，如果想知道 A 元素是否可以放在 B 元素中，只要把所有元素的 categories 和 contentModel 提取出来，筛选出 A 元素的 categories 和 B 元素的 contentModel，再去阅读比较就可以了（当然你还要对标准中的一些术语有所了解，所幸的是这些术语都有超链接指向定义，所以还是比较方便的）。