## 记忆时间

## 卡片

### 0101. 主题卡 —— 思考框架：现状、目标和实施路径

你以为的「终」可能不是终，因为你只是站在自己的角度；你以为自己做了任务分解，在我看来，可能还不够，因为我希望你能够做到微操作；你以为的沟通反馈就是说话聊天，我想告诉你很多技术实践的存在也是为了沟通反馈；你以为自动化就是写代码，我会告诉你，有时候不写代码而解决问题，可能才是一个好方案。

先看一个场景：当一个产品经理给我交代一个要开发的功能特性时，我通常会问他这样一些问题：1）为什么要做这个特性，它会给用户带来怎样的价值？2）什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？3）达成这个目的是否有其它手段？是不是一定要开发一个系统？4）这个特性上线之后，怎么衡量它的有效性？

如果产品经理能够回答好这些问题，说明他基本上已经把这个工作想得比较清楚了，这个时候，我才会放心地去了解后续的细节。我们用思考框架对照一下，为什么我会问这些问题。一般来说，一个新特性要开发时，现状我是知道的。所以，我更关心目标，这里「为什么要做这个特性？」就是在问目标，「给用户带来怎样的价值」是在确定这个目标的有效性。接下来，我会关注实现路径，用户会怎么用，是否有其他的替代手段，我需要了解产品经理的设计是经过思考的，还是「拍着脑袋」给出的。衡量有效性，则是要保证我的工作不会被浪费。

通过这个例子，给你展示了怎么用这个思考框架提出问题。但我估计你更想了解的是，我怎么会想到问这些问题。给出思考框架是为了让你明白为什么要提出问题，而具体问题要怎么问，就可以遵循下面这四项原则：以终为始；任务分解；沟通反馈；自动化。这是从思考框架延伸出来的。

这四个原则互相配合，形成了一个对事情的衡量标准。总体上可以保证我的工作是有效的，在明确目标和完成目标的过程中，都可以尽量减少偶然复杂度。怎么把这四个原则用在工作中呢？

回过头来看一下前面的场景，产品经理把要做的功能特性摆在我面前。站在以终为始的角度，我需要了解真正的目标是什么，所以，我会关心为什么要做这个特性。为了保证目标是有效的，我会关心它给用户带来的价值。有了任务分解的视角，我需要将一个大的目标进行拆解，如果我要达成这个目标，整体解决方案是远远不够的，我需要把任务分解成一个一个小的部分。所以，我会关心一个一个具体的使用场景。一方面，我会了解到更多的细节，另一方面，当时间紧迫的时候，我会和产品经理来谈谈究竟优先实现哪个场景。

为什么要学会沟通反馈？因为我需要明确，自己是否真正理解了产品经理提交的需求。所以，我要不断地问问题，确保自己的理解和产品经理交代的内容一致。另外，我也需要保证我的产品做出来确实能够达到目标。所以，我会关心它上线后的衡量手段。因为我知道，这个行业里有太多代码上线后，从来没有运行过。自动化的角度很有意思，我们做的方案通常是一个自动化方案，但我们需要了解这个方案没有自动化之前是怎么做的。如果不自动化，用户会怎么用。所以，我会关心是不是还有其它替换方案，比如，买一个现成的服务。因为很多需求的提出，只是因为我们有了一个开发团队而已。

1、以终为始，确定好真实目标。以终为始就是在工作的一开始就确定好自己的目标。我们需要看到的是真正的目标，而不是把别人交代给我们的工作当作目标。你可以看出这个原则是在帮助我们回答思考框架中，Where are we going?（我们要到哪儿去？）这个问题。

2、任务分解，找到实施路径。任务分解是将大目标拆分成一个一个可行的执行任务，工作分解得越细致，我们便越能更好地掌控工作，它是帮助我们回答思维框架中，How can we get there?（我们如何到达那里？）的问题。如果说前两个原则是要在动手之前做的分析，那后面两个原则就是在通往目标的道路上，为我们保驾护航，因为在实际工作中，我们少不了与人和机器打交道。

3、沟通反馈，解决与人打交道的问题。沟通反馈是为了疏通与其他人交互的渠道。一方面，我们保证信息能够传达出去，减少因为理解偏差造成的工作疏漏；另一方面，也要保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步。

4、自动化，解决与机器打交道的问题。自动化就是将繁琐的工作通过自动化的方式交给机器执行，这是我们程序员本职工作的一部分，我们擅长的是为其他人打造自动化的服务，但自己的工作却应用得不够，这也是我们工作中最值得优化的部分。

四原则是起点（现状）、终点（目标）、路径思考框架的衍生品。

### 0102. 主题卡 —— 编程的基本框架

基本框架是重构思维加测试思维加面向对象思维。要去看的书有：《重构》、《测试驱动开发》、《修改代码的艺术》、《代码整洁之道》、《架构整洁之道》（面向对象相关）。

### 0103. 主题卡 —— 有效工作

有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。我曾经在一个大公司做咨询，按照他们的统计，线上 60% 的代码从来没有运行过。我们都知道，一多半的代码增加的可不只是一多半的工作量，团队可能需要的是几倍甚至几十倍的心力去维护它。如何有效工作：1）拓展自己的上下文，看到真正的目标，更好地对准靶子，比如，多了解用户，才不至于做错了方向；站在公司的层面上，才知道哪个任务优先级更高；站在行业的角度，而不局限于只在公司内成为高手，等等。2）去掉不必要的内容，减少浪费，比如，花时间分析需求，不做非必要的功能；花时间做好领域设计，别围着特定技术打转；花时间做好自动化，把精力集中在编码上，等等。

要想有效工作，有两点非常重要。一方面，意识上要注意自己工作中无效的部分。这就像一个开关，拨过去就好了。所以，读这个专栏有人常有恍然大悟的感觉，也有人觉得很简单。很多时候，你只是不知道，就像我在专栏中提到，要问产品经理问题，这是很多人没想过的。每篇文章后面的那一句总结，就是这样的开关，拨过去就好。另一方面，要构建自己关于软件开发的知识体系，这是要花时间积累的。在这个专栏中，我给你讲了很多最佳实践，就是让你知道，在某些方面，有人已经做得很好了，花时间学习，比自己从头摸索好很多。这就像所有的数学公式一样，理论上你都可以自行推导，但肯定不如从教科书上学得快。

### 0201. 术语卡 —— 本质复杂度和偶然复杂度

概念来自《人月神话》，已存入书籍「2019655人月神话」。

本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）。本质复杂度是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。比如你要做一个网站，网站的内容是你无论如何都要写的，这是「本质复杂度」。而如果今天你还在用汇编写一个网站，效率是不可能高起来的，因为你选错了工具。这类选错方法或工具而引发的问题就是「偶然复杂度」。

### 0202. 术语卡 —— 算法复杂度差异的本质

排序算法：插入排序、冒泡排序、归并排序、堆排序、快速排序等等。各个算法有其复杂度，比如，插入排序是 O (n^2），快速排序平均情况下是 O (nlogn）等等。你有没有想过一个问题，不同算法的复杂度本质差别到底是什么呢？我们就以插入排序和快速排序为例，为什么快速排序要比插入排序快呢？

答案：因为做比较的次数少。为什么同样的排序，比较次数会有差异呢？因为插入排序每次循环只关注当前的目标，循环之间没有关系，而快速排序在做不同划分时，上一次的结果对下一次有助力，因此它省下了不少的比较次数。

明白了这个道理，再来看所谓的算法优化，其实就是尽可能利用已知的信息，少做不必要的事。再来看一个常见的面试题，给你一堆数，找出前 100 个。很多人直觉就会想到排序，然后选出前 100 个。这种做法固然可行，但一定是做多了，因为这里需要的是找出前 100 个数，而不是要 100 个有序的数字，更不是要所有的数都有序。说到这里，你就知道了，只要把数据划分开就好，并不需要排序，如果划分点不是第 100 个元素，就向着 100 所在的方向继续划分就好。计算机是最擅长处理繁琐重复工作的，即便如此，我们依然要做算法优化，原因是当数据规模大到一定程度时，不同复杂度的算法差别就非常明显了。算法没用好，计算机硬件再好，也是徒劳的。

### 0203. 术语卡 —— 微服务

### 0204. 术语卡 —— DDD

### 0301. 人名卡 —— 人月神话的作者

人月神话的作者。

## 0000. 发刊词

软件行业里有一本名著叫《人月神话》，其中提到两个非常重要的概念：本质复杂度（Essential Complexity）和偶然复杂度（Accident Complexity）。简单来说，本质复杂度就是解决一个问题时，无论怎么做都必须要做的事，而偶然复杂度是因为选用的做事方法不当，而导致要多做的事。比如你要做一个网站，网站的内容是你无论如何都要写的，这就是「本质复杂度」。而如果今天你还在用汇编写一个网站，效率是不可能高起来的，因为你选错了工具。这类选错方法或工具而引发的问题就是「偶然复杂度」。

作为一个在软件行业奋斗了近二十年的程序员，我深刻意识到一个遗憾的事实：大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。换句话说，只要选择了正确的做事方法，减少偶然复杂度带来的工作量，软件开发是可以有条不紊进行的。如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行，这正是我希望通过这个专栏帮你解决的问题。

许多人工作做事主要依靠直觉，在这个科学越发昌明的时代，我们清楚地看到，人类的直觉常常是错的，就像古人凭直觉认为大地是平的一样。软件开发也不例外，如果你不曾在做软件这件事上有过学习和思考，形成一套高效的工作方法，只是凭直觉行事，在真实世界中往往会举步维艰。

幸运的是，总会有不同的人在不同的方向上探索不同的做法，一旦通过真实世界的验证，就会沉淀出可供行业直接应用的最佳实践（Best Practice）。在软件行业中，这样能够提升工作效率的最佳实践已经有很多，但是，学习掌握这些最佳实践是有难度的，其根源就在于，很难找到这些实践彼此间的内在联系。直觉大多是错误的，最佳实践又多而琐碎，所以在这个专栏中，我会尝试给你提供一个思考框架，帮你在遇到问题时梳理自己真正要做的事情。围绕着这个框架，我还会给你一些原则。

这些原则，是我从软件行业的诸多软件开发最佳实践中总结出来的，也是我如今在工作中所坚持的。这些原则就是一条主线，将各种最佳实践贯穿起来。这些原则不多，总结起来就四个：1）以终为始；2）任务分解；3）沟通反馈；4）自动化。也许看到这四个原则的名字，你会不以为然，这些说法你在很多地方都看到过，但我想与你分享的内容可能与你想的并不完全一致。比如：你以为的「终」可能不是终，因为你只是站在自己的角度；你以为自己做了任务分解，在我看来，可能还不够，因为我希望你能够做到微操作；你以为的沟通反馈就是说话聊天，我想告诉你很多技术实践的存在也是为了沟通反馈；你以为自动化就是写代码，我会告诉你，有时候不写代码而解决问题，可能才是一个好方案。

2『又可以固化一个思维模型了，将四原则收录进个人模型里。』

在我看来，想要将精力聚焦在本质复杂度上，提高工作效率，摆脱直觉的束缚，只要掌握上面的四个原则就可以了。或许你此时会问，这些原则很难吧？其实并不难，在探讨这个专栏的内容时，我的编辑作为软件开发的局外人，经常发出感叹：「这事真的就这么简单吗？这不就是正常做事应该有的逻辑吗？」是的，就是这样简单，但大多数人没有这样做，因为这些原则在实际工作中很可能是反直觉的。只要打破思维误区，你的整个人都会变得不一样。

当我们详谈这些原则时，我会给你讲述一些最佳实践，让你看到这些原则是如何应用于不同的实践中的。希望我对这些实践的理解成为你的知识地图，让你拥有继续探索的方向。我做这个专栏的原则是「授人以鱼，不如授人以渔」。我希望你很好地理解这些原则，掌握高效工作的方法。至于最佳实践，你可以自行决定，是直接采纳还是曲线救国更为合适。

### 黑板墙

直觉在某种程度上也是很重要的吧，不是很多专家都是很依赖直觉的么。作者回复：这是一个好问题，这种说法混淆了直觉和洞见两件事。直觉是本能的，无需积累，而洞见是溯因推理（Abductive Reasoning），需要前期进行大量的积累之后，从中发现模式，方能形成洞见。打个比方，同样的思念，可以说，衣带渐宽终不悔，为伊消得人憔悴，也可以说，我想死你了。二者看上去差不多，但境界有差异。

购买了课程，学完了目前更新过的所有课程，除了测试这块，比较难推动，其他的基本都原来都践行，或者正在准备在落实。非常有用的课程，个人觉得，比看 JAVA 或者微服务的一个专栏，更容易学进去，也更有直接的收获，也更迫切需要。技术类课程到处都是，不花钱也可以找到，但是对于程序员的效率提升，整体能力的提升的课程较少，我之前也是一直觉得程序员就是写代码，但是新公司半年的加班告诉我，写代码成本太高，客户，产品经理一句话就可能让你多加几天班，但做出的功能却在业务上并未带来多少意义。我们不是执行指令的机器，也讨厌客户说的那句，你们只管写代码就好了，不要总是提什么拆分任务评估工时，跟她讲条件。按刘慈欣整理定律的方式来整理客户和开发的经验：1）甲方永远觉得付了钱，让乙方多干活也理所当然。2）开发时间是比较难评估的，一定要预留缓冲时间，即使多出来时间，也可以用来优化。3）技术是硬知识，独立思考和沟通，个人管理与项目管理是软知识，软知识是我所欠缺的，有更好的软知识可以事半功倍，可以处理各个上下文的问题。还有最直接的，把甲方拍大腿想的需求推掉，至少晚上更有时间去学习那些技术。作者回复：我希望专栏的读者在学过之后，遇到事情开始动脑想想为什么和怎么做，你的回复让我觉得我的初衷达成了。

对于一个明确的技术点，优秀的程序员仿佛能更快的找到解决方案，而且往往就是最佳实践，这是什么原因？从技术点角度讲，它并不需要掌握其他相关知识。作者回复：你把结果当成了原因，优秀的程序员能够快速解决问题，是因为它已经做了大量积累，有自己的知识体系，任何领域想做到一定的水准都需要刻意练习，而且是大量的刻意练习。刻意练习，是一个重要的概念，我本打算在这个专栏里讲一下，后来由于主题的关系，暂时拿掉了。

## 0001十倍程序员是如何思考的.md

大多数人工作低效是由于工作中偶然复杂度太多造成的，只要能够更多地将注意力放到本质复杂度上，减少偶然复杂度造成的消耗，我们「真实」的工作效率自然会得到大幅度提升。而想要减少偶然复杂度的消耗，就要了解一些高效的工作方式和行业的最佳实践，而这一切是可以用统一的框架进行思考的。运用这个思考框架，我们需要问自己一些问题：1）Where are we?（我们现在在哪？）2）Where are we going?（我们要到哪儿去？）3）How can we get there?（我们如何到达那里？）为了把这个框架应用在我们程序员的工作中，我给了你四个思考原则：1）以终为始，确定好真实目标；2）任务分解，找到实施路径；3）沟通反馈，解决与人打交道出现的问题；4）自动化，解决与机器打交道出现的问题。面对问题时，用思考框架问问自己，现状、目标和路径。

### 1.1 一个思考框架

我曾经组织过针对应届毕业生的培训，第一堂课我往往亲自操刀，其中有一个头脑风暴的环节「畅想未来」，我会让大家思考三个问题：1）我现在是个什么水平？2）我想达到一个什么水平？3）我将怎样到达那个目标？大家会围绕着这三个问题，从各种角度展开讨论。这是一个有趣的练习，你会发现大家「最擅长」的是回答第一个问题：我现在处于什么水平？和有经验的人相比，他们大多自认为比较「菜」。但对于后两个问题的讨论，却可以切实看出人和人之间处理问题的能力差异。有人通过之前的资料搜集，已经对自己的未来有了一个打算。比如想成为一个研发大牛，或者想做一个开源软件等，也就是说，对于第二个问题，他有明确的答案。而有的人则是一脸茫然，他很可能根本没有考虑过这个问题。而从题目本身来看，目标相对清晰的同学，才会进入到第三个问题，而茫然的同学，则完全无从下手。

那么我为什么会问这几个问题呢？我是想让大家跳出现有的思考模式，摆脱仅凭直觉「闷头做事」的习惯方式，把低着的头抬起来，看一眼未来，给自己找一个方向。否则，如果你对未来没有定位，是茫然的，尽管你也知道要努力，但劲儿该往哪里使呢？如果使劲的方向不对，那么你越使劲儿，可能会在错误的路上跑得越远。南辕北辙的道理大家都懂，但具体到自己的工作和发展上，真正能体会并实践的却是少数。其实，这三个问题来自一个思考框架。在给其他公司团队做咨询时，我也经常会运用到它，原来的问题是：1）Where are we?（我们现在在哪？）2）Where are we going?（我们要到哪儿去？）3）How can we get there?（我们如何到达那里？）

这三个问题实际上是帮我们确定：现状；目标；实现路径。如果一个人能够清晰地回答出这三个问题，通常意味着他对要做的事有着清晰的认识。这个框架虽然看似简单，但却非常有效，它已经成为我工具箱里一件非常称手的思考工具。在我的职业生涯里，与很多人讨论不同的事时，我都会用到这个思考框架的不同变体，而在这个专栏里，我也会用它来帮助回答「怎样高效工作、怎样做好软件」这件事。

### 1.2 四个思考原则

在实际的工作中，这个思考框架会帮助我更好地了解自己的工作。比如，当一个产品经理给我交代一个要开发的功能特性时，我通常会问他这样一些问题：1）为什么要做这个特性，它会给用户带来怎样的价值？2）什么样的用户会用到这个特性，他们在什么场景下使用，他们又会怎样使用它？3）达成这个目的是否有其它手段？是不是一定要开发一个系统？4）这个特性上线之后，怎么衡量它的有效性？

如果产品经理能够回答好这些问题，说明他基本上已经把这个工作想得比较清楚了，这个时候，我才会放心地去了解后续的细节。我们用思考框架对照一下，为什么我会问这些问题。一般来说，一个新特性要开发时，现状我是知道的。所以，我更关心目标，这里「为什么要做这个特性？」就是在问目标，「给用户带来怎样的价值」是在确定这个目标的有效性。接下来，我会关注实现路径，用户会怎么用，是否有其他的替代手段，我需要了解产品经理的设计是经过思考的，还是「拍着脑袋」给出的。衡量有效性，则是要保证我的工作不会被浪费。

通过这个例子，我给你展示了怎么用这个思考框架提出问题。但我估计你更想了解的是，我怎么会想到问这些问题。给出思考框架是为了让你明白为什么要提出问题，而具体问题要怎么问，就可以遵循下面这四项原则：以终为始；任务分解；沟通反馈；自动化。这是我从思考框架延伸出来的。在这个专栏里，我会围绕这四项原则和你详细讨论。

解释一下，1）以终为始就是在工作的一开始就确定好自己的目标。我们需要看到的是真正的目标，而不是把别人交代给我们的工作当作目标。你可以看出这个原则是在帮助我们回答思考框架中，Where are we going?（我们要到哪儿去？）这个问题。2）任务分解是将大目标拆分成一个一个可行的执行任务，工作分解得越细致，我们便越能更好地掌控工作，它是帮助我们回答思维框架中，How can we get there?（我们如何到达那里？）的问题。如果说前两个原则是要在动手之前做的分析，那后面两个原则就是在通往目标的道路上，为我们保驾护航，因为在实际工作中，我们少不了与人和机器打交道。3）沟通反馈是为了疏通与其他人交互的渠道。一方面，我们保证信息能够传达出去，减少因为理解偏差造成的工作疏漏；另一方面，也要保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步。4）自动化就是将繁琐的工作通过自动化的方式交给机器执行，这是我们程序员本职工作的一部分，我们擅长的是为其他人打造自动化的服务，但自己的工作却应用得不够，这也是我们工作中最值得优化的部分。

这四个原则互相配合，形成了一个对事情的衡量标准。总体上可以保证我的工作是有效的，在明确目标和完成目标的过程中，都可以尽量减少偶然复杂度。怎么把这四个原则用在工作中呢？我们回过头来看一下前面的场景，产品经理把要做的功能特性摆在我面前。站在以终为始的角度，我需要了解真正的目标是什么，所以，我会关心为什么要做这个特性。为了保证目标是有效的，我会关心它给用户带来的价值。有了任务分解的视角，我需要将一个大的目标进行拆解，如果我要达成这个目标，整体解决方案是远远不够的，我需要把任务分解成一个一个小的部分。所以，我会关心一个一个具体的使用场景。一方面，我会了解到更多的细节，另一方面，当时间紧迫的时候，我会和产品经理来谈谈究竟优先实现哪个场景。

为什么要学会沟通反馈？因为我需要明确，自己是否真正理解了产品经理提交的需求。所以，我要不断地问问题，确保自己的理解和产品经理交代的内容一致。另外，我也需要保证我的产品做出来确实能够达到目标。所以，我会关心它上线后的衡量手段。因为我知道，这个行业里有太多代码上线后，从来没有运行过。自动化的角度很有意思，我们做的方案通常是一个自动化方案，但我们需要了解这个方案没有自动化之前是怎么做的。如果不自动化，用户会怎么用。所以，我会关心是不是还有其它替换方案，比如，买一个现成的服务。因为很多需求的提出，只是因为我们有了一个开发团队而已。

好，现在你已经对这四个原则在工作中的应用有了一个直观的认识。但你也会发现，我问的这些问题似乎已经「超纲」了，超过了一个普通程序员应该关注的范围。但这就是真实世界，它不像考试一样，有一个标准答案。我们不是一个人孤独地在工作，而是与其他人在协作，想要做到高效工作，我们就要「抬起头」来，跳出写代码这件事本身。所以，我在开篇词里说，程序员解决的问题，大多不是程序问题。可能你对这些原则的了解还没过瘾，没关系，这篇文章只是让大家清晰地了解思考框架和原则的背后逻辑。接下来，我会结合行业里的最佳实践，给你进一步讲解这些原则和具体应用。

### 黑板墙

现状：勉强的架构师、技术管理。目标：架构师、cto。途径：1）理论加强学习：togaf 学习理论。2）实践技能应用： netty、redis、mysql、niginx、微服务架构、分布式架构。3）做微信公众号，多思考多积累经验，形成自己的套路，同时形成影响力。

思考框架是道，原则是演化下的术，我们从 A → B，有无穷无尽的路径，最有效的唯有那条直线。本质上，各个维度、原则（不限于作者提到的四项原则）都是帮助我们更好地定位 A 在哪里，B 在哪里，那条直线在哪里。这个思考工具算是吸收了，四项原则也是有借鉴意义。

x-y 问题描述的就是错把手段当目的的没有以终为始的一个典型反例。解决问题第一步就是定义问题，知道自己要解决的问题的实质。爱因斯坦的名言说要解决问题的大部分时间应该拿来弄清问题本质。不过他指的解决问题应该只包含找到解决方案这部分，不包含具体实施。知道了问题的实质之后开始拆解问题，进行任务分解。通常，弄清问题本质和任务拆解是一体的，分不太开。关于任务分解，也就是找出解决方案，学问就大了。其中涉及各种思考框架，包括通用的如金字塔原理，各种领域套路，4c3p。这部分就需要学习工作中常常总结了。沟通反馈透露出控制论的思想。在行动中根据反馈不断调整自己的行动。自动化，在程序员这一职业中更加长见，程序员本身做的事情就是在帮助别人自动化。而自己的工作也不能忘了自动化。从软件的整个生命周期中，大量存在各种使用的工具。不过不能停留在学习这些工具的使用上，而是应该追问这些工具出现的原因，而自己的工作中有哪些工作是可以使用工具帮忙完成的。

老师的建议和指导都是非常有效，而且「感觉非常可行」，可是实际现实的情况，却有太多意外，我个人曾经在某银行的外包团队中，协同开发一个商户 —— 收银以及集成了各种第三方的团队的接口等等，这个大项目大概有 300 人以上，由此我的 leader 不在，我代表开会，足足开了 3-4 个小时 (约 30 个 leader)。杂乱无章，从我个人开发角度无法去高屋建瓴的把握全局应用场景，使用价值之类的。但是每个模块之间互相调用联系，系统升级需要协作。首先，这里沟通成本很高，最要命的是需求变动，无法预测，有的时候新增需求，技术 leader 直接告诉我在什么地方写一个 action，调用一个方法之类的。基本就是码农搬砖之类的，我想提的建议是：希望老师在有丰富理论知识，能给我们有一些实践中的例子，或者列举一些举一反三的例子，理论 + 实践，我觉得才是最佳法则 (没有说老师只是有实际，没有实践，莫怪）。作者回复：你的情况就是工作的上下文不足，这种情况你会很纠结，需要扩大自己的工作上下文，了解更多东西。这个话题后面会讲到。

一个职业发展思考框架：车日路模型。车，指的是你自己，你对自己的马力底盘是否了解？你有什么不足，哪些地方需要提高？你的动力来自于哪里？你要如何长期维持你的动力？路，指的是你到达目的地的要走的路径。你知道你要如何到达吗？你要如何做步骤分解？日，就是指你最终要达到的目标。你长期目标，比如五年计划是什么？短期目标，一两年内要达到什么地方？你最重要的目标是什么？车日路对应着就是自我、目标和路径。

自己看到自己的提问，现在可以用自己领悟到的答案回答自己的问题，扩大自己的上下文，有效的沟通反馈，敢于对于无效的需求说不，减少偶然复杂读，尽量少做无用功，以前总有种感觉是，给别人打工的感觉（叫做什么就得去做，感觉自己没什么反抗的或者反驳的余力，沟通反馈也是谨小慎微，说的多是是是，好好好之类的，然后就是埋头苦干）工作是别给别人打工是没错的，可是改不改做，怎么做作为一个开发人员还是可以以技术实现或者用户体验等等不同方式去考虑，也可以给出建设性意见，做到积极有效的反馈，做积极有效的需求，对个人和团队都是极为有利的。

## 0002结束语少做事才能更有效地工作.md

在这个专栏里，我讲过很多东西，几乎涉及到软件开发的方方面面，但有一个重要的方面，我却从来没有说过，那就是算法。因为我一直把它当做不言而喻的基本功，认为每个程序员都应该掌握。

### 2.1 算法的差异

排序算法是每个程序员都会学到的内容，大家对各种算法也是如数家珍：插入排序、冒泡排序、归并排序、堆排序、快速排序等等。我们也知道各个算法的复杂度，比如，插入排序是 O (n^2），快速排序平均情况下是 O (nlogn）等等。你有没有想过一个问题，不同算法的复杂度本质差别到底是什么呢？我们就以插入排序和快速排序为例，为什么快速排序要比插入排序快呢？我不打算做算法分析，直接公布答案：因为做比较的次数少。为什么同样的排序，比较次数会有差异呢？因为插入排序每次循环只关注当前的目标，循环之间没有关系，而快速排序在做不同划分时，上一次的结果对下一次有助力，因此它省下了不少的比较次数。

明白了这个道理，再来看所谓的算法优化，其实就是尽可能利用已知的信息，少做不必要的事。再来看一个常见的面试题，给你一堆数，找出前 100 个。很多人直觉就会想到排序，然后选出前 100 个。这种做法固然可行，但一定是做多了，因为这里需要的是找出前 100 个数，而不是要 100 个有序的数字，更不是要所有的数都有序。说到这里，你就知道了，只要把数据划分开就好，并不需要排序，如果划分点不是第 100 个元素，就向着 100 所在的方向继续划分就好。计算机是最擅长处理繁琐重复工作的，即便如此，我们依然要做算法优化，原因是当数据规模大到一定程度时，不同复杂度的算法差别就非常明显了。算法没用好，计算机硬件再好，也是徒劳的。有一则《计算机程序设计艺术》作者高德纳（Donald Knuth）的轶事，他年轻时参加算法大赛，用最差的系统击败了诸多对手，拿到算法执行效率的冠军，凭借的就是其强大的算法优化功力。对于计算机，算法尚且如此重要，我们面对工作时何尝不是如此呢！

2『已下载书籍「2020007计算机程序设计艺术1-3」。』

### 2.2 有效工作

《10x 程序员工作法》，也许有的同学最初看到这个标题就急急加入了，以为会从这个专栏中学习到一些「以一抵十」的编程技法，对不起，我彻底让你失望了。我非但没讲太多编程的技法，甚至还从各种角度劝你少写代码：无论是向产品经理提问题，还是让你在前面多考虑设计。难道不是做得越多才越高效吗？插入排序并不会因为干的活多，就比快速排序得到更高的评价，因为它们比的是谁排得快。工作效率高，不是因为代码写得多，而是有效工作做得多。如果 CPU 都被无效指令占据了，哪有时间执行有效指令呢？即使你很忙碌，但工作进展依然是收效甚微，因为无效工作占据了你太多的大脑，让你不能聚焦在正经事上，当然就是效率不高了。

其实，这个专栏的内容在我脑子里已经盘旋很多年了。不过，即便在专栏筹备期，我已经备了很多篇稿子之后，我依然没有找到一个准确的说法能够描绘内心的想法。我想过「程序员的职业素养」，但似乎这会让专栏朝着职场行动指南的方向努力；我想过「高效工作」，但实际上我也不打算讨论那些工作技巧。直到上线日期临近，我的编辑实在受不了我的拖延，坐下来与我交流了很久，我才终于找到了内心的那个词：有效。

我在这个专栏真正探讨的主题是，有效工作。有效工作，需要我们把力量聚焦到正确的地方，做本质复杂度（Essential Complexity）的事情，少做无意义的事情。我曾经在一个大公司做咨询，按照他们的统计，线上 60% 的代码从来没有运行过。我们都知道，一多半的代码增加的可不只是一多半的工作量，团队可能需要的是几倍甚至几十倍的心力去维护它。当然，有效工作最终没有成为这个专栏的名字，而用了更有个性的《10x 程序员工作法》。这个名字也不错，因为在我看来，很多程序员做的是负功，比如，写那 60% 代码的程序员。只要能做到有效工作，效率自然会高出业界平均水平很多。

怎么才能有效工作呢？我在专栏中已经给你讲了很多，小结一下就是：1）拓展自己的上下文，看到真正的目标，更好地对准靶子，比如，多了解用户，才不至于做错了方向；站在公司的层面上，才知道哪个任务优先级更高；站在行业的角度，而不局限于只在公司内成为高手，等等。2）去掉不必要的内容，减少浪费，比如，花时间分析需求，不做非必要的功能；花时间做好领域设计，别围着特定技术打转；花时间做好自动化，把精力集中在编码上，等等。

要想有效工作，有两点非常重要。一方面，意识上要注意自己工作中无效的部分。这就像一个开关，拨过去就好了。所以，读这个专栏有人常有恍然大悟的感觉，也有人觉得很简单。很多时候，你只是不知道，就像我在专栏中提到，要问产品经理问题，这是很多人没想过的。每篇文章后面的那一句总结，就是这样的开关，拨过去就好。另一方面，要构建自己关于软件开发的知识体系，这是要花时间积累的。在这个专栏中，我给你讲了很多最佳实践，就是让你知道，在某些方面，有人已经做得很好了，花时间学习，比自己从头摸索好很多。这就像所有的数学公式一样，理论上你都可以自行推导，但肯定不如从教科书上学得快。

### 2.3 藏经阁目录

虽然我讲了这么多内容，但实际上，因为篇幅的关系，这只是冰山一角。其实，我给你讲的这部分内容并不是具体的知识，而是告诉了你哪些东西要去学习，给了你一张学习地图，把各种知识贯串了起来。我曾与朋友打趣道，我的专栏实际上是藏经阁的目录，真正的经书还要等你自己去参悟。只不过，有一个人把这些经书之间的知识连接给你补齐了。这些连接恰恰是在学习相关内容时，让我苦思冥想许久的。大约一年前（2018 年 4 月），极客时间编辑找到我，问我是否有兴趣在极客时间开个专栏，作为「得到」重度用户的我，一直对知识服务很感兴趣。有这样的机会让我体验，我当然想试试，甚至最初给自己定下了写 100 篇的宏伟计划。

真正开始写，我才知道，在繁忙的日常工作之余，坚持写作还是一件很有挑战的事，今天看来，100 篇的目标显得那么无知无畏。不过，也正是因为压缩到一半左右的篇幅，在专栏后面的部分，我才极大地提高了知识密度，比如，微服务和 DDD，这两个可以分别写成一个系列内容的话题，我用一篇文章就将其精华和知识脉络提炼呈现了出来。因为我想尽我所能，帮助大家构建起一个软件开发的知识体系，让你在未来遇到问题时，知道可以在哪个方面进一步加强。希望这个专栏真的起到帮你理清思路，答疑解惑的作用。

还记得我在开篇词中的最后一段话吗？也许在这个专栏的最后，你发现自己并不认同我的原则，却能够用自己的原则来与我探讨，那么，恭喜你，因为那是最美妙的事情！不知道你是否形成了自己的原则呢？因为它代表着你已经形成了自己的知识体系。与我讲了些什么相比，你学到了什么才是一件更重要的事。希望在学习了这个专栏之后，你可以用自己的工作原则做更多本质复杂度的事情，减少无意义的时间消耗。

其实，这个专栏的最大收益人是我自己，感谢这次的专栏之旅，我终于强行治疗了我的拖延症，把自己对于有效工作的思考完整地整理了出来，那些在脑子里模糊的印象现在终于有了一个完整的体系。这个体系就是我在专栏里提到的工作原则，现在我可以更好地表达自己的想法了。不过，这个专栏于我而言也是有遗憾的。因为我想表达的内容很多，给大家打开更多大门的同时，也给很多同学留下了更多的疑问。有些同学期待在某个方面再深入细节地讲一下，比如，DDD，那可是值得再写一个专栏的主题。限于这个专栏的主题和篇幅关系，我没办法深入展开，只能对大家说声抱歉了。

### 黑板墙

一段历程结束也是另一段历程的开始。最近又完成了 typescript 协议生成，提高了客户端的开发效率，自动化算是又进了一步。结束语中您关于算法本质让我耳目一新，仔细一想确实如此，除了排序算法，字符串匹配中的 KMP 也是这样的。

当前云计算越来越成熟，云服务商提供了更好用的软件基础设施，可以预见这个行业对普通程序员的需求会越来越少，那么我们应该如何应对云计算带来的冲击呢？作者回复：云计算是简化了业务开发的过程，让程序员更多的把注意力放在业务上，这是好事情，未来的工作机会会增多。再者，回顾一下我在 40 那篇文章中提到的观点，先别焦虑，多考虑一下怎么让自己成长。

## 0003总复习重新来看书.md

制作了一个豆列（[10x 程序员工作法](https://www.douban.com/doulist/113366760/)），方便你去找到这些书。

1、编码实践。如果你想详细学习如何写好代码，我推荐你去读 Robert Martin 的《代码整洁之道》（Clean Code），这本书几乎覆盖了如何把代码写好的方方面面。《实现模式》是一本关于如何写好代码的书，更具体一点是，编写别人能够理解的代码。它的作者 Kent Beck 是许多软件开发实践的开创者。但 Kent Beck 的写作能力一般，他的很多作品被埋没了。只有细细品味，才能体会到 Kent Beck 深厚的功力。我提升自己编码水平的理解是从《程序设计实践》（The Practice of Programming）这本书开始的，这本书的作者是 Brian Kernighan 和 Rob Pike，这两个人都出身于大名鼎鼎的贝尔实验室，参与过 Unix 的开发。如果你想从日常开发中提升自己的效率，可以读一下《卓有成效的程序员》。假如你不曾思考过这个问题，这本书会让看到一些不同的工作方式，我也给这本书写过一篇书评。不过，这本书里的技巧太具体了，所以，有一些已经有些过时了。

2、设计。SOLID 原则是一种面向对象软件设计原则。早在 1995 年，Robert Martin 就提出了这些设计原则的雏形，然后在他的《敏捷软件开发：原则、实践与模式》这本书中，比较完整地阐述了这五个原则，后来，他有把这些原则进一步整理，成了今天的「SOLID」。有了设计原则做基础，这本书后面讲了设计模式，理解起来就容易多了。虽然书名是关于敏捷的，但这是一本讲设计的书。设计和架构有什么区别？2017 年，Robert Martin 出版了《架构整洁之道》（Clean Architecture），他在其中告诉我们，二者没有区别。所以，这也是一本关于设计的书，给出了 Robert Martin 对设计的最新理解。你可以把它看成《敏捷软件开发：原则、实践与模式》的修订版。

《设计模式》不推荐阅读，它是设计模式的开山之作，但它的起点是  Erich Gamma 的博士论文，其写作风格偏向学术，而且中文版翻译得也很一般。这里将它罗列出来只是因为其历史重要性。如果你想学习设计模式，现在有一些更容易入门的书，比如《Head First 设计模式》。Martin Fowler 的《企业应用架构模式》将软件开发当时常见的解决方案汇集成模式，今天看来很多模式已经习以为常，但当年出场可是技惊四座的。从这本书的名字你不难看出，它出版的年代是企业级开发盛行的年代。Martin Fowler 一直认为这本书没有写完，希望能够继续更新，但不知道何时能看到这本书的新版。《Unix 编程艺术》也是一本讲软件设计的书，只不过，它选择的切入点是 Unix 中的设计，从中你可以学到「只做一件事，把它做好」、「文本化」等编程理念，有助于你改善日常的工作。这样的书，也就只有 Eric Raymond 这样沉浸编程几十年的人才能写出来。

2『已下载书籍「2019032代码整洁之道 | 2019032Clean-Code」、「2020107Implementation-Pattern」、「2020108卓有成效的程序员 | 2020108The-productive-programmer」、「2020109The-Practice-of-Programming」、「2020111敏捷软件开发 | 2020111Agile-Software-Development」、「2020112Clean-Architecture」、「2019044Head-First设计模式」、「2020105企业应用架构模式」、「2019079Unix编程艺术」。』

3、工程实践。Kent Beck 有一本知名的软件工程之作《解析极限编程》（Extreme Programming Explained），它介绍了一种软件开发方法：极限编程。但更重要的是，今天很多主流的软件开发最佳实践都是从这里出来的。这本书可以理解成诸多最佳工程实践的总纲。Martin Fowler 在 1999 年写下软件行业的名著《重构：改善既有代码的设计》（Refactoring: Improving the Design of Existing Code），把重构这个小圈子实践带到了大众视野。2018 年底，Martin Fowler 时隔近 20 年后，又写出了《重构》第二版。把他对这些年行业发展的新理解融入到重构实践中。重构应该有个目标，这个目标就是「重构成模式」，而这也是一本专门的书：《重构与模式》（Refactoring to Patterns）。

2『已下载书籍「2020130解析极限编程 | 2020130Extreme-Programming-Explained」、「2019030重构2Ed | 2019030Refactoring2Ed」、「2020110重构与模式 | 2020110Refactoring-to-Patterns」』

《测试驱动开发》是 Kent Beck 为世人展示 TDD 做法的一本书。它好的地方需要自己体会，Kent Beck 并没有显式的讲出来，比如：任务分解。Jez Humble 和 Dave Farley 的《持续交付》（Continuous Delivery）让持续集成再进一步，将生产环境纳入了考量。乔梁，他是《持续交付》这本书的中文版译者，而且在这本书出版近十年后，他自己写了《持续交付 2.0》，把自己多年来关于持续交付的新理解整理了进去。说到遗留代码和测试，我推荐一本经典的书：Michael Feathers 的《修改代码的艺术》（Working Effectively with Legacy Code），从它的英文名中，你就不难发现，它就是一本关于遗留代码的书。如果你打算处理遗留代码，也建议你读读这本书。这本书我也写过书评，你可以了解一下我对它看法。

2『已下载书籍「2020114测试驱动开发 | 2020114Test-Driven-Development」、「2020131持续交付 | 2020131Continuous-Delivery」、「2019031修改代码的艺术 | 2019031Working-Effectively-with-Legacy-Code」。其中「持续交付」的中文版微信读书里有的。』

4、领域驱动设计。Eric Evans 2003 年写了《领域驱动设计》，向行业介绍一下 DDD 这套方法论，立即在行业中引起广泛的关注。但实话说，Eric 在知识传播上的能力着实一般，这本关于 DDD 的开山之作，其写作质量却难以恭维，想要通过它去学好 DDD，是非常困难的。所以，在国外的技术社区中，有很多人是通过各种交流讨论逐渐认识到 DDD 的价值所在，而在国内 ，DDD 几乎没怎么掀起波澜。

2013 年，在 Eric Evans 出版《领域驱动设计》十年之后，DDD 已经不再是当年吴下阿蒙，有了自己一套比较完整的体系。Vaughn Vernon 将十年的精华重新整理，写了一本《实现领域驱动设计》，普通技术人员终于有机会看明白 DDD 到底好在哪里了。所以，你会发现，最近几年，国内的技术社区开始出现了大量关于 DDD 的讨论。因为《实现领域驱动设计》实在太厚，Vaughn Vernon 又出手写了一本精华本《领域驱动设计精粹》，让人可以快速上手 DDD，这本书也是我向其他人推荐学习 DDD 的首选。

2『已下载书籍「2020134Domain-Driven-Design」、「2020135实现领域驱动设计 | 2020135Implementing-Domain-Driven-Design」、「2020136Domain-Driven-Design-Distilled」，其中「领域驱动开发」的中文版微信读书里有，不过还是先读 Vaughn Vernon 的 2 本书，有多余的时间再看领域驱动开发。』

5、产品与需求。精益创业是 Eric Ries 最早总结出来的。他在很多地方分享他的理念，不断提炼，最终在 2011 年写成一本同名的书：《精益创业》。如果说精益创业是理论，《精益创业实战》这本书则给了你一个操作流程。Mike Cohn 是敏捷理念的一个重要传播者，我们在讲测试金字塔时，提到了他的著作《Scrum 敏捷软件开发》（Succeeding with Agile）。敏捷开发有两大流派：一派是工程实践，另一派是管理实践。如果你对 Scrum 这类管理实践感兴趣，可以读一下这本书。如果你对用户故事这个话题感兴趣，推荐阅读 Mike Cohn 的两本书《用户故事与敏捷方法》（User Stories Applied）和《敏捷软件开发实践—估算与计划》（Agile Estimating and Planning）。

2『已下载书籍「2020111敏捷软件开发 | 2020111Agile-Software-Development」、「2020137精益创业」、「2020138精益创业实战」、「2020139Scrum敏捷软件开发 | 2020139Succeeding-with-Agile」、「2020140Scrum敏捷软件开发 | 2020140User-Stories-Applied」、「2020141Agile-Estimating-and-Planning」。』

6、开发文化。软件行业里有一本名著叫《人月神话》，这算是软件开发领域第一本反思之作。今天，我们讨论的很多词汇都出自这本书，比如，没有银弹、焦油坑等等。虽然这本书出版于 1975 年，但其中提到的问题，依然困扰着今天的程序员。开源概念的提出者 Eric Raymond，他的《大教堂与集市》推开了开源大门。今天开源软件已经成为程序员日常工作的一部分，但如果没有 Eric Raymond 这些人的努力，我们还必须与复杂的企业级软件搏斗。了解一下开源的历程，可以帮助你更好地理解今天的幸福。程序员应该如何做，Robert Martin 也写了一本书《程序员的职业素养》（Clean Coder），其中对大多数程序员最重要的一点建议是，说「不」。

2『已下载书籍「2019655人月神话」、「2019746大教堂与集市」、「2019033程序员的职业素养 | 2019033The-Clean-Coder」。』

7、软件开发拾遗。高德纳的《计算机程序设计艺术》肯定是一套程序员都知道，但没几个人读完的书。算法的讲解经过几十年已经有了很好的发展，如果学算法，肯定有更好的选择。如果你想看图灵奖获得者如何从根上思考问题，不妨找来这套书来翻翻。《快速软件开发》（Rapid Development），不推荐阅读。在这本书中，作者首次提出了解决集成问题的优秀实践：Daily Build，每日构建。通过这个名字，我们便不难看出它的集成策略，即每天集成一次。它其中很多实践在当时是先进的，但今天看来有些落伍了。如果你只想从中收获一些理念性的东西，可以去读读。

《C 程序设计语言》、《Unix 编程环境》等出自贝尔实验室大师级程序员之手，他们的书都值得一读，其中的内容今天看来可能有些过时，但他们解决问题的方式和手法却值得慢慢品味。我在讲淘宝技术变迁时，提到了《淘宝技术这十年》，这本书算不上经典，但可以当做休闲读物。

8、技术之外。管理大师彼得·德鲁克有一本经典著作《卓有成效的管理者》，虽然标题上带着管理者几个字，但在我看来，这是一本告诉我们如何工作的书，每个人都可以读一下。尤瓦尔·赫拉利的《人类简史》或《未来简史》，是我第一次学到「大历史观」这个说法，历史不再是一个个单独的历史事件，而是一个有内在逻辑的发展脉络。《从一到无穷大》是一本著名科普著作，它向我们介绍了 20 世纪以来的科学进展。作者乔治·伽莫夫既是热宇宙大爆炸模型的提出者，也是生物学上最早提出「遗传密码」模型的人。虽然这本书出版自 1947 年，但以现在社会的整体科学素养，还是有必要读读这本书的。

史蒂芬·柯维（Stephen Richards Covey）的《高效能人士的七个习惯》，其中的理念我在专栏两个不同的地方提到过，一个是讲以终为始时，那段关于智力创造的论述，另一个是讲优先级时提到的艾森豪威尔矩阵。这本书值得每个人阅读，很多程序员欠缺的就是这些观念性的东西。很多程序员都是科幻小说迷，编程和科幻，这两个都是需要想象力的领域。刘慈欣的《三体》，不说它给 IT 行业带来的丰富的词汇表吧，作为科幻小说来说，它就是一流的，值得阅读。它会让你仰望星空，打开思维。如果你对科幻小说有兴趣，推荐阅读阿西莫夫的《银河帝国》系列，这是科幻小说界的扛鼎之作，你会看到，一部出版于 1942 年的书里就有大数据的身影。对于程序员来说，最好的工作状态就是进入心流，它会让你忘我工作。如果你对心流的概念感兴趣，可以去读米哈里·契克森米哈赖的著作《心流》，这位作者就是心流概念的提出者。

### 黑板墙

马大叔的《分析模式》，国内少有人提及，我认为是一本长期被低估的书。最大的价值是把 OO 抽象提到了新的高度。看完我发现：很多看似不同的事物，都有类似的关系。听起来是一句放之四海而皆准的「废话」，只有结合许多实实在在的例子以及思考，才有可能真正转变我们看待世界的方式。作者回复: 《分析模式》确实被低估了，可能是因为和大多数理解的技术有距离。

## 0004总复习重新审视最佳实践.md

希望通过对这些内容的学习，你已经对「如何做好软件」有了一个全新的认识。在这个专栏中，我给你讲了很多行业中的最佳实践，比如：测试、持续集成等等，但因为这个专栏叙述方式的关系，一些有关联的实践被放到了不同的模块下讲解。所以在这一讲中，我们将按照最佳实践的维度重新审视这些内容。我会将这些知识重新串联起来，帮你做一个对专栏的整体复习。

### 4.1 产品

做产品，很多时候是面向不确定性解决问题。目前这方面最好的实践是「精益创业」。对于精益创业的最简单的理解就是「试」。试也有试的方法，精益创业提出了一个「开发（build）- 测量（measure）- 认知（learning）」这样的反馈循环，通过这个循环得到经过验证的认知（Validated Learning）。

既然是对不确定产品特性的尝试，最好的办法就是低成本地试。在精益创业中，最小可行产品（MVP）就是低成本的试法。最小可行产品，就是「刚刚好」满足用户需求的产品。理解这个说法的关键在于用最小的代价，尝试可行的路径。在产品的打磨过程中，可以采用用户测试的方式，直接观察用户对产品的使用。作为程序员，我们要尽可能吃自家的狗粮，即便你做的产品不是给自己使用的产品，也可以努力走近用户。

1）精益创业，相关阅读：《06 | 精益创业：产品经理不靠谱，你该怎么办？》。2）最小可行产品（MVP），相关阅读：《19 | 如何用最小的代价做产品？》。3）用户测试、验证产品特性、吃自家狗粮，相关阅读：《26 | 作为程序员，你也应该聆听用户声音 》

### 4.2 需求

当我们确定做一个产品功能时，怎么描述需求也是很重要的。产品列表式的需求描述方式最容易出现问题的地方在于，看不清需求的全貌。用户故事是一个好的需求描述方式：作为一个什么角色，要做什么样的事，以便达成一种怎样的效果。在用户故事中，验收标准是非常重要的一环。即便不是采用用户故事描述需求，也依然建议先将验收标准定义清楚。

开发团队对需求的理解普遍偏大，基本上都是一个主题。在开发之前，先将需求拆分成小粒度的。衡量一个用户故事拆分是否恰当，一个标准是 INVEST 原则。有了拆分出来的用户故事，就可以进行估算了，估算的过程也是对需求加深理解的过程，过大的用户故事应该再次拆分。

当我们有了拆分之后的需求，就可以对需求进行进行优先级讨论了。先做重要性高的事，而不是一股脑地去做所有的需求。只有分清了需求的优先级，才能方便地对需求进行管理。1）用户故事。相关阅读：《04 | 接到需求任务，你要先做哪件事？ 》。2）需求的分解与估算，相关阅读：《17 | 程序员也可以「砍」需求吗？》。3）需求管理、优先级，相关阅读：《18 | 需求管理：太多人给你安排任务，怎么办？》

### 4.3 持续集成

在开发中，写出代码并不是终点，我们要把代码集成起来。集成要经常做，改动量越小，集成就可以做得越频繁，频繁到每次提交都去集成，这就是持续集成。持续集成发展到今天已经是一套完整的开发实践。想要做好持续集成，你需要记住持续集成的关键是「快速反馈」。1）怎样快速得到反馈。2）怎样反馈是有效的。

持续集成，可以继续延展，将生产部署也纳入其中，这就是持续交付。如果持续交付，再向前一步，就可以同产品验证结合起来。

持续交付的关键点，是在不同的环境验证发布包和自动化部署。不同的环境组成了持续交付的构建流水线，而自动化部署主要是 DevOps 发挥能力的地方。持续交付的发展，让交付物从一个简单的发布包变成了一个拥有完整环境的 Docker 镜像。

持续集成和持续交付可以将诸多的实践贯穿起来：单元测试、软件设计、任务分解、主分支开发、DevOps 等等。所以，如果一个公司希望做过程改进，持续集成是一个好的出发点。1）持续集成发展史。相关阅读：《05 | 持续集成：集成本身就应该是写代码的一个环节》。2）快速反馈。相关阅读：《24 | 快速反馈：为什么你们公司总是做不好持续集成？》。3）持续集成，贯穿诸多实践。相关阅读：《答疑解惑 | 持续集成，一条贯穿诸多实践的主线 》。4）持续交付。相关阅读：《32 | 持续交付：有持续集成就够了吗？》。5）与产品结合：持续验证。相关阅读：《答疑解惑 | 持续集成、持续交付，然后呢？ 》

### 4.4 测试

测试是一个典型的程序员误区，很多程序员误以为测试只是测试人员的事。理解了软件变更成本，知道了内建质量之后，我们就应该清楚，测试应该体现在全部的开发环节中。这一思想在开发中的体现就是自动化测试。

想要写好自动化测试，需要先理解测试金字塔，不同的测试运行成本不同。为了让软件拥有更多的、覆盖面更广的测试，需要多写单元测试。编写测试的方式有很多，一种实践是测试驱动开发（TDD）。先写测试，然后写代码，最后重构，这就是 TDD 的节奏：红 —— 绿 —— 重构。测试驱动开发的本质是测试驱动设计，所以，编写可测试的代码是前提。

要想做好 TDD，一个重要的前提是任务分解，分解到非常小的微操作。学会任务分解，是成为优秀程序员的前提条件。想写好测试，需要懂得好测试是什么样子的，避免测试的坏味道。好测试有一个衡量标准：A-TRIP。我们不只要写好单元测试，还要站在应用的角度写测试，这就是验收测试。验收测试现在比较成体系的做法是行为驱动开发（BDD），它让你可以用业务的语言描述测试。1）单元测试、自动化测试、蛋卷和冰淇淋模型。相关阅读：《12 | 测试也是程序员的事吗？》。2）测试驱动开发。相关阅读：《13 | 先写测试，就是测试驱动开发吗？》、《14 | 大师级程序员的工作秘笈 》。3）测试练习。相关阅读：《15 | 一起练习：手把手带你拆任务 》。4）简单的测试、测试的坏味道、A-TRIP。相关阅读：《16 | 为什么你的测试不够好？ 》。5）验收测试、写好验收测试用例。相关阅读：《32 | 持续交付：有持续集成就够了吗？》。6）外部系统测试，用接口隔离。相关阅读：《答疑解惑 | 如何在实际工作中推行新观念？ 》

### 4.5 编码与设计

编码和设计，是软件开发中最重要的一环。在我看来，编码和设计是一体，想清楚才能写出好代码。很多程序员追求写好代码，却没有一个很好的标准去衡量代码的好坏。结合着软件设计的一些理念，我给你一个编写好代码的进步阶梯，希望你能达到用业务语言编写代码的程度。

用业务语言编写代码，需要对软件设计有着良好的理解。提到设计，人们的初步印象是「高内聚低耦合」，但这是一个太过高度抽象的描述。SOLID 原则是一个更具实践性的指导原则，有了原则做指导，就可以更好地理解设计模式了。

有了基础原则，我们会知道将不同的代码划分开，这样就产生了分层。好的分层可以构建出抽象，而其他人就可以在这个抽象上继续发展。对于程序员来说，构建自己的核心抽象是最关键的一步。目前构建核心抽象最好的方式是领域驱动设计（DDD），它将我们思考的起点拉到了业务层面，通过战略设计将系统按照不同的上下文划分开来，再通过战术设计，指导我们有效地设计一个个的领域模型。但无论怎样做设计，前提是使用适当的技术解决适当的问题，不要把技术用复杂，把团队带入泥潭。1）业务语言写代码。相关阅读：《21 | 你的代码为谁而写？》。2）架构设计。相关阅读：《34 | 你的代码是怎么变混乱的？ 》。3）分层、抽象。相关阅读：《35 | 总是在说 MVC 分层架构，但你真的理解分层吗？》。4）业务与技术。相关阅读：《36 | 为什么总有人觉得 5 万块钱可以做一个淘宝？ 》。5）微服务。相关阅读：《37 | 先做好 DDD 再谈微服务吧，那只是一种部署形式 》

### 4.6 项目准备

从头开始一个项目时，一个好的实践就是把一切都准备好。迭代 0 就是这样一个把迭代准备好的实践，从需求到技术，做好充分的准备工作再开启项目，你会显得从容不迫。在技术方面，迭代 0 最重要的准备工作就是构建脚本，它是后续很多工作的基础，比如，持续集成。1）迭代 0，做基础的准备。相关阅读：《10 | 迭代 0: 启动开发之前，你应该准备什么？》2）构建脚本，让项目一开始就自动化。相关阅读：《30 | 一个好的项目自动化应该是什么样子的？ 》

### 4.7 其余的最佳实践

除了几个花大篇幅介绍的最佳实践，我们还提到了很多不同的最佳实践。

1、DoD。完成的定义（DoD），是一个确保合作各方理解一致的实践。它是一个清单，由一个个检查项组成，每个检查项都是实际可检查的。有了 DoD，做事就只有两种状态：完成和未完成。完成的定义，DOD。相关阅读：《03 | DoD 价值：你完成了工作，为什么他们还不满意？》

2、站会。站会，一种轻量级的会议形式，用来同步每天发生的事情。一般来说，只说三件事：昨天做了什么，今天打算做什么，遇到了什么问题。相关阅读：《22 | 轻量级沟通：你总是在开会吗？ 》

3、看板。看板，一种项目管理工具，将正在进行的工作可视化。通过看板，可以发现团队正在进行工作的很多问题。看板有实体和电子之分，可以根据自己的项目特点进行选择。相关阅读：《23 | 可视化：一种更为直观的沟通方式 》

4、回顾会议。回顾会议，是一种复盘实践，让团队成员对一个周期内发生的事情进行回顾。回顾会议一般分为讲事实、找重点和制定行动项三个部分。但在开始回顾之前，会先进行安全检查，确保每个人都能放心大胆地说真话。回顾会议，相关阅读：《25 | 开发中的问题一再出现，应该怎么办？  》回顾会议中的安全检查，相关阅读：《答疑解惑 | 持续集成，一条贯穿诸多实践的主线 》

5、重构。重构，是程序员的基本功，把调整代码的动作分解成若干可以单独进行的「重构」小动作，一步步完成。重构的前提是识别代码的坏味道。保证代码行为不变，需要有测试配合，而重构的方向是，重构成模式（Refactoring to Patterns）。重构的过程和编写代码的过程最好结伴而行，最佳实践就是测试驱动开发。相关阅读：《加餐 | 你真的了解重构吗？》在测试驱动开发中重构，相关阅读：《13 | 先写测试，就是测试驱动开发吗？》

6、分支开发。分支开发模型，是每个团队都要面临的问题。行业中有两种常见的分支模型，一种是基于主干的开发模型，一种是分支开发模型。分支开发符合直觉，却不是最佳实践。主分支开发模型是与其他实践配合最好的模式，但也需要开发者有着良好的开发习惯。如果并行开发多个功能，可以考虑 Feature Toggle 和 Branch by Abstraction。分支开发，相关阅读：《14 | 大师级程序员的工作秘笈 》。Feature Toggle 和 Branch by Abstraction，相关阅读：《答疑解惑 | 如何分解一个你不了解的技术任务？ 》

7、Fail Fast。Fail Fast 是一个重要的编程原则：遇到问题，尽早报错。不要以构建健壮系统为由，兼容很多奇怪的问题，使得 Bug 得以藏身。相关阅读：《27 | 尽早暴露问题： 为什么被指责的总是你？ 》

### 黑板墙

今天我终于理解了，重构的前提是有测试。因为没有系统的测试，重构就会发生牵一发而动全身的灾难。作者回复：如果说现在有一些进步的地方是，很多 IDE 的重构功能非常强大了。2019-04-24

如果请求第三方接口，不同业务类型共用一个接口，通过请求体参数来区别，moco 是如何支持同一个接口地址支持多个不同响应呢？作者回复: moco 本身支持很多匹配参数，地址只是其中一个，你甚至可以根据请求内容进行匹配，具体内容可以参考 API 文档。2019-05-09

tdd，先写测试，那是不是就意味着没有办法写私有方法了。作者回复：你说得对，但是站在先写测试的角度，为啥要测私有方法呢？2019-04-25

## 0005带着软件设计课回来了.md

我们都知道，《10x 程序员工作法》这个专栏，本质上是在讲如何有效工作，尽量地排除外部干扰，不让别人给我们添麻烦，把精力放在值得做的事情上。然而，当我们真正开始做值得做的事情后，我们做得又怎么样呢？1）别人修改了他的程序，结果你的代码崩溃了，因为你们在底层共用了一个变量。2）不同的项目组竞争公共的测试环境，测出来的常常是一些可以在单元测试里就解决的小问题。如果问他为什么不自己做好单元测试，他的回答常常是不好测。3）为了提高一段代码的处理性能，我们使用了多线程处理。结果，更多的 Bug 随之而来……

是不是有一种熟悉的感觉扑面而来？在我的职业生涯里，我接触过的许多项目都会不停地出现类似的问题。事后究其原因，很大一部分都是软件设计没做好所造成的。换句话说，都是程序员自己给自己挖的坑。
如何避免给自己找麻烦，这就是我要在新专栏里讨论的内容。所以这次，我准备和你聊一下软件设计。

或许你会好奇，这些东西和软件设计有关系吗？软件设计不就是设计模式吗？我会在新专栏里告诉你，软件设计可比你想的内容多得多。它不仅可以教会我们如何组织代码，还会给我们提供一把尺子，用以衡量我们的设计。学会了软件设计，我们甚至可以把许多问题消灭在萌芽阶段，不会让它们为害人间。

如果说这个专栏是在告诉你要做正确的事，做有价值的需求，别把时间浪费在不该做的事情上。那软件设计专栏就是告诉你如何把事做对，如何建立有效的模型，划清模块之间的边界。所以，二者可谓一脉相承。
这个专栏是我工作之外的思考，新专栏则是我本职工作的深思。

### 黑板墙

通过郑大的引导，让我接触到了很多行业内的最佳实践，并且他们之间的关系是什么，怎么才能串成一条线。尤其是对于 Tdd ，以及持续重构，最后到自动化持续交付，软件设计方面的 DDD，微服务等从入门到有自己的思考。从曾今人云亦云的以为程序员是青春饭到把做一个有工匠精神的程序员作为自己的信仰，这是郑大带给我最重要的转变。只有眼界宽了，看到的东西多了，品味才能提升，才能有努力的目标。最近在研究如何让代码才能更有可测试性，期待通过大的分享中，再有新的启发和收获。