## 记忆时间

2021-05-04

## 目录

0400 计算机思维

2『已下载书籍「2020136Computational-Thinking」。』

0401 计算机思维1：无情的计算

可计算要满足 3 个条件：计算过程必须被拆解为很多简单而明确的步骤，这些步骤可拆分为不同的部分给不同的人计算且可汇总，有个纠错机制。上述流程化的操作即为「算法」，算法化即标准化和流程化。计算机不能解决所有的问题，图灵用「图灵停机问题」说明了哪怕在理论上，计算机也不能通说阅读一段算法来判断这个算法到底是能自动执行到停机，还是会永远计算下去。

0402 计算机思维2：自动的机器

通用计算机的简要发展历程，从提花织布的打孔卡（严格的灵活性）到巴贝奇的「分析机」（可编程的通用性），到图灵的完整数学计算理论，再到「冯·诺依曼架构」（CPU 和内存）。香农设计了逻辑门，从硬件到软件的关键思想是分层。格外关注计算机「硬件」特性，它是个机器，没法思考，比如 x=3，是一个动作，是把 3 这个值赋给用 x 标记的那一段内存位置。

0403 计算机思维3：全新的科学

计算机是门全新的科学，计算机科学的发展分三段：初级，是怎么更好地实现自动化，主要解决应用问题；中级，是研究「计算」这件事儿本身，上升到了类似于自然科学的层面；高级，则是把计算思维用到其他科学领域中去，是带给人认知的升级。计算机科学真正成熟的标志，是「计算机」这个东西，和「计算」这个行为本身，成了研究的对象。

0404 计算机思维4：工程的复杂

软件工程师工程管理和综合治理手段的极限。工程师思维和科学家思维至少有三个重大区别。1）科学家是寻找事物的规律，而工程师是去设计一个东西。2）对知识的态度。3）对模型的使用。

0405 计算机思维5：设计的境界

开发软件的流程：1）确认需求；2）把要求具体化，设定各种目标参数；3）进行开工建设；4）做好之后接收和测试；5）交付给用户。软件开发是实现功能和需求，软件设计则要考虑用户想要什么。软件设计方面基本的做法，一个是做好用户调研，深入了解用户的需求；一个是借鉴那些成功的设计都有哪些规律；还有一个叫「敏捷产品管理」，要求在开发的每个环节，都让用户介入进来，根据用户的反馈快速迭代。用户很重要，用户会在软件中做出各种行为，软件是让用户活动的地方。软件设计的目标，是创造一个虚拟世界。

0406 计算机思维6：方程的模拟

科研模式除了传统的「实验」和「理论」外，「计算」成为了第三种，它是用计算机「模拟」一个系统的演化。严格地说计算和理论都是使用模型去模拟真实世界，但是计算的模型相当于直接模拟，真实得多也复杂得多。理论是「求解」，是间接的；计算是「模拟」，是直接的。 传统的因果、理论、学说，无法描述真正复杂的现象。计算不能让你得到什么一句话解释，但计算能让你更接近真实情况。

0407 问答：开发一个操作系统，是更难了还是更容易了？

## 0400. 计算机思维总结

理解算法

1、「算法（algorithm）」这个词，早在十七世纪就有了。把整个计算给流程化，变成标准操作，而且还得能让好几个计算师一起算，这就要求这个计算方法满足三个条件 ——

第一，计算过程必须被拆解成很多步骤，每一步干什么必须是简单而明确的。

第二，所有这些步骤要能拆分开来，分给几个计算师，各自负责其中的一部分。而这就有个交流问题，各个计算师算出来的东西得汇总在一起，形成一个最终的结果。

第三，纠错机制，让计算师们能觉察到自己哪里算错了。

按今天的概念，这其实就是「分布式并行计算」。这不但是计算机方法，而且还是超级计算机的方法。

2、所以我们可不是先有了计算机之后才有的计算机思维。人们早就有了计算机思维，只不过当时没有机器可用、只能用人。

3、能提出算法，和自己会算，完全是两码事。算法最大的好处就是它是机械化的操作。算法化就是标准化和流程化。这其实就是整个机械化大生产的秘密。

4、计算机思维的第一原则：把人的情感和主观判断排除在计算过程之外。

5、哲学家的思想总是领先于技术实现，而老百姓的思想则被技术所左右。每个时代的技术，都会主导这个时代的人的思维。老一辈的人爱说「压力很大」、「动力十足」、「把压力化为动力」，这其实是一种暗喻 —— 是把人给当成了蒸汽时代的机车。而今天的年轻人则善于用计算机做暗喻，会说……「我的大脑死机了」。

理解硬件

1、从提花织机的打孔卡提供了「严格的灵活性」，到巴贝奇的可编程通用计算机，到冯·诺依曼架构的 CPU 和内存，这是非常清晰的演变。现在我们看到了，图灵再厉害，「编程」这个思想不是他先提出的；冯·诺依曼再神，计算机系统不是他发明的。

2、为什么说信息行业是个创新行业呢？因为第一，这里面的想法太密集，有太多可以改进之处；第二，改进的方向相当明确。

3、从计算机思维的角度来说，核心教训是你必须考虑硬件。永远都别忘了计算机是个机器，而机器有数学算法之外的、自己的特点和脾气。

理解学科

计算机科学的发展可以分为三个方面 ——

1、初级，是怎么更好地实现自动化，主要解决应用问题：

汇编语言－高级汇编语言－账号管理－操作系统－系统思维－工程思维－网络思维－安全思维－编程思想－程序员思维－编程技能

2、中级，是研究「计算」这件事儿本身，上升到了类似于自然科学的层面。

计算机科学真正成熟的标志，是「计算机」这个东西，和「计算」这个行为本身，成了研究的对象。就好像动物学研究动物、植物学研究植物一样，计算机科学，研究计算机。计算机问题本质上是数学问题。现在有很多应用数学家就在专门研究这些问题。

3、高级，则是把计算思维用到其他科学领域中去，是带给人认知的升级。

人们突然意识到，「计算」是个非常基础的逻辑，到处都是计算。它还给我们提供了一个非常不一样的观察世界的眼光。

理解软件

1、软件工程，可以说是工程管理和综合治理手段的极限。它告诉我们如何治理最复杂的系统。

2、工程师思维和科学家思维至少有三个重大区别——

第一，科学家是寻找事物的规律，而工程师是去设计一个东西。科学家只要觉得这个规律有意思就可以发表，而工程师得负责任。

第二是对知识的态度。科学家面对知识，看懂了、能总结出规律就行。而工程师要把这个知识拿来用。

第三是对模型的使用。科学家喜欢简化的模型，能抓住实质就行。而工程师必须考虑所有的细节。

所以软件不但是个工程，而且比传统工程难得多。

3、软件工程项目的复杂性问题：

1 个人干 12 个月的活，绝对不是 12 个人在 1 个月内能干完的。项目用的程序员越多，平均每个人出活的速度就越慢。所以你规划项目的时候不要算什么「人月」。你这个团队做出来的软件的结构，往往和你这个团队的人员组织管理结构高度相似。所以软件工程不但要管项目，还要管人。

4、现代软件工程要求，软件产品必须达到下面这五个目标，称之为「DRUSS」 ——

Dependable，可信赖，让顾客真能指望上你这个软件；

Reliable，得可靠，不能总出毛病；

Usable，软件是给人用的，得让人能够上手；

Safe，用的时候不能出安全事故；

Secure，它得不容易被黑客攻击才行。

5、软件工程的根本问题，是人的问题。主导软件开发的这个人，必须得能够理解高度复杂的东西才行。你得能驾驭复杂。

6、「好的判断来自经验，而经验来自坏的判断。」软件每天都在更新，但软件工程的背后，是一棵经年累月长出来的大树。

理解设计

1、发布，是尽最大努力，呈现一个最好的东西的行动。发布能刺激我们完善自我。

2、软件设计是一个激进的思维方式转换。以前的软件工程思维，是关注于功能和实现；现在的设计思维，则要求我们要考虑到用户和产品应用的环境。软件设计和一般产品的设计还不一样。一般产品让你感觉好用、好看比较容易，可能最多考虑一些人体工程学之类。而软件，跟用户是交互式的关系。用户会在软件中做出各种行为，软件是让用户活动的地方。

3、软件设计的目标，是创造一个虚拟世界。

4、软件设计，可以分为六个等级。

-1 级，是流氓软件。这种软件不但不安全而且很可能专门留了收集信息甚至攻击系统的后门，而且完成度很低，一堆 bug。

0 级，是轻蔑的满意。基本上可以用，但是大家都知道其中有很多问题，也不怎么安全。

1 级，是软件能够满足基本的需求，比较可靠。

2 级，软件能跟环境和用户使用习惯达到了完美配合。你不需要学习它怎么用，凭直觉就可以直接使用。该有的功能它都有，而且非常可靠。

3 级，是软件能主动规避负面的结果。这就要求设计者不但要满足用户正常的需求，还得事先把各种怪异的用法、极端的情况都考虑到，确保软件在任何情况下都没有故障。

4 级，也就是最高级，是这个软件能给用户带来喜悦。这意味着软件超出了用户的预期，让人用上之后会迫不及待地想要把它推荐给别人。 

5、软件设计是技术、数学、艺术、文化和哲学的融合创造。软件设计里面有「道」。

理解模拟

1、「理论」和「实验」，都是人的思想和真实世界之间互相印证。但是有了超级计算机之后，就出现了一个新的研究模式，也就是「计算」。是用计算机「模拟」一个系统的演化。

2、「计算思维」带给科学研究的认知升级：传统的因果、理论、学说，无法描述真正复杂的现象。计算不能让你得到什么一句话解释，但是计算能让你更接近真实情况。

## 0401. 计算机思维1：无情的计算

今天开始咱们来讲一本今年 4 月份出版的新书，《计算机思维》（Computational Thinking ），作者是两位计算机科学家，美国的彼得·丹宁（Peter J. Denning）和芬兰的马蒂·泰德（Matti Tedre）。我们要借助这本书系统地、但同时也是快速地了解一下计算机思维 —— 我们要理解计算机是怎么回事儿，计算机能帮我们干什么，以及怎样把计算机思维用于其他领域。

为了让你印象更深，咱们先玩一个小孩爱玩的、小小的数学游戏 —— 1）把你出生的月份和日期这两个数字相加，得到一个数；2）把这个数乘以 18；3）把所得结果的各个数字相加；4）把上一步结果的各个数字再相加。

而我能猜出来，你最后得到的那个数字是什么。答案在文稿最后的注释里 [1]。这个游戏也许能让小学生感到惊奇，对大人来说就有点直白了。不过我想让你体会的是这一波操作的过程。

你有什么感受吗？把一个两位数乘以 18 可能让你感到了一点痛苦。你必须兢兢业业准确无误地按我说的步骤操作，才能得到我想要的结果。你没有自我发挥的余地。在这个过程中，你是一个 computer。

### 1.1 计算师

Computer 这个词，现在我们都翻译成「计算机」。但是这个词最初的含义，可是指人。早在十七世纪就已经出现了 computer，也许应该叫做「计算者」或者「计算师」。计算师不是数学家也不是工程师，他们是专门做计算的人。

二战期间，计算师甚至还是美军一个专门的编制。当时美军发明了射程能达到好几英里的大炮，而这个大炮怎么瞄准，就涉及到很复杂的计算。要算一个瞄准角度，你至少必须考虑目标到你的距离，目标跟你的高度差，以及当时战场上的风速。

如果你学过物理，你应该知道怎么算。但是，在战场上找个懂物理的人现场拿三角函数解方程可就太慢了。计算跟「会算」是完全不同的要求。美军必须把整个计算给流程化，变成标准操作，而且还得能让好几个计算师一起算。这就要求这个计算方法满足三个条件 —— 1）计算过程必须被拆解成很多步骤，每一步干什么必须是简单而明确的。比如这一步就做个加法、下一步就查个三角函数表，在下一步是除法，等等。2）所有这些步骤要能拆分开来，分给几个计算师，各自负责其中的一部分。而这就有个交流问题，各个计算师算出来的东西得汇总在一起，形成一个最终的结果。3）还得有个纠错机制，让计算师们能觉察到自己哪里算错了。

按今天的概念，这其实就是「分布式并行计算」。这不但是计算机方法，而且还是超级计算机的方法。所以你看，我们可不是先有了计算机之后才有的计算机思维。人们早就有了计算机思维，只不过当时没有机器可用、只能用人。

这一波流程化的操作，叫做「算法」。「算法」（algorithm）这个词，也早在十七世纪就有了。现在已知最早的一个算法，是欧几里得在公元前 300 年发明的计算两个整数的「最大公约数」的方法，咱们中国人通常称之为「辗转相除法」。两个数的最大公约数，就是能同时被这两个数整除的最大的数，比如 18 和 48 的最大公约数是 6。你肯定会算最大公约数，但是你的计算方法需要自身的理解和直觉 —— 如果你仔细想想，你也许会发现自己有点说不清是怎么算出来的。

而欧几里得提出了一个得到最大公约数的标准操作。给定任何两个数，它们的最大公约数，和这两个数的差与其中较小的那个数的最大公约数是一样的。使用这个方法，你只做减法就能得到最大公约数！比如我们用 gcd 表示最大公约数，那么：

```
gcd(48,18) = gcd(30,18) = gcd(18,12) = gcd(12,6) = gcd(6,6) = 6
```

欧几里得可能没想到，他发明的这套操作，到现在仍然在被计算机使用。

2『求 2 个数最大公约数的算法，做一张信息数据卡片。（2021-05-04）』

### 1.2 算法的妙处

说到这里你应该看出来了，能提出算法，和自己会算，完全是两码事。算法最大的好处就是它是机械化的操作。有了欧几里得这个算法，操作者根本就不需要知道什么叫最大公约数，他甚至不需要知道我们为什么要做这个计算，他只要会算最基本的加减乘除，能够严格地执行规则就行。这就实现了可推广。

想要现场解决一个数学问题，原本你需要找个专家才行。专家有多年知识储备和技巧训练，他会用到巧妙的构思，很可能还有些说不清道不明的直觉，才能给你解决。可是专家太贵了。而如果我们能把一类通用的问题给算法化，你就不再需要请专家了。你只要雇些计算师就行。

算法化就是标准化和流程化。这其实就是整个机械化大生产的秘密！我们看麦当劳的食物，味道也可以，卫生也放心，价格也便宜 —— 而你去吃的那家麦当劳，可没有著名的厨师。每个麦当劳里的食物都是一样的。任何人经过简单的培训，都能给你操作出麦当劳食品来。麦当劳有自己的研发中心，它始终在测试不同的口味和营养搭配，但是因为它会算法化，它只要定型一个，就可以推广到所有。麦当劳只恨做饭的不是机器人。人们从十七世纪开始就在琢磨怎么让机器去做计算，而且发明了构思巧妙的计算机，只是因为没有电子管晶体管这些东西，那时候的计算机不能取代计算师。

我忍不住就想，如果人类一直没有发明电子计算机，我们今天就会有一个叫做「计算师」的职业。这很可能是一个白领工作。计算师们很可能会使用中国的算盘做各种计算，还要背诵三角函数表和对数表。他们会被分成从初级到高级的职称，会有自己的职业道德和职业规范。他们可能都穿着统一的职业装，发型一丝不苟……

但是，那将是一个非常低端的工作。做计算师不需要什么聪明才智。而要想比他们挣得多，要想领导他们，你就得掌握计算机思维。

### 1.3 计算机思维

古人对计算的钻研可不仅仅是算法，哪怕是没有计算机的时代，那些最聪明的人就已经想得很深了。十七世纪尚未发生工业革命，但是启蒙运动已经开始了，牛顿已经出来了，「理性」已经在知识分子中深入人心。就在十七世纪，笛卡尔和莱布尼茨就有一个设想，说既然计算可以变成流程化、算法化的操作，那能不能把人的推理，也给机械化呢？

今天我们都爱谈论各种心理学意义上的偏见和谬误。启蒙时代的人就已经知道，让人去推理，是非常靠不住的。人会有各种主观的判断、有很多情绪化的东西。那如果我们能把一切理论的推理都给标准化、流程化、机械化，不管是谁来操作，只要你严格遵守规则，就一定能推出客观的、正确的判断，这岂不就解决了一切争论吗？这不就是通往真理之路吗？

笛卡尔和莱布尼茨想要的，是冷酷无情的计算。这恰恰就是计算机思维的第一原则：把人的情感和主观判断排除在计算过程之外。

好消息是我们现在已经取得了很多很多进展。后世的学者发明了像「布尔代数」、「谓词逻辑」这些理论准备，信息论祖师爷香农发明了用电路实现通用逻辑运算的方法 [2]，而且我们有了速度无法想象的快的计算机……今天真的有很多理论推导，可以交给计算机去做。计算机甚至能证明数学定理。

但是，坏消息是计算机不能解决所有的问题。现代计算机的祖师爷，图灵，用「图灵停机问题」说明，哪怕在理论上，计算机也无法通过阅读一段算法来判断这个算法到底是能自动执行到停机呢，还是会永远计算下去。我们专栏还讨论过「哥德尔不完备性定理」，我们知道笛卡尔和莱布尼茨的那个梦想哪怕在数学上也是不可能实现的。但是，我们仍然得到了一个自动化的时代！这个时代的计算机所能做的事情，一定会让十七世纪那些思想家和计算师大开眼界。

哲学家的思想总是领先于技术实现，而老百姓的思想则被技术所左右。每个时代的技术，都会主导这个时代的人的思维。老一辈的人爱说「压力很大」、「动力十足」、「把压力化为动力」，这其实是一种暗喻 —— 是把人给当成了蒸汽时代的机车。而今天的年轻人则善于用计算机做暗喻，会说……「我的大脑死机了」。计算机思维已经深入到了现代生活的方方面面。这一讲我们理解了「算法」，剩下的咱们后面慢慢说。

注释：

[1] 最后的数字一定是 9。这是因为，如果一个数能被 9 整除，它的各位数字相加之和就一定能被 9 整除。

[2] 精英日课第二季，《硬件的大智慧》。

### 黑板墙

就我个人的经验来说，对于计算机的理解是有代沟的。我以前做过工厂的可编程逻辑控制器的程序设计工作。一个最大的苦恼是，总有人会怀疑计算机会算错。老一辈的工人一看到运行出了问题，就会说「这程序乱了吧」。每当此时，我都会耐心的跟他们解释，程序设定好之后是不会出错的，肯定是输入的条件发生了变化，例如传感器失灵之类的问题导致了这样的现象。但是下一次出问题，他们还是会说同样的话。后来我理解了这些人的潜台词是，他们认为人比电脑更可靠，所以一旦电脑出现问题，他们喜欢把原因归结为电脑自身，而不是外部条件。不过随着老一辈的退休，新的一代工人是伴随着电脑长大的，他们就很少怀疑电脑会出问题了。这真的应了那句话：「一种观念的改变，只是因为坚持旧观念的人离开了。」2019-05-13

人类如果了解计算机思维，就不会抱怨它和自己的想法不同，因为本来就不是要一致的，计算机思维更适合某些工作和环境，甚至更能给出好的决策，它可能比人想得更远，而不是因为感情的驱使而背离计算机计算的结果，我相信《流浪地球》中按照刘培强的想法地球肯定活不下来，只走了这一小段就损失了巨大的飞行器，那后面几千年还有什么可以失去，而莫斯的算法是正确的，放弃地球带着空间站独自飞走，那会是更好的结果，先知道什么是正确的，这很多时候靠计算机思维，而这比把事情做对重要的多。算法和感觉完全可以融合在一起而非必定相互独立的，是可以并行前进的马车，共同实现大脑的进化。就拿玩魔方来说，3 阶魔方如果用公式学会非常慢，而如果先记住感觉上怎么拧，先学会复原再看一下公式就会更清楚二者的关系，同时也需要手速和魔方本身的顺滑程度，最快我做到过 40 多秒复原，虽然数学上可以证明魔方的每一步，但我更喜欢凭感觉拧，毕竟这是休闲而非做数学题，计算机思维也是一样，没有的时候需要有，有了以后不沉迷，钉子只是需要处理的很多事情之一，锤子也不是全部的工具。2019-05-13

在《思考会思考的机器》中凯文·凯利说，人类是又迟钝，又懒散，但却是伟大的思想家，机器快速、准确，但却十分愚蠢。还是这本书，著名物理学家哈伊姆·哈拉里说，像人一样思考的机器并不可怕，像机器一样思考的人才会变得更可怕。伊藤穰一说，我们制造出来的机器越来越像人，但我们的教育体制把人培养得更像机器。可见，掌握计算机思维，成为人机合体，才能抢占时代先机，走，我们一起成为新物种。应该说，计算机思维本质上是一种数学思维。著名数学家波利亚就谈过解题一些基本技巧。1）首先，从熟悉的题目出发。2）其次，把复杂的题目简化。先作出最简单的假设，即使这样的假设是非常荒谬的。从最简单的模型出发，一步步地再把它复杂化。从最特殊的例子出发，再一步步地把它一般化。3）再次，把抽象的题目形象化。而研究证明，人类的数学能力和语言能力是同宗同源的，都是为了探索某种模式，而且是为了解决问题，加强协作 —— 说给别人听，并理解别人是什么意思。所以，要相信自己完全能掌握计算机思维。2019-05-13

万老师讲到我的职业领域了，我自己成立了一家教育机构，专门帮助中小学生培养计算思维，所以非常乐于与大家分享一些扩展知识。首先这本书的作者大有来头，彼得丹尼是美国 ACM 学会的前主席，ACM 是全球最权威的计算机学术组织，由 ACM 学会颁发的 ACM Turing Award，以英国著名的计算机科学家阿兰图灵命名，是计算机科学领域的诺贝尔奖。丹宁在 2007 年的《ACM 通讯》上发表过一篇影响非常深远的文章，其中提到计算是一门自然科学，它的存在远早于计算机的产生，而且在很多领域的深层结构中都被发现出来，也广泛的运用于新知识的探索发现。所以他的这本书正确译名应该是《计算思维》，这样更准确提现丹宁的观点。

现在有越来越多的计算机科学家，包括诺奖得主，都主张计算是继理论和实验之后的第三个自然科学基础研究方法。很多科学研究依赖计算机建模和计算进行模拟实验，其中用到的思想和方法与传统的理论和科学实验都明显不同，不应笼统归于实验之中。以物理学家为例，有像爱因斯坦和霍金这样的一个人坐在书房里做思想实验的理论物理学家，有探测宇宙微波背景辐射的实验物理学家，也有用计算机计算黑洞模型的计算物理学家。

我们所面对的未来，是人类与计算机各有所长、合作共生的时代，要求我们掌握计算思维。美籍华人女科学家周以真对计算思维下了一个广受认可的定义 —— 计算思维是运用计算机科学的基本概念，进行问题求解、系统设计以及人类行为理解等一系列思维活动。在最大公约数这个例子中，计算思维的应用体现在：1）把等价于除法运算的复杂的公约数计算，简化为计算机擅长的简单的减法指令运算。2）定义输入、算法和输出。3）运用递归思想对每一个计算步骤的输出进行迭代。2019-05-14

在文末提到了计算机思维已经深入到了生活的方方面面，让我想起看到过的《真正支配整个世界的十种算法》这篇文章，其中就探讨了 10 种支撑着当下这个社会的算法。1）合并排序，快速排序与堆排序。2）傅利叶变换与快速傅利叶变换。3）迪杰斯特拉算法。4）RSA 算法。5）安全哈希算法。6）整数分解。7）链接分析。8）比例微积分算法。9）数据压缩算法。10）随机数生成算法。这些算法广泛存在于互连链接、安全加密、哈希算法、信息传递、人工智能、以及财务等相关领域。而这些应用的背后是则与我们的生活、工作以及与社会的运行发展都是密切相关的，当然还包括影响更深远的计算机思维的扩展和跨界应用。

## 0402. 计算机思维2：自动的机器

今天我们继续讲《计算机思维》。了解一些历史有利于理清思路。上一讲讲算法，我们总结了一个历史教训，那就是人的思想，可以领先于技术应用。人类并不是先有了计算机才有的计算机思维，而是早就有了计算机思维，在那儿等着计算机出现。借用一个佛教术语，启蒙时代以来思想家已经「照见」了计算机的可能性。

我们看计算机产品是最容易过时的，今年买的手机明年就换代了。硬件可以被淘汰，软件可以被升级，但是，思想很难过时，数学永不过时。计算机的发展故事，是把思想实现的故事。我们孜孜以求的，是一个「自动的」机器。

### 2.1 对自动的追求

下面这张图中是一个会下国际象棋的机器人，叫「土耳其行棋傀儡」（Mechanical Turk）。它在 1770 年出现在欧洲，能跟人类棋手对弈，而且水平相当高。它击败过拿破仑·波拿巴和本杰明·富兰克林这样的名人。很多人怀疑棋盘下面那个柜子里可能藏了一个人，可是打开柜子只能看到一堆齿轮。这个下棋机器人在欧美纵横征战了数十年。……当然，那时候可没有「深蓝」和「AlphaGo」。一直到 1857 年这个秘密才被揭开，事实是……里面真的藏了一个人。只不过因为设计巧妙，看不出来而已。

但是你能看出来当时的人对「自动的机器」有多么着迷。人们迫切想要这个东西，而且人们认为有这个东西很正常。「土耳其行棋傀儡」是个魔术，但下面这个东西可不是魔术 —— 这是「作家机械人偶」（The Writer），由瑞士钟表师皮埃尔·雅克·德罗在 1768 年设计制造 [1]。它能自己拿笔蘸墨水，在纸上写字画画 —— 如果你见过这个会写字的机器人，再见到会下棋的机器人可能就不会感到那么不可思议了吧。其实下棋和写字还是有本质区别，写字只是「自动」，而下棋需要智能。但是在谈论智能之前，我们得知道，自动，已经是一个了不起的成就。

这个作家机器人偶是怎么写字画画的呢？你必须能把那些字和画的信息存储到机器里才行。而这是通过机器人后背的一个齿轮实现的 [2]，齿轮上代表不同字母的钢片的形状决定了字母写出来什么样 —— 而那些字母是可以替换的！你换一组字母，或者换一套代表绘画笔画的齿轮，作家机器人偶就可以写出别的内容。就好像我们现在玩游戏机，换个卡带就是一个新游戏一样。

十八世纪真是个蒸汽朋克式的美好时代。如果人类一直没有发明电力，今天我们看到的就都是这样的自动机器。我们想想，像八音盒这种东西，它为什么能播放特定的乐曲？其实是一样的道理。我借用威尔逊在《生命视角》中的一个说法，这是「严格的灵活性」：操作步骤是严格固定的，但是可以接受灵活的输入，产生不同的输出。

1804 年 [3]，法国人发明了一种提花织机（Jacquard loom），它能从一个长长的打孔卡上读取信息，织出特定式样的花纹。打孔卡上的孔可以让钩子穿过去，钩子控制织线。织机是同一个织机，打孔卡可以随便更换，换张卡就是不一样花纹。打孔卡，可以说是机械化自动机器的软件。打孔卡这个技术思想在此后有广泛的应用，IBM 公司最早就是靠这东西起家的……但是，「严格的灵活性」毕竟不是真正的灵活性。打孔卡技术，距离可编程计算，还有根本性的一步。

### 2.2 第一台通用计算机

你可能不知道，第一台可编程的通用计算机，并不是电子的，而是机械的。

1820 年，英国人查尔斯·巴贝奇（Charles Babbage）把「严格的灵活性」发挥到了极致，设计了一个叫做「差分机」的东西，它可以做多步骤的复杂计算。巴贝奇的野心是用差分机计算正确的数学用表。当时公开发行的对数表、三角函数表都是人手算出来的，其中有大量的错误。巴贝奇认为人是靠不住的，这种计算应该交给机器。巴贝奇跟英国政府说，数学用表的错误会导致英国海军的计算出错，那么舰艇就出事儿，搞不好可能会沉船，现在我发明了一种机器，能做冷酷无情的计算。英国政府被说服了，真给了他一笔经费。

巴贝奇的设计包括 25000 个部件，具有强大的计算能力……但是他做了十年只完成了七分之一。而这纯粹是因为硬件技术不允许。巴贝奇必须用齿轮和杠杆实现各种运算，可是这些东西没法做得特别精细，很容易这里卡壳、那里跳线，而且零件越多越容易出问题。英国政府一直看不到成果，把巴贝奇的经费停了。巴贝奇做不出来，可是他特别能想……1830 年，巴贝奇又自费发明了一个更厉害的东西，叫「分析机」。分析机，是一个可编程的通用计算机！

分析机的神来之笔在于它把操作步骤也写进了打孔卡之中，这样计算步骤就是不固定的了，就是可编程的了。不但如此，分析机还可以根据中间的计算结果，决定下一步的计算操作 —— 也就是说，它允许程序里有「If… then… 」这种条件语句，它甚至还包括循环语句！分析机有输入部分、有计算部分、有存储中间计算结果的部分，还有输出打印的部分……分析机，是真正的计算机。

巴贝奇还有一个合作者专门给分析机写程序，可以说是人类历史上第一个程序员，而且这是一个女程序员，叫埃达·洛夫莱斯（Ada Lovelace），他俩用了十余年的时间一直在研究分析机。洛夫莱斯甚至还想到，分析机不仅能用来做数值计算，还能作符号计算 —— 它不仅仅是个「计算」机，它是个能处理任何信息的机器！……可惜的是，分析机也没做成。下面这张图是分析机的一个实验部分，来看一眼世界第一台计算机吧。

人的思想要是领先时代太多，是不是一个悲剧呢？巴贝奇因为发明数学表格的计算理论工具而得过英国皇家天文学会的金奖，他还是第一个提出「科学管理」的人。但是差分机和分析机被当时的人视为是巴贝奇身上的污点，什么实用成果都没拿出来，结果有一万两千个零件被溶解报废了。

1871 年巴贝奇去世的时候 ，《泰晤士报》甚至还专门讽刺了他一番。而通用计算机这种东西再次被人提出来，则是 70 年后的事情了。

### 2.3 现代计算机

1945 年，因为电子真空管技术条件成熟和美国军方资助，世界第一台能用的通用计算机终于被做出来了，这就是著名的 ENIAC 。ENIAC 是现代计算机的鼻祖，它奠定了所谓的「冯·诺依曼架构」。而在此之前，艾伦·图灵已经提出了可编程通用计算机的完整数学理论。

我认为约翰·冯·诺依曼是人类历史上最聪明的几个人之一。他是数学家、物理学家，是博弈论的创始人，还是现代计算机架构的提出者 —— 不过冯·诺依曼自己对此是否认的，他说这个设计是一帮人讨论的结果，他只不过负责做笔记而已。

相对于巴贝奇的设计，冯·诺依曼架构的关键改进在于它有了「内存」这个概念。负责计算的 CPU 速度很快，而从打孔卡读取计算步骤的速度非常慢，所以现在的设计是先一次性地把打孔卡的程序信息读进来，存到内存里，然后在计算过程中让 CPU 直接和内存交换信息，这就能大大加快计算速度。

从提花织机的打孔卡提供了「严格的灵活性」，到巴贝奇的可编程通用计算机，到冯·诺依曼架构的 CPU 和内存，这是非常清晰的演变。现在我们看到了，图灵再厉害，「编程」这个思想不是他先提出的；冯·诺依曼再神，计算机系统不是他发明的。计算机是这么一个不断改进的东西。一代一代的工程师提出各种各种巧妙的设计 ——

要在硬件上实现信息的数字化，人们发现应该用二进制。十进制很直观，但是要用硬件实现十进制，你的电子管就得用十个级别的电压代表 0-9 这 10 个数字，这不但不容易实现，而且很容易出错。二进制只需要电子管和存储点有开和关两个状态就行，这就大大增加了可靠性。

然后香农设计了逻辑门……我们专栏讲过，从硬件到软件的关键思想是分层。

然后你还要考虑 CPU 时钟的同步问题。如果没有「步」这个概念，各方面的计算没有协调，可能会导致两组电信号同时出现，系统就会出错。

然后你还要考虑存储信息和操作过程中可能会有各种小错误，而这就有一个自动纠错的问题……等等等等。

我就想，为什么说信息行业是个创新行业呢？因为第一，这里面的想法太密集，有太多可以改进之处；第二，改进的方向相当明确。这就是说每个参与者都知道自己能干什么……在其他领域，可没有这么好的事情。

从计算机思维的角度来说，这一讲的核心教训是你必须考虑硬件。永远都别忘了计算机是个机器，而机器有数学算法之外的、自己的特点和脾气。比如说，`x = 3` 这个语句，在数学上的意思无非就是变量 x 的值是 3，是一个事实陈述。但是对编程来说，这不是一个陈述，而是一个动作：是把用 x 标记的那一段内存位置，赋值为 3。机器不理解你要说的事实，机器只会按你的指令做各种动作。我们在编程的时候要 debug，要想办法控制内存，要提升计算性能，就必须考虑硬件自身的特点。

今天我们用的一切计算机，包括手机、汽车、凡是通用计算机，就都是冯·诺依曼架构。当然冯·诺依曼架构不是唯一的可能性。现在人们正在研究新的架构，比如量子计算机和神经网络计算机 —— 那些东西有自身的编程特点。不过在我看来，巴贝奇要是看到今天的计算机，是不会感到特别惊奇的。

参考文献：

[1] [故宫中两百多年前的写字机器人堪称 AI 鼻祖，打脸许多当代书法家](https://www.sohu.com/a/253593989_776727)

[2] http://news.ifeng.com/a/20170820/51695992_0.shtml

[3] 《计算机思维》说打孔卡提花织机发明于 1700 年代早期，我调研了历史，认为是作者写错了。

## 0403. 计算机思维3：全新的科学

今天我们继续讲《计算机思维》这本书。我们要讲一个发展建设的故事 —— 不过这里发展建设的不是一个公司也不是一个国家，而是一门新科学。我希望这一讲能增加你对「学问」的亲近感。

你有没有过这样的想法：现在各个学科都要用到计算机，那为什么还要有一个单独的「计算机系」呢？这是大学在蹭一个浮夸的热点吗？是为了应对市场对程序员的巨大需求吗？不是。计算机科学系，不是给程序员提供职业培训的地方。计算机科学系是研究计算机的地方。我们来讲讲「计算机科学」是如何发展壮大的，它为什么是一门「科学」。

不要低估天下英雄。不要以为只有像爱因斯坦的广义相对论才算了不起。计算机科学里，也有层出不穷的高妙思想……这是一个想法产生技术，技术刺激想法，想法又产生新想法的故事。

### 3.1 自然科学的荣誉感

从外面远处看一个很大的东西，你容易把它当成一个整体；而如果深入其中，你会发现它的各个部分之间存在严重差别。比如外国人在中国以外谈论中国，中国是一个标准化的形象 —— 但是咱们中国人知道，中国的各个地区发展很不平衡，中国很复杂。大学也是这样。对一般高中生来说名校都很厉害，都是有光环的地方。而真正身处大学里面，它的各个科系其实是有区别的……这里面有个格调问题。教授们常常互相瞧不起，学科之间有个鄙视链。

当然你也可以说这是「对小区别的自恋」，但这个小区别是存在的。我以前上大学的时候，有一次有个从美国回来的人作物理报告，讲的是用计算方法解决物理问题。听完报告后，有个我很佩服的老师私下对我说，那人搞的东西「不是学问」。这位老师是个理论物理原教旨主义者，认为只有超弦这种东西才是真学问，计算物理只能算是玩花活。

我不是搞超弦理论的，但是我完全能理解这个态度。这是科学家的荣誉感。而在所有学科之中，自然科学能给人提供最大的荣誉感 —— 理解自然现象，是最纯粹科研趣味。比如我们前面讲过「快速射电暴」这个现象 [1]，老百姓对它感兴趣是因为把它当成了外星人发的信号，而在科学家看来，就算它跟外星人没关系，只要它是一个我们尚未理解的自然现象，它就是有意思的 —— 因为这是大自然本身的东西！

反过来说，如果你研究的是某款电动汽车的发动机，你搞了一个什么技术革新，哪怕这项革新有潜力带来巨大的利润，那也对不起，你这个入不了科学家的法眼 —— 因为它不是一个自然现象。你研究的是一个人为的东西。也许在这款电动车的架构之下有这个问题，换一个平台，可能你这个问题就根本不存在。所以这个鄙视原则是 ——

```
自然的 高于 人为的
```

那我们想想，「计算机科学」，是自然的还是人为的呢？

1962 年，普渡大学建立了美国第一个计算机科学系，紧接着斯坦福大学也建立了一个。按当今中国的实用主义价值观来说这肯定是好事儿，但是在当时，可是引发了很大的争议。其他系的教授们纷纷声讨，说「计算机科学」算什么学问，何德何能，居然要开山立派成立新系呢？当然这个灵魂诘问的背后还有一个利益的争夺。成立新系会把其他系的学生、经费和人员编制分流出去，等于是在削弱现有的系。电子工程系的教授完全可以说，我们也可以教计算机课啊？

这就给早期的计算机科学造成了一个重大的选择压力。计算机科学系要竖旗，就不能仅仅是一个培训程序员的地方。计算机科学家必须在企业研发之外，搞出一些有学术味道的东西，得有拿得出手的发现、能提高大学的声望才行。其实他们不用担心。事实证明，计算机科学里中有太多拿得出手的发现了。

### 3.2 从技术到科学

人们研究计算机的初衷，无非是想实现自动化，搞自动计算或者自动控制，解决生产力问题，计算机是一个技术。但是计算机科学一旦成型，它自身的发展就跳出了纯技术的维度。《计算机思维》这本书列举了计算机科学的各种进步，请允许我大言不惭地做个总结，我认为它的发展可以分为三个方面 —— 初级，是怎么更好地实现自动化，主要解决应用问题；中级，是研究「计算」这件事儿本身，上升到了类似于自然科学的层面；高级，则是把计算思维用到其他科学领域中去，是带给人认知的升级。

咱们先说初级，也就是自动化。1940 年代刚刚发明电子计算机的时候，大家都使用所谓「汇编语言」，是让人说机器的语言 —— 直接把机器指令写在打孔卡上，给计算机读取。这个做法对人的要求实在太高了，费时费力不说，还特别容易出错。那么一个自然的需求就是，能不能让人按照人容易理解的思维写程序，然后把写出来的程序自动翻译成机器语言呢？

这就是所谓高级编程语言。1957 年，Fortran 语言被发明了，这是一个科学计算语言，特点是特别容易写公式。1958 年，LISP 语言出现，这是一个极其强大的符号处理和逻辑运算语言，甚至可以用于人工智能设计。1959 年人们又发明了 COBOL 语言，用于商用数据库编程。

然后要方便人们在一台计算机上操作，你就得有账号管理，得安排不同的程序同时运行，那么你就得有操作系统，你就得有系统思维。要想开发出来的软件好用、可靠、容易维护，你就得有工程思维。接下来还有了互联网，你需要网络思维和安全思维。

所有这些自然生长出来的东西都是学问。再进一步，编程「思想」也在演化。传统编程语言是线程式的，程序员思维模式是操控计算机。后来要把软件做得很大的时候，出现了「面向对象」的程序设计。这是不一样的思维模式，程序员想的不再是操控计算机这一台机器，而是「类」和「对象」：每个类和对象就好像是一个小机器一样，是这些虚拟的小机器之间在互动。

那么随着编程语言的发展，同时计算机硬件也在变得越来越快、越来越普及，基础教育界就把编程技能，看得和阅读、写作和数学一样，被认为是人人必备的第四个技能。但这些还都是比较浅层的计算机科学。

### 3.3 从计算自身到「计算宇宙」

计算机科学真正成熟的标志，是「计算机」这个东西，和「计算」这个行为本身，成了研究的对象。

1967 年，三个计算机科学家在《科学》杂志上发表了一篇文章，说现在计算机科学已经称得上是一门真正的科学了：就好像动物学研究动物、植物学研究植物一样，计算机科学，研究计算机。我以前听过一个说法，说真正的程序员，都认为计算机是有生命的。你得把计算机当做一个独立存在的东西才行，它有自己的脾气，有自己的特性和性格。要想操作好计算机，你得像动物学家理解动物一样，去理解它才行。

这个感觉对外行来说可能有点奇怪。难道计算机不是人类设计制造的吗？怎么人类还不理解计算机呢？但事实就是如此，你能设计它制造它，你可不一定就完全理解它。发明围棋的人并没有完全理解围棋。也许计算机是人类释放出来的一个怪兽！比如说，如果几个用户同时使用一台计算机，操作系统必须给他们分配计算机 CPU 时间，那如何分配呢？你在理论上设计得再好，不上机去测试一下就永远不知道结果会是怎么回事儿。你得把计算当成一个生物，在它身上做实验。

与此同时，「计算理论」也在发展。给你一个问题，你能不能估算一下它的难度有多大。计算理论最关心的是，随着问题复杂度上升，计算时间是线性增长呢，还是指数增长？如果是线性增长，我们认为它是一个「简单」问题；如果是指数增长，它就是一个「难的」（hard）问题。

1-2『算法的「复杂度」概念，随着问题复杂度上升，计算时间是线性增长呢，还是指数增长。补充：算法复杂度，之前在王铮的算法专栏课里也看到了，做一张术语卡片。（2021-05-04）』—— 已完成

难的问题，计算机就帮不了太多忙。你就得想点别的办法。那么给你一个复杂问题，我们怎么把它算法化，怎么拆解它？解决这个问题的信息结构应该是什么样的？什么样的问题是可计算的，有没有什么问题是不可计算的？再比如说假设现在有了算法，我们能不能优化这个算法，来提高运算速度呢？再比如如果让你凭空发明一个编程语言，你应该怎么做呢？这些问题似乎像是工程上的，但又带有很强烈的数学味道！其实它们本质上是数学问题。现在有很多应用数学家就在专门研究这些问题。

到 1990 年代，计算机科学的江湖地位就算竖立起来了。人们甚至提出，计算，是在传统的理论和实验这两条路之外，第三条科研道路。但是紧接着的发展超出了计算机科学家的预料……其他学科，开始抢占计算机科学家的地盘。人们突然意识到，「计算」是个非常基础的逻辑，到处都是计算。生物学家说，DNA 就是一个计算系统，DNA 复制就是计算操作，生命本来就是一个计算现象！我们要用计算的眼光来研究生命。

物理学家也可以说，基本粒子的运动就是信息交换啊，物理定律就是计算。甚至有人提出，整个宇宙就是一台计算机 —— 我们很有可能是生活在一个计算机模拟之中。这个思想我们专栏以前讲过 [2]，其实缺乏足够的证据支持。但是我们现在想想，如果没有计算机科学，人们再怎么想，也很难想象宇宙是一台计算机 —— 你根本就不会有这个概念！

所以说，计算机科学绝不仅仅是解决自动化问题的学问，它还有计算机和计算理论自身的学问，它还给我们提供了一个非常不一样的观察世界的眼光。你是不是体会到了一点学术的魅力。一门科学就好像有生命一样，它不但要发展壮大，而且要在不同的维度上发展壮大。计算机科学就好像一棵树，它不但越长越高枝繁叶茂，而且在成长的过程中这棵树本身还在脱胎换骨，你过段时间一看树的材质都和以前不一样了。然后这棵树还影响了别人的认知，让人反思到底什么叫做「树」，甚至怀疑自己和整个世界就是一棵树……

咱们还可以把计算机科学跟那些幻想小说里的魔法和修仙的世界做个类比。这门学问的发展，就如同一个人刚出道的时候被人看不起，但是他有很多奇遇，今天学个大招明天升级一项技能，然后过了几十年换了筋骨，再过几百年居然成仙升天了 —— 同时他还带给我们一个全新的世界观……只不过，真实世界里学问的奥妙，比魔法世界那一套更复杂也更精彩。我看修计算机这个事儿，一点都不比修仙低级。

注释：

[1] 精英日课第三季，《外星信号的思维模型》。

[2] 精英日课第二季，《宇宙是计算机吗？（上 | 下）》。

## 0404. 计算机思维4：工程的复杂

这一讲我们要说一个特别厉害的技能，叫做「软件工程」。以我之见，软件工程，可以说是工程管理和综合治理手段的极限。我希望你能从这一讲体会一下如何治理最复杂的系统。

可能你是一个产品经理，主导开发过一款 APP。可能你是个企业家，管理一个几万人的大工厂。可能你是个土木工程师，设计过一座跨海大桥。你非常厉害，咱们中国有很多这样的厉害人物。中国是手机 APP 开发大国，中国有很多超大型企业，中国有全世界最长的跨海大桥 ——可是为什么中国就没有属于自己的计算机操作系统呢？为啥国产芯片不行呢？因为那些事儿，跟现代软件工程相比，还只能算是简单的事儿。

程序员、CEO、计算机科学家，如果是拍一个超级英雄电影的话，这些人都可以是前台的英雄人物。但是躲在幕后操纵世界的，则将是一位、或者几位，软件工程大师。有句话叫「在计算机科学里，软件工程这一部分，对计算机科学家来说太难了。」不了解软件工程，你就不知道什么叫「大」，什么叫「复杂」。

1『写脚本类的小软件和开发大软件不是一个概念，关键是尺度问题。』

### 4.1 小和大

编程是个非常适合自学成才的项目。很多人不是科班出身，自学编程技术，也容易找到一个程序员的职位，甚至还可以自己开发一个小软件。但仅限于「小」软件。比如你可以自己写一个电子邮件客户端程序，或者写一个视频编辑工具。可是如果要开发一个超大型软件，其中涉及到的学问，可就不是自学所能达到的了，那是需要在重大项目的实践中去领悟和提高的。自学也许可以让你成为一个优秀的侠客，而伟大的将帅，则只能用千万士兵的鲜血铸就。

这里面的关键是一个尺度问题。大，是不一样的 [1]。计算机刚刚出来的时候，程序员都是身上有修士气质的手艺人。编程者经常是孤独的，能说天书一样的语言，想法高深莫测，写出来的代码仿佛有一种暴力美学，他们的眼睛跟显示器一起在黑暗中闪闪发光。编程，是一项神秘的技能。

那时候的程序都是完全自由的 —— 计算机很贵，而程序不要钱。程序员们就好像十九世纪的艺术家一样，偶尔弄个俱乐部或者小作坊，彼此欣赏。不过这个艺术时代并没有持续多长时间，程序员们很快就陷入了极度的悲观情绪之中。因为……错误。

写代码太容易出错了！代码越写越长，出错的频率不成比例地增加。可能你今天费了很大力气好不容易运行通过了，过了几天、遇到一个没想到的情况，发现还有一个隐藏的错误。有个程序员甚至说，他意识到，也许他的余生，都要在纠正自己的错误中度过……程序员们终于明白，他们需要工程师思维。

我们之前讲了一些计算机科学的思维，而工程师思维和科学家思维至少有三个重大区别。

1、科学家是寻找事物的规律，而工程师是去设计一个东西。科学家只要觉得这个规律有意思就可以发表，而工程师得负责任。他得确保这个东西不但要有用，而且还得安全不出事，还得考虑成本，讲究可行性，让人用得上还用得起才行。

2、对知识的态度。科学家面对知识，是把自己当成一个没有利益攸关的旁观者，感觉看懂了、能总结出规律就行。而工程师，则是参与者。他不能仅仅「懂」这个知识，他是要拿来用的。

3、对模型的使用。科学家喜欢简化的模型，能抓住实质就行 —— 爱因斯坦有句名言说「什么东西都要越简单越好，要简单到不能再简单为止」。而工程师必须考虑所有的细节，「魔鬼在细节中」是工程师的座右铭。

2『科学家思维和工程师思维的 3 个区别，做一张主题卡片。』——已完成

要把写程序上升到工程的高度，跟以前那种兴趣爱好式的编程可就完全不同了。更进一步，软件工程和传统的工程也不一样。比如你要修个桥，工程过程中哪里犯个小错误，通常也就是小错误 —— 最多也就是让大桥的质量降级。这座大桥总共有 15 个桥墩，其中第五个桥墩有个地方没建好，这座桥大致上还能用。但软件就不一样了，程序中的一个小错误很可能就会导致整个系统的崩溃。

这是为啥呢？因为软件不但各处的关联非常密集，而且是个「活」的东西。比如发射火箭，软件是要控制火箭做动作的！哪个动作不对，火箭立即失控。所以软件不但是个工程，而且比传统工程难得多。那怎么应对这种复杂呢？

### 4.2 小思维

早期的软件开发者想出了很多工程化的办法，起到了一定的效果。比如以前都是用汇编语言，后来发明了高级编程语言，程序员就不容易出错……当然，这时候也不需要程序员个个都有修士的气质了。

最重要的一个方法，是把常用、好用的代码「封装」起来，重复使用。如果这段代码总是被用到，已经被大家测试过很多次了，证明没有毛病，那就不要再改来改去搞定制了，我们应该把它封装成一个「库函数」。库函数具有标准化的输入和输出，程序员下次再用的时候只需要照顾好输入输出，而不必关心函数内部是什么情形 —— 这就能大大降低出错的概率和提高编程的效率。

封装这个思想可以用在软件的各个方面。数据结构、面向对象的编程、文件系统，这些都是封装和分层。这一层的编程不用考虑底下一层的逻辑。操作系统的内核也是一个类似的智慧。操作系统把最常用的操作计算机的动作，都事先在内核中预备好，而内核经过千锤百炼，不容易出错。等到别人写应用软件的时候，用到相关的动作，就只要调用内核就行，而不必自己直接操作计算机。这就相当于把专业的事儿交给专业的人，也就不那么容易出错了。

所有这些思想都要求对软件开发有个宏观的设计，而不只是吭哧吭哧写代码。然后你还得考虑多个人一起开发一个软件的情形，比如最起码得有个版本控制之类。到这一步，软件业才算正式成了一个行业。在上世纪五十年代，就已经有公司专门开发软件卖钱。……可惜这些还远远不够。

软件业从一开始就不是一个做事漂亮的行业。项目总是再延期。好不容易交付了，软件卖出去之后又总是被人发现各种毛病和错误。客户不满意，可是如果真要搞什么售后服务，到现场去给人解决问题，那几乎就是不可完成的任务……而且还有黑客攻击、还有计算机病毒！

我很早以前听过一个笑话，说一个软件工程师嘲笑一个汽车工程师，说「如果汽车行业像计算机行业一样发展，现在汽车应该一毛钱一辆。」但是汽车工程师不以为然，说「可是谁会要一辆动不动就抛锚的汽车呢？」而早期的软件公司，对此只有两个不是办法的办法。一个办法是尽量去找那些经验丰富、头脑聪明的高水平程序员……一个办法是销售软件的时候干脆附带一个免责声明：如果因为这个软件的毛病给您造成了损失，我们概不负责。社会对计算机的美好幻想被打破了，软件行业陷入了危机。

### 4.3 大思维

软件工程的问题不是你每年能培养多少高水平程序员的问题，而是复杂性问题。小软件和大软件的根本区别在于尺度。以前一个小软件只有几千行代码，现在一个大软件要有几百万行代码。以前的软件是给一个人用，现在是多个用户共同使用一个软件。更重要的一点是，以前的软件是一个人或者几个人开发的，现在则是大型团队一起开发。

计算机思想家弗瑞德里克·布鲁克斯（Fred Brooks），曾经在上世纪六十年代末率领 IBM 公司 300 人的团队开发操作系统。他做完这件事之后很有感触，为此专门写了一本书，叫《人月神话》[2]。布鲁克斯提出两个感慨。1）1 个人干 12 个月的活，绝对不是 12 个人在 1 个月内能干完的。项目用的程序员越多，平均每个人出活的速度就越慢。所以你规划项目的时候不要算什么「人月」。2）你这个团队做出来的软件的结构，往往和你这个团队的人员组织管理结构高度相似。所以软件工程不但要管项目，还要管人。

布鲁克斯这本书出来，人们才充分认识到软件工程的难度。现代软件工程要求，软件产品必须达到下面这五个目标，称之为「DRUSS」 —— 1）Dependable，可信赖，让顾客真能指望上你这个软件；2）Reliable，得可靠，不能总出毛病；3）Usable，软件是给人用的，得让人能够上手；4）Safe，用的时候不能出安全事故；5）Secure，它得不容易被黑客攻击才行。

现代主流操作系统，包括 Windows, Mac 和 Linux，各自都有接近一亿行代码，而且大致实现了这五个方面的要求。而即便是这三个可以说是最成熟的软件系统，其中仍然还有大量的毛病。那怎么才能获得这种大型软件工程的能力呢？我们前面说的办法都还是小软件思维，剩下的，就只有一些经验之谈，而没有什么特别系统的行动指南了。

比如说，在系统安全方面，软件开发的首要原则是默认不给用户授权。如果非要授权用户接触一个什么东西，就必须得有显性的授权；每个程序进程只能拥有最有限的授权，等等。软件工程就是由这些原则、工作中遇到的规律、前辈传下来的经验组成的。

技术进步能解决一定的问题，比如更多的分层封装，搞虚拟机，客户端和服务器，高级编程语言，交互式开发环境，可视化的控制和数据流，更好的操作系统等等……但是技术解决不了所有的问题。

1987 年的时候，布鲁克斯写了一篇文章叫《没有银弹》[3]，又提出一个洞见：软件工程的根本问题，是人的问题。主导软件开发的这个人，必须得能够理解高度复杂的东西才行。写程序是永远在更新的技术，软件分为很多层，会出现各种毛病，你得确保产品满足 DRUSS 五方面的要求，你得操很多的心……你得能驾驭复杂。像这样的人才，都是绝对的帅才。这就好比带兵打仗，你不用说指挥十万人打仗，你能把十万人安全带到战场，不哗变、不闹事、都能吃饱饭就不错了。

2『已下载论文「2019038No-Silver-Bullet」并存入 Zotero。已下载书籍「2019655人月神话 | 2019655Mythical-Man-Month」。』

布鲁克斯有句名言是这么说的 —— 好的判断来自经验，而经验来自坏的判断。（Good judgement comes from experience, and experience comes from bad judgement.）

正所谓一将功成万骨枯，驾驭大型软件工程的能力，只能通过大型软件工程培养出来。我们前面讲《生命视角》的时候说过，有些创新能力难复制 —— 因为它是长出来的。我们中国有很多软件开发者，但是我们缺少操作系统这种级别的大型软件开发积累。我们有几代程序员试炼出来的库函数吗？我们有 Windows 3.1，Windows 95 的种子吗？我们有前辈开发者总结出来的原则、规律和教训吗？我们有自己的标准和规范吗？软件每天都在更新，但软件工程的背后，是一棵经年累月长出来的大树。

我们这一讲正好赶上最近美国要封锁华为公司，而华为正在搞自己的手机操作系统。在软件工程上另起炉灶是一个几乎不可想象的任务，但是如果真有那样的机会，那就是现在。咱们倒要让美国人看看，中国公司有没有驾驭复杂的能力。

注释：

[1] 精英日课第一季，《一个大尺度的话题》。

[2] Frederick Phillips "Fred" Brooks, Jr，1999 年图灵奖得主。《人月神话》（The Mythical Man-Month: Essays on Software Engineering，1975）是软件工程的名著。

[3] Frederick Brooks, No Silver Bullet – Essence and Accident in Software Engineering, 1987.

### 黑板墙

危险与机遇并存。2018 年 4 月，在中兴通讯事件闹得沸沸扬扬之时，梁宁老师写了一篇长文，《一段关于国产芯片和操作系统的往事》，文中讲述了 20 世纪初，一些致力于中国芯片和操作系统开发的英雄们，以及他们身后的悲情故事。方舟科技做完 CPU 后，又做出了公板。北京市顺势而为，发起了「扬帆计划」，针对 Linux 桌面的 13 大类 50 多个问题，在全国进行招标。就在一切形势大好之时，却遭遇了大崩溃。梁宁老师一针见血的指出了问题所在，这里面有政治的因素、有生态的因素，更重要的是思想的因素。

1、政治因素。为了「中国芯」，北京市还干了那件圈子里著名的事 —— 北京市政府办公软件选型，把微软踢出局。那件事 IT 圈轰动一时，微软中国总裁高群耀辞职。不过让人遗憾的事情发生了，基辛格给当时是北京市长写信，为微软说情，向政府施压，后来还上升到了国家层面，导致「芯片」被搁置。

2、生态因素。CPU／芯片能做出来，但搞不定的是操作系统，差距大的是「生态」。当年，绕得过 Intel，跨不过微软。如今，绕得过 Arm，做不出安卓。全球无数团队，基于安卓在源源不断地创意，开发新的应用，不断繁荣、优化这个生态。

3、思想因素。一方面，用户迁移成本过高，面对同样的操作系统，所以不愿意更换。另一方面，政府束手束脚，担心失误、害怕犯错的为难情绪导致这一领域成为「真空地带」，相比「新四大发明」，政府在自主知识产权的「CPU＋操作系统 + 核心办公软件」方面投入不足。

如今，好像又回到了 20 世纪初的那个起点，历史给了我们再来一次的机会，华为的 5G 通信技术正在全球铺开，同时也在加大自主操作系统的研发力度。事情是惊人的相似，但环境已经改变。「要打便打，愿谈则谈」的态度，表明了国家的立场，改革开放 40 年来积攒的工程师红利有待释放，国人的爱国热情早已被点燃，容错机制的出台也为能干事想干事的官员们提供了试错的舞台。可以说，危机之时，既有危险，还有机遇。最危险的时候，恰恰也是最有机会的时候。就像万老师所说：「咱们倒要让美国人看看，中国公司有没有驾驭复杂的能力。」2019-05-20

当年 iPhone 刚出来不久的时候，我在公司总部负责开发手机游戏，公司总部在北京，各地有几个分公司，都派出团队来参与，当时做的还都是小品级休闲游戏，平均三个月一款，后来发现不太容易赚钱，厦门分公司的团队就决定这次要来个大的，结果就是一再延期，做了八个月后，公司总部终于不耐烦了，要把整个团队砍掉，我说大游戏是需要这样的时间，而且这个游戏是有机会的，总部说除非你亲自去厦门坐镇，我当然说可以，在厦门常驻了四个月，又把原本的单机游戏加入了网络对战功能，结果游戏上线三天，就冲到了中国畅销区榜首，可是没高兴两天，就发现因为后加的网络对战功能，数据都是存储在本地，用户只要越狱了手机，就能修改数据，从而在 pvp 中把付费用户打得落花流水。然而结构已经不可改变，所以在这款游戏的生命周期里，始终进行着和黑客之间的攻防战，而且是必须对方出招后，这边才能去堵漏洞。好在整体来说还是赚了钱，于是接下来的产品，就要求数据计算都放在网路端了。2019-05-20

经过多次测试稳定好用的程序，稍微改一点或放到别的项目里用，表面看起来没什么稳定。但真实经历是往往有很大问题，而且总能出人意料。一个实例是这样的，公司一款产品，架构师设计就是只能单设备登陆（可以理解为 A 手机登录了微信，一旦 B 手机也登录这个微信号，那么 A 手机的微信就会掉线退出），并且和老板做了汇报说明，老板也同意了。产品做出来了，一个大用户上手测了下，然后被其他人登录了一下。这个用户截了一个被挤下线的图给老板，意思是这个体验不好，还被挤下线了，表示有点生气。老板就叫架构师和相关人等说，必须要支持多设备登陆！下面的人想解释，但老板看来这是一个非常简单的需求。事就这么定下来了！甚至于一个月几百万研发费，这点小事情还解决不了吗？做事的人只能瑟瑟发抖，然后商量怎么改。

故事已经说完了，也是真实故事！类似的事情也多不胜数。表面看起来很简单的事情，下面复盘一下这个案例中的坑点。因为公司之前被黑客，爬虫等攻击过。所以这个项目安全性想做好点，架构师设计了一套一个用户登陆会产生一个 token，token 随时会变以避免可能的账号被盗，抓包，数据泄露等等问题。这样设计的一个先决条件是单设备登陆，这样 token 唯一，且随时会变，安全性大大提升。新需求完全破坏了这一套架构，且 token 也不可能唯一了，或者唯一也失去了意义。新的需求本身来说确实和表面一样看来很简单，但无形中改变了原有设计和架构。这是很坑的，会埋下很多隐患和坑点。短期可能完全看不出什么问题，但几年下来，类似事情发生多了。某天系统崩溃，工程师奋力修复，找到原因后心想坑爹的需求！产品和管理层心想，坑爹的程序员！客户心想坑爹的产品。

曾经在设计产品的时候，自以为想到了方方面面，可能变化的方向也以为都考虑进去了。真实情况是不出三个月脸就被打的啪啪响。一个产品确实很难在一开始就考虑到后面的路线和变化。可能经历比较多，所以这节感触多点，也体会深一点。英特尔芯片最近也爆出很多漏洞，足以说明一个工程的难。一个问题，微信只是一个 App，但微信有 11 亿用户，且日活很高。微信算是大的软件工程吗？2019-05-20

软件是一个复杂工程，一款 APP 能做到非常出色已经非常不容易了，但跟复杂的软件比起来，还是相对简单的。因为工作关系，作为乙方的工作人员，我接触过很多甲方企业的软件（尤其是管理供应商的软件），最大的感触是：要找到一款使用体验非常好的大型软件真的好难好难，要么对系统和浏览器有着严格要求，要么操作起来非常卡顿和不流畅，要么还有其他各种小问题。这些软件都是大公司开发的，所以我经常有的感受就是，大公司开发的软件也不过尔尔……但实话实说，想要驾驭一款大型复杂软件的开发工作是极具挑战的，它不是任何一家相关公司就能完成的。那些我自己觉得非常不好用的软件，应该已经达到了「DRUSS」，他们也尽了全力。就像文末说的，现在是考验我们国家的时候了，确实要拿出「是骡子是马，拉出来遛遛」的决心，看我们是否真的可以驾驭复杂。只有去做了这件事，才能检验我们到底没有有真正的实力。2019-05-20
 
因为本人从事相关行业的工作，所以本人对于软件工程的复杂有一定的体会。举个例子说明下，就像我们的新华字典，从发布到现在经过了多少代，依然不能确保里面没有一个错误。一个软件工程师的工作技能就像是人体的免疫系统，是经过数百万年的进化形成的，无论面对什么样的问题，都可以产生对应的免疫细胞。所以这个事情很难教会别人。但是随着现实中不断出现新的问题，所以软件也需要不断的升级换代，就像人类总是对感冒没办法一样。软件工程师都是在一个个的项目里面锤炼出来的。有的工作可以允许误差，比如说字典，就算有一些错误但是不影响人们使用，但是像系统软件这样的工作，有一点错误就会让软件报错，实际上报错还是显示出来的错误，我们发现的话可以及时处理，特尴尬的一类错误就是我们根本就不知道错了，一直在使用，等到计算结果和现实出现冲突的时候才可以知道，这类错误往往无处下手。2019-05-20

本职是产品经理，对技术有一些了解，过去两年担任技术部门的负责人，谈一些工作上的事：1）实现一个同样的功能，每个人的代码写法都是不同的，且他们都觉得自己写的方法是正确的，你可以管理功能实现的逻辑但是你无法管理代码如何写，所以人很重要，一个靠谱的程序员能用可靠的代码实现你的逻辑，一个差劲的程序员就仅仅是实现了这个逻辑，一丁点变化都无法适应。2）合作开发项目很头疼，一个项目如何拆分工程、不同的人写出来的东西如何兼容、甚至不同人引用了不同的库，每次代码提交托管都得有专人去合并一整天。3）越大的项目数据以及功能的耦合度越高，那是真的牵一发动全身，一个字母写错了整个软件跑不起来。2019-05-20

## 0405. 计算机思维5：设计的境界

上一讲说的是软件工程，这一讲的主题是软件设计。说到设计，你是否曾经「发布」过什么东西呢？ 你背着人，自己暗中设计和创造一个作品，各种情况考虑周全、反复检查之后，选定一个时间，拿出来给大家看。

在校学生经常做这样的事情，比如参加表演、作报告、甚至交作业也是一种发布。工作中并不是所有人都有这样的机会。如果你没发布过东西，我建议你尝试一下这个体验，哪怕是做一桌子菜请朋友吃也算。我们在得到做这个专栏，发布是我们的日常工作。但是我们每一次发布都很兴奋，就好像天天发射火箭一样。我每次把文章提交给主编的时候，不是感觉任务完成了，而是充满期待感，简直是盼着读者看到。发布，是尽最大努力，呈现一个最好的东西的行动。发布能刺激我们完善自我。

当然我们见过很多低水平的发布。很多人只是例行公事交作业而已。有时候看学校的文艺表演，有的孩子上来弹个琴，的确是有板有眼好像都做对了，可是你坐在那里就觉得差了点什么东西。差什么呢？只会演「对」的人，关注的仅仅是他要发布的这个东西本身；而能演「好」的人，会有意识地跟观众和环境配合。

### 5.1 软件工程和软件设计

软件工程要克服的最大困难是怎么确保不出问题，它的主题大约是「实现」 —— 要忠实地实现各种要求。从软件工程角度来说，开发一个软件应该按下面这个流程走 —— 1）确认需求；2）把要求具体化，设定各种目标参数；3）进行开工建设；4）做好之后接收和测试；5）交付给用户。

想要顺利完成这个过程是很不容易的。一般来说，差不多有 1/3 的项目能按时完成；1/3 的项目会超时、超预算完成；还有 1/3 的项目则干脆就完不成。其中的重大困难当然是软件这个东西实在太复杂，里面有太多的模块和接口，千头万绪难保不出问题。而另一个问题在于，上面这个软件开发的流程，把用户给忽略了。很多项目是在把最终产品交付用户之后，你才有可能得到用户的反馈，可是那时候已经晚了。工程师在开发软件过程中接触不到一线用户是个大问题。你不知道用户到底是怎么用你这个产品的。

我以前看过一个报道，说某个软件公司，邀请一些真实的用户到公司来当场操作他们的软件，让自己的工程师围观。工程师们一看，原来用户使用软件的方式，和他们设想的非常不一样。比如对有些操作，明明软件提供了方便的做法，但是用户不知道；有时候用户绕来绕去很麻烦才能做一个动作。工程师纷纷表示，哪怕只看十分钟真实用户使用软件的场景，都能让他们马上就想到好几个改进软件的办法。

这就引出了软件设计的思想。软件开发是实现功能和需求，软件设计则要考虑用户想要什么。软件设计方面基本的做法，一个是做好用户调研，深入了解用户的需求；一个是借鉴那些成功的设计都有哪些规律；还有一个叫「敏捷产品管理」，要求在开发的每个环节，都让用户介入进来，根据用户的反馈快速迭代。这些做法都是要把用户融合到整个开发的过程中去……但是，这还谈不上是软件设计的精髓。

### 5.2 设计的新思维

没参与过创作的人很难理解设计有多重要。我突发奇想要一个功能，你给我实现一个功能，很多人以为难度和技术含量都在实现上，其实不然。知道该要什么功能，非常关键。

软件设计是一个激进的思维方式转换。以前的软件工程思维，是关注于功能和实现；现在的设计思维，则要求我们要考虑到用户和产品应用的环境。软件设计和一般产品的设计还不一样。一般产品让你感觉好用、好看比较容易，可能最多考虑一些人体工程学之类。而软件，跟用户是交互式的关系。用户会在软件中做出各种行为，软件是让用户活动的地方。

软件设计的目标，是创造一个虚拟世界。比如游戏就是一种虚拟世界。我们在游戏里能获得沉浸式的体验，就好像自己真的生活在游戏世界里一样。创造游戏世界，显然需要有美术，要有环境，要有历史背景和故事，还有人物形象、武器、魔法、战斗动作等等，这些都是设计。但这些都是浅层的。

深层的设计包括游戏规则和游戏的平衡性。游戏里也得有操作守则和玩家的社会规范，明确什么能做什么不能做，得体现价值观。为了保证可玩性，玩家争胜的策略得讲究平衡性和可持续发展。你得让各个种族和职业的实力比较均衡，不能出现一个种族独大的情况。你还需要游戏世界有一个比较稳定的社会经济。

像这样的设计需要专业的人才。我看有些游戏是专门聘请经济学家来设计游戏里的金钱系统。但这个「虚拟世界」说的不仅仅是游戏。所有软件应用都可以说是提供了一个虚拟世界。社交网络、淘宝购物、滴滴打车，这些应用里都要有规则，有奖惩机制，有社会规范，要体现的价值观，更不用说用户界面和美术形象之类了。哪怕是单人应用，比如使用办公软件写个文档或者做一个财务报表，也是处在一个虚拟世界之中。你给人提供的这个世界得是完备自洽的，得在逻辑上能说得通，让人感觉很真实，各种动作很流畅才行。

软件设计，可以分为六个等级。

-1 级，是流氓软件。这种软件不但不安全而且很可能专门留了收集信息甚至攻击系统的后门，而且完成度很低，一堆 bug。但是这样的软件也有很多人用，或者是用于从非正常渠道下载什么东西，或者适用于什么点击广告赚钱之类，用户一般都是被引诱来的。而用户心里也都知道这种软件是不可信的。

0 级，是轻蔑的满意。基本上可以用，但是大家都知道其中有很多问题，也不怎么安全。这种软件一般是为了抢占市场而匆匆推出的，消费者为了使用软件提供的功能，也就认了。

1 级，是软件能够满足基本的需求，比较可靠。

2 级，就要提出表扬了，软件能跟环境和用户使用习惯达到完美配合。比如我们去银行的自动提款机取钱，你不需要学习它怎么用，凭直觉就可以直接使用。该有的功能它都有，而且非常可靠。要做到这一点，开发者必须对用户、社会文化背景和社会规范都有一定的了解。

3 级，是软件能主动规避负面的结果。这就要求设计者不但要满足用户正常的需求，还得事先把各种怪异的用法、极端的情况都考虑到，确保软件在任何情况下都没有故障。如果有黑客攻击怎么办？如果有病毒怎么办？流量突然暴增怎么办？你预判将来可能会出现什么问题，留下充足的应对空间。然后一旦出问题，你还得能快速反应。这个能力已经不是一般意义上的软件工程思维，必须结合设计思维才行。

4 级，也就是最高级，是这个软件能给用户带来喜悦。这意味着软件超出了用户的预期，让人用上之后会迫不及待地想要把它推荐给别人。

达到这个级别的软件，超出了当前用户的认知。凡是能做到这一点的，都曾经是一个传奇。Unix —— 包括后来的 Linux 操作系统，绝对是传奇。我上大学的时候第一次接触 Linux，其实我用的很有限，但真的是有认知升级的感觉。没有什么花哨的界面，很多商用软件和游戏都不能用，但是 Linux 是一个跟 Windows 完全不同的世界，更简单，更丰富，更深刻，可以说其中有「道」 —— 我感觉用 Linux 的时候是在跟一帮比我聪明得多的人打交道，好像把我也带得变聪明了一点。

我在 Linux 面前总是谦卑的。这和用某「音」刷视频完全是两码事。不过好的软件不一定非得让人谦卑。苹果的系统、微软的办公系列、地图导航、Kindle 阅读器、魔兽世界这个游戏，包括现在的打车软件，都给人提供了一种以前根本不存在的东西。没它的时候你觉得日子也是这么过，可是一旦有了它，你就回不去了。像这样的软件都能立即制造一批死忠用户，哪怕一开始有点小毛病也能让人接受。

第一次见到 Word 这个软件，是在大约 1994 年，我高中同学 [1] 的家里，当时我家没电脑。我同学没有向我吹嘘 Word 编辑文档的功能，我认为那些功能本来就应该有。但是他给我演示了一个特性：矢量字体。他把一个字不断地放大，不管怎么放，笔画都是光滑的。他告诉我，所有文字的笔画都是用数学方程现场计算出来的。

我一看肃然起敬。我连想都没想过的问题，人家已经解决了而且应用了而且用得那么漂亮。我感觉进入了一个比自己高得多的新世界。什么样的人物，能给用户提供这样的感觉？这肯定不仅仅是编程的技能。软件设计不是找几个训练有素程序员来个 996 的事儿。软件设计是技术、数学、艺术、文化和哲学的融合创造。软件设计里面有「道」。

注释：

[1] 我这位高中同学叫王越，现在是北京意锐新创科技有限公司的创始人，号称「中国二维码之父」。

## 0406. 计算机思维6：方程的模拟

我们来说说「计算机模拟」在传统科学和技术研究上的应用。我以前就搞过物理学的计算机模拟研究。我模拟过地球外部空间的等离子体现象，我模拟过受控核聚变装置里的不稳定性，我做出过有意思的发现，我使用过全世界最强的超级计算机。我认为计算机改变了某些物理学家的生活方式。我调整几个参数就是一场新的实验。我能方便地读取实验过程中任何时刻任何位置的数据。我可以随意探索极端的实验局面而不用担心把仪器弄坏了。我的猜测都能迅速得到检验。

更好的是，我做一天实验手还是干干净净的，连汗都不用出。我们的实验没有环境污染问题，没有道德伦理问题也没有身心健康问题。我下班之前安排上几个实验，回家如果不想工作可以读读书逗逗孩子，第二天早上实验结果已经在那里等着我了。

计算机，真是科学家的朋友啊。现在包括中国在内的这些老牌核武器国家之所以都不搞核试验了，就是因为他们都掌握了用计算机模拟核试验的技术。他们占据了研发手段的制高点，所以就可以占据道德制高点……只有朝鲜还在苦哈哈地做真实验。那「计算机模拟」到底是干什么的呢？「空间等离子体」这个话题比较冷，「受控核聚变」这个话题比较难，咱们还是用《计算机思维》这本书里的例子。

### 6.1 计算的科学

老百姓用的计算机，严格地说应该叫「个人计算机」，只有一两块 CPU。根据摩尔定律，个人计算机在以很高的速度变得越来越强大，但是这种强大是有限的。

想要在现有的技术条件下获得极端的计算能力，你需要「超级计算机」。所谓超级计算机，是把几百个、甚至几万个 CPU 连在一起共同计算，它拥有巨大的内存和海量的硬盘。这个道理就如同砌墙一样。一个工人干活的速度再快也是有限的，而像砌墙这样简单的活儿，完全可以让很多个工人、在墙的不同位置，一起干，这叫做「并行计算」。并行计算有怎么科学地安排活儿、特别是各个计算进程之间怎么通信的问题，不过只要模型合适，这里面就可以避免「人月困境」：如果你有 1 万块 CPU，你就可以拥有几乎 1 万倍的计算能力。

上世纪八十年代，超级计算机技术成熟了。这就给科学家提供了一件足以改变战争模式的武器。传统上的科学研究有两种模式，一个是实验，一个是理论。实验科学家要搭建一个真实的科学场景，或者是前往一个真实的科学场景去做观测。你尝试各种不同的条件，收集数据，看看能不能验证某个模型或者想法。理论科学家则是对实验观测的现象和数据提出解释。你有时候要发明一个自己的模型，甚至提出一条定律，要不但能解释现有的实验，还能预测新的结果。

「理论」和「实验」，都是人的思想和真实世界之间互相印证。但是有了超级计算机之后，就出现了一个新的研究模式，也就是「计算」。那你可能会说，以前的实验科学家处理数据，理论科学家搞理论，不也要做计算吗？那你说的这个计算有什么不同吗？—— 这个不同就在于，这里说的计算，是用计算机「模拟」一个系统的演化。

我给你打个比方。比如我们要研究两支军队，在给定各自的武器装备的情况下，发生一次战斗，看看双方的胜负和伤亡情况会是怎样。实验科学家的做法，就是找两支这样的军队让他们现场打一仗，但是作为搞科研来说这么干就太贵了。理论科学家的做法是估算一下双方在每一时刻的火力输出和人员消耗情况，做一个数学的推导。这么做不花钱但是你只能「估算」 —— 你只能算个总数，最多细化到双方的每一个兵种，你必须使用某种模型来近似战场的情况，然后你要求解方程。

而所谓「计算」的方法，则是打一场虚拟的战斗。你可以用计算机模拟双方的每一个士兵，让他们按照一定的原则输出火力，以一定的几率、根据对方的火力输出被打死打伤，就好像真正的战斗一样，看看作战过程和结果是什么样的。严格地说计算和理论都是使用模型去模拟真实世界，但是计算的模型相当于直接模拟，真实得多也复杂得多。理论是「求解」，是间接的；计算是「模拟」，是直接的。简单地说，实验费钱，理论费脑，而计算……最多也就费点电。更重要的是计算能让我们达到那些实验无法测量和理论无法求解的地方。计算绝不仅仅是让研究加速，而是把以前的不可能变成可能。

1982 年，肯尼斯·威耳逊（Kenneth G. Wilson）因为用计算方法研究物质相变的现象而获得诺贝尔物理学奖，这是「计算」的第一个重大胜利。威耳逊就此声称，计算的时代已经到来，我们将来可以用计算模拟解决大问题。那时候就人们估计，1995 年之前，我们就可以用纯计算机模拟的方法设计一架商用客机。而事实上果然如此。1994 年，波音公司用纯计算模拟设计了 777 客机。

### 6.2 怎样模拟

咱们来看看怎样搞一次真正的计算模拟研究。设计飞机的关键是搞好空气动力学。以你这个飞机的形状和尺寸，在一定的空气压强和气温之下，以一定的速度飞行的时候，气流对机翼会有一个什么样的作用力？如果有湍流，飞机能不能受得了？传统上这些问题都只能用实验回答。当然你不可能贸然把飞机送上天，大家的做法都是弄一个巨大的「风洞」，把飞机放在里面，然后用强力的鼓风机把气流吹向飞机，效果就如同飞机在气流中飞。

而另一方面，其实我们早就知道气流的运动方程，叫做「纳维尔－斯托克斯方程（Navier-Stokes equations）」。这是一个微分方程，描写流体的速度、密度和压强随时间的变化。传统的理论方法根本无法在飞机附近对这个方程求解，因为飞机的形状太复杂了，而计算机模拟就可以做这件事情。

最早提出用计算机模拟的方法求解微分方程的，正是约翰·冯·诺依曼。他的办法是把时空打上小格子，用有限的差分代替无穷小的微分。模拟飞行气流也是这样。我们不可能模拟每一个空气分子怎么运动 —— 那个运算量是不可想象的 —— 我们要做的是通过纳维尔－斯托克斯方程，在飞机附近的整个空间模拟「气流」的运动。首先给飞机周围的空间打上格子 [1] —— 

注意图中距离飞机特别近的地方因为形状复杂，必须增加格点的密度；比较远的地方形状变化小，就可以少用一些格点，减少运算量。然后我们把时间也要设定成一步一步的，相当于给时间也打格。在 `t=0` 的初始时刻，你设定一个比较简单的初始条件，规定好每一个格点处气体的密度、速度、压强和温度等参数。

纳维尔－斯托克斯方程告诉我们每个时间和地点的气流如何根据周围气流的情况而变化。整个计算模拟的过程，就是在每一个时刻，根据上一时刻各个格点处的物理参数，使用纳维尔－斯托克斯方程，计算下一时刻各个格点处的物理参数。然后你就可以根据任何时刻气流的参数，计算气流对飞机的影响。使用特定的边界条件，你还可以计算飞机对身边气流的作用。

整个过程就好像飞机在气流中飞一样。实际操作中会有很多细节上的考虑，但是这个方法跟我以前模拟磁场中的等离子体运动的原理是一样的，最基本的就是三个要素 —— 网格、运动方程、时间步。你肯定能想象到，网格越小，时间步越短，模拟就越精细。但是这里面充满取舍，你必须适可而止，哪怕最厉害的超级计算机也承受不了特别精细的模拟。科学家必须想各种办法减少运算量。

### 6.3 计算能告诉你什么

随着计算科学的发展，人们想了各种办法来提高计算效率。比如说解微分方程，如果真的老老实实地用差分代替微分去一步一步求解，不但运算量大而且误差也大。所以现在大家都是先对方程来个「傅里叶变换」，这样计算会变得非常容易。而我们早就有了标准的「快速傅里叶变换」库函数。有人估计，从 1950 年代到 1980 年代，数学软件的计算能力大约提高了 10^12 倍 —— 其中 10^6 倍是硬件升级带来的，剩下 10^6 倍，则是由于数值方法的进步。

1-3『傅里叶变换可以简化解微分方程。傅立叶变换，表示能将满足一定条件的某个函数表示成三角函数（正弦和/或余弦函数）或者它们的积分的线性组合。在不同的研究领域，傅立叶变换具有多种不同的变体形式，如连续傅立叶变换和离散傅立叶变换。最初傅立叶分析是作为热过程的解析分析的工具被提出的。』

计算模拟有一个问题，可以说是哲学上的。如果实验观察到一个特别的现象，然后你用计算机模拟真的能够重现这个现象，那你能说，现在你已经「理解」了这个现象吗？恐怕未必。你未必能说清楚是谁导致了谁，是什么样的机制在背后。而模拟研究的可怕之处就在于，也许我们根本就不应该指望能说清楚。

这就好比说两支数万人的大军在一起混战，双方各有长处和弱点，打了整整一天，战斗结束时双方都伤亡惨重，其中一方以微弱优势取胜 —— 我们假设你拥有战场的所有信息，那你能说清楚，胜利的一方是如何胜利的吗？是因为指挥官布阵高明吗？是因为炮火更强吗？是因为对方犯了哪个低级错误吗？很可能这些因素都有，也很可能这些因素都不是决定性的。

其实不用说打仗，就是看完一场足球赛，你也很难说清赢球的一方是因为什么而赢的。在我看来这是「计算思维」带给科学研究的认知升级：传统的因果、理论、学说，无法描述真正复杂的现象。计算不能让你得到什么一句话解释，但是计算能让你更接近真实情况。《计算机思维》这本书里最有意思的话题我们就都讲完了，但是我们远远没有覆盖所有的计算机思维，将来遇到有意思的咱们再讲。

注释：

[1] Shawn Wasserman, What You Need to Know for SOLIDWORKS Flow Simulation in 2016, engineersrule.com, December 23, 2015.

### 黑板墙

作为一个曾经的从业者，我认为计算机模拟只是一个辅助性的工具。在核武器和飞机空气动力学领域它可能比较可靠，但是至少在我以前做的受控核聚变领域，计算机模拟能做的还很有限。这里面关键是个尺度问题。对大尺度现象，我们可以使用磁流体力学之类大尺度的模型；对小尺度现象，我们必须使用动力学之类小尺度的模型。但是有些物理现象是小尺度和大尺度一起起作用，这就很不好办了。都用大尺度模型，你看不到这个现象；都用小尺度模型，你计算能力有限模拟不了那么大的区域。这种多尺度问题非常难办。当然，纯理论更不行。在核聚变这个领域，是实验说了算的。总是实验发现了意想不到的现象，我们跟着过去看看能不能模拟。我们的作用在于用模拟提供一点理解。2019-05-22

我目前的工作是风力发电机的气动和结构计算。您结尾讲的「计算有时很难真正被理解」，我特别有感触，所以我通常写计算报告都写「xxx calculation」，而尽可能不用「analysis」。举个我工作中的例子，之前有一个很复杂的塔式结构。可以理解为乡村能常见到的那种高压输电的支撑结构，就是由很多很多梁组成。设计人员认为这结构无论刚度、强度、稳定性都没问题。我算完…… 都有问题。基于「得到」很多老师讲过的，哥斯拉实际站不起来的原因，能缩小比例进行试验验证的呢，只有稳定性。于是做试验前我让车间师傅给一根梁涂上红漆，就是我算完屈曲变形最严重那根。试验时「果然」那根梁先出问题，我当时知道，这真的是我运气好。另外万老师，您在文章中给出的被网格离散化的飞机和周围空气域的图示，我猜是一张大图的局部，因为要不然飞机距离空气的「进出口」就太近了，而且里面的网格似乎没有空气与飞机交界处的边界层网格。（我平时计算时，相同尺寸的风机叶片周围边界层网格的大小，在不同的风速和风机转速时，事先需要用公式算好，要不结果会非常离谱。）2019-05-22

计算机模拟确实很厉害，但是我有一个疑问，模拟依赖于模型，模型则依赖于一些理论，如果一个模型的构建过程中没有考虑一些关键理论或者根本不知道这个理论那么模拟出来的结果就有错误，如果不进行实验的话那我们岂不是永远不知道真相是什么了。回复：是的，最终还是要跟实验比较。不过对于飞机空气动力学和核武器来说，研究者已经对模拟非常非常有信心了。2019-05-22

越来越多的实验开始使用计算机模拟，这里面有两个要素，一是云计算技术的成熟和大数据的分析；二是越来越多的现象可以用数学方程式来解答，进而可以使用计算机建模，实验只需要调整个别参数就可以得出不同的实验结果。只要算法靠谱，结果也有说服力。今天的大数据分析，可以渲染到各种二维或者三维的图表上，这些常见的都是事后分析。平常人接触最多的计算机实验应该就是，沙盘模拟，用各部门的经营指标建模，来推演各部门不同指标对公司销售的影响，更直观的让管理者感受到那些部门和岗位的重要性。2019-05-22

我是学给水排水的，通过方程的模拟应用，可以将所有设计参数录入后，验证设计的水厂或排水系统是否可以满足需求，如果不能满足可以重新设计，直到满足要求为止，这样的降低实验的成本，还能得到可靠设计方案。类似的方程模拟升级版 AR 成熟以后，人们可以利用这项技术，在线可以练习很多技能，如拳击、射击、驾驶飞机等。将以前需要很高门槛才能学到的技能，通过计算机技术的发展，可以轻易获得，对于终身学习者来说是件大好事。愿和各位道友共享此乐。2019-05-22

计算机模拟在核电站应用。这节课让我想起了 3 年前《反应堆的运行和控制》的培训的计算机模拟课上的情景，因为课上的内容没有听懂，用计算机软件模拟操作的机组，多次停机跳堆，一节课下来后背是一身汗，暗自庆幸这不是真的反应堆。有了计算机模拟软件，操作员可以在模拟机上培训运行机组和处理突发情况，减少了实战中可能会犯的低级错误，也为批量培养操作员提供了可能。计算机模拟真的很有用，未来 AR 技术可能会将计算机模拟技术应用到实际生活场景，我们可以在家里游遍整个世界，很期待那个时代的到来，可以足不出户就能跨过山河大海。2019-05-22

机械、流体和传热是工程上，使用计算机模拟非常频繁的三个领域，对应的也就有了计算流体力学、计算传热学这样的学科，以及 Ansys 之类的经典软件。就像万老师所讲的，流体领域的理论基础就是纳维-斯托克斯方程。但是这个方程包含了密度、压强、速度、外力、粘度、时间在内的六个变量，而且方程本身还是矢量微分方程，经常要展开成 x、y、z 方向分别计算，非常不友好。所以在使用计算机模拟以前，需要用方程估算的时候，通常都需要将问题简化成一些比较简单的情境，并给出每个情境下的简化公式，方便计算。

显然这并不靠谱，想要细致研究，就真的只能去做实验了。而且这实验还很有讲究，你用十分之一尺寸的模型模拟研究对象，那流体速度该是多少？不是十分之一，而是十分之一的某个次方…… 麻烦事实在太多，所以谢天谢地，有了计算机，一切都变得简单多了（虽然设计网格和初始参数仍然是个技术活）。计算机模拟流体，其实还包含着一点网络思想。模拟计算的时候要首先画个网格；而实际模拟的时候，计算的其实是网格节点之间的相互影响，再根据这个影响关系，来迭代出下一个时间步的节点参数。你模拟的其实不是「一团」节点，而是每个节点之间的相互关系。2019-05-22

之前看电影的时候发现计算机模拟在 NASA 应用非常多，尤其是第一次载人航天飞船的成功制作，计算机模拟功不可没，它成功将飞船可能遇到的各种因素尽可能的模拟出来，然后根据现象反推本质从而解决一个又一个问题。计算机模拟是建立研究对象的数学模型或描述模型并在计算机上加以体现和试验，一般从形成问题到最后模型会确认须经过许多步骤：1）形成问题，明确模拟的目的和要求。2）尽可能收集和处理系统有关的数据。3）形成数学模型，找出组成系统的各个部件，并描述它们在各时刻的状态的有关变量（一般包括输入变量、状态变量和输出变量）或参数；确定各部件之间相互作用和影响的规则，即这些描述变量之间的函数关系。选择参数和变量的时候，还须考虑它们能否辨识或求解，以及模型最后是否适于根据真实系统的数据进行检验。4）根据收集的数据确定或估计模型中的参数，并选择模型的初始状态。5）设计逻辑或信息的流程图，直至编制出计算机程序。6）程序验证，检验程序与数学模型之间的一致性，以及输入量的合理性。7）进行模拟试验，对给定的输入在计算机上执行程序。8）结果数据分析，收集和整理试验结果并作出解释。必要时可改变输入量或部分模型结构，重新进行试验。9）模型确认，检验由模型所得的结果与真实系统的性能数据的一致性程度。这是关系到计算机模拟是否有效的关键问题，它依赖于对真实系统本身进行试验的水平、能否获得足够的观测数据和判别一致性的准则。模型有效的级别可分为：重现有效的，即模型可重现真实系统的性能；预测有效的，即模型能有效地预测真实系统的未来性能；构成有效的，即模型能反映真实系统内部的结构。由于系统本身是随时间变化的，或者具有随机性，因此哪怕我们不能够弄明白每一个因素的变化，但是我们能够最贴近并了解真实情况。2019-05-22

## 0407. 问答：到底什么叫「可计算」？

### 来自日课：无情的计算

本周最主要的问题都是集中在「可计算性」上 ——

泼猴要撒野：文章读到最后感觉有一个计算之神在操纵一切世间万物，但是所有的一切都能计算么？似乎不是这样的。

阿丁：新手难以理解「图灵停机问题」，总觉得有点神秘。万老师能解释一下吗？

万维钢：

「可计算性」和「图灵停机问题」是计算机科学中的两个关键问题，我认为每个想要理解计算机的人都应该有所了解。今天的问答，咱们就专门说这两个问题。

1、什么叫「可计算」。

我们知道，计算机思维能给人提供一个观察世界的视角，能让我们审视自己的世界观。因为有了计算机，我们现在可以问出下面这些大问题 —— 1）计算机能解决一切问题吗？2）人脑是一台计算机吗？3）我们生活的这个世界，有没有可能像《黑客帝国》电影那样，其实是一场计算机模拟呢？

我先说结论。科学家和哲学家的当前科学理解，对第 2 和第 3 个问题，还没有答案 —— 你只能猜想。但是对第一个问题，答案则是明确的否定：计算机不能解决一切问题。

那你可能会感到有点奇怪 —— 如果计算机不能解决一切问题，那不就是说计算机是有局限性的吗？那人脑和真实世界怎么还可能是计算机呢？其实这并不奇怪，因为人脑和真实世界也可能是有局限性的。计算机有局限性，不等于人脑就一定强于计算机，也不等于真实世界就不是计算机。

咱们先说说这里什么叫「解决问题」，也就是什么叫「可计算」。对计算机科学家来说，所谓可计算，就是给定输入，经过计算机的有限次操作，能得到一个确定的输出。「可计算」的意思不但是「可以算」，而且是「可以算出结果来」。咱们把问题简化一点。我们考虑这么一种问题，它的答案要么是「是」，要么是「否」，而在逻辑上不存在模棱两可的中间状态。请问，所有这样的问题，都是计算机可以解决的吗？答案是否定的。哪怕像是「是否」这种问题，都不全是可计算的。比如说，图灵停机问题，就是不可计算的。

2、图灵停机问题。

让计算机执行一个「寻常的」程序，比如计算 1+2+3+…… 这么一直加到比如说 10000，只要计算机的内存足够大，只要你给的最后一个数是有限的，只要你愿意等待足够长的时间，它就终有算完、停机、输出一个结果的时候。但是有些程序，却是永远都不会停机的。比如你可以让计算机一直循环执行下面这个命令 ——

在屏幕上打印「你好」

那么你就会看到计算机不断地打印「你好」这两个字。你要是不主动杀死这个程序，它就不会停机，它陷入了「死锁」。「死锁」是程序员的噩梦，有时候写程序说不定哪里没设计好，程序一运行起来就陷入了死锁。所以程序员就有一个美梦。有没有一个什么软件工具，能够直接看一眼我写的程序，就自动判断它会不会出现死锁呢？

这就是「图灵停机问题」。也就是说，有没有这样一个程序，它的输入是任何一段代码和这段代码的输入参数，而它的输出则是这段代码所代表的程序，在那个参数之下运行起来之后会不会自动停机 —— 如果判断会停机，就输出「1」；如果判断不会停机、会死锁，就输出「0」。

想要做到这一点，这个判断程序必须只读、而不能去执行那段代码 —— 因为如果执行，而那段代码又真的不停机的话，计算机就会陷入死锁，这个判断程序就不能输出「0」了。换句话说，这个判断程序得能像一个高水平程序员一样，看一眼你写的代码就知道其中有没有死锁。如果有这么一个判断程序，岂不就是一个绝佳的 debug 工具吗？

而图灵告诉你别做梦了，不存在的。在理论上就不可能存在那样的判断程序。这是一个不可计算的问题。为什么呢？证明非常简单，反证法。以下为了行文方便我不得不使用一点编程语言 ——

我们假设存在这么一个判断程序，称为 Halt(p, I)。其中 p 是 Halt 要判断是否停机的代码，I 是程序 p 的输入。也就是说，如果程序 p 运行输入值 I 的时候会停机，那么 `Halt(p,I) = 1`；否则，`Halt(p,I) = 0`。

好，那么我们构造下面这么一个新程序 [1]，称之为 Z：

```
Program (x)
    If Halt(x, x) then
        永远循环
    Else 停机
    End
```

我解释一下。Z 的输入，是任意的一段字符串 x。x 可以是一段程序的代码，也可以是一段程序的输入。Z 的规则是，如果 `Halt(x,x)` 是 1，则 Z 就永远循环下去，不停机；如果 `Halt(x,x)` 是 0，则 Z 就停机。那么请问，像这样的一个程序 Z，如果把它的代码自身，作为它的输入，会怎样呢？它会停机吗？

如果会停机，那就意味着 `Halt(Z,Z) = 1`，对吧？可是你带入 Z 的规则之中，这时候 Z 就应该不停机。反过来说，如果 Z 不会停机，那么 `Halt(Z,Z) = 0`，带入规则之后 Z 又会停机！悖论！所以 Halt 这样的程序，根本就不可能存在。证明完毕。

这个证明是否让你想起了我们讲逻辑思维的时候说过的「理发师悖论」。Z 就是那个「只给不给自己理发的人理发的理发师」。这个悖论的关键点就在于，一段代码，既是可执行的程序，又可以作为输入的字符串。所以我理解，这个矛盾的根源在于，写代码和判断代码，都是能用语言描述的行为。

3、不可计算意味着什么。

现在图灵给了一个例子，说明世界上有些问题是计算机无法解决的。计算机无法判断任何一段代码是否会停机。这说明哪怕所有问题都能用数字化描写，计算机也解决不了所有问题。

这有什么意义呢？这意味着总有一些事情，你只能慢慢等着它发生，而不能事先知道它的结果。这意味着程序员必须把程序运行一下才知道其中有没有 bug。这意味着理论是有限的，必须得实践才行。这还意味着，世界上有些事情，你只能看着它发生，而无法解释它为什么会发生。这是因为你甚至都无法预测它会不会停下来，又何谈什么解释呢？

那也就意味着，我们不可能完全理解真实世界。我们头脑里的只是世界的模型 —— 而世界的模型不能代表真实世界。世界上总有一些事情，是你没有办法用什么简化的模型预测的，你只能看着它发生才知道结果。这是否使你想起了我们第一季讲过的「不可约化的复杂」[2]，和哥德尔不完备性定理…… 其实它们说的都是理性世界的局限性。而如果你是一个善于感慨人生的人，这也就意味着，哪怕你再聪明，人生也是值得过的。总有些事儿你想不到，你总得经历才知道。

好，下面我来回答你可能会问到的四个问题。

第一，这里的「不可计算」，是因为不确定性吗？

—— 不是。图灵停机问题完全可以没有任何不确定性。哪怕一切都是确定的，没有任何随机变量，最后结果仍然不可知。不可知不等于不确定。我十岁生日那天确定、一定、肯定吃过东西，可是我完全不记得吃的是什么 —— 这件事不可知，但是并非不确定。在一个完全确定的世界里，也有计算机解决不了的问题。

第二，男女感情问题，是不可计算的吗？

—— 好多人问我这个问题。我不是感情问题专家，但是我非常肯定地相信，感情问题是可计算的。因为人的情绪容易多变，感情问题有时候不好计算，但不等于不可计算。计算机科学家说的「可计算」是个严格的定义：只要图灵机能在有限步能算出结果来，就是可计算的。事实上用计算机程序模拟一个人的脾气非常容易。至今没有任何一项属于人的特性，被证明是计算机在理论上也不能推演的。

第三，你说的都是图灵机，是吧？

—— 图灵机并不是一种非常特殊的计算机，它就是我们寻常用的这种计算机。只要满足 1）数字化信息。2）数学式的、有限步的算法。3）能停机，就是图灵机。图灵机只能处理有理数，这是一个重大限制。但是没有任何证据表明，真实世界不仅仅是由有理数组成的。

第四，可是根据量子力学，我们知道真实世界里是有不确定性的，图灵机能模拟不确定性吗？

—— 量子力学的哥本哈根解释认为量子随机性是真正的随机性。我们知道数学方程的解永远都是确定的，所以数学方程无法解释量子现象，那么既然如此，图灵机是基于数学的，所以图灵机就无法代替量子世界。但是，图灵机可以模拟出一些假的随机数来，让你感觉就好像是真的随机一样。我们无法判断在真实世界里遇到的所谓随机现象，到底是不是外星人给我们模拟出来的假随机！

总而言之 ——

有没有一件事是人一定能做，而计算机一定不能做的？目前认为没有。有没有一件事是真实世界里发生了，而计算机一定不能模拟的？目前认为没有。…… 然而计算机仍然不能解决所有问题。这个世界就是这么有意思。

注释：

[1] 这段程序来自 https://www.comp.nus.edu.sg/~cs5234/FAQ/halt.html

[2] 精英日课第一季，《一个神人的世界观》。

## 0408. 问答：开发一个操作系统，是更难了还是更容易了？

### 来自日课：工程的复杂

千秋雪：万老师，你觉得现在这个时代相比八九十年代，开发一个操作系统是更难还是更容易了？

李琼：我觉得，无论面对什么样的压力，试图重新种一棵同类型的树都不是明智的。不顾一切倾尽全力的去种这么一棵树则是危险的。我们要做的是，在别处栽下一棵新品种的小树苗，多少年后，它会硕果累累。而我怀疑的是，美国精英们可能正在偷偷的种树，而我们的精英们则在重新发明系统和芯片。然后又是一个关于弯道超车对抗弯道摆脱的轮回。我这样是多虑了吗？

万维钢：

另立门户、完全自主地开发一个新的操作系统是更难了，因为现代计算机比那时候要复杂得多。但是从一个现有的、开源的操作系统出发，定制一个属于自己的操作系统，则是比较容易的。而不管怎么开发，跟开发相比，要让别人愿意用你新开发的这个操作系统，却是非常非常的难。

操作系统是个底层的东西，必须有很多人用，以至于各个软件公司愿意给这个操作系统开发软件，它才有生命。这就好比说本来大家都说英语和中文，你新发明了一个语言，叫「世界语」 —— 可以是可以，但哪怕你这个语言再科学再完美，别人已经在说英语和中文了，为啥要新学一门不是任何人的母语的语言呢？世界语曾经被人大力推广过，现在已经死了。

八十年代之前，最正宗的操作系统是 UNIX，它的直系子孙就是现在的 Linux，它的旁系子孙就是现在苹果的 Mac。那 Windows 是从哪来的呢？

1980 年，IBM 公司推出一款个人电脑，价格便宜可以用于家庭，但是它没有操作系统。IBM 不屑于自己开发一个操作系统，搞 UNIX 的公司也没在意专门给个人电脑开发一个版本。这就给了一家叫做「微软」的小公司机会。微软从别人那里收购了一款小操作系统，叫 DOS，修改之后授权给 IBM 的个人电脑安装，但自己保留了著作权。当时个人电脑刚刚出现，但是搞个人电脑的并不是只有 IBM 一家。别家再搞个人电脑，也有操作系统的需求，正好微软有现成的，就直接授权安装。

也就是说，微软的操作系统是跟着个人电脑这个新事物一起兴起的，后来 DOS 变成了图形界面的 Windows。事实上在整个八十年代到九十年代，微软的操作系统都是被专业人士嘲笑的对象。跟 UNIX 相比，DOS 性能差、安全低、结构不合理，简直就是个对付出来的东西。可是不管你喜不喜欢，个人电脑上装的都是它。那么这时候如果有哪个公司要开发专门面向个人用户的软件，比如游戏之类，就必须是在微软的平台之下。

微软既不是美国政府搞「美国制造」计划扶植起来的，也不是大公司垄断的产物，也不是美国人民用爱国主义捧起来的。微软是在个人电脑刚刚出现，人们还没有意识到这个东西将会迅速流行，大公司还看不起这个小市场，谁也没想到给个人电脑做操作系统将会比给传统计算机开发软件更赚钱的时候，偶然产生的。我估计比尔盖茨那时候也绝想不到他的公司将来会那么有钱。

而 UNIX 的直系子孙 Linux，现在反而成了非主流，市场占有率不到 1%，对大多数家庭用软件来说，根本不值得专门为它发布一个版本。现在我们回想起来，说「啊，个人电脑是最大市场！啊，要有自己的生态！」 —— 当初人们可没想到。

那难道微软就从此一统天下了吗？也不是。智能手机就是一个出新操作系统的机遇。本来苹果手机的系统最好，但苹果搞封闭，想用它的操作系统只能买它的手机，这就给了别的操作系统机会。最初智能手机领域有好几个操作系统，比如有黑莓和 PALM，也都是自家的系统自家用。这时候 Google 推出开源的安卓系统，允许其他手机制造商使用，于是安卓胜出。

也就是说，要想在天下占有一席之地，你的机会在于新生事物刚出来，群雄并起的混乱时期。在这个时期说我要种树搞生态那是战略，过了这个时期那就只不过是感叹而已。我们要问种什么树，首先得看看新兴的领域在哪里。也许基于大数据的人工智能技术是个机遇，现在各个公司都在积累数据。也许 5G 也是个机遇。

现在美国封锁华为，的确是华为搞自己的操作系统的机会。但是搞好一个操作系统容易，让别人愿意用难。我们无法想象中国为了扶植本国的操作系统而封锁安卓和苹果，那将是拿国民经济为操作系统服务，而不是让操作系统为国民经济服务。更何况华为的市场在全世界，它也不希望各国各自搞封闭的系统。所以中国并没有封锁美国的操作系统，消费者不一定非得用华为。正如任正非所说，手机只是一个产品，我们不应该为了爱国而买手机。

那华为的机会在哪呢？我认为最理想的局面是出现下面这三个条件 —— 1）华为统治了 5G 领域；2）5G 领域有一些人人非用不可的杀手级应用；3）华为手机是最好的、甚至是唯一的 5G 手机。

而目前看来，只有第一个条件最可能实现，所以我感到很困难。我认为最大的可能性是华为搞一个完全兼容安卓的系统。

太西瓜西太：万老师，2006 年的熊猫烧香病毒，2007 年的 U 盘自动运行病毒等等。感觉 10 年前网络上病毒种类复杂，数量多，更新频率快，以至于「江民，瑞星，卡巴斯基」这类杀毒软件可以有市场。但最近 10 年，杀毒软件都被迫免费，而且网络上病毒除了 2018 年的比特币勒索病毒之外似乎安全了很多。请问是因为软件公司采用 DRUSS 原则吗？亦或是其他原因呢？

万维钢：

这是一个非常好的观察。是的，现在计算机病毒没有以前那么猖獗了，而这的确是因为软件公司更加注重安全了。

主要的改变在于操作系统和浏览器现在都内置了安全功能。比如 Chrome 浏览器，它自己就能判断哪些站点是不安全的。如果有什么来历不明的东西想要安装，浏览器自己就能探测到。如果有一个网站被发现有恶意程序，Chrome 会自动对所有的用户屏蔽这个网站，这种情况下想要传播病毒就很难了。

我理解以前的杀毒软件本质上是黑名单制度，是先知道有哪些病毒，列入黑名单，然后排杀。而现在则具有一定的自动探测能力，凡是说不清楚的操作一律禁止。同时像苹果应用商店，更是白名单制度，只有被认可安全可靠的应用才能上架。

由此可见，互联网的野蛮时代已经结束了。如果你要做一个公共网站，给很多人提供服务，你就得让人知道你是谁。现在我们日常访问使用的都是一些成熟的网站和应用，连盗版和色情内容网站都是几家独大，谁想弄个独立网站传播病毒没啥机会。

### 来自日课：设计的境界

黑洞：可以讲讲 Linux 的「道」是什么么？想知道为什么一个应用软件严重缺乏的系统那么受欢迎……为什么一个本来是被开发来玩的系统，走的那么远……

万维钢：

Linux 的缘起是个很随意的项目，但是自从加入自由软件社区之后，它就不再是一个「玩」的操作系统了，它成了 UNIX 的直系传人，可以说它才是 THE 操作系统。

Windows 的本质是一个为个人电脑而生的，简易的、对付出来的操作系统，只适合打游戏，不适合工作。用 Linux 才是真正在「操作」电脑，Shell 命令行是一个丰富的编程环境，提供了各种精妙的小工具，你直接命令计算机去做什么，而不是拿个鼠标在那笨拙地点来点去。Linux 是直接向厨子定制你想吃的内容，Windows 只能让你从菜单里点几个标准化的成品。

Linux 的目录结构和文件系统更符合逻辑，权限非常清楚，多用户管理无比和谐，而不是像 Windows 弄什么 c 盘 d 盘 e 盘……

Linux 能让电脑发挥最大的效能。同样一个数值计算软件，放在 Linux 上它可以轻松调用几乎全部的计算力；放在 Windows 上就不行了 —— 因为 Windows 自己什么都不干的时候也要消耗很多计算力。一台老计算机，装上 Linux 就能焕发青春；一台新计算机，装上 Windows 就会臃肿而心事重重。Linux 不死机不蓝屏，Linux 没病毒。

那这是为啥呢？因为 Linux 是个自由的、干净的、开源的、可控的、品质高尚的系统，而 Windows 则是贪婪、专制和愚蠢的产物。而且 Linux 免费！当然，因为 Linux 更尊重计算机和用户，它有点曲高和寡，不适合普通老百姓，以至于很多商业软件、特别是游戏没有Linux 版。如果资金比较充裕，Mac 是个折中的选择。

### 来自日课：方程的模拟

一如既往：我想起《流浪地球》的一个情节，救援队想出点燃木星的计划，但是 moss 说这个计划科学家已经计算机模拟过，成功率几乎为零！然而人类还是选择了奇迹！那么既然计算机模拟这个好用，我们以后会成为算法的奴隶还是非理性地选择相信奇迹呢？

万维钢：

作为一个曾经的从业者，我认为计算机模拟只是一个辅助性的工具。在核武器和飞机空气动力学领域它可能比较可靠，但是至少在我以前做的受控核聚变领域，计算机模拟能做的还很有限。这里面关键是个尺度问题。

对大尺度现象，我们可以使用磁流体力学之类大尺度的模型；对小尺度现象，我们必须使用动力学之类小尺度的模型。但是有些物理现象是小尺度和大尺度一起起作用，这就很不好办了。都用大尺度模型，你看不到这个现象；都用小尺度模型，你计算能力有限模拟不了那么大的区域。这种多尺度问题非常难办。当然，纯理论更不行。在核聚变这个领域，是实验说了算的。总是实验发现了意想不到的现象，我们跟着过去看看能不能模拟。我们的作用在于用模拟提供一点理解。