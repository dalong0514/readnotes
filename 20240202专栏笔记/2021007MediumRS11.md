## 记忆时间

## 目录

20210220Useful-IPython-Magic-Commands.md

20210317Five-Problems-Faced-When-Using-SOLID-Design-Principles.md

20210318Top-10-Most-Useful-Online-Courses-That-Are-Free.md

## 20210220Useful-IPython-Magic-Commands.md

[Useful IPython magic commands. Towards becoming a Jupyter Notebook… | by Zolzaya Luvsandorj | Feb, 2021 | Towards Data Science](https://towardsdatascience.com/useful-ipython-magic-commands-245e6c024711)

[Creating PDF Files with Python. How to create pdf files using PyFPDF… | by Eser Saygın | Towards Data Science](https://towardsdatascience.com/creating-pdf-files-with-python-ad3ccadfae0f)

When using Jupyter Notebook with IPython kernel, IPython magic commands come in handy. These magic commands make it easier to complete certain tasks. You can think of them as an extra set of helpful syntax in addition to Python syntax. In this post, we will get familiar with a few useful magic commands that you could use in Jupyter Notebook.

If you aren't familiar with magic commands, it's very likely that you may have been using some unknowingly. Does this syntax: `%matplotlib` inline look familiar to you? Probably, yes? `%matplotlib` is a IPython magic command. You see how this command start with %? This is a common characteristic of magic commands: they start with %. There are two kinds of magic commands: 1) line magic commands (start with %). 2) cell magic commands (start with %%).

For a line magic command, inputs are provided following the command in the same line. For a cell magic command, contents in the entire cell become its inputs. If you are not too sure what we mean by this, an example in section 3 will hopefully clarify.

Now we know a little bit about them, it's time to explore a handful of useful magic commands and familiarise with their example usage! 

### 01. Import code with %load

We can load code from an external source into a cell in Jupyter Notebook using this magic command. Here's one useful application of this:

For most data science projects, you may find yourself importing the same set of libraries over and over again across different notebooks. To make this process quicker, we can prepare a standard setup script for a Jupyter Notebook and import this script at the beginning of each notebook to reduce the repetitive typing. Let's look at an example to illustrate what we mean by this.

Imagine that we are working in magic_commands.ipynb that is located in project1 folder and setup.py contained the following setup script:

```py
# Contents in setup.py
# Data manipulation
import numpy as np
import pandas as pd
pd.options.display.max_columns = None
pd.options.display.float_format = '{:.2f}'.format
# Visualisation
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', context='talk', palette='rainbow')
```

We could import the contents in setup.py with the following one liner without leaving the notebook:

```
%load setup.py
```

As we can see from this example, when we run the command, it inserts the code from setup.py and comments itself. Since standard imports can be used across most projects, you may prefer to save the script in Desktop (the parent directory) and have a project specific setup in the project folder only when needed (for instance, NLP projects will need additional set of imports).

If we wanted to load setup.py from the parent folder in the same notebook, we can update the file path to reflect the change:

```
%load ..\setup.py
```

Although this example case may seem trivial, it is a small change you could start practicing and it will hopefully inspire other applications.

Before we move on to the next command, it's worth mentioning that while importing code from `.py` file is common, you can also import content from other files such as `.txt `and `.md`. In addition, you can also import code from URL like this:

1『补充：1）自己的 Mac 上应该改成 `%load ../setup.py`。2）只要是纯文本，应该都可以直接载入。（2021-02-20）』

```
%load 
https://gist.githubusercontent.com/zluvsand/74a6d88e401c4e3f76c2ae783a18689b/raw/5c9fd80a7bed839ba555bf4636e47572bd5c7e6d/pickle.py
```

### 02. Save code with %%writefile

This command lets us do the opposite of the previous command. We can save code to an external source from a cell in Jupyter Notebook using this magic command. If we imagine ourselves still being inside magic_commands.ipynb, this is how we would create setup.py to Desktop without leaving the notebook:

```py
%%writefile ./setup.py
# Data manipulation
import numpy as np
import pandas as pd
pd.options.display.max_columns = None
pd.options.display.float_format = '{:.2f}'.format
# Visualisation
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', context='talk', palette='rainbow')
```

This will create a setup.py file if doesn't exist. Otherwise, it will overwrite the contents in the existing file.

1『直接在 jupyter notebook 里敲上面的代码。（2021-04-23）』

### 03. Time code with %timeit or %%timeit

There are often multiple ways to accomplish the same task. One important consideration when choosing between the options is speed. Or sometimes you just want to time your code to understand its performance. Whatever your use case might be, it's useful to know how to time your code. Fortunately, timing code is easy with `%[%]timeit`.

Firstly, we will prepare some dummy data:

```py
import numpy as np
np.random.seed(seed=123)
numbers = np.random.randint(100, size=1000000)
```

Let's imagine we wanted to time this code: mean = np.mean(numbers). We can do so with the following one liner:

```py
%timeit mean = np.mean(numbers)
```

Output shows mean and standard deviation of the speed across multiple runs & loops. This is more rigorous way to time your code compared to timing based on a single run.

Now let's understand the difference between `%timeit` and `%%timeit` (the following guideline is true for most line and cell magic commands):

1 To use `%timeit`, a line magic command, the code you want to time should consist of a single line and be written in the same line following the magic command. Although this is a good general rule, multiple lines is possible with tweaks according to the documentation (see documentation for details).

[Built-in magic commands — IPython 7.22.0 documentation](https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-timeit)

2 To use `%%timeit`, a cell magic command, the code you want to time can consist of any number of lines and written in the next line(s) following the magic command.

Here's the equivalent of the previous code using `%%timeit`:

```py
%%timeit

mean = np.mean(numbers)
```

It's likely that the code you want to time will consist of multiple lines, in which case `%%timeit` will come in handy.

Here's a quick quiz to test your understanding. What do you think is the difference between the outputs of the following two cells? Try to think of the answer before proceeding.

```py
##### Cell A start #####
%timeit mean = np.mean(numbers)
np.mean(numbers)
##### Cell A end #####
##### Cell B start #####
%%timeit 
mean = np.mean(numbers)
np.mean(numbers)
##### Cell B start #####
```

Here comes the answer. In cell A, first we time the first line of code: mean = np.mean(numbers) then we find the average whereas in cell B, we time two lines of code:

You can see that cell B's mean speed is about twice as cell A's. This makes sense because we are essentially timing the same code twice (one with assignment and one without assignment) in cell B.

`%[%]timeit` automatically adjusts the number of loops depending on how long it takes to execute the code. This means that the longer the runtime, the less number of repetitions and vice versa so that it will always take about the same amount of time to time regardless of the complexity of the code. However, you can control the number of runs and loops by tweaking the optional arguments. Here's an example:

```py
%timeit -n500 -r5 np.mean(numbers)
```

Here, we have specified 5 runs and 500 loops.

### 04. Check session history with %history, %notebook, %recall

These sets of commands are very useful if you experimented with a bunch of things and it's already starting to get messy so it's hard to remember exactly what you did. We can check the history of commands we ran in the current session with %history. Of note, `%hist` can be used instead of `%history`.

Let's imagine we started a new session in section 3. We can see session history with:

```py
%history
```

This is great but a little hard to see where one command ends and the other starts. Here's how to check the history with each command numbered:

```py
%history -n
```

This is easier to work with. Now, let's learn how to export the history. If we want to write the history to a file named history.py in the same directory as the notebook, then we could use:

```py
%history -f history.py
```

If we want to write the history to a Jupyter Notebook called history.ipynb in the same directory as the current notebook, then we use %notebook:

```py
%notebook history.ipynb
```

This will insert each command into a separate cell. Quite convenient isn't it?

Sometimes, we may want to recall a section of commands from the history to tweak it or rerun it. In this case, we can use %recall. When using %recall, we need to pass the corresponding numbers for the section of commands from history like this example:

```py
%recall 1-2
```

The code above inserts first two commands from history into the next cell.

### 05. Other magic commands

We have only covered a small subset of commands in this post. So in this section, I want to provide a simple guide on how to explore more magic commands on your own.

To see all available magic commands, run %lsmagic.

To access documentation for all commands, either check the documentation page or run %magic.

To access documentation of a magic command, you can run the magic command followed by ?. For example: %load?.

Lastly, try running the following one liner in your Jupyter Notebook:

```py
%config MagicsManager
```

If you get the same output, even if we don't write % or %% at the beginning of a magic command, it will still be recognised. For instance, if you try running the following syntax, you will see the same output as before:

```
config MagicsManager
```

While I think it is a convenient feature, writing the prefix makes the code more readable as it's easy to tell it's a magic command by the prefix.

2『文中几个比较常用的魔法命令，做一张主题卡片。（2021-04-23）』—— 已完成

Thank you for reading my post. If you are interested, here are links to some of my posts:

[Introduction to Python Virtual Environment for Data Science | by Zolzaya Luvsandorj | Jan, 2021 | Towards Data Science](https://towardsdatascience.com/introduction-to-python-virtual-environment-for-data-science-3c216929f1a7)

[Introduction to Git for Data Science | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/introduction-to-git-for-data-science-ca5ffd1cebbe)

[Organise your Jupyter Notebook with these tips | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/organise-your-jupyter-notebook-with-these-tips-d164d5dcd51f)

[Simple data visualisations in Python that you will find useful | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/simple-data-visualisations-in-python-that-you-will-find-useful-5e42c92df51e)

[6 simple tips for prettier and customised plots in Seaborn (Python) | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/6-simple-tips-for-prettier-and-customised-plots-in-seaborn-python-22f02ecc2393)

[5 tips for pandas users. A popular Python library used by those… | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/5-tips-for-pandas-users-e73681d16d17)

[Writing 5 common SQL queries in pandas | by Zolzaya Luvsandorj | Towards Data Science](https://towardsdatascience.com/writing-5-common-sql-queries-in-pandas-90b52f17ad76)

## 20210317Five-Problems-Faced-When-Using-SOLID-Design-Principles.md

### Conclusion

As you can see, all of these principles are aimed at simplifying software support and extension. By providing more granular abstractions, we improve the flexibility of our applications. Armed with flexibility, we can successfully deal with a business that tends to change requirements.

### 00

In this article, we'll explore why and when software developers should use SOLID principles.

First, we'll start by exploring the reasons why we should consider them when designing software. Then, we'll outline each principle alongside a problem and solution. Please note that the examples in this article are simplified. Their purpose is simply to demonstrate problems that arise when these principles are violated.

### 01. Introduction

SOLID is an acronym for the five software design principles by Robert C. Martin. I highly recommend reading his book 'Clean Architecture'. So here's the list of principles:

Single-responsibility principle (SRP)

Open-closed principle (OCP)

Liskov substitution principle (LSP)

Interface-segregation Principle (ISP)

Dependency-inversion principle (DIP)

The main goal of these principles is to make software resilient to changes and easy to extend and maintain.

Making changes to the software takes time, which is the most expensive resource. The business has to react to market changes quickly, so the development time is critical. The faster you can adapt your code, the easier it will be for a business to develop and grow.

### 02. Single-Responsibility Principle (SRP)

Each module has one — and only one — reason to change

The hardest principle to understand is SRP because many developers think it means that each module should be responsible for one thing. This really applies when we're working with functions. For example, when we divide functions into smaller ones, we make sure these functions are only doing one thing.

But the essence of SRP is different. To make it clearer, we can paraphrase the principle as follows:

Each module has to be responsible for one — and only one — user or stakeholder.

Software is changed to satisfy users' or stakeholders' needs. So these users and stakeholders are the reason to change. Module, in this case, is a set of functions and data structures that are cohesive.

The problem:

In the following example, we have an AdsAccount class, which violates the SRP principle.

```java
class AdsAccount {
  public startCampaign() { ... }
  public calculateCampaignStats() { ... }
  public save() { ... }
}
```

This module has more than one reason to change:

1 Implementation of the startCampaign method is defined by the marketing team.

2 Implementation of the calculateCampaignStats method is defined by the analytics team.

3 Implementation of the save method is defined by the development team.

If we put the implementation of these methods into one class, there's a chance that new requirements by the marketing team will affect the business logic of the analytics team.

Imagine that the startCampaign and calculateCampaignStats methods use the common method getCampaignImpressions. The marketing team improved the impression-calculation logic, and they want to apply it to new campaigns. The developers updated and tested the startCampaign and getCampaignImpressions methods. The marketing team approved changes, and a new build was deployed.

After some time, it turned out that the campaign stats calculated in an unexpected way, and the analytics team worked with inconsistent data.

The solution:

The solution is pretty straightforward. We just need to split our logic into separate classes.

```java
class AdsAccount {
  constructor() {
    this.statsCalculator = new StatsCalculator()
    this.campaignLauncher = new CampainLauncher()
    this.campaignSaver = new CampaignSaver()
  }

  public startCampaign() {
    this.campaignLauncher.startCampaign(...)
  }

  public calculateCampaignStats() {
    this.statsCalculator.calculateCampaignStats(...)
  }

  public save() {
    this.campaignSaver.save(...)
  }
}

class StatsCalculator {
  public calculateCampaignStats() { ... }
  private getCampaignImpressions() { ... }  
}

class CampaignLauncher {
  public startCampaign() { ... }
  private getCampaignImpressions() { ... }  
}

class CampaignSaver {
  public save() { ... }
}
```

Now we have three classes that follow the SRP: StatsCalculator, CampaignLauncher, and CampaignSaver. Each new class doesn't depend on others. We have separate private methods for getting campaign impressions — each with its own logic needed for a particular team.

AdsAccount is now acting as a facade. It's responsible for creating instances of our new classes and method-call delegation.

### 03. Open-Closed Principle (OCP)

Each module should be opened for extension but closed for modification

Open for an extension means that adding new features to the application could be done only by providing new modules.

Closed for modification means that the result of extending the behavior of existing modules shouldn't force you to make changes in the modules depending on it.

1『原文中上面这段话高亮显示的，做一张金句卡片。（2021-04-23）』—— 已完成

The goal of this principle is to make your system easy to extend and protect from the impact of changes.

If a simple extension of the application logic leads to a chain of changes in the other modules, then you probably have violated the OCP.

Applying this principle in conjunction with the single-responsibility and dependency-inversion principles prevents situations in which a change to one of your classes also requires you to adapt all of your depending modules.
Let's dive into the example.

The problem:

Imagine, you're creating a food delivery application. You have a mobile app where your users create and view orders. The popular solution is where you have a module (aka a controller) that loads models from the database, transforms them to an HTTP response payload, and sends the payload to a client.

Arrows that pointed from module 1 to module 2 shows that the source code of module 1 uses module 2. The source code of module 2 does not know anything about module 1.

In the diagram above, we have OrderController, which holds references to OrderDatabase and OrderPresenter. OrderDatabase is responsible for loading and persisting order models. OrderPresenter is responsible for mapping the order model to the response payload data structure.

Let's assume that stakeholders asked to implement sending orders via email. We quickly update the controller code so that it sends an email to the user when a new order is created.

Let's look at the following pseudocode:

```java
class OrderController {
  constructor() {
    this.mailServer = new MailServer()
    this.orderPresenter = new OrderPresenter()
  }

  public createOrder(): Promise<OrderView> {
    const order = new Order(...)
    
    await order.save()
    
    const orderView = this.orderPresenter.present(order)
    
    this.mailServer.send(orderView)
    
    return orderView
  }
}
```

After some time, new requirements are introduced. We need to display the order total price in the email. In other words, we need to update our order view.

The important thing to understand is that the order is presented by two different views: via a mobile screen and via email. With new requirements, each view displays order details differently.

There are several ways in which we can implement the solution. We can extend OrderPresenter with a new method for creating an email view. We can create another presenter module for emails. In both cases, we have to update our controller to match the new presenter APIs.

Doesn't it look like we are violating the OCP? How can we protect our controller and presenters from changes each time a new requirement is introduced?

The solution:

Let's start off by splitting our presentation logic into two modules. Each module will be responsible for the transformation of the order model to the needed structure for a particular view.

That's better. Changes in the email presenter, like adding new fields and so on, won't affect the mobile presenter. But still, the problem with the controller persists. How do we organize our code in order to protect the controller when the presenter API is changed?

To achieve that, we need to make the controller independent from presenters by inverting the dependencies. Our controller module should define an interface for the presenter. And the presenter should implement this interface.

To achieve that, we need to make the controller independent from presenters by inverting the dependencies. Our controller module should define an interface for the presenter. And the presenter should implement this interface.To achieve that, we need to make the controller independent from presenters by inverting the dependencies. Our controller module should define an interface for the presenter. And the presenter should implement this interface.

1-2『上面的图，很好的展示了「反转依赖关系」，目前没吃透，需反复研读。（2021-04-23）』—— 未完成

With this architecture, the controller doesn't know anything about the actual implementation of presenters. All the presenters must follow the contract defined in the interface. Let's look at the updated code example:

```java
export interface IEmailPresenter {
  present(order: Order): EmailView
}

export interface IMobilePresenter {
  present(order: Order): MobileView
}

class OrderController {
  constructor(emailPresenter: IEmailPresenter, mobilePresenter: IMobilePresenter) {
    this.emailPresenter = orderPresenter
    this.mobilePresenter = mobilePresenter
    this.mailServer = new MailServer()
  }

  public createOrder(): Promise<MobileView> {
    const order = new Order(...)
    
    await order.save()
    
    const emailView = this.emailPresenter.present(order)  
    
    this.mailServer.send(emailView)
    
    const mobileView = this.mobilePresenter.present(order)
    
    return mobileView
  }
}
```

As the result, we closed our OrderController for modification using the interfaces. Additionally, we can say that our presenters are opened for extension. When we need to add another type of functionality, we provide a new module.

This is how OCP works. You split the application, considering how, when, and why it needs to be changed. After that, you organize everything into the components hierarchy. Those components which need to be protected from changes define the interfaces used by frequently changing components.

### 04. Liskov Substitution Principle (LSP)

A subclass should override the parent class methods in a way that does not break functionality from a client's point of view

In other words, software modules that use base type should be able to use subtypes of the base type without changing the code.

Software modules that use base type should be able to use subtypes of the base type without changing the code.Software modules that use base type should be able to use subtypes of the base type without changing the code.
Such design corresponds to LSP if the base type can be replaced by both subtypes.

But what are base types and subtypes? The base type can be a class with subtypes as successors. Or the base type can be an interface with subtypes as its implementations.

To better understand the idea behind LSP, let's look at the example.

The problem:

Imagine we need to implement an e-wallet application, where we can transfer money from one card to another. An abstract solution might look like this:

```java
class BankCard {
  topup() { ... }
  withdraw() { ... }
}

class Wallet {
  transfer(amount: number, sender: BankCard, receiver: BankCard) {
    // ...
  }
}

const wallet = new Wallet()
const senderBankCard = new BankCard()
const receiverBankCard = new BankCard()

wallet.transfer(1000, senderBankCard, receiverBankCard)
```

Here we have a Wallet instance that uses BankCard instances to make transfers.

After some time, new requirements were added to our e-wallet application. Our wallet users have to be able to transfer money from a savings card. These cards are virtual. They can't be replenished manually, so they don't have a topup method.

Now our sender can be a bank card or a savings card.

```java
class BankCard {
  topup() { ... }
  withdraw() { ... }
}
class SavingsCard {
  withdraw() { ... }
}

class Wallet {
  transfer(amount: number, sender: BankCard | SavingsCard, receiver: BankCard) {
    if (sender instanceof BankCard) {
      // ...
    }
    if (sender instanceof SavingsCard) {
      // ...
    }
  }
}

const wallet = new Wallet()
const senderSavingsCard = new SavingsCard()
const receiverBankCard = new BankCard()

wallet.transfer(1000, senderSavingsCard, receiverBankCard)
```

This will work, but any time a new card is introduced, we have to add a new type to the argument and a new if statement. We can't replace BankCard with SavingsCard, so we're violating the LSP.

The solution:

To follow the LSP, we need to add a base type for our cards to support their interchangeability. This approach guarantees that we'll always have the withdraw method.

```java
interface IWithdrawable {
  withdraw(): void
}

interface IRechargeable {
  topup(): void
}

class BankCard implements IRechargable, IWithdrawable {
  topup() { ... }
  withdraw() { ... }
}

class SavingsCard implements IWithdrawable {
  withdraw() { ... }
}

class Wallet {
  transfer(amount: number, sender: IWithdrawable, receiver: IRechargable) {
    // ...
  }
}

const wallet = new Wallet()
const senderSavingsCard = new SavingsCard()
const receiverBankCard = new BankCard()

wallet.transfer(1000, senderSavingsCard, receiverBankCard)
```

Now we can say the solution above follows the LSP. We have a base type: IWithdrawable. It can be replaced by its subtypes BankCard and SavingsCard. Our method works with base type, so we don't need to modify it each time a new card is introduced. The only requirement for new cards is to be subtypes of our base type.

### 05. Interface-Segregation Principle (ISP)

Software modules should not be forced to depend upon interfaces that they do not use

The ISP states that we should write a series of smaller and more specific interfaces that are implemented by the class. Each interface provides a single behavior. In other words, many specific interfaces are better than one general interface.
When the principle is violated, software modules are forced to implement methods that they don't use. Moreover, any changes to the method signature in the interface leads to changes in dependent classes. This is an overhead and undesired level of connectivity between modules.

The problem:

For example, you're creating a blog. You have different types of users.

The top category is iBaseUser and the subcategories are Admin, Writer, and Reader.The top category is iBaseUser and the subcategories are Admin, Writer, and Reader.

IBaseUser is our general interface. It has a set of common methods for each successor type. In our example, the Admin and Writer have a common method for editing blog posts. But readers don't++they can only read posts. Also, only the admin can block posts.

```java
interface IBaseUser {
  viewPost(): void
  editPost(): void
  blockPost(): void
}

class Admin implements IBaseUser {
  public viewPost() { ... }
  public editPost() { ... }
  public blockPost() { ... }
}

class Writer implements IBaseUser {
  public viewPost() { ... }
  public editPost() { ... }
  public blockPost() { 
    throw new Error('writer can not block posts') 
  }
}

class Reader implements IBaseUser {
  public viewPost() { ... }
  public editPost() { 
    throw new Error('reader can not edit post!') 
  }
  public blockPost() { 
    throw new Error('reader can not block posts') 
  }
}
```

The Reader and Writer classes have to implement the methods they donät use — hence, they violate ISP.

When a business grows, so does its functionality. New users are added with a set of methods related to them. Our IBaseUser interface becomes more and more complex. All the classes that implement IBaseUser grow relatively. So how can we solve this problem?

The solution:

This problem can be solved by dividing the functionality into separate small interfaces.

If any client wants both behaviors, then they can implement both interfaces. Let's look at the code example:

```java
interface IReader {
  readPost(): void
}

interface IWriter {
  editPost(): void
}

interface IAdmin {
  blockPost(): void
}

class Admin implements IReader, IWriter, IAdmin {
  public viewPost() { ... }
  public editPost() { ... }
  public blockPost() { ... }
}

class Writer implements IReader, IWriter {
  public viewPost() { ... }
  public editPost() { ... }
}

class Reader extends IReader {
  public viewPost() { ... }
}
```

Following ISP decreases the complexity of developing and maintaining the application. The simpler and more minimalistic of an interface used, the less resource-intensive is its implementation in new classes.

### 06. Dependency-Inversion Principle (DIP)

High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.

High-level modules that provide business logic, should be unaffected by changes in low-level modules that provide utility features. To achieve that, we need to introduce an abstraction such as an interface that decouples modules from each other.

The DIP is a result of the strict following of the open-closed principle and the Liskov substitution principle.

The problem:

For example, we need to create a module that receives the user, encodes its password, and then saves it in the database. Let's look at the diagram.

UserService is the high-level module. Underneath it are the subcategories Crypto PasswordEncoder and UsersRespository.UserService is the high-level module. Underneath it are the subcategories Crypto PasswordEncoder and UsersRespository.

UserService is our high-level module. It contains business logic. It directly depends on CryptoPasswordEncoder and UsersRepository, our low-level modules.

```java
class UserService {
  constructor() {
    this.repository = new UsersRepository()
    this.passwordEncoder = new CryptoPasswordEncoder()
  }
  
  public registerUser(data: RawUser): void {
    const userEntity = new UserEntity({
      email: data.email,
      passwordHash: this.passwordEncoder.encode(data.password)
    })
    this.repository.save(userEntity)
  }
}

class CryptoPasswordEncoder {
  public encode(password: string): string { ... }
}

class UsersRepository {
  public save(userEntity: UserEntity): void { ... }
}
```

But this design doesn't look flexible. Let's imagine that after the security audit, we're asked to use a more secure library, like crypto.

With that in mind, we create the BcryptPasswordEncoder class and change the UserService constructor method. If the method signature was changed too, we also need to modify all of the places where the module is used.
Moreover, it'd be hard to test UserService because it's highly coupled with CryptoPasswordEncoder and UsersRepository.

The solution:

As DIP says, our modules should depend on abstractions. A good way to provide an abstraction is to add an interface.

```java
interface IPasswordEncoder {
  encode(password: string): string
}

interface IUsersRepository {
  save(userEntity: UserEntity): void
}

class UserService {
  constructor(repository: IUsersRepository, passwordEncoder: IPasswordEncoder) {
    this.repository = repository
    this.passwordEncoder = passwordEncoder
  }

  public registerUser(data: RawUser): void {
    const userEntity = new UserEntity({
      email: data.email,
      passwordHash: this.passwordEncoder.encode(data.password)
    })

    this.repository.save(userEntity)
  }
}

class BcryptPasswordEncoder implements IPasswordEncoder {
  public encode(password: string): string { ... }
}

class UsersRepository implements IUsersRepository {
  public save(userEntity: UserEntity): void { ... }
}
```

Now our high-level module UserService depends on two abstractions — IPasswordEncoder and IUsersRepository. Our BcryptPasswordEncoder and UsersRepository classes implement these interfaces.

Now our high-level module UserService depends on two abstractions — IPasswordEncoder and IUsersRepository. Our BcryptPasswordEncoder and UsersRepository classes implement these interfaces.Now our high-level module UserService depends on two abstractions — IPasswordEncoder and IUsersRepository. Our BcryptPasswordEncoder and UsersRepository classes implement these interfaces.

The most important thing we achieved is an inversion of dependencies. Arrows from our low-level modules are pointing in another direction. As a result, we decoupled UserService from CryptoPasswordEncoder and UsersRepository.

Each time we need to change a third-party library or modify existing logic in our low-level modules, we just need to follow the contract defined in interfaces. The interface must be provided by high-level modules.

Besides that, following the DIP forces us to inject our dependencies. In the code example, it's done via the constructor method, where we're passing the repository and passwordEncoder arguments. This approach simplifies unit testing.

The outcome of applying the DIP is the protection of high-level modules from changes. Since these modules contain business logic, the core functionality of our applications, it's beneficial for us to avoid any changes there.

## 20210318Top-10-Most-Useful-Online-Courses-That-Are-Free.md

I tend to prefer courses to books. Although the best books definitely beat mediocre courses, there's a few reasons why a great course can leave a lasting impression.

For starters, courses tend to teach foundational topics. Most books try to be original. But much of what's worth knowing is actually fairly old.

Courses tend to be more balanced. A professor teaching a basic course will try to explain most of the major viewpoints. Yet a popular book written by the same professor might be completely one-sided, as they try to make the strongest case for their views. Polemical works can be useful, but they can be misleading if you mistake a contentious issue for an open-and-shut case.

I also just like watching courses. Reading is good. But so are listening and watching. If you do all three, you'll probably learn more than if you just stick to text. Here are my picks for the best free online courses to watch.

### 01. Justice — Michael Sandel (Harvard)

Honestly, this course is worth watching just to witness one of the best teachers of all time. Sandel teaches moral philosophy, not always known for being the most gripping topic. Yet the lectures are compelling, as students debate real-world examples that illustrate philosophical principles.

What impresses me most is Sandel's ability to teach esoteric points through Socratic dialog with his students, using their own reactions to illustrate the philosophical principles he wants to teach. There's a reason this class is one of Harvard's most popular among incoming freshman. Now you don't need to attend Harvard to take it.

### 02. Physics — Walter Lewin (MIT)

Walter Lewin's physics lectures (both classical and electromagnetism) were the ones I followed during the MIT Challenge. They're some of the finest classes I've ever taken online. Lewin manages to explain deep concepts about how the world works through exciting experiments. He's also really good at drawing dotted lines.

Unfortunately there was a bit of a scandal on MIT's open platform which resulted in MIT removing any affiliation with Lewin for the course. Thus the lectures are harder to find online than they used to be. But since nothing ever truly gets removed from the internet, I think they're still worth watching if you want to learn physics.

[MIT Challenge | Scott H Young](https://www.scotthyoung.com/blog/myprojects/mit-challenge-2/)

### 03. Learning How to Learn — Terrence Sejnowski and Barbara Oakley (UCSD)

Coursera's most popular course, this one also happens to be taught by my friend, Barbara Oakley. The course is engaging and easy to follow, using neuroscience and psychology to illustrate the principles for studying better.

I have to admit, when this course first came out, I was a little nervous since my income depends a lot on my own, paid learning course. But, I've since come to appreciate that learning better is a pretty broad subject, so there's always going to be more to teach (and learn). Nonetheless, I recommend this course as a useful resource!

[Learning How to Learn: Powerful mental tools to help you master tough subjects | Coursera](https://www.coursera.org/learn/learning-how-to-learn)

[How to become a Rapid Learner](https://www.rapid-learner-course.com/)

### 04. Machine Learning — Andrew Ng (Stanford)

This course started the MOOC explosion, with Ng leaving his Stanford teaching position to launch Coursera. This course has gone through multiple iterations, first as recorded lectures from an actual Stanford class, later as a simplified MOOC and now as a full-blown machine learning educational platform.

I've linked to the original Stanford class, as I prefer to embed YouTube. The Coursera version is also a little unclear as to whether it is actually free, or whether there's a small fee. However, you may prefer the MOOC version here since it is more recent.

[Machine Learning | Coursera](https://www.coursera.org/learn/machine-learning)

[Machine Learning - Home | Coursera](https://www.coursera.org/learn/machine-learning/home/welcome)

[Deep Learning | Coursera](https://www.coursera.org/specializations/deep-learning?#enroll)

### 05. Quantum Mechanics — Richard Feynman

Richard Feynman is my all-time intellectual hero. He does a brilliant job here of explaining quantum mechanics — without using any math. I would have thought it was impossible, but somehow Feynman manages to pull it off. (And barefoot, no less!).

While I highly enjoyed Allan Adams MIT quantum physics class, the math requirements are fairly steep. The amount of people who both have the math and physics requirements, but somehow didn't study quantum mechanics in their undergraduate education, might be fairly limiting so I didn't include it here. (That said, the first lecture of the class is math-free and very well done, so I recommend it, even if you don't know calculus.)

[1. Introduction to Superposition - YouTube](https://www.youtube.com/watch?v=lZ3bPUKo5zc)

### 06. Medical Neuroscience — Leonard White (Duke)

This course is the best one I've found on neuroscience. White gives a detailed walkthough of how the brain works. He even shows actual human brain tissue on camera, along with copious diagrams and slides.

The course is tough, especially if you want to pass the exams. I even made flashcards for it while I was studying it to keep all the anatomy straight. That said, if you just wanted to audit the class I think you'd still learn a lot about how the brain works.

[Medical Neuroscience | Coursera](https://www.coursera.org/learn/medical-neuroscience)

### 07. Organic Chemistry — Michael McBride (Yale)

This was a course I just finished watching recently, after a reader suggested it for my effort to learn more biology.

I found the course really engaging, especially the first semester. While organic chemistry is often one of those feared courses for memorization and complexity, McBride manages to convey the fundamental ideas through the lens of scientific discovery.

Considerable time is spent showing how certain ideas in chemistry were discovered, starting with Lavoisier, to Wöhler and Kekulé. I enjoy science classes that show how we managed to figure things out, rather than encouraging you to simply accept it as true just because the teacher told you so.

[What's the Best Way to Learn Biology? | Scott H Young](https://www.scotthyoung.com/blog/2021/01/18/biology/)

### 08. Immunology — Alma Novotny (Rice)

A four-part course series on the immune system, I coincidentally started taking this one shortly before the coronavirus pandemic began.

The immune system is much more interesting than I had realized, prior to taking this course. Just how can your body develop cells that can recognize and remove completely novel pathogens, without harming any of your own tissues? How do you defend against viruses that hijack your body's cells or bacteria that replicate rapidly and evolve around your defenses? Why do we get allergies or suffer from autoimmune diseases?

This course builds a great foundation for these topics. The cute illustrations of various immune cells too are also a plus, as someone who likes to communicate ideas visually can appreciate.

[Fundamentals of Immunology | Coursera](https://www.coursera.org/specializations/immunology)

### 09. World History — John Green (Crash Course)

Beautifully animated and tightly scripted, this is a course specifically developed for a YouTube audience. I enjoyed this course immensely when it first came out, giving a good overview of many different historical events.

Crash Course now has many courses on different topics, so they're a great resource if you prefer this style to chalkboard or PowerPoint lectures.

[CrashCourse - YouTube](https://www.youtube.com/channel/UCX6b17PVsYBQ0ip5gyeme-Q)

### 10. Microeconomics — Tyler Cowen and Alex Tabbarock (MRU)

Economics is probably the subject I use most in my daily thinking. If you're keen on learning mental models by which to see reality, economics is a really good place to start.

Cowen and Tabbarock write the popular economics blog Marginal Revolution and teach at George Mason University. Their foray into online education has produced some truly stellar video courses. Their micro and macro courses are quite good, and they manage to convey complicated ideas about the economy without veering into too much abstraction.

[Principles of Economics: Macroeconomics | Marginal Revolution University](https://mru.org/principles-economics-macroeconomics-0)

[Principles of Economics: Microeconomics | Marginal Revolution University](https://mru.org/principles-economics-microeconomics)

### Honorable Mentions

I realized, after creating this list, how many good courses I've taken that couldn't fit. So here's a short list of some honorable mentions:

1 Nonlinear Dynamics and Chaos by Steven Strogatz — The math behind the Butterfly Effect and why reality can be inherently unpredictable.

[Nonlinear Dynamics and Chaos - Steven Strogatz, Cornell University - YouTube](https://www.youtube.com/playlist?list=PLbN57C5Zdl6j_qJA-pARJnKsmROzPnO9V)

2 Systems Biology by Uri Alon — Fascinating machinery of human cells, from gene regulation to why we get Type II diabetes.

[Systems biology course 2018 Uri Alon - Lecture 1 - Basic concepts - YouTube](https://www.youtube.com/watch?v=N6VZeWuME_A)

3 Programming Paradigms by Jerry Cain — One of my first-ever online courses. Part of the impetus to do the MIT Challenge.

[Lecture 1 | Programming Paradigms (Stanford) - YouTube](https://www.youtube.com/watch?v=Ps8jOj7diA0)

1-2-3『

这是之前自己看到好几次，一直想找的斯坦福大学的「编程范式」公开课。想不到在这里看到了。同时在 B 站上也找到了课程资源，那么可以去下载了。（2021-04-24）

[Stanford CS107 Programming Paradigms 编程范式_哔哩哔哩](https://www.bilibili.com/video/BV1Cx411S7HJ?from=search&seid=3072034374126116190)

[Stanford Engineering Everywhere | CS107 - Programming Paradigms](https://see.stanford.edu/Course/CS107)

已下载视频专栏「2021008斯坦福的编程范式课」以及课件专栏「2021008斯坦福的编程范式」。

同时顺藤摸瓜，有发现了一个大大的宝藏，斯坦福大学的其他公开课：[Stanford Engineering Everywhere | Courses](https://see.stanford.edu/Course/)。那么同理，其他名校应该也有这种公开课教材网，以后一定要留意这个。斯坦福大学的公开课网站，做一张主题卡片。（2021-04-24）—— 已完成

CS106A - Programming Methodology

This course is the largest of the introductory programming courses and is one of the largest courses at Stanford. Topics focus on the introduction to the engineering of computer applications emphasizing modern software engineering principles: object-oriented design, decomposition, encapsulation, abstraction, and testing.

Programming Methodology teaches the widely-used Java programming language along with good software engineering principles. Emphasis is on good programming style and the built-in facilities of the Java language. The course is explicitly designed to appeal to humanists and social scientists as well as hard-core techies. In fact, most Programming Methodology graduates end up majoring outside of the School of Engineering.

Prerequisites: The course requires no previous background in programming, but does require considerable dedication and hard work.

上面的公开课可以用来学习 Java。

CS106B - Programming Abstractions

This course is the natural successor to Programming Methodology and covers such advanced programming topics as recursion, algorithmic analysis, and data abstraction using the C++ programming language, which is similar to both C and Java. If you've taken the Computer Science AP exam and done well (scored 4 or 5) or earned a good grade in a college course, Programming Abstractions may be an appropriate course for you to start with, but often Programming Abstractions (Accelerated) is a better choice. Programming Abstractions assumes that you already have familiarity with good programming style and software engineering issues (at the level of Programming Methodology), and that you can use this understanding as a foundation on which to tackle new topics in programming and data abstraction.

Topics: Abstraction and its relation to programming. Software engineering principles of data abstraction and modularity. Object-oriented programming, fundamental data structures (such as stacks, queues, sets) and data-directed design. Recursion and recursive data structures (linked lists, trees, graphs). Introduction to time and space complexity analysis. Uses the programming language C++ covering its basic facilities.

Prerequisites: Solid performance in Programming Methodology and readiness to move on to advanced programming topics. A comparable introductory programming course (including high school AP courses) is often a reasonable substitute for our Programming Methodology.

上面的公开课可以用来学习 C++。

』

4 Intro Biology by Eric Lander — Great lectures on biology, especially those taught by Lander. The only annoyance is that this course is stitched together from multiple segments rather than complete lectures. Nonetheless, the sections on genetics are really well done.

[Introduction to Biology | Biology | MIT OpenCourseWare](https://ocw.mit.edu/courses/biology/7-012-introduction-to-biology-fall-2004/index.htm)

5 Poker Theory and Analytics by Kevin Desmond — Fun class on the math behind poker betting. I took this when working on a poker programming project.

[Poker Theory and Analytics | Sloan School of Management | MIT OpenCourseWare](https://ocw.mit.edu/courses/sloan-school-of-management/15-s50-poker-theory-and-analytics-january-iap-2015/index.htm)

6 Being and Time by Hubert Dreyfus — Dreyfus has a ton of audio-only courses on Contintental philosophers. His one on Heidegger is the best.

[01 of 28 Heidegger's Being & Time Hubert Dreyfus 2007 - YouTube](https://www.youtube.com/watch?v=IaIWz_87Kz0)

What are your favorite online courses you've taken? Are there any greats that I've missed? Share your suggestions in the comments!