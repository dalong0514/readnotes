## 记忆时间

## 0400. 可扩展架构模式

## 0401. 可扩展架构的基本思想和模式

软件系统与硬件和建筑系统最大的差异在于软件是可扩展的，一个硬件生产出来后就不会再进行改变、一个建筑完工后也不会再改变其整体结构。例如，一颗 CPU 生产出来后装到一台 PC 机上，不会再返回工厂进行加工以增加新的功能；金字塔矗立千年历经风吹雨打，但其现在的结构和当时建成完工时的结构并无两样。相比之下，软件系统就完全相反，如果一个软件系统开发出来后，再也没有任何更新和调整，反而说明了这套软件系统没有发展、没有生命力。真正有生命力的软件系统，都是在不断迭代和发展的，典型的如 Windows 操作系统，从 Windows 3.0 到 Windows 95 到 Windows XP，直到现在的 Windows 10，一直在跟着技术的发展而不断地发展。

今天我们进入架构可扩展模式的学习，这部分内容包括分层架构、SOA 架构、微服务和微内核等，先来聊聊架构的可扩展模式。软件系统的这种天生和内在的可扩展的特性，既是魅力所在，又是难点所在。魅力体现在我们可以通过修改和扩展，不断地让软件系统具备更多的功能和特性，满足新的需求或者顺应技术发展的趋势。而难点体现在如何以最小的代价去扩展系统，因为很多情况下牵一发动全身，扩展时可能出现到处都要改，到处都要推倒重来的情况。这样做的风险不言而喻：改动的地方越多，投入也越大，出错的可能性也越大。因此，如何避免扩展时改动范围太大，是软件架构可扩展性设计的主要思考点。

### 1.1 可扩展的基本思想

幸运的是，可扩展性架构的设计方法很多，但万变不离其宗，所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：拆！

拆，就是将原本大一统的系统拆分成多个规模小的部分，扩展时只修改其中一部分即可，无须整个系统到处都改，通过这种方式来减少改动范围，降低改动风险。说起来好像挺简单，毕竟「拆」我们见得太多了。一般情况下，我们要拆一个东西时，都是简单粗暴的。例如，用推土机拆房子、用剪刀拆快递包装、用手撕开包装袋等，反正拆完了这些东西就扔了。但面对软件系统，拆就没那么简单了，因为我们并不是要摧毁一个软件系统，而是要通过拆让软件系统变得更加优美（具备更好的可扩展性）。形象地说，软件系统中的「拆」是建设性的，因此难度要高得多。

按照不同的思路来拆分软件系统，就会得到不同的架构。常见的拆分思路有如下三种。1）面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。2）面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。3）面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。

理解这三种思路的关键就在于如何理解「流程」「服务」「功能」三者的联系和区别。从范围上来看，从大到小依次为：流程 > 服务 > 功能，单纯从概念解释可能难以理解，但实际上看几个案例就很清楚了。我以 TCP/IP 协议栈为例，来说明「流程」「服务」「功能」的区别和联系。TCP/IP 协议栈和模型图如下图所示。

1、流程。对应 TCP/IP 四层模型，因为 TCP/IP 网络通信流程是：应用层 → 传输层 → 网络层 → 物理 + 数据链路层，不管最上层的应用层是什么，这个流程都不会变。

2、服务。对应应用层的 HTTP、FTP、SMTP 等服务，HTTP 提供 Web 服务，FTP 提供文件服务，SMTP 提供邮件服务，以此类推。

3、功能。每个服务都会提供相应的功能。例如，HTTP 服务提供 GET、POST 功能，FTP 提供上传下载功能，SMTP 提供邮件发送和收取功能。

1『上面关于流程、服务和功能的信息，收获很大，特别是意外获得了：HTTP 提供 Web 服务，FTP 提供文件服务，SMTP 提供邮件服务。拆分软件系统的思路，做一张主题卡片。』——已完成

我再以一个简单的学生信息管理系统为例（几乎每个技术人员读书时都做过这样一个系统），拆分方式是：

1、 面向流程拆分。展示层 → 业务层 → 数据层 → 存储层，各层含义是：1）展示层：负责用户页面设计，不同业务有不同的页面。例如，登录页面、注册页面、信息管理页面、安全设置页面等。2）业务层：负责具体业务逻辑的处理。例如，登录、注册、信息管理、修改密码等业务。3）数据层：负责完成数据访问。例如，增删改查数据库中的数据、记录事件到日志文件等。4）存储层：负责数据的存储。例如，关系型数据库 MySQL、缓存系统 Memcache 等。最终的架构如下：

2、面向服务拆分。将系统拆分为注册、登录、信息管理、安全设置等服务，最终架构示意图如下：

3、面向功能拆分。每个服务都可以拆分为更多细粒度的功能，例如：1）注册服务：提供多种方式进行注册，包括手机号注册、身份证注册、学生邮箱注册三个功能。2）登录服务：包括手机号登录、身份证登录、邮箱登录三个功能。3）信息管理服务：包括基本信息管理、课程信息管理、成绩信息管理等功能。4）安全设置服务：包括修改密码、安全手机、找回密码等功能。最终架构图如下：

通过学生信息管理系统的案例可以发现，不同的拆分方式，架构图差异很大。但好像无论哪种方式，最终都是可以实现的。既然如此，我们何必费尽心机去选择呢，随便挑选一个不就可以了？当然不能随便挑，否则架构设计就没有意义了，架构师也就要丢掉饭碗了。原因在于：不同的拆分方式，本质上决定了系统的扩展方式。

### 1.2 可扩展方式

当我们谈可扩展性时，很多同学都会有一个疑惑：就算是不拆分系统，只要在设计和写代码时做好了，同样不会出现到处改的问题啊？例如，在面向服务拆分的案例中，增加「学号注册」，就算是不拆分为服务，也可以控制修改的范围，那为何我们要大费周章地去拆分系统呢？

在一个理想的环境，你的团队都是高手，每个程序员都很厉害，对业务都很熟悉，新来的同事很快就知晓所有的细节…… 那确实不拆分也没有问题。但现实却是：团队有菜鸟程序员，到底是改 A 处实现功能还是改 B 处实现功能，完全取决于他觉得哪里容易改；有的程序员比较粗心；有的程序员某天精神状态不太好；新来的同事不知道历史上某行代码为何那么「恶心」，而轻易地将其改漂亮了一些…… 所有的这些问题都可能出现，这时候你就会发现，合理的拆分，能够强制保证即使程序员出错，出错的范围也不会太广，影响也不会太大。

下面是不同拆分方式应对扩展时的优势。

1、面向流程拆分。扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。例如学生信息管理系统，如果我们将存储层从 MySQL 扩展为同时支持 MySQL 和 Oracle，那么只需要扩展存储层和数据层即可，展示层和业务层无须变动。

2、面向服务拆分。对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。同样以学生管理系统为例，如果我们需要在注册服务中增加一种「学号注册」功能，则只需要修改「注册服务」和「登录服务」即可，「信息管理服务」和「安全设置」服务无须修改。

3、面向功能拆分。对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。同样以学生管理系统为例，如果我们增加「学号注册」功能，则只需要在系统中增加一个新的功能模块，同时修改「登录功能」模块即可，其他功能都不受影响。

不同的拆分方式，将得到不同的系统架构，典型的可扩展系统架构有：1）面向流程拆分：分层架构。2）面向服务拆分：SOA、微服务。3）面向功能拆分：微内核架构。当然，这几个系统架构并不是非此即彼的，而是可以在系统架构设计中进行组合使用的。以学生管理系统为例，我们最终可以这样设计架构：1）整体系统采用面向服务拆分中的「微服务」架构，拆分为「注册服务」「登录服务」「信息管理服务」「安全服务」，每个服务是一个独立运行的子系统。2）其中的「注册服务」子系统本身又是采用面向流程拆分的分层架构。3）「登录服务」子系统采用的是面向功能拆分的「微内核」架构。

### 黑板墙

规则引擎是常用的一种支持可扩展的方式，按照今天的分析，它属于哪一类？

面向流程、面向服务、面向功能，这三个的命名，面向服务和面向功能还可以，面向流程这个容易让人误解。面向流程，大概指的是数据移动的流程，而不是业务流程。分层架构的本质，就是固定的内核，移动的数据。规则引擎的扩展方式，可以用下排除法。首先，肯定不是分层架构，即不是面向流程的，因为规则引擎主要作用在业务层。其次，也不应该是面向服务的，因为规则引擎都是跨越多个服务的。规则引擎和插件式架构，解决的都是功能扩展的问题。微内核架构就是一种插件式架构。所以，规则引擎应该是面向功能的扩展方式。作者回复：思路很清晰，赞，面向流程这个说法确实不那么容易理解，但你对照 TCP/IP 那个图就很清晰了。2018-07-10

规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策。规则引擎是将业务决策与业务分离，它提供的还是决策功能，我觉得是面向功能，我没使用规则引擎的经验！不知道这样理解是否存在问题？作者回复：理解正确。2018-07-10

规则引擎是嵌入的一种功能组件，就像计算引擎一样，属于功能级的概念，应该属于面向功能的拆分。另一方面，即使把规则相关的部分做成服务，仅就规则引擎来讲，它也是功能级的概念，而非流程或者服务。2018-07-26

面向服务和面向功能，这两个概念感觉十分难以区分，某个功能也可以做成一个微服务，某个微服务也可以认为是一个功能，求教二者的差别。作者回复：可以理解服务是一组相似功能的集合，例如用户登录是服务，这个服务支持手机号登录，微信登录，QQ 登录 3 个登录功能，当然，如果你真的需要把手机号登录做成一个独立的服务也是可以的，不存在绝对的界限。2018-07-11

面向流程是否可以这样理解，比如电商网站下单的流程。登陆、浏览商品、加入购物车、结算、下单、支付、收货、评价等。拆完就是用户服务、商品服务、订单服务、评价服务等。谢谢华仔这么赞的所有章节！作者回复：是的，这就是面向流程拆分，同样是这个电商案例，如果按照男装，女装，电器拆分，就是面向服务拆分。2018-07-17

总结下今天所学到的内容。可拓展架构的基本思想就是拆，拆又分为流程拆分，服务拆分，功能拆分，三个粒度是越来越小。在工作中首先是按照业务流程拆分为不同的服务，小服务为了支持可拓展按流程拆分为合单、过滤拦截、冻结、查询库存、预售、寻仓等，再每个小流程按功能去拆分为不同的接口，再通过配置化实现这些接口的组装或者说调用链，来实现可配置化的支持业务。有新增业务，只需增加配置项和接口，不会影响到其他业务功能。2020-08-07

面向服务的拆分成独立的子系统，如文中所讲的学生管理系统，拆分为注册服务，登录服务，管理系统等子系统，请问老师，这些子系统是自己链接数据库的吗？实际项目都是怎么做的？作者回复：每个服务是独立的子系统，有各自独立的数据库，缓存，服务器。2018-07-10

规则引擎更多的是对变化比较频繁、参数比较多、条件组合比较多场景下的一种相对优雅的解决方法，可以归属为服务或功能层面，具体是功能还是服务要看切分的粒度。比如判断当前操作者是否为用户本人，可以采用规则引擎来实现，但这是一个服务还是功能就需要看具体的切分粒度和实现方式。作者回复：通常规则引擎还是按功能拆分更方便实施。2018-09-09

面向服务拆分的具体表现形式是每个服务部署为一个子系统，面向功能拆分的具体表现形式是怎样的呢，新功能一个 dll？作者回复：微内核，规则引擎。2018-07-16

感觉像是按功能拆分，一个模块可能之前只支持一两个规则，在有新的功能要加进来时可以只添加具体功能的实现，嵌入到原来的流程中。比如我们之前做的积分系统，各种活动获取积分时翻倍，新的活动规则都是用插件的方式添加的，不知道这个算不算。作者回复：是的，功能拆分。2018-07-10

## 0402. 传统的可扩展架构模式：分层架构和 SOA

李运华 2018-07-12

相比于高性能、高可用架构模式在最近几十年的迅猛发展来说，可扩展架构模式的发展可以说是步履蹒跚，最近几年火热的微服务模式算是可扩展模式发展历史中为数不多的亮点，但这也导致了现在谈可扩展的时候必谈微服务，甚至微服务架构都成了架构设计的银弹，高性能也用微服务、高可用也用微服务，很多时候这样的架构设计看起来高大上，实际上是大炮打蚊子，违背了架构设计的「合适原则」和「简单原则」。为了帮助你在实践中更好的进行可扩展架构设计，我将分别介绍几种可扩展架构模式，指出每种架构模式的关键点和优缺点。今天我来介绍传统的可扩展模式，包括分层架构和 SOA，后面还会介绍微服务架构。

### 2.1 分层架构

分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。按照分层架构进行设计时，根据不同的划分维度和对象，可以得到多种不同的分层架构。

1、C/S 架构、B/S 架构。划分的对象是整个业务系统，划分的维度是用户交互，即将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层。例如，下面是 C/S 架构结构图。

2、MVC 架构、MVP 架构。划分的对象是单个业务子系统，划分的维度是职责，将不同的职责划分到独立层，但各层的依赖关系比较灵活。例如，MVC 架构中各层之间是两两交互的：

3、逻辑分层架构。划分的对象可以是单个业务子系统，也可以是整个业务系统，划分的维度也是职责。虽然都是基于职责划分，但逻辑分层架构和 MVC 架构、MVP 架构的不同点在于，逻辑分层架构中的层是自顶向下依赖的。典型的有操作系统内核架构、TCP/IP 架构。例如，下面是 Android 操作系统架构图。

典型的 J2EE 系统架构也是逻辑分层架构，架构图如下：

针对整个业务系统进行逻辑分层的架构图如下：

无论采取何种分层维度，分层架构设计最核心的一点就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构，这也是分层不能分太多层的原因。否则如果两个层的差异不明显，就会出现程序员小明认为某个功能应该放在 A 层，而程序员老王却认为同样的功能应该放在 B 层，这样会导致分层混乱。如果这样的架构进入实际开发落地，则 A 层和 B 层就会乱成一锅粥，也就失去了分层的意义。

分层架构之所以能够较好地支撑系统扩展，本质在于隔离关注点（separation of concerns），即每个层中的组件只会处理本层的逻辑。比如说，展示层只需要处理展示逻辑，业务层中只需要处理业务逻辑，这样我们在扩展某层时，其他层是不受影响的，通过这种方式可以支撑系统在某层上快速扩展。例如，Linux 内核如果要增加一个新的文件系统，则只需要修改文件存储层即可，其他内核层无须变动。

当然，并不是简单地分层就一定能够实现隔离关注点从而支撑快速扩展，分层时要保证层与层之间的依赖是稳定的，才能真正支撑快速扩展。例如，Linux 内核为了支撑不同的文件系统格式，抽象了 VFS 文件系统接口，架构图如下：

如果没有 VFS，只是简单地将 ext2、ext3、reiser 等文件系统划为「文件系统层」，那么这个分层是达不到支撑可扩展的目的的。因为增加一个新的文件系统后，所有基于文件系统的功能都要适配新的文件系统接口；而有了 VFS 后，只需要 VFS 适配新的文件系统接口，其他基于文件系统的功能是依赖 VFS 的，不会受到影响。

对于操作系统这类复杂的系统，接口本身也可以成为独立的一层。例如，我们把 VFS 独立为一层是完全可以的。而对于一个简单的业务系统，接口可能就是 Java 语言上的几个 interface 定义，这种情况下如果独立为一层，看起来可能就比较重了。例如，经典的 J2EE 分层架构中，Presentation Layer 和 Business Layer 之间如果硬要拆分一个独立的接口层，则显得有点多余了。

分层结构的另外一个特点就是层层传递，也就是说一旦分层确定，整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃。最简单的 C/S 结构，用户必须先使用 C 层，然后 C 层再传递到 S 层，用户是不能直接访问 S 层的。传统的 J2EE 4 层架构，收到请求后，必须按照下面的方式传递请求：

分层结构的这种约束，好处在于强制将分层依赖限定为两两依赖，降低了整体系统复杂度。例如，Business Layer 被 Presentation Layer 依赖，自己只依赖 Persistence Layer。但分层结构的代价就是冗余，也就是说，不管这个业务有多么简单，每层都必须要参与处理，甚至可能每层都写了一个简单的包装函数。我以用户管理系统最简单的一个功能「查看头像」为例。查看头像功能的实现很简单，只是显示一张图片而已，但按照分层分册架构来实现，每层都要写一个简单的函数。比如：

Presentation Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarView {
     public void displayAvatar(int userId){
         String url = AvatarBizz.getAvatarUrl(userId);
   
         //此处省略渲染代码
         return;
     }
  }
```

Business Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarBizz {
     public static String getAvatarUrl(int userId){
         return AvatarDao.getAvatarUrl(userId);
     }
  }
```

Persistence Layer：

```java
package layer;
   
  /**
   * Created by Liyh on 2017/9/18.
   */
  public class AvatarDao {
     public static String getAvatarUrl(int userId) {
       //此处省略具体实现代码，正常情况下可以从MySQL数据库中通过userId查询头像URL即可
         return "http://avatar.csdn.net/B/8/3/1_yah99_wolf.jpg";
     }
  }
```

可以看出 Business Layer 的 AvatarBizz 类的 getAvatarUrl 方法和 Persistence Layer 的 AvatarDao 类的 getAvatarUrl 方法，名称和参数都一模一样。既然如此，我们是否应该自由选择是否绕过分层的约束呢？例如，「查看头像」的示例中，直接让 AvatarView 类访问 AvatarDao 类，不就可以减少 AvatarBizz 的冗余实现了吗？

答案是不建议这样做，分层架构的优势就体现在通过分层强制约束两两依赖，一旦自由选择绕过分层，时间一长，架构就会变得混乱。例如，Presentation Layer 直接访问 Persistence Layer，Business Layer 直接访问 Database Layer，这样做就失去了分层架构的意义，也导致后续扩展时无法控制受影响范围，牵一发动全身，无法支持快速扩展。除此以外，虽然分层架构的实现在某些场景下看起来有些啰嗦和冗余，但复杂度却很低。例如，样例中 AvatarBizz 的 getAvatarUrl 方法，实现起来很简单，不会增加太多工作量。

分层架构另外一个典型的缺点就是性能，因为每一次业务请求都需要穿越所有的架构分层，有一些事情是多余的，多少都会有一些性能的浪费。当然，这里所谓的性能缺点只是理论上的分析，实际上分层带来的性能损失，如果放到 20 世纪 80 年代，可能很明显；但到了现在，硬件和网络的性能有了质的飞越，其实分层模式理论上的这点性能损失，在实际应用中，绝大部分场景下都可以忽略不计。

### 1.2 SOA

SOA 的全称是 Service Oriented Architecture，中文翻译为「面向服务的架构」，诞生于上世纪 90 年代，1996 年 Gartner 的两位分析师 Roy W. Schulte 和 Yefim V. Natis 发表了第一个 SOA 的报告。2005 年，Gartner 预言：到了 2008 年，SOA 将成为 80% 的开发项目的基础。历史证明这个预言并不十分靠谱，SOA 虽然在很多企业成功推广，但没有达到占有绝对优势的地步。SOA 更多是在传统企业（例如，制造业、金融业等）落地和推广，在互联网行业并没有大规模地实践和推广。互联网行业推行 SOA 最早的应该是亚马逊，得益于杰弗·贝索斯的远见卓识，亚马逊内部的系统都以服务的方式构造，间接地促使了后来的亚马逊云计算技术的出现。

SOA 出现的背景是企业内部的 IT 系统重复建设且效率低下，主要体现在：1）企业各部门有独立的 IT 系统，比如人力资源系统、财务系统、销售系统，这些系统可能都涉及人员管理，各 IT 系统都需要重复开发人员管理的功能。例如，某个员工离职后，需要分别到上述三个系统中删除员工的权限。2）各个独立的 IT 系统可能采购于不同的供应商，实现技术不同，企业自己也不太可能基于这些系统进行重构。3）随着业务的发展，复杂度越来越高，更多的流程和业务需要多个 IT 系统合作完成。由于各个独立的 IT 系统没有标准的实现方式（例如，人力资源系统用 Java 开发，对外提供 RPC；而财务系统用 C# 开发，对外提供 SOAP 协议），每次开发新的流程和业务，都需要协调大量的 IT 系统，同时定制开发，效率很低。

为了应对传统 IT 系统存在的问题，SOA 提出了 3 个关键概念。

1、服务。所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。服务可大可小，可简单也可复杂。例如，人力资源管理可以是一项服务，包括人员基本信息管理、请假管理、组织结构管理等功能；而人员基本信息管理也可以作为一项独立的服务，组织结构管理也可以作为一项独立的服务。到底是划分为粗粒度的服务，还是划分为细粒度的服务，需要根据企业的实际情况进行判断。

2、ESB。ESB 的全称是 Enterprise Service Bus，中文翻译为「企业服务总线」。从名字就可以看出，ESB 参考了计算机总线的概念。计算机中的总线将各个不同的设备连接在一起，ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。

3、松耦合。松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。但实际上真正做到松耦合并没有那么容易，要做到完全后向兼容，是一项复杂的任务。典型的 SOA 架构样例如下：

SOA 架构是比较高层级的架构设计理念，一般情况下我们可以说某个企业采用了 SOA 的架构来构建 IT 系统，但不会说某个独立的系统采用了 SOA 架构。例如，某企业采用 SOA 架构，将系统分为「人力资源管理服务」「考勤服务」「财务服务」，但人力资源管理服务本身通常不会再按照 SOA 的架构拆分更多服务，也不会再使用独立的一套 ESB，因为这些系统本身可能就是采购的，ESB 本身也是采购的，如果人力资源系统本身重构为多个子服务，再部署独立的 ESB 系统，成本很高，也没有什么收益。

SOA 解决了传统 IT 系统重复建设和扩展效率低的问题，但其本身也引入了更多的复杂性。SOA 最广为人诟病的就是 ESB，ESB 需要实现与各种系统间的协议转换、数据转换、透明的动态路由等功能。例如，下图中 ESB 将 JSON 转换为 Java（摘自《Microservices vs. Service-Oriented Architecture》）。

下图中 ESB 将 REST 协议转换为 RMI 和 AMQP 两个不同的协议：

ESB 虽然功能强大，但现实中的协议有很多种，如 JMS、WS、HTTP、RPC 等，数据格式也有很多种，如 XML、JSON、二进制、HTML 等。ESB 要完成这么多协议和数据格式的互相转换，工作量和复杂度都很大，而且这种转换是需要耗费大量计算性能的，当 ESB 承载的消息太多时，ESB 本身会成为整个系统的性能瓶颈。

当然，SOA 的 ESB 设计也是无奈之举。回想一下 SOA 的提出背景就可以发现，企业在应用 SOA 时，各种异构的 IT 系统都已经存在很多年了，完全重写或者按照统一标准进行改造的成本是非常大的，只能通过 ESB 方式去适配已经存在的各种异构系统。

### 黑板墙

为什么互联网企业很少采用 SOA 架构？

SOA 是把多个系统整合，而微服务是把单个系统拆开来，方向正好相反。作者回复：言简意赅。2018-07-19

SOA 是集成的思想，是解决服务孤岛打通链条，是无奈之举。esb 集中化的管理带来了性能不佳，厚重等问题。也无法快速扩展。不适合互联网的业务特点。作者回复：赞同。2018-07-18

为什么互联网不用 SOA？1）互联网企业，通常比较年轻，没有那么多异构系统，技术是公司的关键；如果有整合或者服务化的需求，公司有人也有钱专门搞这个；拆到重做/重构很平常；相反的，传统企业，举个例子：某传统炼钢国企：有多个遗留 .net 系统，有几个实习生做的 java 系统，有基于数据库 procedure 的系统；有各种已经倒闭了的第三方企业的系统等等；企业领导不会有精力和想法全部推倒重来，只会花钱请第三方，成本越低越好；这个时候就需要 ESB 这种总线。2）传统企业 IT 追求的是「需求灵活，变更快」，而互联网企业追求性能，传统 soa 性能不佳。传统的 esb，说实话，使用 webservice 以及 soap 这种基于 xml 的技术；wsdl 这东西是真的难用，难学难用难维护；结构冗杂。3）soa 这个东西很多时候只是一个概念，而不是实践。个人觉得，现在的微服务，更像是 soa 思想的一个落地（相比 esb）。作者回复：分析的很好，微服务和 SOA 的关系后面会讲。2018-07-12

回答问题：文中也说了，soa 是特定历史条件下的产物，为了适配各种异构的 it 系统，而有如此多系统的自然是变化减少且稳定的传统企业。互联网企业的特点就是小，新，快。没有历史包袱，变化快，大部分是从单体演进到分布式，技术栈一脉相承或者在分布式之前已经从 php,ruby 等改造到 java 等了。而到了分布式之后，面对不断的耦合，系统复杂度的陡增，这时一个 soa 的特例微服务出现了。实际上 soa 的思想还在，只不过实现的方式不一样了。作者回复：关于 soa 和微服务的关系，我会特别讲述。2018-07-12

一直不明白 SOA 和微服务的具体区别，知道作者讲到了 ESB 的功能，原来就是适配各种协议，顿时明白了！SOA 是为了适配老系统。作者回复：是的，所以 SOA 不适合创新型的互联网企业，比较适合传统大企业。2019-10-25

在传统企业从原先的手工作业转为采用 IT 系统作业的过程中，大多是采用向外采购的方式逐步实现的，在这个过程中不同部门采购系统的实现语言、通信协议并不完全相同，但为提升运行效率又要能够做到企业内部信息互通、相互协作，这是 soa 诞生的背景。而互联网企业是新创的企业，没有这么多的历史包袱，同时出于快速迭代的要求，有时会自建所需的系统，即使是对外采购，也会选择和已有系统对接方便的系统，从根本上避免了相关问题，因而 soa 在互联网公司中使用不多。作者回复：赞同。2018-09-09

SOA 更像一种架构理念，不够具体。在传统企业的 IT 系统中落地为 ESB，主要是为了集成异构系统。因为传统企业特别是大型企业的历史长，在其发展过程中自己开发或采购了不少异构系统。而互联网企业历史都短（腾讯 98 年，阿里 99 年，百度 2000 年），很少有遗留异构系统（像阿里的系统绝大部分应该都是 Java 开发的吧？)。像阿里这种互联网大型企业的痛点是随着业务越来越多，整个系统成了个巨无霸（可能是数以千记的模块数），模块之间的调用像蜘蛛网，极大降低了开发、测试、部署、运维的效率，所以把庞大的业务逻辑层又切分成了业务更独立的应用层和公共功能模块组成服务层。接下来一是要提供应用层与服务层之间、服务层内部服务之间的高效通信机制，二是要对大量的服务进行治理，于是分布式服务框架出现了（阿里就出了 Dubbo 和 HSF 两个服务框架？）。感觉在大型互联网企业，SOA 实际是落地为分布式服务框架，它更像是微服务架构的一个雏形，服务框架提供的功能实际也是微服务架构里必不可少的功能。作者回复：确实也有人将 SOA 理解为一个思想，微服务理解为 SOA 的具体实现。2019-05-04

soa 解决的是资源的重复利用，它的拆分粒度比较大，比如财务系统跟 oa 系统的员工模块。互联网企业有几种情况：1）初创公司，这种公司一般会有试错的过程，需要技术快速实现业务落地，这种情况下使用 SOA 不适合快速敏捷迭代开发。2）对于成熟的互联网业务来说，需要解决的是是高并发，高性能和高存储等一系列问题，对于这类企业来说，使用 SOA 拆分不能解决太多问题，还得做更加细粒度的拆分。作者回复：分析到位。2018-08-21

其实，个人理解的传统 SOA 和 ESB 在互联网企业之所以不怎么使用主要原因就是中心化的 ESB 架构会逐渐成为性能、可用性、可扩展性的瓶颈。但是 SOA 的思想本身是没有什么问题的。互联网企业中用的微服务甚至最近很火的 Service Mesh 都可以看成是 SOA、ESB 的变形。比如 Service Mesh 也可以看成是一个去中心化的 ESB。作者回复：这也是一种理解方式吧，微服务基础设施做完，确实感觉是做了一个 ESB。2018-07-18

互联网行业很少采用 soa，感觉有两点原因：1）soa 主要是解决异构系统之间的集成，传统企业有大量的异构系统，而互联网属于新兴行业，不存在大量的异构系统需要集成，2）esb 存在性能的瓶颈和不易扩展的问题，无法应对互联网这种业务会快速增长场景。作者回复：赞同。2018-07-12

第一章说 MVC 是开发规范，本章节说 MVC 是分层架构，不太明白，这两 MVC 说的不是一个东西吗，还是出发点不同。作者回复：按照 MVC 开发规范的系统就是 MVC 架构，这个是逻辑上的架构。2019-02-15

ESB 太重了，一般的互联网企业无福消受，性价比低。作者回复：其实现在微服务全套搞下来，不见得比 ESB 简单了，ESB 的核心问题是所有东西都在一套系统里面。2020-03-30

感觉 ESB 就像一个集中式的网关一样…...作者回复：是的，不单是网关，是整个微服务基础组件都在里面。2020-02-23

我对 soa 一直是不太清楚，其中 ESB 是不是可以理解为我们用的 dubbo，soa 可不可以理解为把项目进行粗力度的拆分，通过 dubbo 或者 http 协议向外提供服务。作者回复: dubbo 不是 ESB，dubbo 是统一的协议，ESB 需要兼容和适配很多协议。soa 主要不是为了拆分，而是将已经存在的异构系统整合起来。2018-07-17

之前还以为 SOA 在互联网很流行呢，没想到根本不用啊。作者回复：用得少，都用微服务了。2018-07-17

不知道大家为什么总是提到 esb 的问题，从文章中可以看到 esb 的出现也是无奈之举，互联网完全可以做到统一，不需要 esb，而且 soa 只是在功能分解上面的发展，而按照功能分解实现是很早就开始的，所以，不明白为什么互联网公司 soa 比较少。作者回复：虽然是无奈，但确实太重量级了，互联网公司 soa 用的少，但微服务做到最后，复杂度和 ESB 其实也差不多了。2018-07-16

## 0403. 深入理解微服务架构：银弹 or 焦油坑？

微服务是近几年非常火热的架构设计理念，大部分人认为是 Martin Fowler 提出了微服务概念，但事实上微服务概念的历史要早得多，也不是 Martin Fowler 创造出来的，Martin 只是将微服务进行了系统的阐述「[Microservices](https://martinfowler.com/articles/microservices.html)」。不过不能否认 Martin 在推动微服务起到的作用，微服务能火，Martin 功不可没。

微服务的定义相信你早已耳熟能详，参考维基百科，我就来简单梳理一下微服务的历史吧：

2005 年：Dr. Peter Rodgers 在 Web Services Edge 大会上提出了「Micro-Web-Services」的概念。

2011 年：一个软件架构工作组使用了「microservice」一词来描述一种架构模式。

2012 年：同样是这个架构工作组，正式确定用「microservice」来代表这种架构。

2012 年：ThoughtWorks 的 James Lewis 针对微服务概念在 QCon San Francisco 2012 发表了演讲。

2014 年：James Lewis 和 Martin Fowler 合写了关于微服务的一篇学术性的文章，详细阐述了微服务。

1-2『 2014 年的那篇文章就是前面的那个原文链接，一定要去研读。（2020-11-20）』——未完成

由于微服务的理念中也包含了「服务」的概念，而 SOA 中也有「服务」的概念，我们自然而然地会提出疑问：微服务与 SOA 有什么关系？有什么区别？为何有了 SOA 还要提微服务？这几个问题是理解微服务的关键，否则如果只是跟风拿来就用，既不会用，也用不好，用了不但没有效果，反而还可能有副作用。今天我们就来深入理解微服务，到底是银弹还是焦油坑。

### 3.1 微服务与 SOA 的关系

对于了解过 SOA 的人来说，第一次看到微服务这个概念肯定会有所疑惑：为何有了 SOA 还要提微服务呢？等到简单看完微服务的介绍后，可能很多人更困惑了：这不就是 SOA 吗？关于 SOA 和微服务的关系和区别，大概分为下面几个典型的观点。

1、微服务是 SOA 的实现方式。如下图所示，这种观点认为 SOA 是一种架构理念，而微服务是 SOA 理念的一种具体实现方法。例如，「微服务就是使用 HTTP、RESTful 协议来实现 ESB 的 SOA」「使用 SOA 来构建单个系统就是微服务」和「微服务就是更细粒度的 SOA」。

2、微服务是去掉 ESB 后的 SOA。如下图所示，这种观点认为传统 SOA 架构最广为人诟病的就是庞大、复杂、低效的 ESB，因此将 ESB 去掉，改为轻量级的 HTTP 实现，就是微服务。

3、微服务是一种和 SOA 相似但本质上不同的架构理念。如下图所示，这种观点认为微服务和 SOA 只是有点类似，但本质上是不同的架构设计理念。相似点在于下图中交叉的地方，就是两者都关注「服务」，都是通过服务的拆分来解决可扩展性问题。本质上不同的地方在于几个核心理念的差异：是否有 ESB、服务的粒度、架构设计的目标等。

以上观点看似都有一定的道理，但都有点差别，到底哪个才是准确的呢？单纯从概念上是难以分辨的，我来对比一下 SOA 和微服务的一些具体做法，再来看看到底哪一种观点更加符合实际情况。

1、服务粒度。整体上来说，SOA 的服务粒度要粗一些，而微服务的服务粒度要细一些。例如，对一个大型企业来说，「员工管理系统」就是一个 SOA 架构中的服务；而如果采用微服务架构，则「员工管理系统」会被拆分为更多的服务，比如「员工信息管理」「员工考勤管理」「员工假期管理」和「员工福利管理」等更多服务。

2、服务通信。SOA 采用了 ESB 作为服务间通信的关键组件，负责服务定义、服务路由、消息转换、消息传递，总体上是重量级的实现。微服务推荐使用统一的协议和格式，例如，RESTful 协议、RPC 协议，无须 ESB 这样的重量级实现。Martin Fowler 将微服务架构的服务通讯理念称为「Smart endpoints and dumb pipes」，简单翻译为「聪明的终端，愚蠢的管道」。之所以用「愚蠢」二字，其实就是与 ESB 对比的，因为 ESB 太强大了，既知道每个服务的协议类型（例如，是 RMI 还是 HTTP），又知道每个服务的数据类型（例如，是 XML 还是 JSON），还知道每个数据的格式（例如，是 2017-01-01 还是 01/01/2017），而微服务的「dumb pipes」仅仅做消息传递，对消息格式和内容一无所知。

3、服务交付。SOA 对服务的交付并没有特殊要求，因为 SOA 更多考虑的是兼容已有的系统；微服务的架构理念要求「快速交付」，相应地要求采取自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。如果没有这些基础能力支撑，微服务规模一旦变大（例如，超过 20 个微服务），整体就难以达到快速交付的要求，这也是很多企业在实行微服务时踩过的一个明显的坑，就是系统拆分为微服务后，部署的成本呈指数上升。

4、应用场景。SOA 更加适合于庞大、复杂、异构的企业级系统，这也是 SOA 诞生的背景。这类系统的典型特征就是很多系统已经发展多年，采用不同的企业级技术，有的是内部开发的，有的是外部购买的，无法完全推倒重来或者进行大规模的优化和重构。因为成本和影响太大，只能采用兼容的方式进行处理，而承担兼容任务的就是 ESB。微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速尝试、快速交付；同时基本都是基于 Web，虽然开发技术可能差异很大（例如，Java、C++、.NET 等），但对外接口基本都是提供 HTTP、RESTful 风格的接口，无须考虑在接口层进行类似 SOA 的 ESB 那样的处理。

综合上述分析，我将 SOA 和微服务对比如下：

对比维度 | SOA | 微服务
|---|---|---|
| 服务粒度 | 粗 | 细 |
| 服务通信 | 重量级、ESB | 轻量级，如 RESTful |
| 服务交付 | 慢 | 快 |
| 应用场景 | 企业级 | 互联网 |

因此，我们可以看到，SOA 和微服务本质上是两种不同的架构设计理念，只是在「服务」这个点上有交集而已，因此两者的关系应该是上面第三种观点。其实，Martin Fowler 在他的微服务文章中，已经做了很好的提炼：

In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery.

上述英文的三个关键词分别是：small、lightweight、automated，基本上浓缩了微服务的精华，也是微服务与 SOA 的本质区别所在。

2『微服务，做一张术语卡片。』——已完成

通过前面的详细分析和比较，似乎微服务本质上就是一种比 SOA 要优秀很多的架构模式，那是否意味着我们都应该把架构重构为微服务呢？其实不然，SOA 和微服务是两种不同理念的架构模式，并不存在孰优孰劣，只是应用场景不同而已。我们介绍 SOA 时候提到其产生历史背景是因为企业的 IT 服务系统庞大而又复杂，改造成本很高，但业务上又要求其互通，因此才会提出 SOA 这种解决方案。如果我们将微服务的架构模式生搬硬套到企业级 IT 服务系统中，这些 IT 服务系统的改造成本可能远远超出实施 SOA 的成本。

### 3.2 微服务的陷阱

单纯从上面的对比来看，似乎微服务大大优于 SOA，这也导致了很多团队在实践时不加思考地采用微服务 —— 既不考虑团队的规模，也不考虑业务的发展，也没有考虑基础技术的支撑，只是觉得微服务很牛就赶紧来实施，以为实施了微服务后就什么问题都解决了，而一旦真正实施后才发现掉到微服务的坑里面去了。我们看一下微服务具体有哪些坑：

1、服务划分过细，服务间关系复杂。服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。从理论的角度来计算，n 个服务的复杂度是 `n×(n-1)/2`，整体系统的复杂度是随着微服务数量的增加呈指数级增加的。下图形象了说明了整体复杂度：

粗粒度划分服务时，系统被划分为 3 个服务，虽然单个服务较大，但服务间的关系很简单；细粒度划分服务时，虽然单个服务小了一些，但服务间的关系却复杂了很多。

2、服务数量太多，团队效率急剧下降。微服务的「微」字，本身就是一个陷阱，很多团队看到「微」字后，就想到必须将服务拆分得很细，有的团队人员规模是 5-6 个人，然而却拆分出 30 多个微服务，平均每个人要维护 5 个以上的微服务。这样做给工作效率带来了明显的影响，一个简单的需求开发就需要涉及多个微服务，光是微服务之间的接口就有 6-7 个，无论是设计、开发、测试、部署，都需要工程师不停地在不同的服务间切换。1）开发工程师要设计多个接口，打开多个工程，调试时要部署多个程序，提测时打多个包。2）测试工程师要部署多个环境，准备多个微服务的数据，测试多个接口。3）运维工程师每次上线都要操作多个微服务，并且微服务之间可能还有依赖关系。

3、调用链太长，性能下降。由于微服务之间都是通过 HTTP 或者 RPC 调用的，每次调用必须经过网络。一般线上的业务接口之间的调用，平均响应时间大约为 50 毫秒，如果用户的一起请求需要经过 6 次微服务调用，则性能消耗就是 300 毫秒，这在很多高性能业务场景下是难以满足需求的。为了支撑业务请求，可能需要大幅增加硬件，这就导致了硬件成本的大幅上升。

4、调用链太长，问题定位困难。系统拆分为微服务后，一次用户请求需要多个微服务协同处理，任意微服务的故障都将导致整个业务失败。然而由于微服务数量较多，且故障存在扩散现象，快速定位到底是哪个微服务故障是一件复杂的事情。下面是一个典型样例。

Service C 的数据库出现慢查询，导致 Service C 给 Service B 的响应错误，Service B 给 Service A 的响应错误，Service A 给用户的响应错误。我们在实际定位时是不会有样例图中这么清晰的，最开始是用户报错，这时我们首先会去查 Service A。导致 Service A 故障的原因有很多，我们可能要花半个小时甚至 1 个小时才能发现是 Service B 返回错误导致的。于是我们又去查 Service B，这相当于重复 Service A 故障定位的步骤…… 如此循环下去，最后可能花费了几个小时才能定位到是 Service C 的数据库慢查询导致了错误。如果多个微服务同时发生不同类型的故障，则定位故障更加复杂，如下图所示。

Service C 的数据库发生慢查询故障，同时 Service C 到 Service D 的网络出现故障，此时到底是哪个原因导致了 Service C 返回 Error 给 Service B，需要大量的信息和人力去排查。

5、没有自动化支撑，无法快速交付。如果没有相应的自动化系统进行支撑，都是靠人工去操作，那么微服务不但达不到快速交付的目的，甚至还不如一个大而全的系统效率高。例如：1）没有自动化测试支撑，每次测试时需要测试大量接口。2）没有自动化部署支撑，每次部署 6-7 个服务，几十台机器，运维人员敲 shell 命令逐台部署，手都要敲麻。3）没有自动化监控，每次故障定位都需要人工查几十台机器几百个微服务的各种状态和各种日志文件。

6、没有服务治理，微服务数量多了后管理混乱。信奉微服务理念的设计人员总是强调微服务的 lightweight 特性，并举出 ESB 的反例来证明微服务的优越之处。但具体实践后就会发现，随着微服务种类和数量越来越多，如果没有服务治理系统进行支撑，微服务提倡的 lightweight 就会变成问题。主要问题有：1）服务路由：假设某个微服务有 60 个节点，部署在 20 台机器上，那么其他依赖的微服务如何知道这个部署情况呢？2）服务故障隔离：假设上述例子中的 60 个节点有 5 个节点发生故障了，依赖的微服务如何处理这种情况呢？3）服务注册和发现：同样是上述的例子，现在我们决定从 60 个节点扩容到 80 个节点，或者将 60 个节点缩减为 40 个节点，新增或者减少的节点如何让依赖的服务知道呢？如果以上场景都依赖人工去管理，整个系统将陷入一片混乱，最终的解决方案必须依赖自动化的服务管理系统，这时就会发现，微服务所推崇的「lightweight」，最终也发展成和 ESB 几乎一样的复杂程度。

### 黑板墙

你们的业务有采用微服务么？谈谈具体实践过程中有什么经验和教训。

我们公司的实践是比较粗粒度的子系统或服务，基本上没有太细粒度的微服务，以 webapi 为主。感觉更像微服务架构，只是服务粒度比较粗，从概念上算是 SOA 还是微服务架构呢？作者回复：我理解算微服务，千万不要理解为微服务就是将服务拆的很细，后面有具体实践技巧介绍这部分。2018-08-10

对于一个新事物的诞生，本能地套用已有的知识。特别是一个并不简单的东西，这算是一种高效的入门方法。微服务架构其实相当复杂，我是分成好几个阶段理解。1）第一阶段，微服务架构就是去掉了 ESB 的 SOA 架构，只不过是通信的方式和结构变了。对于初级的使用者而言，这样理解没有太大问题。2）第二阶段，没有了 ESB，原本很多由 ESB 组件做的事儿，转到服务的提供者和调用者这里了。他们需要考虑服务的拆分粒。大体仍然算是 SOA 架构。3）第三阶段，随着服务的数量大幅增加，服务的管理越来越困难，此时 DevOps 出现了。这个阶段的微服务架构，已经是跟 SOA 架构完全不同的东西了。

之前给一家大国企分享过一些经验。他们想从传统架构，转向微服务架构。1）建设好基础设施，RPC、服务治理、日志、监控、持续集成、持续部署、运维自动化是基本的，其它包括服务编排、分布式追踪等。2）要逐步演进和迭代，不要过于激进，更不要拆分过细，拆分的粒度，要与团队的架构相互匹配。（康威定律）3）微服务与数据库方面，是个很大的难点，可以深入了解下领域驱动设计，做好领域建模，特别是数据库要随着服务一起拆分。说完上面这些，他们的研发负责人说，我说的跟他们的架构师说的不一样，他们的架构师说，微服务就是各种拆分，不顾一切地拆分。作者回复：他们架构师是水货，你的理解和分析是对的，后一篇就讲了。2018-07-16

之前一家公司搞了一次完整的微服务改造，享受到了一些好处，但是文中说到的问题，大部分都碰上了。先说下好处，原来的单体应用都服务化了，扩容简单很多。功能隔离后之前一个 bug 导致系统挂掉的现象没了。问题责任定位划分的更清楚，比如之前大量慢 sql 无人管，现在通过监控快速找到开发责任人。再说下坏处，1）服务太多了，人不够啊。之前的架构师按照小的原则，把数据层，服务层，应用层严格拆分。一个人手上超过 10 几个服务。2）服务化不彻底，太多事手工干。服务监控只能监控一半指标，各种远程调用异常没人解决。运维只有打包发布做了自动化。可以想象下开发人员基本下改 bug 和发布的死循环中。服务网关没有，服务调用就是一张密密麻麻的网。3）培训不到位，直接上阵，开发人员对微服务理解不到位，服务质量可想而知。没有专职测试，自动化测试靠开发写脚本，谁有空啊，单元测试能写一个就算相当有觉悟了。总结下来，做服务化改造首先问自己这些问题，业务真的需要微服务来解决吗？真的所有模块的问题都要微服务来解决吗？技术人员的配置和水平达到要求了吗？2018-07-14

我们是一家社交公司，后端加厚的演变符合 dubbo 官网的那张图，在 Mvc 架构坚持了一年后，业务越来越大，工程越来越臃肿。后面我们一致同意进行服务话，开始用了 dubbo。后面由于决策层的原因没有上，后面来了个架构师，又重启了服务拆分，到现在已经用于生产。我们使用的是 Spring cloud，现在拆分暴露了很多问题：1）个别服务没有熔断出来，出现过雪崩效应。2）服务拆分过细，服务调用链过长。3）开发人员能力不一样，代码水平不一样。4）没有监控措施。5）每个服务部署多台，日志查询就会死人的感觉。6）开发过程中经常出现访问不到该访问的接口，这是因为开发人员经常启动本地服务，就会导致 30% 的概率访问不到。7）使用了不合理的持久层框架，使用了 JPA 访问。大概就有上面的问题，总之微服务不是银弹，用得不好会发现无穷无尽的坑。当然，出现问题解决问题就是了。唯一的就像 CEO 说的：你们他妈的是完全在拿用户当小白鼠使用。2018-07-16

我们目前全部微服务，踩坑踩了不少，拆分服务同时要把自动化运维系统和多维度监控系统，包括问题定位跟踪系统建立起来，要不然拆了就是噩梦。作者回复：感同身受啊。2018-08-17

说到微服务，切分的粒度和基础设施都致关重要。经历的项目有创业初期的单体服务，也有不太完善的服务切分的系统，也有微服务基础设施相对完善的公司。单体服务致命就致命在随着项目的发展，项目会越来越臃肿，越不利于扩展开发。微服务过程怕就怕基础不完善，人员配备不够盲目切分，导致工程师开发和维护的战线拉长，特别疲惫和泄气，容易产生一种抱怨的大气氛，从而导致微服务失败，重新合并一部分服务。

微服务做的好的，也有所经历，公司的基础设施完全云化和统一管理，申请几台机器，一套缓存集群，一套 mq，sql/nosql…...特别容易，工程师愿意建独立的工程，因为很容易构建和部署。这种感觉有点像 svn 和 git，git 建分支特别轻量，大家都愿意用分支管理自己的代码，迭代开发，应急处理都能自由切换，得心应手。

现在遇到一个问题，就是微服务内部系统大多使用 rpc，但对接外部系统，或者跨外网传输到客户端就需要 http-rest 类的协议。也就是我们常说的网关，如果是纯 http 就很容易做到通用的转发机制，但是 http 转 rpc 就不知道有什么方式可以做到通用转发了，内部每增加一个 rpc，网关就需要增加一个对应的服务处理逻辑。不知道，这个问题，有没有好的解决办法？作者回复：把 HTTP 转 RPC 做成规则，别硬编码每个接口，例如，规定 HTTP URL 为 `/service/interface/method?para1=xxx&para2=yyy`。2018-07-16

我们公司的平台就是使用微服务架构，十多二十个微服务，但是没有自动化部署，监控，自动化测试这些，而且每次报错日志也特别难找，但是我们那架构师却不重视这些，只想继续升级平台的功能。2018-07-15

我们项目之前是把数据采集，和展示都是我们 Java 组去写的。后面公司为了统一，把采集部分交给了.net 组。我们 Java 只负责数据展示。但是我们这边又按照领导的要求把整个业务拆分为模板解析层 —> api 层 —> 终端层。现在每次最烦的事就是找 bug。一直感觉现阶段我们的任务和目标没有这么庞大，这与架构中的简单和合适原则想违背。搞的整个项目组一直在反复的开发工作中。都很心累。2018-09-18

我们的业务也算是微服务吧，接手项目时，已经有好多服务，主要采用的语言有 java，php，nodejs，存在以下问题：1）没有一个统一的网关服务，前端请求后端服务都需要后端的服务 A 来充当安全校验，权限校验等，A 服务充当了多重职责，变的职责不明确了，后来抽出网关系统，负责平台统一的流量入口。在构建微服务网关系统是至关重要的。2）监控系统不完善，调用链跟踪，异常报警都不完善，对微服务是巨坑，查找问题如同一场噩梦，调用链很长，一旦发生异常不知道到底哪里出现问题，得一个一个去找。后来慢慢完善，变得好了很多，问题很快定位。3）加入网关后，没有一个统一的服务发现注册中心，网关的路由依靠人工手动配置，变的很麻烦，也很容易出错。后来引入 consul，得到改善。作者回复：spring 全家桶，你值得拥有。2018-07-14

16 年时，架构师引入了微服务架构，架构设计分为三层：网关层、业务处理层、数据处理层（getaway —> ls —> ds），自上而下依赖，业务层之间也互相依赖，构建过程中发现引入了分布式事务和调用链长（调用链的消耗时间无法接受），经常无故报错，定位问题慢，测试复杂等问题，而我们的大多数业务相对简单，所以重新划分服务粒度，分为两层：1）网关层：提供路由功能，2）业务处理层：处理请求，业务层中间可以相互调用，当出现有出现分布式事务时，采取 MQ 或者更新状态的方式解决，如果是充值 + 业务订单的这种会直接在一个事务里处理（其实这里就混乱一点了），层与层之间没有完全隔离，但是将调用链缩短，我觉得采用微服务架构确实解决了单体应用的一些问题，如资源问题（但消耗资源是比以前多的）、耦合问题、快速迭代问题，服务与服务的职责更加清晰，不同的服务粒度设计的系统是天差地别的。作者回复：是的，粒度太重要了。2018-12-11

我个人比较认同康威定律，微服务的拆分粒度一定要和组织结构匹配起来，组织结构和开发管理模式是微服务粒度的最重要参考指标之一。作者回复：是的，康威定律和微服务拆分是相关的。2018-11-08

个人觉得 SOA 只是提出了面向服务的编程，到但没有对服务粒度的定义，以及服务的治理问题做深入的分析。提出微服务主要是为了解决面向服务架构后如何能够在实际工程中带来真正的红利。微服务对 SOA 的技术关键点给出了指导意见。微服务对分布式服务的诱惑力的确很大，但做但微服务都不会免费的，需要很多的基础设施来做铺垫和基石，才有可能搞定。除了基础设施还有很多设计思想需要学习，我觉得 DDD 就是微服务的绝配。作者回复：SOA 是完整的解决方案哦，IBM 等公司卖 ESB 都卖了好多钱。2018-08-09

我弄微服务遇到最大的坑，就是 jvm 与 docker 兼容性不好，导致每个微服务会消耗过多不必要的内存，我感觉从资源消耗上来说，java 开发的微服务都不能算是微服务了，最近在转向 go 来改造。作者回复：这还真是第一次听说 jvm 与 docker 不兼容，看看是不是有 bug。2018-07-14

我记得有一次做业务，当时不知道什么原因，整体使用微服务，当时是个新业务，完全从 0 开始，没有任何用户基础，当时按照业务把服务拆成了 7.8 个微服务，但没有自动化，服务还是部署在一台机器上，服务之间也没有服务治理，服务之间的调用链很长，开发就 4.5 个人，定位问题花费时间长，典型的基础服务也跟不上。现在想想，当时团队不知道咋想的，觉得微服务比较新就上了，完全没有考虑到产生的问题。还好后来这块业务黄了。要不然估计坑更多。对于创业公司来说，刚开始的时候，其实一个服务就够了，真等用户上来了，业务有希望了，那时候再上其他架构模式也不迟，忌讳一开始就求新求全，说到底，对于大部分公司来说。技术是为业务服务的。作者回复：你们缺少一个真正的架构师。2018-08-21

dubbo 和 motan 这类 rpc 框架，是微服务框架？作者回复：dubbo 可以算微服务基础设施的一部分，主要承担服务注册发现等。2018-07-15。我们用的是 dubbo。最开始系统要快速上线，所以服务拆分的不彻底。订单，商品，店铺等这些服务都没有进行拆分。就把支付和营销两个服务拆分出来了。服务拆分不彻底经常导致一个业务有问题。整个系统都用不了。作者回复：不是拆分有问题，是配套基础设施有问题。2018-07-15

我家公司之前在满足现有业务增长规模的情况下，也涉足微服务领域了，其实遇到的问题跟大家也差不多：1）业务拆分问题，大家对服务的理解类似于某个技术框架，让这个技术框架适配现有业务流程和架构就好了，这就有点新瓶装旧酒的味道，对于怎么拆分，大家各执一词，争论不休，尤其在数据库规划上，更是举步维艰，很难有进展，后来才找到一种方法，领域驱动设计（DDD），算是解了燃眉之急。2）技术栈在应对微服务架构的时候，显得心有余而力不足，传统技术栈不会包括服务发现，服务治理，以及调用链分析，在微服务架构上知识结构体系是不全的。3）整个微服务环境甚至文化处于原始阶段，大家都觉得微服务只是一个点上面的事情，比如只是后台的事情，而事实上，这个关乎测试（自动化测试）还有运维（持续集成，持续部署，监控）等，也就是华哥在回复区提到的基础架构部分。4）研发部门的尴尬，由于公司一向偏向于 c++，没有人熟悉 java，所以在落地的时候，就没有 spring 全家桶就能解决所有事情的那种小幸运，而要选择不同的服务组件来满足微服务架构的需求。作者回复：c++ 确实没有合适的全家桶，自己搞投入还是很大的。2020-03-10

我们现有的服务也算是微服务了，也是逐渐演进过来的，微服务不单单是服务的拆分解耦。还包含 devops 自动化部署，自动化监控，服务编排以及各类方便开发人员聚焦到开发上的工具，不要把精力都消耗在那些重复工作中。作者回复：嗯，微服务必须要有基础设施配套，不然很蛋疼。2019-12-12

微服务遇到的坑，不知道算不算。第一个是到底满足什么条件才能算一个微服务，往往是为了拆分而拆分，比如将一个服务拆分成了 ABC 三个微服务，BC 仅仅是为 A 提供服务不具有独立的能力，接口也只是内部接口，对外完全不可见。第二个是微服务内部是有状态的，这就导致了其它访问的时候必须请求到那个实例，对伸缩和可靠性带来了不利的影响。第三个是扩缩容依赖，服务 A 需要扩充一倍，依赖的服务要扩充多少呢？这个往往很难评估准确，曾出现过由于扩充的比例不对导致现网紧急变更。最后是分布式一致性，微服务之间往往需要互相配合来完成某个业务功能，但是由于网络故障或其它原因经常处理不一致。然后通过各种系统定时任务去清理或修正，系统越来越难以理解。作者回复：都算，尤其是最后一个，查起来很麻烦。2019-09-20

非常认同老师的微服务没有基础的治理平台是非常坑的观点，我就亲身经历过，上一家公司是个只有七八个人的小团队，一切都是从零开始，项目经理也挺喜欢研究技术的，当时就是使用 spring 的全家桶来搭建的微服务，开发、测试、部署、运维真是非常费劲。一台机器从编译到部署完启动起来就需要半天功夫，什么都是人肉来处理，效率相当慢。目前的公司基础技术服务比较完善，RPC、MQ、缓存、监控、部署等等都有专门的团队来维护，基本是自研或二次开发，上线部署轻松简单，上几百台也是很轻松容易的，时间主要花费在业务验证上，有一套流程要走。基础服务的使用也比较简单，他们来运维，有需求也可以提。微服务是把双刃剑，用好了能杀敌，用不好会伤己。2019-09-02

服务拆分的粒度太小，造成了一个业务的修改涉及的系统太多，引入了很多系统复杂度，但是又缺少人手，经常造成开发工作量太大，需要同时上线多个服务，缺乏自动化部署，每次测试都要涉及多个系统接口的测试。最大问题是服务无法实现事务的原子性（实现分布式事务代价太高没有采用），造成一个业务异常无法回滚，频繁需要修改数据。服务没有实现治理，造成发生问题时，没有及时发现问题。2019-08-30

我们公司拆分的原因主要是基于现有遗留的老系统太过于庞大，代码结构比较混乱，每次新的需求过来的时候，都会牵一发而动全身，从而有了服务拆分的想法，但是对于当时的服务拆分的粒度，受限于人员数量以及对微服务的理解，根据业务模块做了服务的拆分，但是有一个问题是还是共用的一个库，而且链路监控以及服务治理都还在预研阶段，并没有落地，现在都是哪边遇到坑就去填坑，数据库的拆分以及数据迁移在后面也是一个不得不头痛的问题，请求老师现在的这个情况，您这边有什么好的建议么？作者回复：先完善基础设施。2019-04-18

我在想如果启动一个服务进程 服务里有多线程 每个线程启动一个 vm 虚拟机去执行脚本 一个脚本的 vm 去对应一个微服务 这个部署只需启动一个进程服务器就可以啦 另外一个 vm 对应一个 actor 实体 对应一个微服务 然后用每个 actor 处理自己的消息，通过 rpc 调用是不是可以？部署从外部看是一个整体 从内部看是众多的服务（每个服务对应一个 actor 个体实现相应的功能）。作者回复：akka 框架就是做这事的，但很复杂。2018-12-14

我想问问 HTTP 和 RPC 的调用方式，目前对外接口采用 http，内部服务间调用采用 RPC，不知道有没有问题。作者回复：这是最常见的做法，你可以思考一下为什么对外用 HTTP 对内用 RPC，而不是反过来。2018-11-12

文中说的问题深有体会！服务与服务之间调用失败难以定位，因为这个问题我们也做了服务调用链路日志监控，但还不完善。因为服务拆分数据存储在不同的库，导致统计报表，一些实时查询缓慢。部署耗时 3 个环境，多个服务简直是蛋疼。目前没有自动化部署，自动化测试，后端开发 3 人。因为是新产品试用阶段，根据用户反馈不断修改增加功能。因为没控制好拆分和架构师的指导目前项目显得有点臃肿。基于一路走过来的坑，我感觉新项目开始，需要不明确，功能逻辑反复推翻，未有一套完整的微服务架构。基础设施不完善的情况下不要实施微服务，前期实施单体，业务功能稳定后有一定的微服务经验才实施微服务。作者回复：你们应该是过度设计了。2018-09-26

之前公司把业务是分为几个大系统，通过 hessian 进行通信，请问老师这算是什么架构，这个架构师是支付宝过来的。还有系统间可以直接调用，什么情况下需要 esb，它究竟有什么用？作者回复：你可以这么理解，每个系统对外提供的接口协议都是一样的就是服务拆分，每个系统的接口协议不同，需要中间件来转换，那就是 ESB。2018-08-26

像我们公司这种：产品划分为几个大应用，每个应用暴露出来一系列 rpc 接口，部分公共逻辑拆分为小应用，也是暴露 rpc 接口。系统之间就通过 rpc 交互，中间加个 nginx 做负载均衡；没有服务发现和配置中心，因为接口不是很多，都靠配置文件手工管理。算不算是比较 low 的微服务？作者回复：合适就好，太高逼格可能问题更多，参考架构设计的其中一条原则。2018-08-25

App 后台设计了用户、LBS、商品、UGC、订单 & 支付、活动等微服务，然后由 API 根据不同功能模块串联提供给客户端。服务之间通过 rpc 通信。优点：1）独立部署，性能优化容易。2）便于分工，实现相互独立 & 透明。缺点：1）需求开发沟通成本高（尤其当新增终端时）。2）线上排查问题慢（链路长，多机部署）。作者回复：需要微服务基础设施来解决你的问题。2018-08-03

http 转 rpc 我们卡在了怎么去掉模型和接口这两个骨架代码这里，有没有办法可以不加入骨架代码，按照既定的 url 自动解析，然后转发？或者说只能使用协议解析实现？我们用的 thrift，回头我需要确认一下 thrift 的 protocol 在编解码的时候，有没有写入模型的类型信息，如果没有的话，实现起来感觉不会太复杂，如果包含模型的类型信息，就和骨架代码强耦合了。阿里如何处理的这种情况呢？作者回复：HTTP 协议解析很简单的呀，可以试试，阿里也有 MTOP 承担类似职责。2018-07-17

按照这样说，用 Web API 方式构造的服务，也是属于微服务吗？作者回复：不一定，微服务不单单是将 ESB 改为 HTTP，后面会深入阐述。2018-07-17

## 0404. 微服务架构最佳实践 —— 方法篇

专栏上一期，我谈了实施微服务需要避免踩的陷阱，简单提炼为：1）微服务拆分过细，过分强调「small」。2）微服务基础设施不健全，忽略了「automated」。3）微服务并不轻量级，规模大了后，「lightweight」不再适应。针对这些问题，今天我们看看微服务最佳实践应该如何去做。我会分两期介绍这部分内容，今天是微服务架构最佳实践的方法篇，下一期是基础设施篇。

### 4.1 服务粒度

针对微服务拆分过细导致的问题，我建议基于团队规模进行拆分，类似贝索斯在定义团队规模时提出的「两个披萨」理论（每个团队的人数不能多到两张披萨都不够吃的地步），分享一个我认为微服务拆分粒度的「三个火枪手」原则，即一个微服务三个人负责开发。当我们在实施微服务架构时，根据团队规模来划分微服务数量，如果业务规继续发展，团队规模扩大，我们再将已有的微服务进行拆分。例如，团队最初有 6 个人，那么可以划分为 2 个微服务，随着业务的发展，业务功能越来越多，逻辑越来越复杂，团队扩展到 12 个人，那么我们可以将已有的 2 个微服务进行拆分，变成 4 个微服务。为什么是 3 个人，不是 4 个，也不是 2 个呢？

首先，从系统规模来讲，3 个人负责开发一个系统，系统的复杂度刚好达到每个人都能全面理解整个系统，又能够进行分工的粒度；如果是 2 个人开发一个系统，系统的复杂度不够，开发人员可能觉得无法体现自己的技术实力；如果是 4 个甚至更多人开发一个系统，系统复杂度又会无法让开发人员对系统的细节都了解很深。

其次，从团队管理来说，3 个人可以形成一个稳定的备份，即使 1 个人休假或者调配到其他系统，剩余 2 个人还可以支撑；如果是 2 个人，抽调 1 个后剩余的 1 个人压力很大；如果是 1 个人，这就是单点了，团队没有备份，某些情况下是很危险的，假如这个人休假了，系统出问题了怎么办？

最后，从技术提升的角度来讲，3 个人的技术小组既能够形成有效的讨论，又能够快速达成一致意见；如果是 2 个人，可能会出现互相坚持自己的意见，或者 2 个人经验都不足导致设计缺陷；如果是 1 个人，由于没有人跟他进行技术讨论，很可能陷入思维盲区导致重大问题；如果是 4 个人或者更多，可能有的参与的人员并没有认真参与，只是完成任务而已。

「三个火枪手」的原则主要应用于微服务设计和开发阶段，如果微服务经过一段时间发展后已经比较稳定，处于维护期了，无须太多的开发，那么平均 1 个人维护 1 个微服务甚至几个微服务都可以。当然考虑到人员备份问题，每个微服务最好都安排 2 个人维护，每个人都可以维护多个微服务。

### 4.2 拆分方法

基于「三个火枪手」的理论，我们可以计算出拆分后合适的服务数量，但具体怎么拆也是有技巧的，并不是快刀砍乱麻随便拆分成指定数量的微服务就可以了，也不是只能按照业务来进行拆分，而是可以根据目的的不同灵活地选取不同的拆分方式。接下来我一一介绍常见的拆分方式。

#### 4.2.1 基于业务逻辑拆分

这是最常见的一种拆分方式，将系统中的业务模块按照职责范围识别出来，每个单独的业务模块拆分为一个独立的服务。基于业务逻辑拆分虽然看起来很直观，但在实践过程中最常见的一个问题就是团队成员对于「职责范围」的理解差异很大，经常会出现争论，难以达成一致意见。例如：假设我们做一个电商系统，第一种方式是将服务划分为「商品」「交易」「用户」3 个服务，第二种方式是划分为「商品」「订单」「支付」「发货」「买家」「卖家」6 个服务，哪种方式更合理，是不是划分越细越正确？

导致这种困惑的主要根因在于从业务的角度来拆分的话，规模粗和规模细都没有问题，因为拆分基础都是业务逻辑，要判断拆分粒度，不能从业务逻辑角度，而要根据前面介绍的「三个火枪手」的原则，计算一下大概的服务数量范围，然后再确定合适的「职责范围」，否则就可能出现划分过粗或者过细的情况，而且大部分情况下会出现过细的情况。

例如：如果团队规模是 10 个人支撑业务，按照「三个火枪手」规则计算，大约需要划分为 4 个服务，那么「登录、注册、用户信息管理」都可以划到「用户服务」职责范围内；如果团队规模是 100 人支撑业务，服务数量可以达到 40 个，那么「用户登录」就是一个服务了；如果团队规模达到 1000 人支撑业务，那「用户连接管理」可能就是一个独立的服务了。

1『不是很赞同作者按人头拆服务的思路，目前还是觉得按「领域」划分，按领域驱动开发的思想来。但有点得承认，要用好 DDD 的门槛是很高的，必须团队里的人都懂业务。（2020-11-21）』

#### 4.2.2 基于可扩展拆分

将系统中的业务模块按照稳定性排序，将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。稳定的服务粒度可以粗一些，即使逻辑上没有强关联的服务，也可以放在同一个子系统中，例如将「日志服务」和「升级服务」放在同一个子系统中；不稳定的服务粒度可以细一些，但也不要太细，始终记住要控制服务的总数量。

这样拆分主要是为了提升项目快速迭代的效率，避免在开发的时候，不小心影响了已有的成熟功能导致线上问题。

#### 4.2.3 基于可靠性拆分

将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。具体拆分的时候，核心服务可以是一个也可以是多个，只要最终的服务数量满足「三个火枪手」的原则就可以。

这样拆分带来下面几个好处：1）避免非核心服务故障影响核心服务。例如，日志上报一般都属于非核心服务，但是在某些场景下可能有大量的日志上报，如果系统没有拆分，那么日志上报可能导致核心服务故障；拆分后即使日志上报有问题，也不会影响核心服务。2）核心服务高可用方案可以更简单。核心服务的功能逻辑更加简单，存储的数据可能更少，用到的组件也会更少，设计高可用方案大部分情况下要比不拆分简单很多。3）能够降低高可用成本。将核心服务拆分出来后，核心服务占用的机器、带宽等资源比不拆分要少很多。因此，只针对核心服务做高可用方案，机器、带宽等成本比不拆分要节省较多。

#### 4.2.4 基于性能拆分

基于性能拆分和基于可靠性拆分类似，将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。常见的拆分方式和具体的性能瓶颈有关，可以拆分 Web 服务、数据库、缓存等。例如电商的抢购，性能压力最大的是入口的排队功能，可以将排队功能独立为一个服务。

以上几种拆分方式不是多选一，而是可以根据实际情况自由排列组合，例如可以基于可靠性拆分出服务 A，基于性能拆分出服务 B，基于可扩展拆分出 C/D/F 三个服务，加上原有的服务 X，最后总共拆分出 6 个服务（A/B/C/D/F/X）。

### 4.3 基础设施

大部分人主要关注的是微服务的「small」和「lightweight」特性，但实际上真正决定微服务成败的，恰恰是那个被大部分人都忽略的「automated」。为何这样说呢？因为服务粒度即使划分不合理，实际落地后如果团队遇到麻烦，自然会想到拆服务或者合服务；如果「automated」相关的基础设施不健全，那微服务就是焦油坑，让研发、测试、运维陷入我上一期讲的各种微服务陷阱中。微服务基础设施如下图所示：

1-2『微服务基础设置内容，上面图内的信息提取：服务发现、服务内容、服务容错、服务监控、服务跟踪、服务安全、自动化测试、自动化部署、配置中心、接口框架、API 网关。做一张术语卡片。』——已完成

看到上面这张图，相信很多人都会倒吸一口凉气，说好的微服务的「轻量级」呢？都这么多基础设施还好意思说自己是「轻量级」，感觉比 ESB 还要复杂啊？确实如此，微服务并不是很多人认为的那样又简单又轻量级。要做好微服务，这些基础设施都是必不可少的，否则微服务就会变成一个焦油坑，让业务和团队在里面不断挣扎且无法自拔。因此也可以说，微服务并没有减少复杂度，而只是将复杂度从 ESB 转移到了基础设施。你可以看到，「服务发现」「服务路由」等其实都是 ESB 的功能，只是在微服务中剥离出来成了独立的基础系统。

虽然建设完善的微服务基础设施是一项庞大的工程，但也不用太过灰心，认为自己团队小或者公司规模不大就不能实施微服务了。第一个原因是已经有开源的微服务基础设施全家桶了，例如大名鼎鼎的 Spring Cloud 项目，涵盖了服务发现、服务路由、网关、配置中心等功能；第二个原因是如果微服务的数量并不是很多的话，并不是每个基础设施都是必须的。

1『原来这就是之前作者在黑板墙里说的 Spring 全家桶，哈哈。（2020-11-21）』

通常情况下，我建议按照下面优先级来搭建基础设施：1）服务发现、服务路由、服务容错：这是最基本的微服务基础设施。2）接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。3）自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。4）服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。

以上 3 和 4 两类基础设施，其重要性会随着微服务节点数量增加而越来越重要，但在微服务节点数量较少的时候，可以通过人工的方式支撑，虽然效率不高，但也基本能够顶住。

### 黑板墙

参考文章中提到的方法，思考一下你所在的业务微服务架构是否还有可以改进和提升的空间？

感谢老师对微服务解读，有 3 个问题：目前公司有个在线交易系统，大概几百个表的单体服务项目，其他业务前端都远程调用这个项目，现在想做微服务的改造。1）实施微服务按业务职责划分后，是否对应模块的数据库也必须要独立？2）若为每个微服务项目都拆出来新的数据库，原来各业务间的数据依赖（单库的时候 Join 查询就 ok 了），拆分多个项目后，有何好的处理办法？3）团队开发时的问题，由于每小团队负责一个微服务，但开发时需要访问其他微服务，应该有个开发环境负责集成大家提交的代码，构建新版本供其他团队调用和调试，即：开发团队都可以作为消费者访问服务器上微服务（互通），但是开发人员本机启动调试时，不能注册到这台服务器（隔离），这块如何能很好解决？

作者回复：1）需要，微服务需要独立部署独立运行，数据库不拆分做不到这点。2）参考专栏前面分库分表内容。3）开发环境也可以搭建微服务，我们是三套环境：开发，测试，线上。2018-07-18

三个火枪手分前后端吗？作者回复：一般指后端人员，前端人员是多服务公用的，如果用 node 之类的系统，本身可以算一个独立的微服务。2018-07-18

使用 dubbo 体系，开发微服务。那么一个微服务是指一个部署单元 (jar or war) 还是指一个暴露的接口？我的答案是部署单元。作者回复：一个可以独立部署和运行的子系统。2018-07-17

那么对于像 kafka，rabbitmq 这样的对应的消费者服务的消费地址是否应该放置到配置中心动态配置？还是不建议动态修改？作者回复：任何配置都可以放配置中心，区别只是动态配置还是需要重启，中间件也不例外。2018-10-24

看来小企业还是不太适合微服务架构，尤其是开发人员少的？作者回复：是的，等业务发展，人员规模大了再重构，90% 以上的新业务还没发展就挂掉了。2018-07-17

请问「接口框架」是指什么？有无成熟产品可以借鉴，它的作用是什么？API 网关是指通用网关，比如支付宝开放平台网关，还是业务网关呢？我理解的业务网关的职责应该包括协议转换（比如外网的 HTTP 转内部 Dubbo）和业务逻辑。作者回复：下一课就讲了。2018-10-05

咨询老师一个问题：在服务切分的时候会存两个系统间数据发生交集的情况，比如一个是设备系统，另一个是用户系统，用户的各项操作必然发生在设备上，这样就会存在设备和用户的各种关系和操作记录，像这样的数据设备系统和用户系统都希望以自己为准，而后对外提供相应的服务。如果是数据存储两份，设备系统存储设备和用户的关系，用户系统存储用户和设备的关系，那么在数据一致性和调用链路上就会变得复杂；如果只存储一份，放在那个系统上另一个系统都会有意见。对于此种情况，有什么比较好的解法？作者回复：其实你这句话已经包含了答案「用户操作必然发生在设备上」，这就是说设备是基础数据，用户和设备对应关系应该是用户系统管理的。还有一种判断标准是设备数据还可以给其它业务用，如果设备系统存储用户和设备对应关系，这个数据不是通用的，违背了设备系统的职责。2018-09-15

为什么说配置中心可以提升测试和运维的效率，这里不是太理解。作者回复：不用去几十台服务器几百个节点手工修改配置文件。2019-03-28

问一下关于配置中心的问题，配置中心修改配置，然后通知对应的微服务，那么收到通知的微服务怎么使新的配置生效，我这里特别指的是那些通过配置有创建长生命周期对象的那种。比如 mysql 连接池，redis-client。比如数据库配置修改了，怎么使新的配置生效？作者回复：通常这类配置需要重启生效，一般改动频率也低，改动的时候由运维人工参与是可以的。2018-10-24

我们项目正好相反，将系统拆分了多个子系统，但是同一个库，子系统之间没有相互调用，而是直接对相同库中的表进行操作。在开发过程中发现每个系统中多少会有些重复的代码。该系统是校级系统，目前没发现其它弊端。作者回复：正常来说这样有很大隐患，我们之前有后台管理系统这样做，每周都需要安排人力排查线上数据错乱问题，因为数据写入有两个源。2018-07-19

感觉应该还可以按照领域模型中数据一致性的维度来拆分。比如对实时一致性要求比较高的业务，尽量避免散落在太多服务中，增加分布式事务管理的复杂度。还有，感觉现在各种服务治理的架构其实还是造名词多一些，本质上都应该算是 SOA 思想的延伸或者变形。比如现在很火的 Service Mesh 本质上就是借鉴了通信领域的控制面数据面分离思想做出的去中心化的 ESB。作者回复：1）这也是一种思路。2）微服务基础设施做完，复杂度和 ESB 类似。2018-07-18

我所在工作单位系统基本都是外部采购，大概有 100 多个，开发、测试人员大部分是各个公司的外包人员，开发和运维部门又相对比较独立。请问实施微服务是否是一个明智的选择？代价会有多大？领导觉得 SOA 的 ESB 太重，又没有使用。希望华仔帮忙给些架构方面的建议。作者回复：采用微服务不明智，你们这种是典型的 SOA 应用场景，因为基本都是采购的。2018-07-18

这里面服务容错是比较容易被忽视的，见过太多的开发问，服务好好的怎么会出错呢？我做开发 2、3 年了也没见过数据库数据损坏。关于 api 网关请教下，什么时候应该考虑加网关层，以微服务数量来评估吗？还有现在讨论的比较多的 service mesh，单独把通信层解耦出来，感觉对于一般的中型互联网公司也没有必要吧。作者回复：1）网关的场景和设计关键点下一章节会讲。2）service mesh 目前并不算成熟，中小公司没有必要用。2018-07-17

目前 Spring Cloud 哪个版本更稳定些？作者回复：通常用 GA 版本就可以。2018-07-17

请问老师，到底项目进展到什么程度，才需要做微服务架构的拆分，可不可以在业务最初设计时就做简单的微服务拆分设计？（在满足人员需求时）作者回复：可以的，一般最开始拆分几个粗一点的。2019-03-13

老师请教一个问题，如果一个业务需要由多个微服务参与。如果在调用链中一部分已经成功，数据已提交数据库，此时某服务失败，那么此时如何保证所有服务上的数据一致性呢？作者回复：要精确保证的话需要引入 zookeeper 之类的系统，不需要精确保证的话可以通过定时校验来做。2018-12-06

请问 api 网关的职责是什么？只负责协议转码参数校验，不包含业务逻辑吗？另外，有没有线下沟通的微信群呢？作者回复：不包含业务逻辑，只负责编解码，路由，安全这些功能。2018-09-30

目前业务中只使用了网关，为什么首先使用网关呢？因为想对一批互不关联的服务进行统一认证、限流等。这样的话，这批服务就不是微服务了，因为服务间没有关联。面对这种场景，认为不能完全照搬微服务的一些设施，具体问题还得具体分析。由于服务间不存在互相调用，所以一些微服务的设施可以不使用。比如：1）服务追踪，服务发现、路由，容错。2）配置中心。作者回复：你们这个算不上微服务，微服务是业务相关的，肯定有依赖关系和调用关系。2018-08-25

我的团队有 20 个人，但有二十多个服务模块，目前是采用人员复用的方式，比如甲乙丙负责 A 服务，乙丙丁负责 B 服务，从长远来看，有没有好的建议？加人？合并服务？作者回复：缩减服务数量到 6-10 个最好。2018-07-23

微服务的基础设施非常重要，希望后续老师可以花比较多的篇幅来把这块讲透。作者回复：微服务基础设施全部讲透的内容足够开另外一个专栏了，极客时间已有类似的专栏，我主要提炼关键设计点。2018-07-17

3 个人负责开发一个微服务，每个微服务由 2 个人负责维护，的确是一个很好的人力资源配置标准。微服务可以按照业务逻辑（其实是按照团队规模？）以及可扩展、高可用、高性能（架构设计三原则？）来拆分。微服务所需要的基础设施确实比较多，但是搭建了微服务基础设施之后，应该是可以重复利用的 —— 一次搭建，多处使用。文中给出的微服务基础设施优先级很有帮助，而且老师似乎是比较推崇 Spring Cloud 全家桶的，不知道还有没有其他的微服务开发框架？作者回复：用最成熟的非 Spring 莫属。2020-10-11

DDD 也算是微服务划分的利器了。作者回复：是的，但是 DDD 既想搞定业务服务划分，又想搞定实际代码编写，很多人看不清什么时候该用哪一部分。2020-09-23

如果在网关做协议转换，比如 htpp 到 grpc 的转换，没有办法做的自动转换的，我知想到了两个思路，一个是一大堆的 reflect 操作，一个是动态生成代码去映射，但都觉得好麻烦。目前有一个思路就是提供 sdk 给每个微服务端，然后在微服务端提供接口去做协议的转换和映射，不知道我这个想法对不对？作者回复：你这个思路是说网关通过 http 访问微服务，微服务来完成转换？这样性能太低了。通常的做法是制定标准，然后按照标准转化，网关不应该理解实际的接口含义。2020-06-20

道理都是相通的，虽然是华仔自己思考和总结的，不过和胡忠想老师讲的异曲同工，并且他讲的更加细致，专栏定位不同吧！老师所提的这些基础服务目前的公司基本都有，要说提升自己到是需要多多提升，因为有人运维和和研发，作为业务开发时间多花在了业务开发的细节上了，这也是公司这么安排的目的，不过作为业务研发再出去找工作就处于劣势位置了，中间件是各种使用都 OK，不过里面的实现细节却不太清楚。另外，压测时是有痛点的，特别是微服务的使用赖外部服务较多的接口压测时疼得更厉害。不能压到其他系统，但又不得不依赖 ，只能自己模拟一下外部接口。所以，每逢大促必压测必痛一次。不知老师针对这种情况，有什么更好的方式？作者回复：全链路压测呀，但是成本高。2019-09-02

服务粒度控制有内在的划分方法，如果加入团队人数去指导划分会不会出现自相矛盾。比如按照业务、可扩展来划分的话有 5 个服务。但是人只有 9 个人，是不是要把原来的 5 个服务压缩成 3 个？作者回复：按照业务可以分的很细，不一定是 5 个。2019-05-13

我们现在的微服务是基于业务进行拆分的，基本是一个人对接 3-4 个微服务项目，当时拆的时候根本没有考虑人员的实际情况，目前的微服务已经开始有烂的迹象了（三个火枪手的原则现在来看确实是太形象生动）！看了下老师这篇文章，感觉现在要么是招人（人月神话中添加人手指不定是好是坏），要么是需要对服务进行整理合并，另外基础设施目前只接入了 1 和 2 两个。请问老师现在这种情况您这边有什么好的建议么？作者回复：合并微服务是最有效的。2019-04-18

构建一个微服务作为消息处理中心，客户端先发送消息到 kafka，然后消息处理中心根据配置消费 Kafka 集群消息，并以 http 形式投递消息到真实的消费端，消息中心会对消费失败的消息进行重新投递，请问这个有意义吗？相比消费端直接对接 Kafka 集群消费消息有什么不同？作者回复：不是很明白这么做要解决什么问题，本来消息队列就有消费确认的功能，消费端可以直接消费成功后确认。2018-09-01

这种每个服务都是分开的库，数据 join 一般如何做？作者回复：没法在数据库层面做，只能自己代码做，或者冗余数据来做 join，例如统计报表类系统。2018-08-28

接口框架是什么作用，有开源项目可以直接用的嘛？作者回复：可以基于 gRPC 之类的制定自己的数据规范就是接口框架了。2018-07-21

能否讲一下 app 多版本共存问题和解决思路呢。作者回复：没有太好方法，要么接口后向兼容，要么接口加版本号。2018-07-18

多个微服务会共用一个数据库实例吗，还是每个微服务都有独立的数据库绑定？作者回复：可以共用实例，别共用库。2018-07-17

## 0405. 微服务架构最佳实践 —— 基础设施篇

每项微服务基础设施都是一个平台、一个系统、一个解决方案，如果要自己实现，其过程和做业务系统类似，都需要经过需求分析、架构设计、开发、测试、部署上线等步骤，专栏里我来简单介绍一下每个基础设施的主要作用，更多详细设计你可以参考 Spring Cloud 的相关资料（[Spring Cloud](https://spring.io/projects/spring-cloud)）。下面进入今天的内容，微服务架构最佳实践的基础设施篇。

### 5.1 自动化测试

微服务将原本大一统的系统拆分为多个独立运行的「微」服务，微服务之间的接口数量大大增加，并且微服务提倡快速交付，版本周期短，版本更新频繁。如果每次更新都靠人工回归整个系统，则工作量大，效率低下，达不到「快速交付」的目的，因此必须通过自动化测试系统来完成绝大部分测试回归的工作。

自动化测试涵盖的范围包括代码级的单元测试、单个系统级的集成测试、系统间的接口测试，理想情况是每类测试都自动化。如果因为团队规模和人力的原因无法全面覆盖，至少要做到接口测试自动化。

### 5.2 自动化部署

相比大一统的系统，微服务需要部署的节点增加了几倍甚至十几倍，微服务部署的频率也会大幅提升（例如，我们的业务系统 70% 的工作日都有部署操作），综合计算下来，微服务部署的次数是大一统系统部署次数的几十倍。这么大量的部署操作，如果继续采用人工手工处理，需要投入大量的人力，且容易出错，因此需要自动化部署的系统来完成部署操作。

自动化部署系统包括版本管理、资源管理（例如，机器管理、虚拟机管理）、部署操作、回退操作等功能。

### 5.3 配置中心

微服务的节点数量非常多，通过人工登录每台机器手工修改，效率低，容易出错。特别是在部署或者排障时，需要快速增删改查配置，人工操作的方式显然是不行的。除此以外，有的运行期配置需要动态修改并且所有节点即时生效，人工操作是无法做到的。综合上面的分析，微服务需要一个统一的配置中心来管理所有微服务节点的配置。

配置中心包括配置版本管理（例如，同样的微服务，有 10 个节点是给移动用户服务的，有 20 个节点给联通用户服务的，配置项都一样，配置值不一样）、增删改查配置、节点管理、配置同步、配置推送等功能。

### 5.4 接口框架

微服务提倡轻量级的通信方式，一般采用 HTTP/REST 或者 RPC 方式统一接口协议。但在实践过程中，光统一接口协议还不够，还需要统一接口传递的数据格式。例如，我们需要指定接口协议为 HTTP/REST，但这还不够，还需要指定 HTTP/REST 的数据格式采用 JSON，并且 JSON 的数据都遵循如下规范。

```json
{
    "requestId": 10086,
    "time": "2017-01-01 00:00:00",
    "caller": "tencent",
    "param": {
        "userId": 13800138
    },
    "sign": "074hfg48723hjsg2723ksyje83"
}
```

如果我们只是简单指定了 HTTP/REST 协议，而不指定 JSON 和 JSON 的数据规范，那么就会出现这样混乱的情况：有的微服务采用 XML，有的采用 JSON，有的采用键值对；即使同样都是 JSON，JSON 数据格式也不一样。这样每个微服务都要适配几套甚至几十套接口协议，相当于把曾经由 ESB 做的事情转交给微服务自己做了，这样做的效率显然是无法接受的，因此需要统一接口框架。

接口框架不是一个可运行的系统，一般以库或者包的形式提供给所有微服务调用。例如，针对上面的 JSON 样例，可以由某个基础技术团队提供多种不同语言的解析包（Java 包、Python 包、C 库等）。

### 5.5 API 网关

系统拆分为微服务后，内部的微服务之间是互联互通的，相互之间的访问都是点对点的。如果外部系统想调用系统的某个功能，也采取点对点的方式，则外部系统会非常「头大」。因为在外部系统看来，它不需要也没办法理解这么多微服务的职责分工和边界，它只会关注它需要的能力，而不会关注这个能力应该由哪个微服务提供。

除此以外，外部系统访问系统还涉及安全和权限相关的限制，如果外部系统直接访问某个微服务，则意味着每个微服务都要自己实现安全和权限的功能，这样做不但工作量大，而且都是重复工作。

综合上面的分析，微服务需要一个统一的 API 网关，负责外部系统的访问操作。API 网关是外部系统访问的接口，所有的外部系统接⼊系统都需要通过 API 网关，主要包括接入鉴权（是否允许接入）、权限控制（可以访问哪些功能）、传输加密、请求路由、流量控制等功能。

### 5.6 服务发现

微服务种类和数量很多，如果这些信息全部通过手工配置的方式写入各个微服务节点，首先配置工作量很大，配置文件可能要配几百上千行，几十个节点加起来后配置项就是几万几十万行了，人工维护这么大数量的配置项是一项灾难；其次是微服务节点经常变化，可能是由于扩容导致节点增加，也可能是故障处理时隔离掉一部分节点，还可能是采用灰度升级，先将一部分节点升级到新版本，然后让新老版本同时运行。不管哪种情况，我们都希望节点的变化能够及时同步到所有其他依赖的微服务。如果采用手工配置，是不可能做到实时更改生效的。因此，需要一套服务发现的系统来支撑微服务的自动注册和发现。

服务发现主要有两种实现方式：自理式和代理式。

1、自理式。自理式结构如下：

自理式结构就是指每个微服务自己完成服务发现。例如，图中 SERVICE INSTANCE A 访问 SERVICE REGISTRY 获取服务注册信息，然后直接访问 SERVICE INSTANCE B。自理式服务发现实现比较简单，因为这部分的功能一般通过统一的程序库或者程序包提供给各个微服务调用，而不会每个微服务都自己来重复实现一遍；并且由于每个微服务都承担了服务发现的功能，访问压力分散到了各个微服务节点，性能和可用性上不存在明显的压力和风险。

2、代理式。代理式结构如下：

代理式结构就是指微服务之间有一个负载均衡系统（图中的 LOAD BALANCER 节点），由负载均衡系统来完成微服务之间的服务发现。代理式的方式看起来更加清晰，微服务本身的实现也简单了很多，但实际上这个方案风险较大。第一个风险是可用性风险，一旦 LOAD BALANCER 系统故障，就会影响所有微服务之间的调用；第二个风险是性能风险，所有的微服务之间的调用流量都要经过 LOAD BALANCER 系统，性能压力会随着微服务数量和流量增加而不断增加，最后成为性能瓶颈。因此 LOAD BALANCER 系统需要设计成集群的模式，但 LOAD BALANCER 集群的实现本身又增加了复杂性。

不管是自理式还是代理式，服务发现的核心功能就是服务注册表，注册表记录了所有的服务节点的配置和状态，每个微服务启动后都需要将自己的信息注册到服务注册表，然后由微服务或者 LOAD BALANCER 系统到服务注册表查询可用服务。

### 5.7 服务路由

有了服务发现后，微服务之间能够方便地获取相关配置信息，但具体进行某次调用请求时，我们还需要从所有符合条件的可用微服务节点中挑选出一个具体的节点发起请求，这就是服务路由需要完成的功能。

服务路由和服务发现紧密相关，服务路由一般不会设计成一个独立运行的系统，通常情况下是和服务发现放在一起实现的。对于自理式服务发现，服务路由是微服务内部实现的；对于代理式服务发现，服务路由是由 LOAD BALANCER 系统实现的。无论放在哪里实现，服务路由核心的功能就是路由算法。常见的路由算法有：随机路由、轮询路由、最小压力路由、最小连接数路由等。

### 5.8 服务容错

系统拆分为微服务后，单个微服务故障的概率变小，故障影响范围也减少，但是微服务的节点数量大大增加。从整体上来看，系统中某个微服务出故障的概率会大大增加。专栏第 34 期我在分析微服务陷阱时提到微服务具有故障扩散的特点，如果不及时处理故障，故障扩散开来就会导致看起来系统中很多服务节点都故障了，因此需要微服务能够自动应对这种出错场景，及时进行处理。否则，如果节点一故障就需要人工处理，投入人力大，处理速度慢；而一旦处理速度慢，则故障就很快扩散，所以我们需要服务容错的能力。

常见的服务容错包括请求重试、流控和服务隔离。通常情况下，服务容错会集成在服务发现和服务路由系统中。

### 5.9 服务监控

系统拆分为微服务后，节点数量大大增加，导致需要监控的机器、网络、进程、接口调用数等监控对象的数量大大增加；同时，一旦发生故障，我们需要快速根据各类信息来定位故障。这两个目标如果靠人力去完成是不现实的。举个简单例子：我们收到用户投诉说业务有问题，如果此时采取人工的方式去搜集、分析信息，可能把几十个节点的日志打开一遍就需要十几分钟了，因此需要服务监控系统来完成微服务节点的监控。

服务监控的主要作用有：1）实时搜集信息并进行分析，避免故障后再来分析，减少了处理时间。2）服务监控可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警，降低了问题影响的范围和时间。3）通常情况下，服务监控需要搜集并分析大量的数据，因此建议做成独立的系统，而不要集成到服务发现、API 网关等系统中。

### 5.10 服务跟踪

服务监控可以做到微服务节点级的监控和信息收集，但如果我们需要跟踪某一个请求在微服务中的完整路径，服务监控是难以实现的。因为如果每个服务的完整请求链信息都实时发送给服务监控系统，数据量会大到无法处理。

服务监控和服务跟踪的区别可以简单概括为宏观和微观的区别。例如，A 服务通过 HTTP 协议请求 B 服务 10 次，B 通过 HTTP 返回 JSON 对象，服务监控会记录请求次数、响应时间平均值、响应时间最高值、错误码分布这些信息；而服务跟踪会记录其中某次请求的发起时间、响应时间、响应错误码、请求参数、返回的 JSON 对象等信息。目前无论是分布式跟踪还是微服务的服务跟踪，绝大部分请求跟踪的实现技术都基于 Google 的 Dapper 论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》。

### 5.11 服务安全

系统拆分为微服务后，数据分散在各个微服务节点上。从系统连接的角度来说，任意微服务都可以访问所有其他微服务节点；但从业务的角度来说，部分敏感数据或者操作，只能部分微服务可以访问，而不是所有的微服务都可以访问，因此需要设计服务安全机制来保证业务和数据的安全性。

服务安全主要分为三部分：接入安全、数据安全、传输安全。通常情况下，服务安全可以集成到配置中心系统中进行实现，即配置中心配置微服务的接入安全策略和数据安全策略，微服务节点从配置中心获取这些配置信息，然后在处理具体的微服务调用请求时根据安全策略进行处理。由于这些策略是通用的，一般会把策略封装成通用的库提供给各个微服务调用。基本架构如下：

### 黑板墙

这一期的思考题很特别，给你一个由 10 位 Java 高级软件工程师组成的开发团队，采用自研的方式，完成所有的微服务基础设施开发，你预测需要多长时间？理由是什么呢？

文章中一共列了 11 个部分，但只有 10 个人，很明显是不可能是同时开工的，即使能够同时开工也是需要经过几轮迭代才能达到一个比较完善的状态。依据简单原则和演化原则以及「三个火枪手」的人员分配原则，首先可以做 API 网关、配置中心、服务发现、服务路由这 4 部分，经过一个月的开发 + 半个月的联调的先让基础框架搭建起来，业务能够运行起来。业务上线后，为了保证用户体验和问题跟踪，在保留一两个留守同学的情况下，开始服务容错、服务监控、服务跟踪这几部分的开发，因为这个阶段中可能还要回头修改已完成的部分让这几个部分配合的更好，联调的工作量也多了不少，这个过程大概要 2.5 月。而后随着业务逐渐增多，流量逐渐增加，为避免被黑产「薅羊毛」需要把服务安全部分给完成，同时为了快速响应新的业务需要把接口框架给完成，但此时有些同学会被已完成部分的日常维护、修 bug 等，这些初步需要两个月时间。在这里都完成后，可以开始自动化测试、自动化部署这部分，也按照两个月的时间，这样一轮下来总体需要 8 个月时间。经过第一轮后微服务的基础实施是有了，但要真正的运作起来还需要经过几轮的迭代才可以，但此时面对老系统的维护新系统的开发整体的进度会变慢不少，这样一个合格的比较完善的微服务基础设施差不多要两年时间了。作者回复：你是第一个认真分析且抓住重点的同学。2018-09-18

很多人把 oauth2 的鉴权放到了网关，这个你怎么看。作者回复：不符合网关的定位，因为有的业务要鉴权有的不要，放在网关就相当于网关要和业务耦合了。2018-07-20

之前看您留言提到过 service mesh 不成熟，中小公司不建议使用。请问看起来最近 gcp 云平台，主推的 k8s 加上 Istio/envoy 实现服务治理，您认为未来方向如何，这个是试用中小型团队的方案吗？作者回复：我没有 service mesh 具体实践经验，主要信息来源于网上资料，意见供参考。1）Istio 刚发布 1.0 版本，spring cloud 成熟很多。2）service mesh 中文为服务网格，很形象，说明了更加适合非常多的服务节点，简单来说，如果你只有一两个服务没必要用微服务架构，你只有几十个微服务节点可能也不需要 service mesh。3）service mesh 对程序无侵入，这点非常好，但随着 spring cloud 之类的方案成熟，侵入问题其实不是主要问题。因此，我认为大部分中小公司目前不需要 service mesh，能把微服务做好已经很不错了。2018-08-12

自己写的话肯定坑太多，也没有经过太多实践上的检验。感觉真正稳定下来需要躺过很多坑才行，当然成长也是成倍的，最终苦了公司，系统天天挂。2018-11-29

汇总：1）自动化测试（代码级单元测试，单个系统级系统测试，接口间接口测试）。2）自动化部署（版本管理，资源管理（机器管理，虚拟机管理），部署操作，回退操作）。3）配置中心（配置版本管理，节点管理，配置同步，配置推送，增删查改操作）。4）服务监控（宏观，考察请求次数，响应平均时间，响应最高值，减少故障处理时间，针对故障提前预警）。5）服务跟踪（微观，某次请求的发起请求记录，响应时间，响应错误码，请求参数等）。6）服务安全（接入安全，数据安全，传输安全）。7）接口框架（对外用 http/json 方式，对内用 rpc 方式）。8）api 网关（唯一提供外部访问的，接入鉴权（是否接入），权限控制（是否能访问），流量控制，请求路由，传输加密）。9）服务发现（自主式（每个微服务之间自己完成服务发现），代理式（每个微服务之间借助负载均衡系统完成服务发现）。10）服务路由（随机，轮询，最小压力，最小连接）。11）服务容错（请求重试，流式和服务隔离）

根据简单和演化原则，自研项目可以从最简单的开始，比如从服务发现，服务路由，服务容错，以及接口框架和 api 网关出发，等迭代完毕后再跟进自动化测试，自动化部署，配置中心，服务监控，服务跟踪，服务安全，按照逐步迭代，不断演化的思路。至于预测时间，真不好预测，之前做一个基于旧业务的新框架翻新，前前后后花了半年多才出雏形，后面再花半年才稳定下来。还不包括踩坑什么的。

作者回复：差不多，半年落地，半年稳定。2020-03-12

看了这么久第一次留言，老师你好，刚看你说网关层不建议做鉴权！但是如果这样的话，那内部微服务之间如何进行通信呢？我的理解是网关做与 url 有关的权限处理！而具体的业务服务里面做与数据相关的权限鉴别！这样职业分开！然后内部进行通信的话就可以采用 rpc 进行高效的交互，而且都是可信的！作者回复：这样是可以的，网关鉴权仅限于和用户相关的登录态，登录环境等，业务权限还是要业务做。2019-01-03

按照以往了解的基础架构部的开发速度来看，而且文中涉及的基础设施都有开源实现可以借鉴，一个基础设施从调研（开源系统代码 review），到设计，再到开发，再到小流量接入，全公司推广，一个基础设施 3 个人大概 5 到 6 个月时间，如果去掉小流量和推广阶段，估计也需要 3 到 4 个月。文中说到的前 10 个微服务，按照单个 3*3 人月算下来的话，理想情况下，需要 9 个月。当然，这里没有考虑严格的测试和压力测试，否则每个系统，需要增加至少一个人月的周期。作者回复：这类微服务做出基本功能 9 个月可以，做完善需要耗时更长。2018-07-19

其实在微服务的 11 个基础设施里面，我觉得自动化测试和自动化部署反而是比较基础的，并且需要开发人员能够适应并且投入。不知道国内有多少团队能够做到单元测试，或者是自动化测试；自动化部署因为有 Jenkins，可能会好一点。如果按照上一章节的优先级顺序，应该从服务发现、服务路由和服务容错起步，然后再做接口框架和 API 网关；最后是服务监控、服务跟踪和服务安全。10 位 Java 高手，自研微服务基础设施，如果采用 3 个人一组的方式，3 个月（9 人月）完成一项基础设施，那么大概 1 年左右应该有小成。假设 Java 高手的月薪在 50K 左右，那么 1 年的人力成本不少于 600 万。为什么要自研呢？很多基础设施已经是现成的轮子了。同样 10 位高手，采用开源软件，选型、搭建全套的微服务基础设施，可能 2 个月应该就可以跑的很流畅了吧。作者回复：基本正确，但是在大厂如果能自己做，晋升会比较容易。2020-10-11

我们将原有系统从传统架构调整为为服务，基本按照 spring boot 全家桶来搞，拆分成了接近 20 个微服务，做的过程中微服务尤其表的划分以及互相之间调用，十分头疼。涉及代码 100 万。整个开发加测试耗时 10 个月，人员 100 人左右。作者回复：这个投入还是很大的。2020-03-15

请问一下 json 数据格式规范，主要是约定公共字段名吗？还有其它要定义的内容吗？作者回复：主要是这个。2020-01-25。你在文章中提到的「即使同样都是 JSON，JSON 数据格式也不一样。」想请教 json 数据格式规范具体指什么？此规范要约定那些内容？作者回复：json 里面的字段不一样。2020-01-05

请教一个问题，微服务本身要实现请求鉴权，这个功能和网关相同，如果一个外部请求通过网关访问，它将要进行两次验证，有点重复呀，是这样吗？作者回复：网关可以做鉴权，也可以不做，由应用自己来做，不要重复做两次。2020-01-25

请问：服务间的安全策略通过配置中心下发给各节点，一般采用那些安全策略？我了解到的有黑白名单（根据服务名、IP），这个方案比较容易伪造（服务名和 IP），还有其它策略吗？作者回复：内部网络需要与外部隔离，因此内部反而一般黑白名单用的少，因为机器会经常变，黑白名单管理比较麻烦；通常是给每个服务分配服务名称 + 服务访问密码之类的做法。2020-01-05

你说 API 网关的主要包括接入鉴权、权限控制，然后在留言中又说不应该把 oauth2 的鉴权放到网关。我觉得前后矛盾了，是我对鉴权和权限控制哪里理解的还不到位吗？作者回复：oauth2 是第三方授权，API 网关是二方授权，二方是公司内不同业务部门的请求方和调用方，第三方授权是外部系统，内部系统，用户这三方。2019-06-11

基础设施为啥要自研呢？有没有现成的成熟框架？如果有，不知道后面作者会不会有对比分析？作者回复：小厂用 spring 全家桶，大厂为了可控和按需定制，一般会自己做。2019-06-02

关于绕过网关进行接口调用的问题，如果通过 SDK 的方式提供给业务方使用，那是不是业务方也需要登录鉴权了，和网关功能重复了呢。作者回复：都封装在 SDK 里面。2019-05-31

用了网关后，如何避免服务调用不会绕过网关直接调用接口？作者回复：封装 SDK 给业务用。2019-03-02

上面一共提到 11 个功能，每个功能按照业务职责去分可以分成 11 个服务，但按照三个火枪手原则来拆分服务大概是 4 个服务，拆分如下。按照业务拆分：分为三类：1）构建微服务的的内部依赖：接口框架、服务路由、服务容错、服务安全。2）构建微服务的外部依赖：配置中心、api 网关、服务发现、服务可持续集成、监控相关。3）与服务间无强关联的：自动化测试、自动化部署、服务监控、服务追踪。按照服务性能 + 可靠性拆分为两类，性能要求低，对内部应用提供服务：配置中心、服务发现，性能要求高，对外部请求提供服务，保证性能要求高的处理速率和高可用：api 网关，如果网关宕机则整个系统无法对外提供服务。最后拆分为 4 个服务：1）接口框架、服务路由、服务容错、服务安全。2）配置中心、服务发现。3）api 网关。4）自动化测试、自动化部署、服务监控、服务追踪。2018-12-13

接上一问题，微服务提倡无状态，那就必须有一个认证授权服务存在，我的理解是在 APIGateway 下层，存在一个同级服务来提供验证授权，或者说结合 API 网关提供全面安全机制，这样既可以在 APIGateway 层过滤部分非法请求，又在下层提供更细粒度安全控制，整体来说压到服务节点的流量被有效降低了，不知道这样子理解正确否。作者回复：可以这样做，网关依赖安全服务。2018-10-29

请教个问题：API 网关提供认证授权功能，那请求穿透 API 网关这一层之后，后续的业务流程依然会涉及在多个子服务之间交互，此时如何授权呢？难道需要反向去 API 网关查询吗？作者回复：网关是针对外部系统的认证授权，内部系统如果要做权限控制，一般放在配置中心做，因为独立做内部的认证系统代价比较高。2018-10-29

代理式服务发现，代理还负责转发请求消息响应消息对吗。作者回复：是的，和网关类似。2018-08-09

请问微服务架构中的网关和 soa 架构中的 esb 有什么区别？难道网关不会成为整体架构中的性能瓶颈吗？作者回复：网关的功能只是 esb 中的其中一个职责。2018-07-22

老师关于服务发现主要有两种实现方式：自理式和代理式，我没有听明白。我理解两种方式的服务注册都是一样的，都是需要服务实例自己去注册，对比两种服务发现方式代理方式的负载均衡通过图示感觉多过了一道。没有任何意义。不知道负载均衡的意义何在？作者回复：注册都是要自己注册的，但是服务发现和路由处理不一样，一个是服务自己完成发现和路由，一个是代理去完成发现和路由。2018-07-20

我想问下是不是有服务统一调度的模块，比如一个基本的银行转账业务，我们把该业务的调度流程参数化到表中，比如第一步要调用存款服务的转账功能，第二步调用会计服务的流水登记功能，假设调度表中对于活期转账已经配置了两个步骤，那调度模块就根据配置依次顺序调用微服务 a 存款服务和 b 会计服务，那调度模块是放在 api 网关做总体调度还是让微服务 a 自发去调用微服务 b 吗？哪种合理？还是说调度参数化这种设计不好？在服务 a 中写死调用服务 b？作者回复：网关不要有业务逻辑，因此你说的调度模块不适合放到网关，应该放到 a 服务去调用 b 服务。至于流程设计，a 服务可以采用规则引擎，或者有一个独立的服务 c 基于规则引擎配置业务逻辑，然后根据逻辑调用 a 或者 b 服务。2018-07-19

### 0406. 微内核架构详解

微内核架构（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构，通常用于实现基于产品（原文为 product-based，指存在多个版本、需要下载安装才能使用，与 web-based 相对应）的应用。例如 Eclipse 这类 IDE 软件、UNIX 这类操作系统、淘宝 App 这类客户端软件等，也有一些企业将自己的业务系统设计成微内核的架构，例如保险公司的保险核算逻辑系统，不同的保险品种可以将逻辑封装成插件。今天我将为你详细介绍常见的微内核架构及其实现。

### 6.1 基本架构

微内核架构包含两类组件：核心系统（core system）和插件模块（plug-in modules）。核心系统负责和具体业务功能无关的通用功能，例如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑，例如专栏前面经常提到的「学生信息管理」系统中的「手机号注册」功能。微内核的基本架构示意图如下：

上面这张图中核心系统 Core System 功能比较稳定，不会因为业务功能扩展而不断修改，插件模块可以根据业务功能的需要不断地扩展。微内核的架构本质就是将变化部分封装在插件里面，从而达到快速灵活扩展的目的，而又不影响整体系统的稳定。

### 6.2 设计关键点

微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。

1、插件管理。核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。

2、插件连接。插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（Spring 使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式。

3、插件通信。插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。

### 6.3 OSGi 架构简析

OSGi 的全称是 Open Services Gateway initiative，本身其实是指 OSGi Alliance。这个联盟是 Sun Microsystems、IBM、爱立信等公司于 1999 年 3 月成立的开放的标准化组织，最初名为 Connected Alliance。它是一个非盈利的国际组织，旨在建立一个开放的服务规范，为通过网络向设备提供服务建立开放的标准，这个标准就是 OSGi specification。现在我们谈到 OSGi，如果没有特别说明，一般都是指 OSGi 的规范。

OSGi 联盟的初始目标是构建一个在广域网和局域网或设备上展开业务的基础平台，所以 OSGi 的最早设计也是针对嵌入式应用的，诸如机顶盒、服务网关、手机、汽车等都是其应用的主要环境。然而，无心插柳柳成荫，由于 OSGi 具备动态化、热插拔、高可复用性、高效性、扩展方便等优点，它被应用到了 PC 上的应用开发。尤其是 Eclipse 这个流行软件采用 OSGi 标准后，OSGi 更是成为了首选的插件化标准。现在我们谈论 OSGi，已经和嵌入式应用关联不大了，更多是将 OSGi 当作一个微内核的架构模式。

Eclipse 从 3.0 版本开始，抛弃了原来自己实现的插件化框架，改用了 OSGi 框架。需要注意的是，OSGi 是一个插件化的标准，而不是一个可运行的框架，Eclipse 采用的 OSGi 框架称为 Equinox，类似的实现还有 Apache 的 Felix、Spring 的 Spring DM。OSGi 框架的逻辑架构图如下：

1、模块层（Module 层）。模块层实现插件管理功能。OSGi 中，插件被称为 Bundle，每个 Bundle 是一个 Java 的 JAR 文件，每个 Bundle 里面都包含一个元数据文件 MANIFEST.MF，这个文件包含了 Bundle 的基本信息。例如，Bundle 的名称、描述、开发商、classpath，以及需要导入的包和输出的包等，OSGi 核心系统会将这些信息加载到系统中用于后续使用。一个简单的 MANIFEST.MF 样例如下：

```java
// MANIFEST.MF 
  Bundle-ManifestVersion: 2 
  Bundle-Name:UserRegister
  Bundle-SymbolicName: com.test.userregister 
  Bundle-Version: 1.0 
  Bundle-Activator: com.test.UserRegisterActivator
   
  Import-Package: org.log4j;version="2.0", 
  ..... 
  Export-Package: com.test.userregister;version="1.0", 
```

2、生命周期层（Lifecycle 层）。生命周期层实现插件连接功能，提供了执行时模块管理、模块对底层 OSGi 框架的访问。生命周期层精确地定义了 Bundle 生命周期的操作（安装、更新、启动、停止、卸载），Bundle 必须按照规范实现各个操作。例如：

```java
public class UserRegisterActivator implements BundleActivator { 
   
   public void start(BundleContext context) { 
       UserRegister.instance = new UserRegister (); 
   } 
   
   public void stop(BundleContext context) { 
       UserRegister.instance = null; 
   } 
  } 
```

3、服务层（Service 层）。服务层实现插件通信的功能。OSGi 提供了一个服务注册的功能，用于各个插件将自己能提供的服务注册到 OSGi 核心的服务注册中心，如果某个服务想用其他服务，则直接在服务注册中心搜索可用服务中心就可以了。例如：

```java
// 注册服务
public class UserRegisterActivator implements BundleActivator {
//在start()中用BundleContext.registerService()注册服务
public void start(BundleContext context) {
context.registerService(UserRegister.class.getName(), new UserRegisterImpl(), null);
}
//无须在stop()中注销服务，因为Bundle停止时会自动注销该Bundle中已注册的服务
public void stop(BundleContext context) {}
}
// 检索服务
public class Client implements BundleActivator {
public void start(BundleContext context) {
// 1. 从服务注册表中检索间接的“服务引用”
ServiceReference ref = context.getServiceReference(UserRegister.class.getName());
// 2. 使用“服务引用”去访问服务对象的实例
((UserRegister) context.getService(ref)).register();
}
public void stop(BundleContext context) {}
}
```

注意：这里的服务注册不是插件管理功能中的插件注册，实际上是插件间通信的机制。

### 6.4 规则引擎架构简析

规则引擎从结构上来看也属于微内核架构的一种具体实现，其中执行引擎可以看作是微内核，执行引擎解析配置好的业务流，执行其中的条件和规则，通过这种方式来支持业务的灵活多变。规则引擎在计费、保险、促销等业务领域应用较多。例如电商促销，常见的促销规则有：

```
满 100 送 50

3 件立减 50

3 件 8 折

第 3 件免费

跨店满 200 减 100

新用户立减 50

……
```

以上仅仅列出来常见的几种，实际上完整列下来可能有几十上百种，再加上排列组合，促销方案可能有几百上千种，这样的业务如果完全靠代码来实现，开发效率远远跟不上业务的变化速度，而规则引擎却能够很灵活的应对这种需求，主要原因在于：1）可扩展。通过引入规则引擎，业务逻辑实现与业务系统分离，可以在不改动业务系统的情况下扩展新的业务功能。2）易理解。规则通过自然语言描述，业务人员易于理解和操作，而不像代码那样只有程序员才能理解和开发。3）高效率。规则引擎系统一般提供可视化的规则定制、审批、查询及管理，方便业务人员快速配置新的业务。

规则引擎的基本架构如下：

我来简单介绍一下：1）开发人员将业务功能分解提炼为多个规则，将规则保存在规则库中。2）业务人员根据业务需要，通过将规则排列组合，配置成业务流程，保存在业务库中。3）规则引擎执行业务流程实现业务功能。

对照微内核架构的设计关键点，我们来看看规则引擎是具体是如何实现的。

1、插件管理。规则引擎中的规则就是微内核架构的插件，引擎就是微内核架构的内核。规则可以被引擎加载和执行。规则引擎架构中，规则一般保存在规则库中，通常使用数据库来存储。

2、插件连接。类似于程序员开发的时候需要采用 Java、C++ 等语言，规则引擎也规定了规则开发的语言，业务人员需要基于规则语言来编写规则文件，然后由规则引擎加载执行规则文件来完成业务功能，因此，规则引擎的插件连接实现机制其实就是规则语言。

3、插件通信。规则引擎的规则之间进行通信的方式就是数据流和事件流，由于单个规则并不需要依赖其他规则，因此规则之间没有主动的通信，规则只需要输出数据或者事件，由引擎将数据或者事件传递到下一个规则。

目前最常用的规则引擎是开源的 JBoss Drools，采用 Java 语言编写，基于 Rete 算法（参考 https://en.wikipedia.org/wiki/Rete_algorithm）。Drools 具有下面这些优点：1）非常活跃的社区支持，以及广泛的应用。2）快速的执行速度。3）与 Java Rule Engine API（JSR-94）兼容。4）提供了基于 Web 的 BRMS——Guvnor，Guvnor 提供了规则管理的知识库，通过它可以实现规则的版本控制，以及规则的在线修改与编译，使得开发人员和系统管理人员可以在线管理业务规则。

虽然 Drools 号称简单易用，但实际上其规则语言还是和编程语言比较类似，在实际应用的时候普通业务人员面对这样的规则语言，学习成本和理解成本还是比较高的，例如下面这个样例（[Drools规则引擎介绍——drools规则引擎可视化](https://blog.csdn.net/ouyangshixiong/article/details/46315273)）：

因此，通常情况下需要基于 Drools 进行封装，将规则配置做成可视化的操作，例如下面电商反欺诈的一个示例（[规则引擎-BRMS在企业开发中的应用 - 云+社区 - 腾讯云](https://cloud.tencent.com/developer/article/1031839)）：

### 黑板墙

留一道思考题给你吧，结合今天所学内容，尝试分析一下手淘 Atlas 容器化框架是如何实现微内核架构的设计关键点的，分享一下你的理解。

突然发现我们用了很久的框架，是微内核架构。作者回复：惊不惊喜，意不意外，醍醐灌顶。2018-08-01

汇总：1）规则引擎，我简单的理解为开发人员把规则提前写到数据库，这个是基础数据，然后用户选择规则，具体选择了那些规则可以通过外键关联。2）那么多规则，就比如促销的例子，用策略模式实现是否更妥当？作者回复：纯代码实现可以用策略模式，但每次新来一种促销都要写代码，虽然代码写的少，但还是要测试部署。2018-07-22

想问问流程引擎算不算规则引擎的一种呢？作者回复：流程引擎应该是粗粒度的规则引擎。2018-07-22

请教一个问题，我们目前使用的规则引擎就是这种架构，不过目前存在一个比较头疼的问题，就是对内开放了一个引擎调用接口，可是由于规则非常多，所以接口的请求参数和响应参数是动态的，所以接口调用传参比较头疼。目前我们的做法是将规则根据业务整合成起来，然后将每个业务的输入参数输出参数写入配置表，调用方先根据业务类型读取配置表查询输入输出参数的定义和类型，然后调用方自己生成这份数据调用接口，这样导致接入很不友好同时每次变动改动的地方非常多，而且配置表也越来越臃肿，请问老师这种情况有什么比较好的方案吗？作者回复：调用方自己管理各自的配置，不要由规则引擎来管理。2019-07-28

微内核我还真没接触过，又 get 到灵活的方案。作者回复：银行，保险，电商用的比较多。2018-09-14

能不能写个基于微内核的代码例子在 github 上，之前也听过微内核，但是到目前为止，接触到的都是分层结构的架构。作者回复：你可以对照 Drools 的文档写个促销的方案。2018-07-25

尝试了一下用规则引擎实现各种活动的业务逻辑，感觉很复杂，比如首先第一步你需要通过运营配置的原子规则构造规则模板，这一步少不了代码中写 ifelse 或者模板中写 when then , 第 2 步需要把业务逻辑封装成各种规则规则，第 3 步组装规则为新业务，感觉还不如策略模式好维护和效率高，唯一的优点貌似只是动态化，并且这种规则运营会不会使用。作者回复：可能是你们的规则抽象太细，基本等同于代码块了，所以觉得比较难用，不过确实规则引擎里面各种 if 和 when 也是比较复杂的。2019-11-24

每个规则对应的取数规则编码到程序中的吗？如果想实现让业务自己根据数据源，抽取出自定义规则，有没有好办法？我想到的是脚本语言，比如 java+groovy, 还有其他方法吗？作者回复：把规则引擎嵌入到业务代码中。2019-08-03

微内核架构和微服务架构区别就在于粒度吗？作者回复：形式也不同，微内核是一个应用，微服务是多个应用。2019-07-15

那能不能说规则引擎用了策略模式。作者回复：你可以理解为道理是相通的，但不要这么等同，规则引擎是面向功能的一个架构设计模式，策略模式是一个面向对象的类设计模式。2018-09-28

我们现在的数据平台是通过节点连接来表示数据处理和流转，是否也适合用微内核来实现底层引擎。请教下阿里这种数据流引擎是怎么实现的。作者回复：有商用的解决方案，也有开源系统。2018-09-14