## 记忆时间

## 目录

20200409Why-should-you-use-Vuejs-when-using-Laravel.md

20200428JavaScript1-2-and-in-between.md

20200501How-to-Use-JSON-Data-with-PHP-or-JavaScript.md

20200511css长度单位解析.md

20200512浅谈前后端路由与前后端渲染.md

20200519axios.md

20200521史上最全的Vue开发规范.md

20200531json与dataframe互相转换.md

20200617Python-Masonite框架中文翻译召集.md

## 20200409Why-should-you-use-Vuejs-when-using-Laravel.md

### 01. What is Vue.js?

Straight from the horse’s mouth, “Vue is a progressive framework for building user interfaces”. Vue at its core is focused on the view layer only of an application, so integrating with other platforms or existing applications is really easy. You can also use Vue on its own to build sophisticated single page applications.

1『 vue 是用于视图层的框架。』

### 02. How does Vue work?

If you have programmed for the web before the era of event-driven frontend JavaScript frameworks, you would understand there are considerable difficulties and inefficiencies that arise from trying to update the Document Object Model (DOM).

To update the DOM directly means you would have to take the page, make the change to a small part of it, then reload the entire DOM so the changes can take effect. If say you are watching a YouTube video and there is a new comment, the entire page would reload and your video would have to start afresh.

1『 DOM 的一大弊端，页面改动一点点需要重新渲染整个 DOM。』

Vue tries to solve these challenges by utilizing a virtual DOM to manage the view a user sees. Vue essentially creates a copy of the DOM and stores it. When a change is made to any part of the DOM, it just updates only that section of the DOM without reloading the DOM. This means the comments would update without you even noticing it.

1『 Vue 的基本原理。』

Vue provides reactive and composable view components. Vue responds to events and triggers changes on the DOM instantaneously. Its composable components can be selected and assembled in various combinations to satisfy whatever need arises. You can have components for everything and reuse them however you need.

### 03. Why you should use Vue with Laravel

This is one question that you need to take your time to answer. It is important to understand what Vue has to offer and what that means for your work. We are going to explore a few reasons why you should use Vue with Laravel.

#### 3.1 Everything happens on the frontend

Applications on the internet today are event-driven. They are built to ensure users have a seamless experience like they would if they used an application installed on their computer. Everything now happens on the frontend and users never have to reload a page again (thank you JavaScript).

#### 3.2 Reactive components make for an excellent event-driven app

Vue lets you build a full-scale application that is event-driven and has all activity completely handle on the frontend. It also provides composable components that can be used however you wish. Given that it couples nicely with Laravel, you will only need to make a few trips to request data from your Laravel application and make UI changes by switching components without reloading the page.

1『上面的观点又想到，laravel 就负责做 api？』

You can trigger UI changes that are seamless with your Vue frontend, which in turn gives your users an amazing experience. It could be as simple as making a text on your page editable or swapping out an entire component to load up a video requested by a user without reloading the page. Given Vue’s speed and performance, this happens very fast and smoothly without taking up so much of your computer resources.

#### 3.3 Building optimal complex frontend pages

If you think of building an application with parts that need to update frequently, you have no other choice than to make the frontend run completely on JavaScript. The challenge with vanilla JavaScript or jQuery or other JavaScript libraries that do not have a virtual DOM is that you quickly hit performance issues with the frequency of update increases or the volume of data to track for changes increases significantly. Changes to the DOM will gradually cease to be instantaneous and you begin to experience noticeable performance lags.

When you compose your application with Vue components, each component’s dependencies are automatically tracked during its render, so the system knows precisely which component actually needs to be updated when there is a change in data. This makes all updates to the DOM use minimal resources, thereby improving the overall application efficiency.

Vue is also compatible with state managers like Flux, Redux, and Vuex which are excellent in managing data flow in complex applications. Vue’s utilization of a one-way data binding model also makes state management easier in complex applications.

#### 3.4 Single Page Application

I would like to share a personal opinion – Single Page Applications are the greatest thing to happen to the internet in the last decade. It opens up applications to a wider audience of users than was possible before. When you consider that many internet users outside of some parts of America and Europe have challenges getting on the internet, you begin to appreciate the role single page applications play in delivering a rich web experience to them. Your entire application assets get loaded once (and most of it cached), all that your application does as the user engages with it is request data which typically requires low bandwidth to fulfill.

#### 3.5 Easy to learn and use

Vue is easy to get into. It provides very few options for you as the developer and has a lot abstracted away. You feel like you are writing plain JavaScript when you use Vue and you can make a simple application with plain JavaScript and it remains valid in Vue.

Another great thing about Vue is that your valid HTML is also a valid Vue template. You can keep your CSS external or you can process it with JavaScript depending on your application needs. You can also take advantage of scoped styling, to apply style changes to a single component on the fly without the change affecting other components. If you are familiar with JavaScript, you can build a non-trivial application with Vue after just one day of reading the documentation.

### 04. Basic Vue usage with Laravel

Vue integrates nicely with Laravel. You can create Vue components and use them like you would use regular HTML tags inside your blade file. You can pass props to the component from the output generated when your blade file renders. To try it out, create a new Laravel installation using the Laravel installer:

    $ composer create-project laravel/laravel vueapp --prefer-dist '6.*'

1『

composer create-project laravel/laravel laravel --prefer-dist '6.*'

目前新建项目：

```
Package jakub-onderka/php-console-color is abandoned, you should avoid using it. Use php-parallel-lint/php-console-color instead.
Package jakub-onderka/php-console-highlighter is abandoned, you should avoid using it. Use php-parallel-lint/php-console-highlighter instead.
```

』

Install Vue and other JavaScript libraries your application needs to run:

    $ npm install

1『

这里改用 yarn 安装：

```
yarn install --no-bin-links
yarn add cross-env
```

发现跑 watch 还是失败，最后还是通过 npm 安装解决的：npm install。安装后有 2 个警告：

```
npm WARN sass-loader@8.0.2 requires a peer of node-sass@^4.0.0 but none is installed. You must install peer dependencies yourself.
npm WARN sass-loader@8.0.2 requires a peer of fibers@>= 3.1.0 but none is installed. You must install peer dependencies yourself.
```

手动安装下 2 个包：

```
npm install node-sass
npm install fibers
```

』

Setup your application to reload when you make changes to your js assets:

    $ npm run watch

1『用 npm run watch-poll 命令。』

If you like seeing your changes as you make them, especially since you are learning, then you should definitely run watch to watch the applications. Now, open another terminal instance and start the Laravel application server:

    $ php artisan serve

### 05. Creating your first Vue Component

1『在 resources/js/ 下新建文件夹 components，该文件夹下新建 Welcome.vue 并把原文中的代码复制过去。』

### 06. Using the component in your blade file

We have made our first Vue component (I know, it is that easy). To use it in the welcome.blade.php file, we would need to make Vue aware that it exists and give it a name Vue would label it with. Open the resources/assets/js/app.js file and edit it to the following:

```
require('./bootstrap');

window.Vue = require('vue');

Vue.component('welcome', require('./components/Welcome.vue'));

const app = new Vue({
    el: '#app'
});
```

1『

上面是配置的关键。报错：

```
ERROR in ./resources/js/app.js
Module not found: Error: Can't resolve 'vue' in '/Users/Daglas/laravel/vueapp/resources/js'
 @ ./resources/js/app.js 3:13-27
 @ multi ./resources/js/app.js ./resources/sass/app.scss
```

问题在这个语句：window.Vue = require('vue'); 从哪引入 vue 呢？因为之前 laravel 里没装 vue 框架。vue 官网上找到了答案：NPM，在用 Vue 构建大型应用时推荐使用 NPM 安装。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。

```
# 最新稳定版
$ npm install vue
```

用 npm 装完后，上面 app.js 里的代码就没问题了。

』

Next, use the Vue component inside of your resources/views/welcome.blade.php file:

```html
[...]
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Laravel</title>

[...]
    <body>
        <div id="app">
            <welcome></welcome>
        </div>
        <script type="text/javascript" src="js/app.js"></script>
    </body>
[...]
```

1『

报错：Failed to mount component: template or render function not defined

搜索获得解决方案：[[Vue warn]: Failed to mount component: template or render function not defined. (found in root instance) · Issue #198 · JeffreyWay/laravel-mix](https://github.com/JeffreyWay/laravel-mix/issues/198)

It should be require('./components/Example.vue').default. Since v13, vue-loader exports the component as the default key, which still works the same when using import, but requires the above when using require.

把 app.js 里 vue 的引入语句改为：Vue.component('welcome', require('./components/Welcome.vue').default);

』

Make sure to edit the file accordingly and include the script tag in it so that your Vue component can be visible on the page. If you set your application to watch for changes to your js assets, then you should see that it already built the entire application and would output compiled successfully in XXXms.

### 07. Passing data to the component

Let us assume we want to output the details of the developer of the application, and we cannot know it because only the application can give that detail. We can easily pass the details to the component and have it display it when it renders. Next, we will pass a title to the component and see what it looks like. Open the welcome blade file located at resources/views/welcome.blade.php and add the following:

```html
[...]
<div id="app">
   <welcome :title="'This cool app'"></welcome>
</div>
[...]
```

We just passed data into the component by binding the data to a variable we would receive in the component as a property (prop). Then, open the Welcome.vue file located at resources/assets/js/components/Welcome.vue and add the following to it:

```js
<template>
            [...]
            <div class="title m-b-md">
                {{title}}
            </div>

            [...]
</template>

<script>
    export default {
        props : ['title']
    }
</script>
```

From the above code, you will see we replaced the Welcome to Vue.js on Laravel with {{title}}. This is the way to output the content of a variable in your Vue template, just like with Laravel blade template. In the script section, we received a prop using props : ['title'] and the prop we received is what we displayed.

Next, we will pass the title from our application server. Open the routes/web.php file and edit as follows:

```php
[...]
Route::get('/', function () {
    return view('welcome',
        [
            'title' => "An even cooler way to do the title"
        ]
    );
});
```

Then, edit the welcome.blade.php file as follows:

```html
[...]
<div id="app">
   <welcome :title="'{{$title}}'"></welcome>
</div>
[...]
```

1『注意，绑定 title 变量时不要漏掉单引号。』

We just output the content title from the server and pass it directly to the component. Next, we will add a second page to our application and make a second component. Create a new file resources/assets/js/components/Page.vue and add the following to it:

```html
<template>
    <div class="flex-center position-ref full-height">
        <div class="content">
            <div class="title m-b-md">
                {{title}}
            </div>

            <div class="links">
                <span class="subtitle">Name : {{author.name}}</span><br/>
                <span class="subtitle">Role : {{author.role}}</span><br/>
                <span class="subtitle">Code : {{author.code}}</span><br/>
            </div>
        </div>
    </div>
</template>

<script>
    export default {
        props : ['title', 'author']
    }
</script>
<style scoped>
    html, body {
        background-color: #fff;
        color: #939b9f;
        font-family: 'Raleway', sans-serif;
        font-weight: 100;
        height: 100vh;
        margin: 0;
    }
    .title {
        font-size: 60px;
    }
    .subtitle {
        font-size: 20px;
    }
    .full-height {
        height: 100vh;
    }

    .flex-center {
        align-items: center;
        display: flex;
        justify-content: center;
    }
    .position-ref {
        position: relative;
    }

    .top-right {
        position: absolute;
        right: 10px;
        top: 18px;
    }
    .content {
        text-align: center;
    }
    .m-b-md {
        margin-bottom: 30px;
    }
</style>
```

Like the first page, we received a second prop that is a json object that contains author information. We have rendered the page with the Author information. Let us make Vue aware of the new component we just created. Open resources/assets/js/app.js file and add the following:

```
[...]

Vue.component('welcome', require('./components/Welcome.vue'));
Vue.component('page', require('./components/Page.vue'));

[...]
```

Now, create a new file resources/views/page.blade.php and add the following to it:

```html
<!doctype html>
<html lang="{{ app()->getLocale() }}">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Page</title>

        <link href="https://fonts.googleapis.com/css?family=Raleway:100,600" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="app">
            <page :title="'{{$title}}'" :author="{{$author}}"></page>
        </div>
        <script type="text/javascript" src="js/app.js"></script>
    </body>
</html>
```

Finally, open routes/web.php and add a route for loading the page at the end of the file:

```php
[...]

Route::get('/page', function () {
    return view('page',
        [
            'title' => "Page 2 - A little about the Author",
            'author' => json_encode([
                    "name" => "Fisayo Afolayan",
                    "role" => "Software Enginner",
                    "code" => "Always keeping it clean"
            ])
        ]
    );
});
```

To view our new route, visit http://127.0.0.1:8000/page on your browser.

### 08. Building the entire frontend in Vue

So far, we have looked at one way to use Vue and Laravel. When we started this article, we talked about everything running on the frontend and users not having to reload anything. We are going to see how to build a Single Page App (SPA) a user would only have to load once and fetch everything by making API calls.

1『单页 APP，这个思想好，就最开始构建一次页面，后面所有的更新通过掉 api 的数据来交互。』

### 09. Installing vue router

Vue router is the Vue tool for building navigation on the frontend application. It would allow you navigate an SPA like you would a regular application. To install vue router, run the following command on your terminal:

    $ npm install vue-router

Exit the watch process we initiated earlier using ctrl + c. We would start watching for changes again after vue router is installed.

### 10. Setting up the routes

Now that vue router is installed, we need to define the routes of the application. This will be the guide for switching between the components we have made. Create a new file resources/assets/js/vueapp.js and edit it as follows:

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

import App from './components/App'
import Welcome from './components/Welcome'
import Page from './components/Page'

const router = new VueRouter({
    mode: 'history',
    routes: [
        {
            path: '/home',
            name: 'welcome',
            component: Welcome,
            props: { title: "This is the SPA home" }
        },
        {
            path: '/spa-page',
            name: 'page',
            component: Page,
            props: { 
                title: "This is the SPA Second Page",
                author : {
                    name : "Fisayo Afolayan",
                    role : "Software Engineer",
                    code : "Always keep it clean"
                }
            }
        },    
    ],
})
const app = new Vue({
    el: '#app',
    components: { App },
    router,
});
```

### 11. What sorcery was that?

You are already familiar with what import does in JavaScript and how to do it. In the above code, we have imported everything we want to use for our SPA.

Vue.use(VueRouter) – telling vue to use the router package, so it can access all the functionalities of the router and interpret the route we are about to create.

const router = new VueRouter – defines the routes our application is going to have. Through the application, the routes definitions will not be changed, so we have to make them constant.

mode – this is the mode we want the router to use in managing the navigation of the application. The default mode is hash mode which uses the URL hash to simulate a full URL so that the page won’t be reloaded when the URL changes. The other is history mode, which leverages the history.pushState API to achieve URL navigation without a page reload.

routes – the routes we would like our application to have.

path – the url to access this route.

name – the name we would like to give this route (useful when navigating in-component).

component – the component we want loaded when this route is visited.

props – we are passing props to the component as we mount them.

The last part creates the Vue application and defines the parent component the router will use as it’s entry point. In our case, we used the App component as the parent component.

### 12. Setting up the parent container

We need to create the App component in resources/assets/js/components directory. Add the following to it:

```html
<template>
    <div>
        <nav class="navbar navbar-expand-md navbar-light navbar-laravel">
            <div class="container">
                <ul class="navbar-nav">
                    <router-link :to="{ name: 'welcome' }" class="nav-link">Home</router-link>
                    <router-link :to="{ name: 'page' }" class="nav-link" >Spa-Page</router-link>
                </ul>
            </div>
        </nav>
        <main>
            <router-view></router-view>
        </main>
    </div>
</template>
<script>
    export default {}
</script>
```

Vue will use \<router-view> as the outlet for any component we visit as its URL. The \<router-link> is responsible for navigating between components. If you notice, we are assigning the name we gave the routes to the to attribute of the route.

1『在 components 文件夹下新建文件 App.vue。』

### 13. Mounting our components

We need to do a few things before we can use our SPA. We need to first set the vueapp.js file to be built. We need to also define the blade file our SPA will use as it’s entry point. Finally, we need to define the route that w enable us to access the SPA.

To set vueapp.js to be built, edit the webpack.mix.js file as follows:

```js
[...]

mix.js('resources/assets/js/app.js', 'public/js')
   .js('resources/assets/js/vueapp.js', 'public/js')
   .sass('resources/assets/sass/app.scss', 'public/css');
```

Now, create the file vueapp.blade.php inside the resources/views directory. Edit it as follows:

```html
<!doctype html>
<html lang="{{ app()->getLocale() }}">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">

        <title>Outlet for SPA</title>

        <link href="https://fonts.googleapis.com/css?family=Raleway:100,600" rel="stylesheet" type="text/css">
        <link rel="stylesheet" type="text/css" href="css/app.css">
    </head>
    <body>
        <div id="app">
            <app></app>
        </div>
        <script type="text/javascript" src="js/vueapp.js"></script>
    </body>
</html>
```

Then define the route in routes/web.php file as follows:

```php
[...]
Route::get('/{any}', function(){
        return view('vueapp');
})->where('any', '.*');
```

Now, build the application by running the following command:

    $ npm run prod

Visit the application on http://127.0.0.1:8000/home

1『跑完后，public 文件夹下的 js 文件夹会自动生成 vueapp.js。』

### Conclusion

In this guide we have looked at what Vue.js can do and how it can work with Laravel. We explored some reasons why you should consider using Vue with Laravel. We also looked at how to use Vue with Laravel, including making a single page application that will run on Laravel.

There is a whole lot you can build with Vue and Laravel. Only the surface was scratched in this article to give you an idea of what is obtainable. Vue is very easy to use and works well with Laravel. You should read the documentation to learn of the cool thing you can build with it.

2『 [fisayoafolayan/laravel-vue: This project creates a simple SPA application using Laravel and VueJS.](https://github.com/fisayoafolayan/laravel-vue) 已下载项目源码「2020016laravel-vue」存入「2020017forked」。』

## 20200428JavaScript1-2-and-in-between.md

Brendan Eich, 2005

Inventing toolkits and extension systems on top of JS is cool. I hoped that would happen, because during Netscape 2 and 3 days I was under great pressure to minimize JS-the-language, implement JS-the-DOM, and defer to Java for “real programming” (this was a mistake, but until Netscape hired more than temporary intern or loaner help, around the time Netscape 4 work began, I was the entire “JS team” — so delegating to Java seemed like a good idea at the time). Therefore in minimizing JS-the-language, I added explicit prototype-based delegation, allowing users to supplement built-in methods with their own in the same given single-prototype namespace.

In listening to user feedback, participating in ECMA TG1 (back during Edition 1 days, and again recently for E4X and the revived Edition 4 work), and all the while watching how the several major “JS” implementors have maintained and evolved their implementations, I’ve come to some conclusions about what JS does and does not need.

1『关键知识来了，EC 总结了 JS 需要进化的内容以及不需要做的。』

1. JS is not going away, so it ought to evolve. As with sharks (and relationships, see Annie Hall), a programming language is either moving forward, or it’s dead. Now dead languages (natural and programming) have their uses; fixed denotation and grammar, and in general a lack of “versionitis”, are virtues. You could argue that JS’s stagnation, along with HTML’s, was beneficial for the “Web 1.0” build-out of the last decade. But given all the ferment on the web today, in XUL and its stepchildren, and with user scripting, there should be a JS2, and even a JS1.6 on the way toward JS2.

2. JS does not need to become Java, or C#, or any other language. 

3. JS does need some of its sharp corners rounded safely. See the table below for details.

4. Beyond fixing what was broken in JS1, JS should evolve to solve problems that users face today in the domains where JS lives: web page and application content (including Flash), server-side scripting (whether Rhino or .NET), VXML and similar embeddings, and games.

5. For example, it should be trivial in a future version of JS to produce or consume a “package” of useful script that presents a consistent interface to consumers, even as its implementation details and new interfaces evolve to better meet existing requirements, and to meet entirely new requirements. In no case should internal methods or properties be exposed by default.

6. It’s clear to me that some users want obfuscated source code, but I am not in favor of standardizing an obfuscator. Mozilla products could support the IE obfuscator, if someone wants to fix bug 125525. A standard obfuscator is that much less obscure, besides being unlikely to be adopted by those who have already invented their own (who appear to be the only users truly motivated by a need for obfuscation at this point).
A more intuitive numeric type or type tower would help many users, although to be effective it would have to be enabled via a new compile-time option of some sort. Numeric type improvements, together with Edition 4’s extensible operator and unit proposals, would address many user requests for enhancement I’ve heard over the years.

7. Too much JS, in almost every embedding I’ve seen, suffers from an execution model that appears single-threaded (which is good for most users) yet lacks coroutining or more specific forms of it such as generators (Boo has particularly nice forms, building on Python with a cleanup or two). So users end up writing lots of creepy callbacks, setTimeout chains, and explicit control block state machines, instead of simply writing loops and similar constructs that can deliver results one by one, suspending after each delivery until called again.

That’s my “do and don’t” list for any future JS, and I will say more, with more specifics, about what to add to the language. What to fix is easier to identify, provided we can fix compatibly without making a mess of old and new.

Here are the three most-duplicated bug reports against core language design elements tracked by Mozilla’s bugzilla installation:

I argue that we ought to fix these, in backward-compatible fashion if possible, in a new Edition of ECMA-262. If we solve other real problems that have not racked up duplicate bug counts, but fail to fix these usability flaws, we have failed to listen to JS users. Let’s consider these one by one:

1. Unlike object and array initialisers, and E4X’s XML literals, regular expression literals correspond one-for-one with objects created during parsing. While this is often optimal and even useful, when combined with the g (global) flag and the lastIndex property, these singleton literals make for a pigeon-hole problem, and a gratuitous inconsistency with other kinds of “literals”. To fix this compatibly, we could add a new flag, although it would be good to pick a letter not used by Perl (or Perl 6, which fearlessly revamps Perl’s regular expression sub-language in ways that ECMA-262 will likely not follow).

2. The Date.prototype.getYear method is a botch and a blight, the only Y2K bug in Mozilla-based browsers that still ships for compatibility with too many web sites. This bug came directly from java.util.Date, which was deprecated long ago. I’d like to get rid of it, but in the mean time, perhaps we should throw in the towel and emulate IE’s non-ECMA behavior (ECMA-262 did standardize getYear in a non-normative annex).
The solution here is a new default number type, with arbitrary precision and something equivalent to decimal radix. Mike Cowlishaw has advocated and implemented his own flavor of decimal arithmetic, but it is not popular in ECMA TG1. Still, I bet we could make life better for many JS users with some innovation here.

There are other bugs in JS1 to fix, particularly to do with Unicode in regular expressions, and even in source text (see the infamous ZWNJ and ZWJ should not be ignored bug). More on these too, shortly, but in a wiki, linked with informal discussion here.

## 20200501How-to-Use-JSON-Data-with-PHP-or-JavaScript.md

As you can see, it's a human readable format of data that might traditionally be stored in a table. Some companies might have public .json files located that you can access and extract data from (an API you can connect to). You might also save a .json file somewhere in your project that you want to extract data from.JSON data can be accessed and utilized with many programming languages. In this tutorial, we'll learn how to access JSON with PHP and JavaScript.

### 01. What is JSON?

JSON stands for JavaScript Object Notation. It is data saved in a .json file, and consists of a series of key/value pairs.

```js
{ "key": "value" }
```

The value of any JSON key can be a string, Boolean, number, null, array, or object. Comments are not allowed in JSON. Although JSON resembles an object or an array, JSON is a string. A serialized string, which means it can later be parsed and decoded into data types.

### 02. Using data from JSON with PHP

First, to drill in that JSON is simply a string, we're going to write JSON into a PHP string and apply it to a variable called \$data.

```php
$data = '{
	"name": "Aragorn",
	"race": "Human"
}';
```

Then we'll use the json\_decode() function to convert the JSON string into a PHP object.

```php
$character = json_decode($data);
```

Now we can access it as a PHP object.

```php
echo $character->name;
```

Here's the whole file.

```php
<?php

$data = '{
	"name": "Aragorn",
	"race": "Human"
}';

$character = json_decode($data);
echo $character->name;
```

Here is the output.

    Aragorn

### 03. Accessing a JSON feed from a URL

From here out, we'll put all JSON data into its own .json file. This way, we can retrieve the contents of the file instead of keeping it as a PHP string. Here's what data.json will look like.

```json
[{
	"name": "Aragorn",
	"race": "Human"
}, {
	"name": "Legolas",
	"race": "Elf"
}, {
	"name": "Gimli",
	"race": "Dwarf"
}]
```

And here's how we'll extract that data in PHP.

```php
$url = 'data.json'; // path to your JSON file
$data = file_get_contents($url); // put the contents of the file into a variable
$characters = json_decode($data); // decode the JSON feed
```

In order to get one entry, we'll have to access the appropriate array number. Remember, counting begins with 0 in programming.

```php
echo $characters[0]->name;
```

    Aragorn

I can access all the data in the array with a foreach loop.

```php
foreach ($characters as $character) {
	echo $character->name . '<br>';
}
```

Here is the full PHP file.

```php
<?php

$url = 'data.json'; // path to your JSON file
$data = file_get_contents($url); // put the contents of the file into a variable
$characters = json_decode($data); // decode the JSON feed

echo $characters[0]->name;

foreach ($characters as $character) {
	echo $character->name . '<br>';
}
```

We can display the data in a table, for an example.

```html
<table>
	<tbody>
		<tr>
			<th>Name</th>
			<th>Race</th>
		</tr>
		<?php foreach ($characters as $character) : ?>
        <tr>
            <td> <?php echo $character->name; ?> </td>
            <td> <?php echo $character->race; ?> </td>
        </tr>
		<?php endforeach; ?>
	</tbody>
</table>
```

1『可以直接用 vue 实现。』

In this example, I'm using the alternate syntax for foreach, which looks like foreach() : /* loop \*/ endforeach; instead of foreach() { /* loop */ }. This is often preferable when outputting HTML.

### 04. Using associative arrays

There's another way we can access the data in PHP. If you pass true as the argument in json\_decode(), the data becomes an associative array instead of an object. This means we'll be using square bracket notation[] instead of the skinny arrow ->.

```php
$characters = json_decode($data, true); // decode the JSON feed and make an associative array
```

Instead of ->race, we will access the value with ['race'].

```php
echo $characters[0]['race'];
```

And here's how to access the loop.

```php
foreach ($characters as $character) {
	echo $character['race'] . "\n";
}
```

### 05. Getting data from nested arrays

So far, we've only used JSON feeds with key/value pairs, but it's common to encounter nesting. Here's another nerdy example, which we can save in a new file called wizards.json.

```json
[
	{
		"name": "Harry Potter",
		"wand": [
			{
"core": "phoenix feather",
"length": "11 inches",
"wood": "holly"
			}
		]
	},
	{
		"name": "Hermione Granger",
		"wand": [
			{
"core": "dragon heartstring",
"length": "10 and 3/4 inches",
"wood": "vine"
			}
		]
	}
]
```

Decoding the feed.

```php
$url = 'wizards.json';
$data = file_get_contents($url);
$wizards = json_decode($data, true);
```

We'll be able to access the nested array using \$wizard['key'][0]['key'] in a loop, or whatever number corresponds correctly if you only want to print one.

```php
foreach ($wizards as $wizard) {
	echo $wizard['name'] . '\'s wand is ' .
	$wizard['wand'][0]['wood'] . ', ' .
	$wizard['wand'][0]['length'] . ', with a ' .
	$wizard['wand'][0]['core'] . ' core. <br>' ;
}
```

```
Harry Potter's wand is holly, 11 inches, with a phoenix feather core.
    Hermione Granger's wand is vine, 10 and 3/4 inches, with a dragon heartstring core.
```

### 06. Converting a PHP object or array into JSON

Just as you use json_decode() to turn JSON into PHP, you can turn PHP into JSON with json_encode().

```php
$data = [
	'name' => 'Aragorn',
	'race' => 'Human'
];

echo json_encode($data);
```

We made a PHP array and encoded it. Here's the output:

```json
{"name":"Aragorn","race":"Human"}
```

### 07. Using data from JSON with JavaScript

We're going to create a JavaScript variable called data and apply the JSON string.

```js
var data = '[ { "name": "Aragorn", "race": "Human" }, { "name": "Gimli", "race": "Dwarf" } ]'
```

Now we'll use JavaScript built in JSON.parse() function to decode the string.

```js
data = JSON.parse(data);
```

From here we can access the data like a regular JavaScript object.

```js
console.log(data[1].name)
```

    Gimli

And we can loop through each iteration with a for loop.

```js
for (var i = 0; i < data.length; i++) {
  console.log(data[i].name + ' is a ' + data[i].race + '.')
}
```

That was easy! Now, we'll probably need to access JSON from a URL. There's an extra step involved, where we have to make a request to the file. Let's just take the above JSON string and put it in data.json.

```js
;[
  {
    name: 'Aragorn',
    race: 'Human',
  },
  {
    name: 'Gimli',
    race: 'Dwarf',
  },
]
```

Now we'll make an XMLHttpRequest().

```js
var request = new XMLHttpRequest()
```

We'll open the file (data.json) via GET (URL) request.

```js
request.open('GET', 'data.json', true)
```

From here, we'll parse and work with all our JSON data within the onload function.

```js
request.onload = function() {
  // begin accessing JSON data here
}
```

Then finally, submit the request.

```js
request.send()
```

Here's the final code.

```js
var request = new XMLHttpRequest()

request.open('GET', 'data.json', true)

request.onload = function() {
  // begin accessing JSON data here
  var data = JSON.parse(this.response)

  for (var i = 0; i < data.length; i++) {
    console.log(data[i].name + ' is a ' + data[i].race + '.')
  }
}

request.send()
```

And the output.

```
Aragorn is a Human.
Gimli is a Dwarf.
```

#### 7.1 Using Fetch

Now you can also use the Fetch API to do the same thing. Read How to use the JavaScript Fetch API to Get JSON Data for an easier method to get this data.

```js
// Replace ./data.json with your JSON feed
fetch('./data.json')
  .then(response => {
    return response.json()
  })
  .then(data => {
    // Work with JSON data here
    console.log(data)
  })
  .catch(err => {
    // Do something for an error here
  })
```

#### 7.2 Using jQuery

As you can see, it's not too difficult to retrieve a JSON feed with plain JavaScript. However, it's even easier with jQuery, using the getJSON() function. If you don't know how jQuery works, you'll need to load the jQuery JavaScript library before any of this custom code.

```js
$(document).ready(function() {
  $.getJSON('data.json', function(data) {
    // begin accessing JSON data here
    console.log(data[0].name)
  })
})
```

You might also see jQuery access JSON via an AJAX request, which is a little more verbose.

```js
$(document).ready(function() {
  var data
  $.ajax({
    dataType: 'json',
    url: 'data.json',
    data: data,
    success: function(data) {
      // begin accessing JSON data here
      console.log(data[0].name)
    },
  })
})
```

Both will have the same output.

```
Aragorn
Conclusion
```

Hopefully this article has taught you a bit about what JSON is and does, and how to access JSON data with PHP, JavaScript, or jQuery.

## 20200511css长度单位解析.md

### 01. 掌握 web 开发基础长度单位

[掌握 web 开发基础系列 -- 长度单位 - 掘金](https://juejin.im/post/5cceb946e51d453afb40d820)

css 中的长度单位有哪些？px, pt，em，rem，%，vw，vh，vmin，vmcx，ex，ch，cm，mm，in(inch)，pc ···

我们常用的其实就是 px，em，rem，% 四种，下文中我们将对常用的长度单位重点分析，对非常用的长度单位简单介绍。首先我们要知道 css 中的长度单位可以分为两类：相对长度单位和绝对长度单位 。

#### 1.1 相对长度单位

css 相对长度单位中的「相对」二字，表明了其长度会随着它的参考值的变化而变化，不是固定的。所以，在使用相对长度单位之前一定要知道其「参考元素」是什么。

1、px (pixel)。1px 到底有多长？关于 px 的相关信息 《[CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport](https://www.cnblogs.com/zaoa/p/8630393.html)》 这篇文章中已经介绍的很详细很详细。下面对 px 进行概括总结。

浏览器内的一切长度都是以 CSS 像素为单位的，CSS 像素的单位是 px，px 是一个相对单位，相对的是设备像素 (device pixel)，也就是物理像素，其相对性体现在在同一个设备上或在不同设备之间每 1 个 px 所代表的物理像素是可以变化的。

那么 px 到底是什么？px 实际是 pixel（像素）的缩写，根据维基百科的解释，它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚它的上下文！一定要清楚它的上下文！一定要清楚它的上下文！不同的设备，图像基本采样单元是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为 ppi 和 dpi：1）ppi：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。2）dpi：每英寸多少点。

关于打印机的点距我们不去关心，只要知道当用于描述显示器设备时 ppi 与 dpi 是同一个概念 。

CSS 像素的真正含义。由于不同的物理设备的物理像素的大小是不一样的，所以 css 认为浏览器应该对 css 中的像素进行调节，使得浏览器中 1css 像素的大小在不同物理设备上看上去大小总是差不多 ，目的是为了保证阅读体验一致。为了达到这一点浏览器可以直接按照设备的物理像素大小进行换算，而 css 规范中使用「参考像素」来进行换算。

1 参考像素即为从一臂之遥看，解析度为 96DPI 的设备输出（即 1 英寸 96 点）时，1 点（即 1/96 英寸）的视角。它并不是 1/96 英寸长度，而是从一臂之遥的距离处看解析度为 96DPI 的设备输出一单位（即 1/96 英寸）时视线与水平线的夹角。通常认为常人臂长为 28 英寸，所以它的视角是: (1/96) in / (28in \* 2 \* PI / 360deg) = 0.0213 度。

由于 css 像素是一个视角单位，所以在真正实现时，为了方便基本都是根据设备像素换算的。浏览器根据硬件设备能够直接获取 css 像素。这个换算过程有些烧脑，感兴趣的同学自己去研究 css 规范。下面两个不同设备物理像素转换为 css 像素的对比。

14 英寸 MacBook PRO，屏幕（设备）分辨率为 2560dp x 1600dp，浏览器最大宽度（css 像素）为 1440px

13.3 英寸 HP 440 G5，屏幕（设备）分辨率为 1366dp x 768dp，浏览器最大宽度（css 像素）为 1366px。

2、em。em 用来适应用户所使用的字体，1em 相当于当前的字体尺寸（font-size 属性），2em 相对于当前字体尺寸的 2 倍。1）如果当前元素的父元素设置了 font-size，则 em 参考元素为其父元素。2）如果当前元素的父元素没有设置 font-size，则逐级向上查找有设置 font-size 属性的元素，直到 \<html> 根元素。3）如果当前元素的父元素向上所有父元素均没有设置 font-size，则 em 其参考大小为浏览器默认大小 16px。

妙招：段落首行缩进两个汉字

```css
.indent {
    text-indent: 2em;
}
```

3、rem。rem 即 root em，其参考元素为文档的根元素 \<html> 中 font-size 属性。1）如果文档根元素 \<html> 没有设置 font-size 属性，那么当前元素 rem 相对于浏览器默认字体大小 16px。2）如果文档根元素 \<html style="font-size: 20px"> 设置了 font-size 属性，那么当前元素 rem 相对于文档的根元素 \<html>。

em，rem 不仅仅是用于控制当前字体的大小，可以应用于各自可以设置长度的属性上，width、height···

4、百分比 - %。在做页面布局时需要知道的几个点：1）块级元素默认宽度 width 是 100%，默认高度 height 是 0。2）块级元素的默认宽度 100% 是相对其父元素的宽度，父元素的宽度相对更上一级元素的宽度。

思考：为什么块级元素默认高度 height 是 0 而不是 100%？浏览器是如何计算高度与宽度的？

Web 浏览器在计算有效宽度时会考虑浏览器窗口的打开宽度。如果你不给宽度设定任何缺省值，那浏览器会自动将页面内容平铺填满整个横向宽度。即我们不设置宽，会自动填满整个横向宽度。高度的计算方式完全不一样。事实上，浏览器根本就不计算内容的高度，除非内容超出了视窗范围（导致滚动条出现）。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。更多相关内容请阅读 《[为啥你的 height:100% 不起作用？](https://blog.csdn.net/yanchenxi313761/article/details/79437541)》

5、vw、vh。vh vw 全称为 Viewport Height 和 Viewport Width 意思就是视窗，vh、vw 是相对于视口的高度和宽度。1vh 等于 1/100 的视口高度，1vw 等于 1/100 的视口宽度。例如：浏览器高度 900px，宽度为 750px, 1vh = 9px，1vw = 7.5 px。设置一个和屏幕同宽的标题，h1 {font-size:100vw}，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和 viewport 大小同步的效果。

6、vmin、vmcx。vmin：vw 和 vh 中较小的那个。vmax：vw 和 vh 中较大的那个。例如，如果浏览器设置为 1100px 宽、700px 高，1vmin 会是 7px，1vmax 为 11px。然而，如果宽度设置为 800px，高度设置为 1080px，1vmin 将会等于 8px 而 1vmax 将会是 10.8px。

7、ex。当前字体的 x-height（当前字体小写 x 的高度），在无法确定 x 高度的情况下以 0.5em 计算。

8、ch。数字 0 的宽度，无法确定时为 0.5em。

#### 1.2 绝对长度单位

绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。绝对长度单位视输出介质而定，不依赖于环境（显示器、分辨率、操作系统等）。注：在日常 web 开发中绝对长度单位的使用场景着实太少，简单了解即可。1）cm，厘米。2）mm，毫米。3）in（Inch），英寸。4）pt（Point），点，确切的说法是一个专用的印刷单位「磅」，大小为 1/72 英寸。用于印刷业。5）pc（Pica），派卡，相当于我国新四号铅字的尺寸。

## 20200512浅谈前后端路由与前后端渲染.md

### 01. 浅谈前后端路由与前后端渲染

[浅谈前后端路由与前后端渲染 - 掘金](https://juejin.im/post/5abae9acf265da2378404fc8)

[Molunerfinn 的个人主页 - 专栏 - 掘金](https://juejin.im/user/56610b1400b0d1dba2813a98/posts)

[搭建一个 vue-cli4+webpack 移动端框架 - 掘金](https://juejin.im/post/5eb766296fb9a0432f0ff8c7#heading-16)

最近经常会遇到有人问诸如类似下面的问题：为啥我写的 Vue 应用在开发阶段都没问题，部署到服务端之后访问不了除了 / 的页面呢？为啥我写的 SPA 页面的路由用 hash 模式都没问题，改成 history 模式就问题百出呢？啥是前端路由啥是后端路由，要怎么配后端才能支持我的前端路由呢？

#### 1.1 什么是路由

「[理解 Web 路由](https://zhuanlan.zhihu.com/p/24814675)」这篇文章讲得特别好了。

在 Web 开发过程中，经常会遇到「路由」的概念。那么，到底什么是路由？简单来说，路由就是 URL 到函数的映射。访问的 URL 会映射到相应的函数里（这个函数是广义的，可以是前端的函数也可以是后端的函数），然后由相应的函数来决定返回给这个 URL 什么东西。路由就是在做一个匹配的工作。

#### 1.2 从后端路由讲起

在 web 开发早期的「刀耕火种」年代里，一直是后端路由占据主导地位。不管是 php，还是 jsp、asp，用户能通过 URL 访问到的页面，大多是通过后端路由匹配之后再返回给浏览器的。经典面试题，「你从浏览器地址栏里输入 www.baidu.com 到你看到网页这个过程中经历了什么」其实讲的也是这个道理。

在 web 后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的 URL 地址，以及一些表单提交、ajax 请求的地址。通常遇到无法匹配的路由，后端将会返回一个 404 状态码。这也是我们常说的 404 NOT FOUND 的由来。

#### 1.2.1 URL 与 Methods

如果你关注 RESTful API，那么将会很熟悉下面四种发起请求的类型：GET，POST，PUT，DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。—— 来自阮一峰《[理解 RESTful 架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)》

虽然上面说的是 RESTful API，但是实际上我们在地址栏输入一个 URL，并回车的时候，是以 GET 请求发出去的。这也体现了，URL 地址和请求的 method 也应该是一一对应。下面给出一个例子：

```php
router.post('/user/:id', addUser)
```

假如我的后端路由配置里只有这一句路由。那么我通过浏览器里访问：http://xxx.com/user/123 的话是无法访问到的，也会返回一个 404。因为后端只配了一个 post 方法的路由。如果要接受这个请求，那么必须有如下的路由：

```php
router.get ('/user/:id', getUser) // 配置 get 路由
router.post('/user/:id', addUser)
```

#### 1.2.2. 后端路由与服务端渲染

前面说了，「刀耕火种」的年代里，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的 html 一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是通过预先写在页面里的 jQuery、Bootstrap 等常见的前端框架去负责的。

如果你说有些网站已经是通过 ajax 去实现的页面，比如 gmail，比如 qq 邮箱。那么你要注意到哪怕是这些页面，它们页面的「龙骨」也并非是全部通过 ajax 去实现的，依然还是后端直出 —— 这也就是我们现在又老生常谈的服务端渲染。

服务端渲染的好处有很多，比如对于 SEO 友好，一些对安全性要求高的页面采用服务端渲染是更保险的。而在当时还没有 node.js 的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。比如 Laravel 的 blade，用在 Django 上的 jinja2，用在 Struts 的 jsp 等等。实际上到如今，一门后端语言想要能实现自己的 web 功能，都需要有自己对应的模板引擎。node.js 诞生之后，前端拥有自己的后端渲染的模板引擎也成为了现实。常见的比如 pug、ejs、nunjucks 等。这些模板引擎搭配 Express、Koa 等后端框架也在一开始风靡一时。

不过在这个过程中，随着 web 应用的开发越来越复杂，单纯服务端渲染的问题开始慢慢的暴露出来了 —— 耦合性太强了，jQuery 时代的页面不好维护，页面切换白屏严重等等。耦合性问题虽然能通过良好的代码结构、规范来解决，不过 jQuery 时代的页面不好维护这是有目共睹的，全局变量满天飞，代码入侵性太高。后续的维护通常是在给前面的代码打补丁。而页面切换的白屏问题虽然可以通过 ajax、或者 iframe 等来解决，但是在实现上就麻烦了 —— 进一步增加了可维护的难度。于是，我们开始进入了前端路由的时代。

#### 1.3 过渡到前端路由

前端路由 —— 顾名思义，页面跳转的 URL 规则匹配由前端来控制。而前端路由主要是有两种显示方式：1）带有 hash 的前端路由，优点是兼容性高。缺点是 URL 带有 # 号不好看。2）不带 hash 的前端路由，优点是 URL 不带 #号，好看。缺点是既需要浏览器支持也需要后端服务器支持。

前端路由应用最广泛的例子就是当今的 SPA 的 web 项目。不管是 Vue、React 还是 Angular 的页面工程，都离不开相应配套的 router 工具。前端路由带来的最明显的好处就是，地址栏 URL 的跳转不会白屏了 —— 这也得益于前端渲染带来的好处。

#### 1.3.1 前端路由与前端渲染

讲前端路由就不能不说前端渲染。我以 Vue 项目为例。如果你是用官方的 vue-cli 搭配 webpack 模板构建的项目，你有没有想过你的浏览器拿到的 html 是什么样的？是你页面长的那样有 button 有 form 的样子么？我想不是的。在生产模式下，你看看构建出来的 index.html 长什么样：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vue</title>
</head>
<body>
  <div id="app"></div>
  <script type="text/javascript" src="xxxx.xxx.js"></script>
  <script type="text/javascript" src="yyyy.yyy.js"></script>
  <script type="text/javascript" src="zzzz.zzz.js"></script>
</body>
</html>

```

通常长上面这个样子。可以看到，这个其实就是你的浏览器从服务端拿到的 html。这里面空荡荡的只有一个 \<div id="app"></div> 这个入口的 div 以及下面配套的一系列 js 文件。所以你看到的页面其实是通过那些 js 渲染出来的。这也是我们常说的前端渲染。

前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合前端路由，无缝的页面切换体验自然是对用户友好的。不过带来的坏处就是对 SEO 不友好，毕竟搜索引擎的爬虫只能爬到上面那样的 html，对浏览器的版本也会有相应的要求。

需要明确的是，只要在浏览器地址栏输入 URL 再回车，是一定会去后端服务器请求一次的。而如果是在页面里通过点击按钮等操作，利用 router 库的 api 来进行的 URL 更新是不会去后端服务器请求的。

#### 1.3.2 Hash 模式

hash 模式利用的是浏览器不会对 # 号后面的路径对服务端发起路由请求。也即在浏览器里输入如下这两个地址：http://localhost/#/user/1 和 http://localhost/ 其实到服务端都是去请求 http://localhost 这个页面的内容。

而前端的 router 库通过捕捉 # 号后面的参数、地址，来告诉前端库（比如 Vue）渲染对应的页面。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过 router 的 api 进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回 http://localhost 对应的 html，剩下具体是哪个页面，就由前端路由去判断便可。

#### 1.3.3 History 模式

不带 # 号的路由，也就是我们通常能见到的 URL 形式。router 库要实现这个功能一般都是通过 HTML5 提供的 history 这个 api。比如 history.pushState() 可以向浏览器地址栏 push 一个 URL，而这个 URL 是不会向后端发起请求的！通过这个特性，便能很方便地实现漂亮的 URL。不过需要注意的是，这个 api 对于 IE9 及其以下版本浏览器是不支持的，IE10 开始支持，所以对于浏览器版本是有要求的。vue-router 会检测浏览器版本，当无法启用 history 模式的时候会自动降级为 hash 模式。

上面说了，你在页面里的跳转，通常是通过 router 的 api 去进行的跳转，router 的 api 调用的通常是 history.pushState() 这个 api，所以跟后端没什么关系。但是一旦你从浏览器地址栏里输入一个地址，比如 http://localhost/user/1, 这个 URL 是会向后端发起一个 get 请求的。后端路由表里如果没有配置相应的路由，那么自然就会返回一个 404 了！这也就是很多朋友在生产模式遇到 404 页面的原因。

那么很多人会问了，那为什么我在开发模式下没问题呢？那是因为 vue-cli 在开发模式下帮你启动的那个 express 开发服务器帮你做了这方面的配置。理论上在开发模式下本来也是需要配置服务端的，只不过 vue-cli 都帮你配置好了，所以你就不用手动配置了。

那么该如何配置呢？其实在生产模式下配置也很简单，参考 vue-router 给出的配置例子「[HTML5 History 模式 | Vue Router](https://router.vuejs.org/zh/guide/essentials/history-mode.html)」。一个原则就是，在所有后端路由规则的最后，配置一个规则，如果前面其他路由规则都不匹配的情况下，就执行这个规则 —— 把构建好的那个 index.html 返回给前端。这样就解决了后端路由抛出的 404 的问题了，因为只要你输入了 http://localhost/user/1 这地址，那么由于后端其他路由都不匹配，那么就会返回给浏览器 index.html。

浏览器拿到这个 html 之后，router 库就开始工作，开始获取地址栏的 URL 信息，然后再告诉前端库（比如 Vue）渲染对应的页面。到这一步就跟 hash 模式是类似的了。当然，由于后端无法抛出 404 的页面错误，404 的 URL 规则自然是交给前端路由来决定了。你可以自己在前端路由里决定什么 URL 都不匹配的 404 页面应该显示什么。

#### 1.4 前端路由与服务端渲染

虽然前端渲染有诸多好处，不过 SEO 的问题，还是比较突出的。所以 react、vue 等框架在后来也在服务端渲染上做着自己的努力。基于前端库的服务端渲染跟以前基于后端语言的服务端渲染又有所不同。前端框架的服务端渲染大多依然采用的是前端路由，并且由于引入了状态统一、vnode 等等概念，它们的服务端渲染对服务器的性能要求比 php 等语言基于的字符串填充的模板引擎渲染对于服务器的性能要求高得多。所以在这方面不仅是框架本身在不断改进算法、优化，服务端的性能也必须要有所提升。当初掘金换成 SSR 的时候也遇到了对应的性能问题，就是这个原因。

当然在二者之间，也出现了预渲染的概念。也即先在服务端构建出一部分静态的 html 文件，用于直出浏览器。然后剩下的页面再通过常用的前端渲染来实现。通常我们可以把首页采用预渲染的方式。这个的好处是明显的，兼顾了 SEO 和服务器的性能要求。不过它无法做到全站 SEO，生产构建阶段耗时也会有所提高，这也是遗憾所在。关于预渲染，可以考虑使用[prerender-spa-plugin: Prerenders static HTML in a single-page application.](https://github.com/chrisvfritz/prerender-spa-plugin)这个 webapck 的插件，它的 3.x 版本开始使用 puppeteer 来构建 html 文件了。

#### 1.5 前后端分离

得益于前端路由和现代前端框架的完整的前后端渲染能力，跟页面渲染、组织、组件相关的东西，后端终于可以不用再参与了。前后端分离的开发模式也逐渐开始普及。前端开始更加注重页面开发的工程化、自动化，而后端则更专注于 api 的提供和数据库的保障。代码层面上耦合度也进一步降低，分工也更加明确。我们也摆脱了当初「刀耕火种」的 web 开发年代。

总结：希望通过此文能够让你对于前后端路由和前后端渲染有所了解。在实际开发的过程中，也不应该仅仅关注于自己所在的领域，相关的领域也要有所涉猎，这样才能面对问题游刃有余。

3『单页应用的话是前后端分离的，所以数据都是通过 ajax 传递的。』

### 02. 理解 Web 路由

编辑于 2017-01-13

[理解 Web 路由](https://zhuanlan.zhihu.com/p/24814675)

#### 2.1 router 和 route 的区别

route 就是一条路由，它将一个 URL 路径和一个函数进行映射，例如：

```php
/users        ->  getAllUsers()
/users/count  ->  getUsersCount()
```

这就是两条路由，当访问 /users 的时候，会执行 getAllUsers () 函数；当访问 /users/count 的时候，会执行 getUsersCount () 函数。而 router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了 URL 和函数的映射，而在当接收到一个 URL 之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。一句话概括就是「The router routes you to a route」。

#### 2.2 服务器端路由

对于服务器来说，当接收到客户端发来的 HTTP 请求，会根据请求的 URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有 URL 的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。以 Express 为例，

```php
app.get('/', (req, res) => {
  res.sendFile('index')
})

app.get('/users', (req, res) => {
  db.queryAllUsers()
    .then(data => res.send(data))
})
```

这里定义了两条路由：1）当访问 / 的时候，会返回 index 页面。2）当访问 /users 的时候，会从数据库中取出所有用户数据并返回。

不仅仅是 URL。在 router 匹配 route 的过程中，不仅会根据 URL 来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过 POST 方法来访问 /users，就会找不到正确的路由。

1『所以在 laravel 里优先使用 router。』

#### 2.3 客户端路由

对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些 DOM 的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：1）基于 Hash、2）基于 History API。

1、基于 Hash。我们知道，URL 中 # 及其后面的部分为 hash。例如：

```js
const url = require('url')
var a = url.parse('http://example.com/#/foo/bar')
console.log(a.hash)
// => #/foo/bar
```

hash 仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash 部分并不会发过去。通过监听 window 对象的 hashChange 事件，可以实现简单的路由。例如：

```js
window.onhashchange = function() {
  var hash = window.location.hash
  var path = hash.substring(1)

  switch (path) {
    case '/':
      showHome()
      break
    case '/users':
      showUsersList()
      break
    default:
      show404NotFound()
  }
}
```

2、基于 History API。通过 HTML5 History API 可以在不刷新页面的情况下，直接改变当前 URL。详细用法可以参考：

[Using the HTML5 History API | CSS-Tricks](https://css-tricks.com/using-the-html5-history-api/)

[History API - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/History_API)

我们可以通过监听 window 对象的 popstate 事件，来实现简单的路由：

```js
window.onpopstate = function() {
  var path = window.location.pathname

  switch (path) {
    case '/':
      showHome()
      break
    case '/users':
      showUsersList()
      break
    default:
      show404NotFound()
  }
}
```

但是这种方法只能捕获前进或后退事件，无法捕获 pushState 和 replaceState，一种最简单的解决方法是替换 pushState 方法，例如：

```js
var pushState = history.pushState
history.pushState = function() {
  pushState.apply(history, arguments)

  // emit a event or just run a callback
  emitEventOrRunCallback()
}
```

不过，最好的方法还是使用实现好的 history 库。

3、两种实现的比较。总的来说，基于 Hash 的路由，兼容性更好；基于 History API 的路由，更加直观和正式。但是，有一点很大的区别是，基于 Hash 的路由不需要对服务器做改动，基于 History API 的路由需要对服务器做一些改造。下面来详细分析。假设服务器只有如下文件（script.js 被 index.html 所引用）：

```
/-
 |- index.html
 |- script.js
```

基于 Hash 的路径有：

```
http://example.com/
http://example.com/#/foobar
```

基于 History API 的路径有：

```
http://example.com/
http://example.com/foobar
```

当直接访问 / 的时候，两者的行为是一致的，都是返回了 index.html 文件。当从 / 跳转到 /#/foobar 或者 /foobar 的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。

当直接访问 /#/foobar 的时候，实际上向服务器发起的请求是 /，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。

当直接访问 /foobar 的时候，实际上向服务器发起的请求也是 /foobar，然而服务器端只能匹配 / 而无法匹配 /foobar，因此会出现 404 错误。

因此如果使用了基于 History API 的路由，需要改造服务器端，使得访问 /foobar 的时候也能返回 index.html 文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。

#### 2.4 动态路由

上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户 id）来实现。

例如在 Express 中：

```php
app.get('/user/:id', (req, res, next) => {
  // ... ...
})
```

在 Flask 中：

```php
@app.route('/user/<user_id>')
def get_user_info(user_id):
    pass
```

#### 2.5 严格路由

在很多情况下，会遇到 /foobar 和 /foobar/ 的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。在 Flask 的文档 中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问 /foobar 的时候，可能会重定向到 /foobar/，而反过来则不会。如果使用的是 Express，默认这两者是一样的，也可以通过 app.set 来设置 strict routing，来区别对待这两种情况。

### 03. 理解 RESTful 架构

作者： 阮一峰；日期： 2011 年 9 月 12 日

[理解RESTful架构 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2011/09/restful.html)

越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种「互联网软件」采用客户端 / 服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。

网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。

RESTful 架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。但是，到底什么是 RESTful 架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的 RESTful 架构。

#### 3.1 起源

REST 这个词，是 Roy Thomas Fielding 在他 2000 年的博士论文中提出的。Fielding 是一个非常重要的人，他是 HTTP 协议（1.0 版和 1.1 版）的主要设计者、Apache 服务器软件的作者之一、Apache 基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。

他这样介绍论文的写作目的：

本文研究计算机科学两大前沿 —— 软件和网络 —— 的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。

This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. 

2『论文「2020015Architectural Styles and the Design of Network-based Software Architectures」已存入 zotero，发现其按书籍排版的，故存入书籍「2020129Architectural-Styles-and-the-Design-」，按书籍消化吸收。在线版：[Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)。』

#### 3.2 名称

Fielding 将他对互联网软件的架构原则，定名为 REST，即 Representational State Transfer 的缩写。我对这个词组的翻译是「表现层状态转化」。如果一个架构符合 REST 原则，就称它为 RESTful 架构。

要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会 REST 是一种什么样的设计。

#### 3.3 资源（Resources）

REST 的名称「表现层状态转化」中，省略了主语。「表现层」其实指的是「资源」（Resources）的表现层。

所谓「资源」，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。所谓「上网」，就是与互联网上一系列的「资源」互动，调用它的 URI。

#### 3.4 表现层（Representation）

「资源」是一种信息实体，它可以有多种外在表现形式。我们把「资源」具体呈现出来的形式，叫做它的「表现层」（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。

URI 只代表资源的实体，不代表它的形式。严格地说，有些网址最后的「.html」后缀名是不必要的，因为这个后缀名表示格式，属于「表现层」范畴，而 URI 应该只代表「资源」的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对「表现层」的描述。

#### 3.5 状态转化（State Transfer）

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。

互联网通信协议 HTTP 协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生「状态转化」（State Transfer）。而这种转化是建立在表现层之上的，所以就是「表现层状态转化」。

1『 vue-state 用来管理「状态」，上面的信息加深了此概念的理解。』

客户端用到的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。

#### 3.6 综述

综合上面的解释，我们总结一下什么是 RESTful 架构：1）每一个 URI 代表一种资源；2）客户端和服务器之间，传递这种资源的某种表现层；3）客户端通过四个 HTTP 动词，对服务器端资源进行操作，实现「表现层状态转化」。

#### 3.7 误区

RESTful 架构有一些典型的设计误区。最常见的一种设计错误，就是 URI 包含动词。因为「资源」表示一种实体，所以应该是名词，URI 不应该有动词，动词应该放在 HTTP 协议中。举例来说，某个 URI 是 /posts/show/1，其中 show 是动词，这个 URI 就设计错了，正确的写法应该是 /posts/1，然后用 GET 方法表示 show。

如果某些动作是 HTTP 动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户 1 向账户 2 汇款 500 元，错误的 URI 是：

```
POST /accounts/1/transfer/500/to/2
```

正确的写法是把动词 transfer 改成名词 transaction，资源不能是动词，但是可以是一种服务：

```
POST /transaction HTTP/1.1
Host: 127.0.0.1
　　
from=1&to=2&amount=500.00
```

另一个设计误区，就是在 URI 中加入版本号：

```
http://www.example.com/app/1.0/foo
http://www.example.com/app/1.1/foo
http://www.example.com/app/2.0/foo
```

因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分（参见 Versioning REST Services）：

```
Accept: vnd.example-com.foo+json; version=1.0
Accept: vnd.example-com.foo+json; version=1.1
Accept: vnd.example-com.foo+json; version=2.0
```

## 20200519axios.md

[axios - npm](https://www.npmjs.com/package/axios)

Promise based HTTP client for the browser and node.js

### 01. Features

Features of axios: 1) Make XMLHttpRequests from the browser. 2) Make http requests from node.js. 3) Supports the Promise API. 4) Intercept request and response. 5) Transform request and response data. 6) Cancel requests. 7) Automatic transforms for JSON data. 8) Client side support for protecting against XSRF.

### 02. Example

note: CommonJS usage.

In order to gain the TypeScript typings (for intellisense / autocomplete) while using CommonJS imports with require() use the following approach:

```js
const axios = require('axios').default;
// axios.<method> will now provide autocomplete and parameter typings
```

1『以后就按上面的方式引入 axios。』

#### 2.1 Performing a GET request

```js
const axios = require('axios');
 
// Make a request for a user with a given ID
axios.get('/user?ID=12345')
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .finally(function () {
    // always executed
  });
 
// Optionally the request above could also be done as
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .finally(function () {
    // always executed
  });  
 
// Want to use async/await? Add the `async` keyword to your outer function/method.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```

NOTE: async/await is part of ECMAScript 2017 and is not supported in Internet Explorer and older browsers, so use with caution.

1『以后尽量用 async 语法，同步的句法实现异步的逻辑，哈哈。』

#### 2.2 Performing a POST request

```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

#### 2.3 Performing multiple concurrent requests

```js
function getUserAccount() {
  return axios.get('/user/12345');
}
 
function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}
 
axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));
```

### 03. axios API

Requests can be made by passing the relevant config to axios.

#### 3.1  axios(config)

```js
// Send a POST request
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
});
// GET request for remote image
axios({
  method: 'get',
  url: 'http://bit.ly/2mTM3nY',
  responseType: 'stream'
})
  .then(function (response) {
    response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))
  });
```

axios(url[, config])

```js
// Send a GET request (default method)
axios('/user/12345');
```

#### 3.2 Request method aliases

For convenience aliases have been provided for all supported request methods.

```
axios.request(config)
axios.get(url[, config])
axios.delete(url[, config])
axios.head(url[, config])
axios.options(url[, config])
axios.post(url[, data[, config]])
axios.put(url[, data[, config]])
axios.patch(url[, data[, config]])
```

NOTE: When using the alias methods url, method, and data properties don't need to be specified in config.

#### 3.3 Concurrency

Helper functions for dealing with concurrent requests.

```js
axios.all(iterable)
axios.spread(callback)
```

Creating an instance. You can create a new instance of axios with a custom config.

axios.create([config])

```js
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

Instance methods. The available instance methods are listed below. The specified config will be merged with the instance config.

```
axios#request(config)
axios#get(url[, config])
axios#delete(url[, config])
axios#head(url[, config])
axios#options(url[, config])
axios#post(url[, data[, config]])
axios#put(url[, data[, config]])
axios#patch(url[, data[, config]])
axios#getUri([config])
```

### 04. Request Config

These are the available config options for making requests. Only the url is required. Requests will default to GET if method is not specified.

```js
{
  // `url` is the server URL that will be used for the request
  url: '/user',
 
  // `method` is the request method to be used when making the request
  method: 'get', // default
 
  // `baseURL` will be prepended to `url` unless `url` is absolute.
  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs
  // to methods of that instance.
  baseURL: 'https://some-domain.com/api/',
 
  // `transformRequest` allows changes to the request data before it is sent to the server
  // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'
  // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,
  // FormData or Stream
  // You may modify the headers object.
  transformRequest: [function (data, headers) {
    // Do whatever you want to transform the data
 
    return data;
  }],
 
  // `transformResponse` allows changes to the response data to be made before
  // it is passed to then/catch
  transformResponse: [function (data) {
    // Do whatever you want to transform the data
 
    return data;
  }],
 
  // `headers` are custom headers to be sent
  headers: {'X-Requested-With': 'XMLHttpRequest'},
 
  // `params` are the URL parameters to be sent with the request
  // Must be a plain object or a URLSearchParams object
  params: {
    ID: 12345
  },
 
  // `paramsSerializer` is an optional function in charge of serializing `params`
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function (params) {
    return Qs.stringify(params, {arrayFormat: 'brackets'})
  },
 
  // `data` is the data to be sent as the request body
  // Only applicable for request methods 'PUT', 'POST', and 'PATCH'
  // When no `transformRequest` is set, must be of one of the following types:
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - Browser only: FormData, File, Blob
  // - Node only: Stream, Buffer
  data: {
    firstName: 'Fred'
  },
  
  // syntax alternative to send data into the body
  // method post
  // only the value is sent, not the key
  data: 'Country=Brasil&City=Belo Horizonte',
 
  // `timeout` specifies the number of milliseconds before the request times out.
  // If the request takes longer than `timeout`, the request will be aborted.
  timeout: 1000, // default is `0` (no timeout)
 
  // `withCredentials` indicates whether or not cross-site Access-Control requests
  // should be made using credentials
  withCredentials: false, // default
 
  // `adapter` allows custom handling of requests which makes testing easier.
  // Return a promise and supply a valid response (see lib/adapters/README.md).
  adapter: function (config) {
    /* ... */
  },
 
  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.
  // This will set an `Authorization` header, overwriting any existing
  // `Authorization` custom headers you have set using `headers`.
  // Please note that only HTTP Basic auth is configurable through this parameter.
  // For Bearer tokens and such, use `Authorization` custom headers instead.
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },
 
  // `responseType` indicates the type of data that the server will respond with
  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'
  //   browser only: 'blob'
  responseType: 'json', // default
 
  // `responseEncoding` indicates encoding to use for decoding responses
  // Note: Ignored for `responseType` of 'stream' or client-side requests
  responseEncoding: 'utf8', // default
 
  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token
  xsrfCookieName: 'XSRF-TOKEN', // default
 
  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
  xsrfHeaderName: 'X-XSRF-TOKEN', // default
 
  // `onUploadProgress` allows handling of progress events for uploads
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },
 
  // `onDownloadProgress` allows handling of progress events for downloads
  onDownloadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },
 
  // `maxContentLength` defines the max size of the http response content in bytes allowed
  maxContentLength: 2000,
 
  // `validateStatus` defines whether to resolve or reject the promise for a given
  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
  // or `undefined`), the promise will be resolved; otherwise, the promise will be
  // rejected.
  validateStatus: function (status) {
    return status >= 200 && status < 300; // default
  },
 
  // `maxRedirects` defines the maximum number of redirects to follow in node.js.
  // If set to 0, no redirects will be followed.
  maxRedirects: 5, // default
 
  // `socketPath` defines a UNIX Socket to be used in node.js.
  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
  // Only either `socketPath` or `proxy` can be specified.
  // If both are specified, `socketPath` is used.
  socketPath: null, // default
 
  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http
  // and https requests, respectively, in node.js. This allows options to be added like
  // `keepAlive` that are not enabled by default.
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),
 
  // 'proxy' defines the hostname and port of the proxy server.
  // You can also define your proxy using the conventional `http_proxy` and
  // `https_proxy` environment variables. If you are using environment variables
  // for your proxy configuration, you can also define a `no_proxy` environment
  // variable as a comma-separated list of domains that should not be proxied.
  // Use `false` to disable proxies, ignoring environment variables.
  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and
  // supplies credentials.
  // This will set an `Proxy-Authorization` header, overwriting any existing
  // `Proxy-Authorization` custom headers you have set using `headers`.
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },
 
  // `cancelToken` specifies a cancel token that can be used to cancel the request
  // (see Cancellation section below for details)
  cancelToken: new CancelToken(function (cancel) {
  })
}
```

### 05. Response Schema

The response for a request contains the following information.

```js
{
  // `data` is the response that was provided by the server
  data: {},
 
  // `status` is the HTTP status code from the server response
  status: 200,
 
  // `statusText` is the HTTP status message from the server response
  statusText: 'OK',
 
  // `headers` the headers that the server responded with
  // All header names are lower cased
  headers: {},
 
  // `config` is the config that was provided to `axios` for the request
  config: {},
 
  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance in the browser
  request: {}
}
```

When using then, you will receive the response as follows:

```js
axios.get('/user/12345')
  .then(function (response) {
    console.log(response.data);
    console.log(response.status);
    console.log(response.statusText);
    console.log(response.headers);
    console.log(response.config);
  });
```

When using catch, or passing a rejection callback as second parameter of then, the response will be available through the error object as explained in the Handling Errors section.

### 06. Config Defaults

You can specify config defaults that will be applied to every request.

#### 6.1 Global axios defaults

```js
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
```

#### 6.2 Custom instance defaults

```js
// Set config defaults when creating the instance
const instance = axios.create({
  baseURL: 'https://api.example.com'
});
 
// Alter defaults after instance has been created

instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

#### 6.3 Config order of precedence

Config will be merged with an order of precedence. The order is library defaults found in lib/defaults.js, then defaults property of the instance, and finally config argument for the request. The latter will take precedence over the former. Here's an example.

```js
// Create an instance using the config defaults provided by the library
// At this point the timeout config value is `0` as is the default for the library
const instance = axios.create();
 
// Override timeout default for the library
// Now all requests using this instance will wait 2.5 seconds before timing out
instance.defaults.timeout = 2500;
 
// Override timeout for this request as it's known to take a long time
instance.get('/longRequest', {
  timeout: 5000
});
```

### 07. Interceptors

You can intercept requests or responses before they are handled by then or catch.

```js
// Add a request interceptor
axios.interceptors.request.use(function (config) {
    // Do something before request is sent
    return config;
  }, function (error) {
    // Do something with request error
    return Promise.reject(error);
  });
 
// Add a response interceptor
axios.interceptors.response.use(function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });
```

If you need to remove an interceptor later you can.

```js
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

You can add interceptors to a custom instance of axios.

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

### 08. Handling Errors

```js
axios.get('/user/12345')
  .catch(function (error) {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      console.log(error.response.data);
      console.log(error.response.status);
      console.log(error.response.headers);
    } else if (error.request) {
      // The request was made but no response was received
      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
      // http.ClientRequest in node.js
      console.log(error.request);
    } else {
      // Something happened in setting up the request that triggered an Error
      console.log('Error', error.message);
    }
    console.log(error.config);
  });
```

Using the validateStatus config option, you can define HTTP code(s) that should throw an error.

```js
axios.get('/user/12345', {
  validateStatus: function (status) {
    return status < 500; // Reject only if the status code is greater than or equal to 500
  }
})
```

Using toJSON you get an object with more information about the HTTP error.

```js
axios.get('/user/12345')
  .catch(function (error) {
    console.log(error.toJSON());
  });
```

### 09. Cancellation

You can cancel a request using a cancel token. The axios cancel token API is based on the withdrawn cancelable promises proposal. You can create a cancel token using the CancelToken.source factory as shown below:

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();
 
axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function (thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
    // handle error
  }
});
 
axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})
 
// cancel the request (the message parameter is optional)
source.cancel('Operation canceled by the user.');
```

You can also create a cancel token by passing an executor function to the CancelToken constructor:

```js
const CancelToken = axios.CancelToken;
let cancel;
 
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});
 
// cancel the request
cancel();
```

Note: you can cancel several requests with the same cancel token.

### 10. Using application/x-www-form-urlencoded format

By default, axios serializes JavaScript objects to JSON. To send data in the application/x-www-form-urlencoded format instead, you can use one of the following options.

#### 10.1 Browser

In a browser, you can use the URLSearchParams API as follows:

```js
const params = new URLSearchParams();
params.append('param1', 'value1');
params.append('param2', 'value2');
axios.post('/foo', params);
```

Note that URLSearchParams is not supported by all browsers (see caniuse.com), but there is a polyfill available (make sure to polyfill the global environment).

Alternatively, you can encode data using the qs library:

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```

Or in another way (ES6),

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```

#### 10.2 Node.js

In node.js, you can use the querystring module as follows:

```js
const querystring = require('querystring');
axios.post('http://something.com/', querystring.stringify({ foo: 'bar' }));
```

You can also use the qs library.

NOTE: The qs library is preferable if you need to stringify nested objects, as the querystring method has known issues with that use case (https://github.com/nodejs/node-v0.x-archive/issues/1665).

3『 [TypeScript - JavaScript that scales.](https://www.typescriptlang.org/) 』

## 20200521史上最全的Vue开发规范.md

### 01. 规范目的

目的汇总：1）为提高团队协作效率；2）便于后台人员添加功能及前端后期优化维护；3）输出高质量的文档。

为了让大家书写可维护的代码，而不是一次性的代码，让团队当中其他人看你的代码能一目了然，甚至一段时间时候后你再看你某个时候写的代码也能看。

### 02. 命名规范

#### 2.1 普通变量命名规范

命名方法 ：驼峰命名法。

命名规范 ：1）命名必须是跟需求的内容相关的词，比如说我想申明一个变量，用来表示我的学校，那么我们可以这样定义 const mySchool = "我的学校"；2）命名是复数的时候需要加 s，比如说我想申明一个数组，表示很多人的名字，那么我们可以这样定义 const names = new Array()。

#### 2.2 常量

命名方法：全部大写。

命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词。

```js
const MAX_COUNT = 10
const URL = 'https://www.baidu.com/'
```

#### 2.3 组件命名规范

官方文档推荐及使用遵循规则：

1、PascalCase（单词首字母大写命名）是最通用的声明约定。

2、kebab-case（短横线分隔命名）是最通用的使用约定。1）组件名应该始终是多个单词的，根组件 App 除外。2）有意义的名词、简短、具有可读性。3）命名遵循 PascalCase 约定。公用组件以 Abcd (公司名缩写简称) 开头，如（AbcdDatePicker,AbcdTable）。页面内部组件以组件模块名简写为开头，Item 为结尾，如（StaffBenchToChargeItem，StaffBenchAppNotArrItem）。4）使用遵循 kebab-case 约定。在页面中使用组件需要前后闭合，并以短线分隔，如（\<abcd-date-picker>\</abcd-date-picker>，\<abcd-table></abcd-table>）。5）导入及注册组件时，遵循 PascalCase 约定。6）同时还需要注意：必须符合自定义元素规范：切勿使用保留字。

#### 2.4 method 方法命名命名规范

1、驼峰式命名，统一使用动词或者动词 + 名词形式。

```
//bad
go、nextPage、show、open、login

// good
jumpPage、openCarInfoDialog
```

2、请求数据方法，以 data 结尾。

```
//bad
takeData、confirmData、getList、postForm

// good
getListData、postFormData
```

3、init、refresh 单词除外。

4、尽量使用常用单词开头（set、get、go、can、has、is）。

附： 函数方法常用的动词。

```js
get 获取——set 设置
add 增加——remove 删除
create 创建——destory 移除
start 启动——stop 停止
open 打开——close 关闭
read 读取——write 写入
load 载入——save 保存
create 创建——destroy 销毁
begin 开始——end 结束
backup 备份——restore 恢复
import 导入——export 导出
split 分割——merge 合并
inject 注入——extract 提取
attach 附着——detach 脱离
bind 绑定——separate 分离
view 查看——browse 浏览
edit 编辑——modify 修改
select 选取——mark 标记
copy 复制——paste 粘贴
undo 撤销——redo 重做
insert 插入——delete 移除
add 加入——append 添加
clean 清理——clear 清除
index 索引——sort 排序
find 查找——search 搜索
increase 增加——decrease 减少
play 播放——pause 暂停
launch 启动——run 运行
compile 编译——execute 执行
debug 调试——trace 跟踪
observe 观察——listen 监听
build 构建——publish 发布
input 输入——output 输出
encode 编码——decode 解码
encrypt 加密——decrypt 解密
compress 压缩——decompress 解压缩
pack 打包——unpack 解包
parse 解析——emit 生成
connect 连接——disconnect 断开
send 发送——receive 接收
download 下载——upload 上传
refresh 刷新——synchronize 同步
update 更新——revert 复原
lock 锁定——unlock 解锁
check out 签出——check in 签入
submit 提交——commit 交付
push 推——pull 拉
expand 展开——collapse 折叠
begin 起始——end 结束
start 开始——finish 完成
enter 进入——exit 退出
abort 放弃——quit 离开
obsolete 废弃——depreciate 废旧
collect 收集——aggregate 聚集
```

#### 2.5 views 下的文件命名

1、只有一个文件的情况下不会出现文件夹，而是直接放在 views 目录下面，如 index.vue。

2、尽量是名词，且使用驼峰命名法。

3、开头的单词就是所属模块名字（workbenchIndex、workbenchList、workbenchEdit）。

4、名字至少两个单词（good: workbenchIndex）（bad:workbench）。

#### 2.6 props 命名

在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板中应该始终使用 kebab-case。

```js
<!-- bad -->
<script>
props: {
  'greeting-text': String
}
</script>

<welcome-message greetingText="hi"></welcome-message>

<!-- good -->
<script>
props: {
  greetingText: String
}
</script>

<welcome-message greeting-text="hi"></welcome-message>
```

#### 2.7 例外情况

1、作用域不大临时变量可以简写，比如：str，num，bol，obj，fun，arr。

2、循环变量可以简写，比如：i，j，k 等。

### 03. 结构化规范

#### 3.1 目录文件夹及子文件规范

以下统一管理处均对应相应模块。

以下全局文件文件均以 index.js 导出，并在 main.js 中导入。

以下临时文件，在使用后，接口已经有了，发版后清除。

```
src                               源码目录
|-- api                              接口，统一管理
|-- assets                           静态资源，统一管理
|-- components                       公用组件，全局文件
|-- filters                          过滤器，全局工具
|-- icons                            图标，全局资源
|-- datas                            模拟数据，临时存放
|-- lib                              外部引用的插件存放及修改文件
|-- mock                             模拟接口，临时存放
|-- router                           路由，统一管理
|-- store                            vuex, 统一管理
|-- views                         视图目录
|   |-- staffWorkbench               视图模块名
|   |-- |-- staffWorkbench.vue       模块入口页面
|   |-- |-- indexComponents          模块页面级组件文件夹
|   |-- |-- components               模块通用组件文件夹
```

#### 3.2 vue 文件基本结构

```html
  <template>
    <div>
      <!--必须在div中编写页面-->
    </div>
  </template>
  <script>
    export default {
      components：{
      },
      data () {
        return {
        }
      },
      mounted() {
      }，
      methods: {
      }
   }
  </script>
  <!--声明语言，并且添加scoped-->
  <style lang="scss" scoped>
  </style>
```

#### 3.3 多个特性的元素规范

多个特性的元素应该分多行撰写，每个特性一行。（增强更易读）

```html
<!-- bad -->
<img src="https://vuejs.org/images/logo.png" alt="Vue Logo">
<my-component foo="a" bar="b" baz="c"></my-component>

<!-- good -->
<img
  src="https://vuejs.org/images/logo.png"
  alt="Vue Logo"
>
<my-component
  foo="a"
  bar="b"
  baz="c"
>
</my-component>
```

#### 3.4 元素特性的顺序

原生属性放前面，指令放后面。如下所示：

```
  - class
  - id,ref
  - name
  - data-*
  - src, for, type, href,value,max-length,max,min,pattern
  - title, alt，placeholder
  - aria-*, role
  - required,readonly,disabled
  - is
  - v-for
  - key
  - v-if
  - v-else-if
  - v-else
  - v-show
  - v-cloak
  - v-pre
  - v-once
  - v-model
  - v-bind,:
  - v-on,@
  - v-html
  - v-text
```

#### 3.5 组件选项顺序

如下所示：

```
  - components
  - props
  - data
  - computed
  - created
  - mounted
  - metods
  - filter
  - watch
```

### 04. 注释规范

代码注释在一个项目的后期维护中显的尤为重要，所以我们要为每一个被复用的组件编写组件使用说明，为组件中每一个方法编写方法说明。

#### 4.1 务必添加注释列表

如下：1）公共组件使用说明；2）各组件中重要函数或者类说明；3）复杂的业务逻辑处理说明；4）特殊情况的代码处理说明，对于代码中特殊用途的变量、存在临界值、函数中使用的 hack、使用了某种算法或思路等需要进行注释描述；5）多重 if 判断语句；6）注释块必须以/*/*（至少两个星号）开头**/；7）单行注释使用 //。

#### 4.2 单行注释

注释单独一行，不要在代码后的同一行内加注释。例如：

```js
bad

var name =”abc”; // 姓名    

good

// 姓名
var name = “abc”;         
```

#### 4.3 多行注释

组件使用说明，和调用说明。

```js
/**
* 组件名称
* @module 组件存放位置
* @desc 组件描述
* @author 组件作者
* @date 2017年12月05日17:22:43
* @param {Object} [title]    - 参数说明
* @param {String} [columns] - 参数说明
* @example 调用示例
*  <hbTable :title="title" :columns="columns" :tableData="tableData"></hbTable>
**/
```

### 05. 编码规范

优秀的项目源码，即使是多人开发，看代码也如出一人之手。统一的编码规范，可使代码更易于阅读，易于理解，易于维护。尽量按照 ESLint 格式要求编写代码。

#### 5.1 源码风格

使用 ES6 风格编码。

1、定义变量使用 let，定义常量使用 const。

2、静态字符串一律使用单引号或反引号，动态字符串使用反引号。

```js
// bad
const a = 'foobar'
const b = 'foo' + a + 'bar'

// acceptable
const c = `foobar`

// good
const a = 'foobar'
const b = `foo${a}bar`
const c = 'foobar'
```

3、解构赋值。

数组成员对变量赋值时，优先使用解构赋值。

```js
// 数组解构赋值
const arr = [1, 2, 3, 4]
// bad
const first = arr[0]
const second = arr[1]

// good
const [first, second] = arr
```

函数的参数如果是对象的成员，优先使用解构赋值。

```js
// 对象解构赋值
// bad
function getFullName(user) {
const firstName = user.firstName
const lastName = user.lastName
}

// good
function getFullName(obj) {
const { firstName, lastName } = obj
}

// best
function getFullName({ firstName, lastName }) {}
```

4、拷贝数组。使用扩展运算符（...）拷贝数组。

```js
const items = [1, 2, 3, 4, 5]

// bad
const itemsCopy = items

// good
const itemsCopy = [...items]
```

1『上面的几个知识点牢牢记住。』

5、箭头函数。需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。

```js
// bad
const self = this;
const boundMethod = function(...params) {
return method.apply(self, params);
}

// acceptable
const boundMethod = method.bind(this);

// best
const boundMethod = (...params) => method.apply(this, params);
```

6、模块。如果模块只有一个输出值，就使用 export default，如果模块有多个输出值，就不使用 export default，export default 与普通的 export 不要同时使用。

```js
// bad
import * as myObject from './importModule'

// good
import myObject from './importModule'
```

如果模块默认输出一个函数，函数名的首字母应该小写。

```js
function makeStyleGuide() {
}

export default makeStyleGuide;
```

如果模块默认输出一个对象，对象名的首字母应该大写。

```js
const StyleGuide = {
es6: {
}
};

export default StyleGuide;
```

1『变量名、函数名的首字母小写，对象名的首字母大写。』

#### 5.2 指令规范

指令有缩写一律采用缩写形式。

```html
// bad
v-bind:class="{'show-left'：true}"
v-on:click="getListData"

// good
:class="{'show-left'：true}"
@click="getListData"
```

v-for 循环必须加上 key 属性，在整个 for 循环中 key 需要唯一。

```html
<!-- good -->
<ul>
<li v-for="todo in todos" :key="todo.id">
  {{ todo.text }}
</li>
</ul>

<!-- bad -->
<ul>
<li v-for="todo in todos">
  {{ todo.text }}
</li>
</ul>
```

避免 v-if 和 v-for 同时用在一个元素上（性能问题）。以下为两种解决方案：

1『原来还有这个要求。』

1、将数据替换为一个计算属性，让其返回过滤后的列表。

```html
  <!-- bad -->
  <ul>
    <li v-for="user in users" v-if="user.isActive" :key="user.id">
      {{ user.name }}
    </li>
  </ul>

  <!-- good -->
  <ul>
    <li v-for="user in activeUsers" :key="user.id">
      {{ user.name }}
    </li>
  </ul>

  <script>
  computed: {
    activeUsers: function () {
      return this.users.filter(function (user) {
        return user.isActive
      })
    }
  }
  </script>
```

1『这个思路好，把 v-if 判断放进过滤函数里。』

2、将 v-if 移动至容器元素上（比如 ul, ol）。

```html
  <!-- bad -->
  <ul>
    <li v-for="user in users" v-if="shouldShowUsers" :key="user.id">
      {{ user.name }}
    </li>
  </ul>

  <!-- good -->
  <ul v-if="shouldShowUsers">
    <li v-for="user in users" :key="user.id">
      {{ user.name }}
    </li>
  </ul>
```

#### 5.3 Props 规范

Props 定义应该尽量详细。

```js
// bad 这样做只有开发原型系统时可以接受
props: ['status']

// good
props: {
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        'syncing',
        'synced',
        'version-conflict',
        'error'
      ].indexOf(value) !== -1
    }
  }
}
```

#### 5.4 其他

1、避免 this.\$parent。

2、调试信息 console.log() debugger 使用完及时删除。

3、除了三目运算，if, else 等禁止简写。

```js
  // bad
  if (true)
      alert(name);
  console.log(name);

  // bad
  if (true)
  alert(name);
  console.log(name)

  // good
  if (true) {
      alert(name);
  }
  console.log(name);
```

### 06. CSS 规范

#### 6.1 通用规范

1、统一使用 "-" 连字符。

2、省略值为 0 时的单位。

```css
 // bad
  padding-bottom: 0px;
  margin: 0em;

 // good
  padding-bottom: 0;
  margin: 0;
```

3、如果 CSS 可以做到，就不要使用 JS。

4、建议并适当缩写值，提高可读性，特殊情况除外。1）「建议并适当」是因为缩写总是会包含一系列的值，而有时候我们并不希望设置某一值，反而造成了麻烦，那么这时候你可以不缩写，而是分开写。2）当然，在一切可以缩写的情况下，请务必缩写，它最大的好处就是节省了字节，便于维护，并使阅读更加一目了然。

```css
  // bad
  .box{
    border-top-style: none;
    font-family: palatino, georgia, serif;
    font-size: 100%;
    line-height: 1.6;
    padding-bottom: 2em;
    padding-left: 1em;
    padding-right: 1em;
    padding-top: 0;
  }

  // good
  .box{
    border-top: 0;
    font: 100%/1.6 palatino, georgia, serif;
    padding: 0 1em 2em;
  }
```

5、声明应该按照下表的顺序：左到右，从上到下。

```
显示属性	自身属性	文本属性和其他修饰
display	width	font
visibility	height	text-align
position	margin	text-decoration
float	padding	vertical-align
clear	border	white-space
list-style	overflow	color
top	min-width	background
```

```css
  // bad
  .box {
    font-family: 'Arial', sans-serif;
    border: 3px solid #ddd;
    left: 30%;
    position: absolute;
    text-transform: uppercase;
    background-color: #eee;
    right: 30%;
    isplay: block;
    font-size: 1.5rem;
    overflow: hidden;
    padding: 1em;
    margin: 1em;
  }

  // good
  .box {
    display: block;
    position: absolute;
    left: 30%;
    right: 30%;
    overflow: hidden;
    margin: 1em;
    padding: 1em;
    background-color: #eee;
    border: 3px solid #ddd;
    font-family: 'Arial', sans-serif;
    font-size: 1.5rem;
    text-transform: uppercase;
  }
```

6、元素选择器应该避免在 scoped 中出现。官方文档说明：在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。

7、分类的命名方法。1）使用单个字母加上 "-" 为前缀；2）布局（grid）（.g-）；3）模块（module）（.m-）；4）元件（unit）（.u-）；5）功能（function）（.f-）；6）皮肤（skin）（.s-）；7）状态（.z-）。

8、统一语义理解和命名。

#### 6.2 sass 规范

1、当使用 Sass 的嵌套功能的时候，重要的是有一个明确的嵌套顺序，以下内容是一个 SCSS 块应具有的顺序。1）当前选择器的样式属性；2）父级选择器的伪类选择器 (:first-letter, :hover, :active etc)；3）伪类元素 (:before and :after)；4）父级选择器的声明样式 (.selected, .active, .enlarged etc.)；5）用 Sass 的上下文媒体查询；6）子选择器作为最后的部分。

```css
  .product-teaser {
    // 1. Style attributes
    display: inline-block;
    padding: 1rem;
    background-color: whitesmoke;
    color: grey;

    // 2. Pseudo selectors with parent selector
    &:hover {
      color: black;
    }

    // 3. Pseudo elements with parent selector
    &:before {
      content: "";
      display: block;
      border-top: 1px solid grey;
    }

    &:after {
      content: "";
      display: block;
      border-top: 1px solid grey;
    }

    // 4. State classes with parent selector
    &.active {
      background-color: pink;
      color: red;

      // 4.2. Pseuso selector in state class selector
      &:hover {
        color: darkred;
      }
    }

    // 5. Contextual media queries
    @media screen and (max-width: 640px) {
      display: block;
      font-size: 2em;
    }

    // 6. Sub selectors
    > .content > .title {
      font-size: 1.2em;

      // 6.5. Contextual media queries in sub selector
      @media screen and (max-width: 640px) {
        letter-spacing: 0.2em;
        text-transform: uppercase;
      }
    }
  }
```

#### 6.3 特殊规范

对用页面级组件样式，应该是有作用域的；对于公用组件或者全局组件库，我们应该更倾向于选用基于 class 的 BEM 策略。

```css
  <style lang='scss'></style> // bad

  <!-- 使用 scoped 作用域 -->
  <style lang='scss' scoped></style> // good

  <!-- 使用 BEM 约定 -->
  <style> // good
  .c-Button {
    border: none;
    border-radius: 2px;
  }

  .c-Button--close {
    background-color: red;
  }
  </style>
```

## 20200531json与dataframe互相转换.md

[python 中基于 pandas 模块：json 与 dataframe 的互相转换](https://blog.csdn.net/qq_41780234/article/details/84990551)

[pandas.read_json — pandas 1.0.3 documentation](https://pandas.pydata.org/docs/reference/api/pandas.read_json.html#pandas.read_json)

[pandas.DataFrame.to_json — pandas 1.0.3 documentation](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_json.html?highlight=to_json#pandas.DataFrame.to_json)

### 01. 消化

1、对于简单的 json 形式。所谓的简单的 json 格式，就是将字典形式的文件，直接输出成 dataframe 形式的文件。

利用 pandas 自带的 read_json 直接解析字符串。

```py
import pandas as pd
df = pd.read_json("test.json",encoding="utf-8", orient='records')
print(df)
```

利用 json 库 loads 方法和 pandas 库中的 json_normalize 方法。

```py
import json 
from pandas.io.json import json_normalize
data=open("test.json",encoding="utf-8").read()
data_list = json.loads(data)
df = json_normalize(data_list)
print(df)
```

2、对于稍微复杂一些的 json 进行处理。复杂的一些的 json 格式的文件，例子如下，我们想要得到的数据是张三兄弟的数据，同样先写入 json 文件：

```py
obj = """
{"姓名": "张三",
 "住处": ["天朝", "岛国", "万恶的资本主义日不落帝国"],
 "宠物": null,
 "兄弟": [{"姓名": "李四", "年龄": 25, "宠物": "汪星人"},
              {"姓名": "王五", "年龄": 23, "宠物": "喵星人"}]
}"""
with open("test1.json","w",encoding="utf-8") as f:
    f.write(obj)
```

利用 json 的 loads 和 pandas 的 DataFrame。

```py
import json 
import pandas as pd
with open("test1.json","r",encoding="utf-8") as f:
    info=f.read()
    data_list = json.loads(info)
    brother_info = data_list["兄弟"]
    df=pd.DataFrame(brother_info)
#     print(type(brother_info))
#     print(brother_info)
#     print(brother_info)
```

利用 json 的 loads 和 pandas 的 json_normalize。

```py
from pandas.io.json import json_normalize
import json 
with open("test1.json","r",encoding="utf-8") as f:
    info=f.read()
    data_list = json.loads(info)
    brother_info = data_list["兄弟"]
    df = json_normalize(brother_info)
    print(df)
```

利用 json 的 loads 和 pandas 的 read_json。

```py
import json 
import pandas as pd
with open("test1.json","r",encoding="utf-8") as f:
    info=f.read()
    data_list = json.loads(info)
    brother_info = data_list["兄弟"]
    json_data=json.dumps(brother_info)
    df=pd.read_json(json_data,orient="records")
    print(df)
```

总结：

在以上的例子中，可以发现在进行简单的格式转换的时候，可以使用 pandas 库的 read_json 进行处理，在进行复杂的格式转换的时候就要配合 json 库进行使用。无论是什么样的 json 数据，基本思路都是现将 json 文件读取进来，然后选择想要转换的数据，或是列表或是字典，然后再进行转换。

在这里重点介绍一下两个函数 read\_json 方法和 json\_normalize 方法。在使用时，要注意 read\_json 方法中 orient 参数的选择，同时 json\_normalize 可以将传入的列表、字典形式的 json 格式数据直接转换成 dataframe。

DataFrame 转为 json。通常情况下，我们使用的都是 pandas 中的 to\_json() 函数，可以通过设置 orient 参数来转换成为我们想要的 json 格式，orient 函数有以下几个参数："split", "records", "index", "columns", "values"。

### 02. 自由发挥

#### df.to_json()

在 excel 里就做一个字段 explosive_mixture，excel 读取成 dataframe 格式，直接用 df.to_json() 转成的 json 格式是：

```js
{
    "explosive_mixture": {
        "0": "the first row data",
        "1": "the second row data",
        ...
    }
}
```

#### df.to_json(orient='split')

```
‘split’ : dict like {‘index’ -> [index], ‘columns’ -> [columns], ‘data’ -> [values]}
```

实例：

```json
{
"columns":["combustion_mixture"],
"index":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
"data":[["\\u6eb4\\u4e0e\\u78f7\\u3001\\u950c\\u7c89\\u3001\\u9541\\u7c89"],["\\u6d53\\u786b\\u9178\\u3001\\u6d53\\u785d\\u9178\\u4e0e\\u6728\\u6750\\u3001\\u7ec7\\u7269\\u7b49"]
}
```

#### df.to_json(orient='records')

```
‘records’ : list like [{column -> value}, … , {column -> value}]
```

实例：

```json
[{"combustion_mixture":"\\u6eb4\\u4e0e\\u78f7\\u3001\\u950c\\u7c89\\u3001\\u9541\\u7c89"},{"combustion_mixture":"\\u6d53\\u786b\\u9178\\u3001\\u6d53\\u785d\\u9178\\u4e0e\\u6728\\u6750\\u3001\\u7ec7\\u7269\\u7b49"},{"combustion_mixture":"\\u94dd\\u7c89\\u4e0e\\u6c2f\\u4eff"}]
```

#### df.to_json(orient='index')

```
‘index’ : dict like {index -> {column -> value}}
```

```json
{"0":{"combustion_mixture":"\\u6eb4\\u4e0e\\u78f7\\u3001\\u950c\\u7c89\\u3001\\u9541\\u7c89"},"1":{"combustion_mixture":"\\u6d53\\u786b\\u9178\\u3001\\u6d53\\u785d\\u9178\\u4e0e\\u6728\\u6750\\u3001\\u7ec7\\u7269\\u7b49"},"2":{"combustion_mixture":"\\u94dd\\u7c89\\u4e0e\\u6c2f\\u4eff"}}
```

#### df.to_json(orient='columns')

```
‘columns’ : dict like {column -> {index -> value}}
```

可参考 df.to_json(orient='index')。

#### df.to_json(orient='values')

```
‘values’ : just the values array
```

```json
[["\\u6eb4\\u4e0e\\u78f7\\u3001\\u950c\\u7c89\\u3001\\u9541\\u7c89"],["\\u6d53\\u786b\\u9178\\u3001\\u6d53\\u785d\\u9178\\u4e0e\\u6728\\u6750\\u3001\\u7ec7\\u7269\\u7b49"],["\\u94dd\\u7c89\\u4e0e\\u6c2f\\u4eff"],["\\u738b\\u6c34\\u4e0e\\u6709\\u673a\\u7269"]]
```

#### df.to_json(orient='table')

```
‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
```

```json
{"schema":{"fields":[{"name":"index","type":"integer"},{"name":"combustion_mixture","type":"string"}],"primaryKey":["index"],"pandas_version":"0.20.0"},"data":[{"index":0,"combustion_mixture":"\\u6eb4\\u4e0e\\u78f7\\u3001\\u950c\\u7c89\\u3001\\u9541\\u7c89"},{"index":1,"combustion_mixture":"\\u6d53\\u786b\\u9178\\u3001\\u6d53\\u785d\\u9178\\u4e0e\\u6728\\u6750\\u3001\\u7ec7\\u7269\\u7b49"},{"index":2,"combustion_mixture":"\\u94dd\\u7c89\\u4e0e\\u6c2f\\u4eff"}]}
```

目前个人用的最多的是 df.to_json(orient='records')，scrapy 爬虫抓来的 json 数据就用它直接转成 dataframe 格式。

## 20200617Python-Masonite框架中文翻译召集.md

关注 Masonite 已经很久了，去年服务过一个项目，合作公司团队由 Python 程序员组成，帮他们开发网站时要求以 Python 语言来构建，对我们 Laravel 开发者来讲 Masonite 框架无疑是最好的选择。总体使用下来，对此框架评分很高，框架拥有 100% 的测试覆盖率，核心架架构上也借鉴了 Laravel 上成熟的解决方案，如服务提供者、服务容器等。功能上也是直追 Laravel 路由、命令行、计划任务、队列任务等。

本社区将从 2.3 版本开始对 Masonite 框架的中文文档进行维护。对 Masonite 感兴趣的同学，欢迎加入我们的翻译队伍。

### 黑板墙

汇总：1）diango 的 orm 太难受了。2）Summer （楼主）：只要作者继续维护，以后肯定是 Masonite 的，为啥？好用且设计优良，就像用了 Laravel 其他框架就看不上一样。3）django 3.0 已逐步开始支持异步。4）django的路由太弱了。5）Python 本来就慢，还跟 laravel 一样重不得。6）还是喜欢 Python，希望能出现与 Laravel 相提并论的框架。7）FastAPI 专注 API 开发，写接口狠给力。Laravel 和 Masonite 都是追求大而全的框架。理念不同。8）目前有的教学课程好像只有作者在做，还在 slack 上在线答疑。9）以后 python 的 web 框架，肯定是 masonite 的天下了，如果大家目前遇到一些问题可以尝试在 Slack 频道上提问，作者实时解答很积极。

[Slack | Get Started | dalong](https://app.slack.com/client/T015401PEQ7/learning-slack)

