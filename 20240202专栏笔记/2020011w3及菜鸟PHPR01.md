## 记忆时间

2020-06-05

## 0101基础教程.md

发现国外的一个 PHP 教程网站：[Setting Up Project with PHP and MySQL Database - Tutorial Republic](https://www.tutorialrepublic.com/php-tutorial/php-get-started.php)

### 1.0 安装

1、使用 XAMPP（一个 IDE），官网下载：[Download XAMPP](https://www.apachefriends.org/download.html)

2、应该是电脑里配套比较全，ProFTPD、Apache、MYSQL 都有，全绿灯通过。在「Volumes」里要点挂起「Mount」，然后点 export 可以进入 htdocs 文件夹，代码「test.php」放进去即可。

/Users/Daglas/.bitnami/stackman/machines/xampp/volumes/root/htdocs

/Users/Daglas/.bitnami/stackman/machines/xampp/volumes/root/htdocs/dashboard/phpinfo

3、浏览器里输入地址：http://192.168.64.2/2020011w3school/test.php 即可运行文件。

3『发现 docker 上也可以配置 php 环境：[Docker 安装 PHP | 菜鸟教程](https://www.runoob.com/docker/docker-install-php.html)、[vscode-php-debug/README.md at master · felixfbecker/vscode-php-debug](https://github.com/felixfbecker/vscode-php-debug/blob/master/README.md)。』

1『目前 php 的开发用框架 laravel。（2020-04-14）』

### 1.1 PHP 简介

PHP 脚本在服务器上执行。什么是 PHP？1）PHP 是 PHP Hypertext Preprocessor 的首字母缩略词。2）PHP 是一种被广泛使用的开源脚本语言。3）PHP 脚本在服务器上执行。4）PHP 没有成本，可供免费下载和使用。

PHP 是一门令人惊叹的流行语言！1）它强大到足以成为在网络上最大的博客系统的核心（WordPress）！2）它深邃到足以运行最大的社交网络（facebook）！3）而它的易用程度足以成为初学者的首选服务器端语言！

什么是 PHP 文件？1）PHP 文件能够包含文本、HTML、CSS 以及 PHP 代码。2）PHP 代码在服务器上执行，而结果以纯文本返回浏览器。2）PHP 文件的后缀是 ".php"

PHP 能够做什么？1）PHP 能够生成动态页面内容。2）PHP 能够创建、打开、读取、写入、删除以及关闭服务器上的文件。3）PHP 能够接收表单数据。4）PHP 能够发送并取回 cookies。5）PHP 能够添加、删除、修改数据库中的数据。6）PHP 能够限制用户访问网站中的某些页面。7）PHP 能够对数据进行加密。

通过 PHP，您可以不受限于只输出 HTML。您还能够输出图像、PDF 文件、甚至 Flash 影片。您也可以输出任何文本，比如 XHTML 和 XML。

为什么使用 PHP？1）PHP 运行于各种平台（Windows, Linux, Unix, Mac OS X 等等）。2）PHP 兼容几乎所有服务器（Apache, IIS 等等）。3）PHP 支持多种数据库。4）PHP 是免费的。请从官方 PHP 资源下载：www.php.net。5）PHP 易于学习，并可高效地运行在服务器端。

### 1.3 PHP 语法

PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。基础 PHP 语法。PHP 脚本可放置于文档中的任何位置。PHP 脚本以 \<?php 开头，以?> 结尾。

注释：PHP 语句以分号结尾（;）。PHP 代码块的关闭标签也会自动表明分号（因此在 PHP 代码块的最后一行不必使用分号）。PHP 中的注释。PHP 代码中的注释不会被作为程序来读取和执行。它唯一的作用是供代码编辑者阅读。注释用于：1）使其他人理解您正在做的工作 —— 注释可以让其他程序员了解您在每个步骤进行的工作（如果您供职于团队）。2）提醒自己做过什么 —— 大多数程序员都曾经历过一两年后对项目进行返工，然后不得不重新考虑他们做过的事情。注释可以记录您在写代码时的思路。PHP 支持三种注释：

```php
<?php
// 这是单行注释

# 这也是单行注释

/*
这是多行注释块
它横跨了
多行
*/
?>
```

1『 VScode 的多行注释快捷键：shift+option+A。』

PHP 的大小写敏感。在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。在下面的例子中，所有这三条 echo 语句都是合法的（等价）：

```php
<?php
ECHO "Hello World!<br>";
echo "Hello World!<br>";
EcHo "Hello World!<br>";
?>
```

1『\<br> 是 html 标记语言里的换行标签。』

不过在 PHP 中，所有变量都对大小写敏感。在下面的例子中，只有第一条语句会显示 \$color 变量的值（这是因为 \$color、\$COLOR 以及 \$coLOR 被视作三个不同的变量）：

```php
<?php
$color="red";
echo "My car is " . $color . "<br>";
echo "My house is " . $COLOR . "<br>";
echo "My boat is " . $coLOR . "<br>";
?>
```

1『奇奇怪怪，变量大小写敏感，而关键字、类、函数却大小写不敏感。』

### 1.4 PHP 变量

变量是存储信息的容器：

```php
<?php
$x=5;
$y=6;
$z=$x+$y;
echo $z;
?>
```

类似代数。在代数中我们使用字母（比如 x）来保存值（比如 5）。从上面的表达式 z=x+y，我们能够计算出 z 的值是 11。在 PHP 中，这三个字母被称为变量。注释：请把变量视为存储数据的容器。正如代数，PHP 变量可用于保存值（x=5）和表达式（z=x+y）。变量的名称可以很短（比如 x 和 y），也可以取更具描述性的名称（比如 carname、total_volume）。PHP 变量规则：变量以 \$ 符号开头，其后是变量的名称，变量名称必须以字母或下划线开头，变量名称不能以数字开头，变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _），变量名称对大小写敏感（\$y 与 \$Y 是两个不同的变量）。创建 PHP 变量。PHP 没有创建变量的命令。变量会在首次为其赋值时被创建：

1『动态语言。目前的理解变量时一个内存地址，这些内存里存着数据结构，所以说数据结构是内存的抽象，同时解释了数组 list[0] 写法的原因，0 是指针的偏移量为 0，即首个内存地址，1 代码偏移一个单位的地址，即第二个元素。（2020-03-07）』

```php
<?php
$txt="Hello world!";
$x=5;
$y=10.5;
?>
```

以上语句执行后，变量 txt 会保存值 Hello world!，变量 x 会保存值 5，变量 y 会保存值 10.5。PHP 是一门类型松散的语言。在上面的例子中，请注意我们不必告知 PHP 变量的数据类型。PHP 根据它的值，自动把变量转换为正确的数据类型。在诸如 C 和 C++ 以及 Java 之类的语言中，程序员必须在使用变量之前声明它的名称和类型。

1『跟 JS 一样，PHP 是弱类型语言。』

PHP 变量作用域。在 PHP 中，可以在脚本的任意位置对变量进行声明。变量的作用域指的是变量能够被引用 / 使用的那部分脚本。PHP 有三种不同的变量作用域：1）local（局部）。2）global（全局）。3）static（静态）。

Local 和 Global 作用域。函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。下面的例子测试了带有局部和全局作用域的变量：

```php
<?php
$x=5; // 全局作用域

function myTest() {
  $y=10; // 局部作用域
  echo "<p>测试函数内部的变量：</p>";
  echo "变量 x 是：$x";
  echo "<br>";
  echo "变量 y 是：$y";
} 

myTest();

echo "<p>测试函数之外的变量：</p>";
echo "变量 x 是：$x";
echo "<br>";
echo "变量 y 是：$y";
?>
```

在上例中，有两个变量 \$x 和 \$y，以及一个函数 myTest()。\$x 是全局变量，因为它是在函数之外声明的，而 \$y 是局部变量，因为它是在函数内声明的。如果我们在 myTest() 函数内部输出两个变量的值，\$y 会输出在本地声明的值，但是无法输出 \$x 的值，因为它在函数之外创建。然后，如果在 myTest() 函数之外输出两个变量的值，那么会输出 \$x 的值，但是不会输出 \$y 的值，因为它是局部变量，并且在 myTest() 内部创建。注释：您可以在不同的函数中创建名称相同的局部变量，因为局部变量只能被在其中创建它的函数识别。

1『函数内竟然访问不了函数外的全局变量，注意这一点。JS 的闭包当然可以访问，试验了下 python 尽管也可以访问，python 是不是也有类似「闭包」的概念？待确认（2020-04-14）。』

PHP global 关键词。global 关键词用于在函数内访问全局变量。要做到这一点，请在（函数内部）变量前面使用 global 关键词：

```php
<?php
$x=5;
$y=10;

function myTest() {
  global $x,$y;
  $y=$x+$y;
}

myTest();
echo $y; // 输出 15
?>
```

PHP 同时在名为 \$GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。上面的例子可以这样重写：

```php
<?php
$x=5;
$y=10;

function myTest() {
  $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];
} 

myTest();
echo $y; // 输出 15
?>
```

PHP static 关键词。通常，当函数完成 / 执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作。要完成这一点，请在您首次声明变量时使用 static 关键词：

```php
<?php

function myTest() {
  static $x=0;
  echo $x;
  $x++;
}

myTest();
myTest();
myTest();

?>
```

然后，每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。注释：该变量仍然是函数的局部变量。

参数作用域。参数是通过调用代码将值传递给函数的局部变量。参数是在参数列表中声明的，作为函数声明的一部分：

```php
<?php
function myTest($x)
{
    echo $x;
}
myTest(5);
?>
```

### 1.5 PHP5 echo 和 print 语句

在 PHP 中，有两种基本的输出方法：echo 和 print。在本教程中，我们几乎在每个例子中都会用到 echo 和 print。因此，本节为您讲解更多关于这两条输出语句的知识。echo 和 print 之间的差异：1）echo —— 能够输出一个以上的字符串；2）print —— 只能输出一个字符串，并始终返回 1。提示：echo 比 print 稍快，因为它不返回任何值。echo 是一个语言结构，有无括号均可使用：echo 或 echo()。

显示字符串。下面的例子展示如何用 echo 命令来显示不同的字符串（同时请注意字符串中能包含 HTML 标记）：

```php
<?php
echo "<h2>PHP is fun!</h2>";
echo "Hello world!<br>";
echo "I'm about to learn PHP!<br>";
echo "This", " string", " was", " made", " with multiple parameters.";
?>
```

2『经验证，\<br> 是换行的标签。』

显示变量。下面的例子展示如何用 echo 命令来显示字符串和变量：

```php
<?php
$txt1="Learn PHP";
$txt2="W3School.com.cn";
$cars=array("Volvo","BMW","SAAB");

echo $txt1;
echo "<br>";
echo "Study PHP at $txt2";
echo "My car is a {$cars[0]}";
?>
```

print 也是语言结构，有无括号均可使用：print 或 print()。显示字符串。下面的例子展示如何用 print 命令来显示不同的字符串（同时请注意字符串中能包含 HTML 标记）：

```php
<?php
print "<h2>PHP is fun!</h2>";
print "Hello world!<br>";
print "I'm about to learn PHP!";
?>
```

显示变量。下面的例子展示如何用 print 命令来显示字符串和变量：

```php
<?php
$txt1="Learn PHP";
$txt2="W3School.com.cn";
$cars=array("Volvo","BMW","SAAB");

print $txt1;
print "<br>";
print "Study PHP at $txt2";
print "My car is a {$cars[0]}";
?>
```

### 1.6 PHP 数据类型

字符串、整数、浮点数、逻辑、数组、对象、NULL。

PHP 字符串。字符串是字符序列，比如 "Hello world!"。字符串可以是引号内的任何文本。您可以使用单引号或双引号：

1、PHP 整数。整数是没有小数的数字。整数规则：1）整数必须有至少一个数字（0-9）。2）整数不能包含逗号或空格。3）整数不能有小数点。4）整数正负均可。5）可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）。在下面的例子中，我们将测试不同的数字。

var_dump() 会返回变量的数据类型和值：

```php
<?php 
$x = 5985;
var_dump($x);
echo "<br>"; 
$x = -345; // 负数
var_dump($x);
echo "<br>"; 
$x = 0x8C; // 十六进制数
var_dump($x);
echo "<br>";
$x = 047; // 八进制数
var_dump($x);
?>
```

1『打断点测试的时候用 var_dump() 来显示信息，配合「exit;」。』

2、PHP 浮点数。浮点数是有小数点或指数形式的数字。在下面的例子中，我们将测试不同的数字。

```php
<?php 
$x = 10.365;
var_dump($x);
echo "<br>"; 
$x = 2.4e3;
var_dump($x);
echo "<br>"; 
$x = 8E-5;
var_dump($x);
?>
```

3、PHP 逻辑。逻辑是 true 或 false。逻辑常用于条件测试。

```php
$x=true;
$y=false;
```

4、PHP 数组。数组在一个变量中存储多个值。在下面的例子中，我们将测试不同的数组。

```php
<?php 
$cars=array("Volvo","BMW","SAAB");
var_dump($cars);
?>
```

5、PHP 对象。对象是存储数据和有关如何处理数据的信息的数据类型。在 PHP 中，必须明确地声明对象。首先我们必须声明对象的类。对此，我们使用 class 关键词。类是包含属性和方法的结构。然后我们在对象类中定义数据类型，然后在该类的实例中使用此数据类型：

```php
<?php
class Car
{
  var $color;
  function Car($color="green") {
    $this->color = $color;
  }
  function what_color() {
    return $this->color;
  }
}
?>
```

1『在 PHP 里，对象是类的实例化，所以必须得先声明对象。』

6、PHP NULL 值。特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。可以通过把值设置为 NULL，将变量清空：

```php
<?php
$x="Hello world!";
$x=null;
var_dump($x);
?>
```

3『 var_dump() 方法，判断一个变量的类型与长度，并输出变量的数值，如果变量有值，则输出是变量的值，并返回数据类型。显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。注意：用保证 var_dump 中的变量必须是存在的，如果变量不存在则返回 NULL。该函数有输出的功能，因此不必加其它的输出函数。』

PHP 类型比较。虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。1）松散比较：使用两个等号 == 比较，只比较值，不比较类型。2）严格比较：用三个等号 === 比较，除了比较值，也比较类型。例如，"42" 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 "false" 是一个字符串。

1『上面阐明了 == 和 === 的关系，PHP 的语法跟 JS 真的很像。』

### 1.7 PHP 字符串函数

字符串是字符序列，比如 "Hello world!"。字符串函数。在本节中，我们将学习常用的字符串操作函数。

1、strlen() 函数。strlen() 函数返回字符串的长度，以字符计。

提示：strlen() 常用于循环和其他函数，在确定字符串何时结束很重要时。（例如，在循环中，我们也许需要在字符串的最后一个字符之后停止循环）。对字符串中的单词计数。

2、str\_word\_count() 函数对字符串中的单词进行计数：

```php
<?php
echo str_word_count("Hello world!"); // 输出 2
?>
```

3、反转字符串，strrev() 函数反转字符串：

```php
<?php
echo strrev("Hello world!"); // 输出 !dlrow olleH
?>
```

4、strpos() 函数。strpos() 函数用于检索字符串内指定的字符或文本。如果找到匹配，则会返回首个匹配的字符位置。如果未找到匹配，则将返回 FALSE。下例检索字符串 "Hello world!" 中的文本 "world"：

```php
<?php
echo strpos("Hello world!","world");
?>
```

以上代码的输出是：6。提示：上例中字符串 "world" 的位置是 6。是 6（而不是 7）的理由是，字符串中首字符的位置是 0 而不是 1。替换字符串中的文本。

1『字符串的操作可以类比于数组的操作。』

5、str_replace() 函数用一些字符串替换字符串中的另一些字符。下面的例子用 "Kitty" 替换文本 "world"：

```php
<?php
echo str_replace("world", "Kitty", "Hello world!"); // 输出 Hello Kitty!
?>
```

6、PHP 并置运算符。在 PHP 中，只有一个字符串运算符。并置运算符 . 用于把两个字符串值连接起来。下面的实例演示了如何将两个字符串变量连接在一起：

```php
<?php
$txt1="Hello world!";
$txt2="What a nice day!";
echo $txt1 . " " . $txt2;
?>
```

上面的代码将输出：Hello world! What a nice day! 

提示：在上面的代码中，我们已经使用了两次并置运算符。这是由于我们需要在两个字符串之间插入一个空格。

3『

[PHP 5 String 函数](https://www.w3school.com.cn/php/php_ref_string.asp)

```php
public static function search($keyword){
    return self::query()
        ->where('bigclass', $keyword)
        ->orwhere('title', $keyword)
        ->orwhere('bigclass', 'like', '%' . $keyword . '%')
        ->orwhere('title', 'like', '%' . $keyword . '%')
        ->select(self::$_field)
        ->get();
}
```

做设备 api 筛选数据的时候，当时没细想「点」的含义，原来是并置运算符，用来连接字符串的。

』

### 1.8 PHP 常量

常量类似变量，但是常量一旦被定义就无法更改或撤销定义。常量是单个值的标识符（名称）。在脚本中无法改变该值。有效的常量名以字符或下划线开头（常量名称前面没有 \$ 符号）。注释：与变量不同，常量贯穿整个脚本是自动全局的。

设置 PHP 常量。如需设置常量，请使用 define() 函数 - 它使用三个参数：1）首个参数定义常量的名称。2）第二个参数定义常量的值。3）可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。下例创建了一个对大小写敏感的常量，值为 "Welcome to W3School.com.cn!"：

```php
<?php
define("GREETING", "Welcome to W3School.com.cn!");
echo GREETING;
?>
```

下例创建了一个对大小写不敏感的常量，值为 "Welcome to W3School.com.cn!"：

```php
<?php
define("GREETING", "Welcome to W3School.com.cn!", true);
echo greeting;
?>
```

下面的例子在函数内使用了一个常量，即使它在函数外定义：

```php
<?php
define("GREETING", "Welcome to W3School.com.cn!");

function myTest() {
    echo GREETING;
}
 
myTest();
?>
```

1『常量名全部大写。』

### 1.9 PHP 运算符

本节展示了可用于 PHP 脚本中的各种运算符。

1、PHP 算数运算符。下例展示了使用不同算数运算符的不同结果。（简单的加减乘除）

2、PHP 赋值运算符。PHP 赋值运算符用于向变量写值。PHP 中基础的赋值运算符是 "="。这意味着右侧赋值表达式会为左侧运算数设置值。下例展示了使用不同赋值运算符的不同结果：

```php
<?php 
$x=17; 
echo $x; // 输出 17

$y=17; 
$y += 8;
echo $y; // 输出 25

$z=17;
$z -= 8;
echo $z; // 输出 9

$i=17;
$i *= 8;
echo $i; // 输出 136

$j=17;
$j /= 8;
echo $j; // 输出 2.125

$k=17;
$k %= 8;
echo $k; // 输出 1
?>
```

3、PHP 字符串运算符。下例展示了使用字符串运算符的结果：

```php
<?php
$a = "Hello";
$b = $a . " world!";
echo $b; // 输出 Hello world!

$x="Hello";
$x .= " world!";
echo $x; // 输出 Hello world!
?>
```

4、PHP 递增 / 递减运算符。下例展示了使用不同递增 / 递减运算符的不同结果：

```php
<?php
$x=17; 
echo ++$x; // 输出 18

$y=17; 
echo $y++; // 输出 17

$z=17;
echo --$z; // 输出 16

$i=17;
echo $i--; // 输出 17
?>
```

3『 [PHP: 递增／递减运算符 - Manual](https://www.php.net/manual/zh/language.operators.increment.php)

PHP 支持 C 风格的前／后递增与递减运算符。递增／递减运算符不影响布尔值。递减 NULL 值也没有效果，但是递增 NULL 的结果是 1。

```
++$a	前加	$a 的值加一，然后返回 $a。
$a++	后加返回 $a，然后将 $a 的值加一。
--$a	前减	$a 的值减一， 然后返回 $a。
$a--	后减返回 $a，然后将 $a 的值减一。
```

』

5、PHP 比较运算符。PHP 比较运算符用于比较两个值（数字或字符串）；下例展示了使用某些比较运算符的不同结果。

3『 [PHP: 比较运算符 - Manual](https://www.php.net/manual/zh/language.operators.comparison.php)

```php
$a == $b	等于	TRUE，如果类型转换后 $a 等于 $b。
$a === $b	全等	TRUE，如果 $a 等于 $b，并且它们的类型也相同。
$a != $b	不等	TRUE，如果类型转换后 $a 不等于 $b。
$a <> $b	不等	TRUE，如果类型转换后 $a 不等于 $b。
$a !== $b	不全等	TRUE，如果 $a 不等于 $b，或者它们的类型不同。
$a < $b	小与	TRUE，如果 $a 严格小于 $b。
$a > $b	大于	TRUE，如果 $a 严格大于 $b。
$a <= $b	小于等于	TRUE，如果 $a 小于或者等于 $b。
$a >= $b	大于等于	TRUE，如果 $a 大于或者等于 $b。
$a <=> $b	结合比较运算符，当 $a 小于、等于、大于 than $b 时，分别返回一个小于、等于、大于 0 的 integer 值。 PHP7 开始提供。
```

』

6、PHP 逻辑运算符。

3『 [PHP: 逻辑运算符 - Manual](https://www.php.net/manual/zh/language.operators.logical.php)

```php
$a and $b	And（逻辑与）	TRUE，如果 $a 和 $b 都为 TRUE。
$a or $b	Or（逻辑或）	TRUE，如果 $a 或 $b 任一为 TRUE。
$a xor $b	Xor（逻辑异或）	TRUE，如果 $a 或 $b 任一为 TRUE，但不同时是。
! $a	Not（逻辑非）	TRUE，如果 $a 不为 TRUE。
$a && $b	And（逻辑与）	TRUE，如果 $a 和 $b 都为 TRUE。
$a || $b	Or（逻辑或）	TRUE，如果 $a 或 $b 任一为 TRUE。
```
』

7、PHP 数组运算符。PHP 数组运算符用于比较数组；下例展示了使用不同数组运算符的不同结果：

```php
<?php
$x = array("a" => "apple", "b" => "banana"); 
$y = array("c" => "orange", "d" => "peach"); 
$z = $x + $y; // $x 与 $y 的联合
var_dump($z);
var_dump($x == $y);
var_dump($x === $y);
var_dump($x != $y);
var_dump($x <> $y);
var_dump($x !== $y);
?>
```

3『 [PHP: 数组运算符 - Manual](https://www.php.net/manual/zh/language.operators.array.php)

```php
$a + $b	联合	$a 和 $b 的联合。
$a == $b	相等	如果 $a 和 $b 具有相同的键／值对则为 TRUE。
$a === $b	全等	如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。
$a != $b	不等	如果 $a 不等于 $b 则为 TRUE。
$a <> $b	不等	如果 $a 不等于 $b 则为 TRUE。
$a !== $b	不全等	如果 $a 不全等于 $b 则为 TRUE。
```
』


8、三元运算符。另一个条件运算符是 ?:（或三元）运算符 。

```php
(expr1) ? (expr2) : (expr3) 
```

对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。以下实例中通过判断 \$_GET 请求中含有 user 值。

如果有返回 \$_GET['user']，否则返回 nobody：

```php
<?php
$test = '菜鸟教程';
// 普通写法
$username = isset($test) ? $test : 'nobody';
echo $username, PHP_EOL;
 
// PHP 5.3+ 版本写法
$username = $test ?: 'nobody';
echo $username, PHP_EOL;
?>

//输出
菜鸟教程
菜鸟教程
```

注意：PHP_EOL 是一个换行符，兼容更大平台。在 PHP7+ 版本多了一个 NULL 合并运算符 ??，实例如下：

```php
<?php
// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值
$username = $_GET['user'] ?? 'nobody';
// 类似的三元运算符
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';
?>
```

9、组合比较符（PHP7+）。PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 <=>。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。语法格式如下：

```php
$c = $a <=> $b;
```

解析如下：1）如果 \$a > \$b, 则 \$c 的值为 1。2）如果 \$a == \$b, 则 \$c 的值为 0。3）如果 \$a < \$b, 则 \$c 的值为 -1。

```php
<?php
// 整型
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// 浮点型
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// 字符串
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
?>
```

10、运算符优先级。下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。运算符优先级中，or 和 ||，&& 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。

1『原来一直以为只是写法不同，原来这几个逻辑符的优先级也不相同。（2020-06-05）』

```php
<?php
// 优先级： &&  >  =  >  and
// 优先级： ||  >  =  >  or
 
$a = 3;
$b = false;
$c = $a or $b;
var_dump($c);          // 这里的 $c 为 int 值3，而不是 boolean 值 true
$d = $a || $b;
var_dump($d);          //这里的 $d 就是 boolean 值 true 
?>
```

括号的使用。我们通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。

### 1.10 if...else...elseif 语句

条件语句用于基于不同条件执行不同的动作。PHP 条件语句。在您编写代码时，经常会希望为不同的决定执行不同的动作。您可以在代码中使用条件语句来实现这一点。在 PHP 中，我们可以使用以下条件语句：1）if 语句 —— 如果指定条件为真，则执行代码；2）if...else 语句 —— 如果条件为 true，则执行代码；如果条件为 false，则执行另一端代码；3）if...elseif....else 语句 —— 根据两个以上的条件执行不同的代码块；4）switch 语句 —— 选择多个代码块之一来执行。

1、PHP —— if 语句。if 语句用于在指定条件为 true 时执行代码。

```php
if (条件) {
  当条件为 true 时执行的代码;
}
```

下例将输出 "Have a good day!"，如果当前时间 (HOUR) 小于 20：

```php
<?php
$t=date("H");

if ($t<"20") {
  echo "Have a good day!";
}
?>
```

2、PHP —— if...else 语句。请使用 if....else 语句在条件为 true 时执行代码，在条件为 false 时执行另一段代码。

```php
if (条件) {
  条件为 true 时执行的代码;
} else {
  条件为 false 时执行的代码;
}
```

如果当前时间 (HOUR) 小于 20，下例将输出 "Have a good day!"，否则输出 "Have a good night!"：

```php
<?php
$t=date("H");

if ($t<"20") {
  echo "Have a good day!";
} else {
  echo "Have a good night!";
}
?>
```

3、PHP —— if...elseif....else 语句。请使用 if....elseif...else 语句来根据两个以上的条件执行不同的代码。

```php
if (条件) {
  条件为 true 时执行的代码;
} elseif (condition) {
  条件为 true 时执行的代码;
} else {
  条件为 false 时执行的代码;
}
```

如果当前时间 (HOUR) 小于 10，下例将输出 "Have a good morning!"，如果当前时间小于 20，则输出 "Have a good day!"。否则将输出 "Have a good night!"：

```php
<?php
$t=date("H");

if ($t<"10") {
  echo "Have a good morning!";
} elseif ($t<"20") {
  echo "Have a good day!";
} else {
  echo "Have a good night!";
}
?>
```

### 1.11 Switch 语句

switch 语句用于基于不同条件执行不同动作。如果您希望有选择地执行若干代码块之一，请使用 Switch 语句。使用 Switch 语句可以避免冗长的 if..elseif..else 代码块。

```php
switch (expression)
{
case label1:
  expression（label1 时执行的代码）;
  break;  
case label2:
  expression（label2 时执行的代码）;
  break;
default:
  表达式的值不等于 label1 及 label2 时执行的代码;
}
```

工作原理：1）对表达式（通常是变量）进行一次计算；2）把表达式的值与结构中 case 的值进行比较；3）如果存在匹配，则执行与 case 关联的代码；4）代码执行后，break 语句阻止代码跳入下一个 case 中继续执行；5）如果没有 case 为真，则使用 default 语句。

```php
<?php
$favfruit="orange";

switch ($favfruit) {
   case "apple":
     echo "Your favorite fruit is apple!";
     break;
   case "banana":
     echo "Your favorite fruit is banana!";
     break;
   case "orange":
     echo "Your favorite fruit is orange!";
     break;
   default:
     echo "Your favorite fruit is neither apple, banana, or orange!";
}
?>
```

### 1.12 PHP while 循环

PHP while 循环在指定条件为 true 时执行代码块。PHP 循环。在您编写代码时，经常需要反复运行同一代码块。我们可以使用循环来执行这样的任务，而不是在脚本中添加若干几乎相等的代码行。在 PHP 中，我们有以下循环语句：1）while —— 只要指定条件为真，则循环代码块；2）do...while —— 先执行一次代码块，然后只要指定条件为真则重复循环；3）for —— 循环代码块指定次数；4）foreach —— 遍历数组中的每个元素并循环代码块。

1、PHP while 循环。只要指定的条件为真，while 循环就会执行代码块。

```php
while (条件为真) {
  要执行的代码;
}
```

下例首先把变量 \$x 设置为 1（\$x=1）。然后执行 while 循环，只要 \$x 小于或等于 5。循环每运行一次，\$x 将递增 1：

```php
<?php 
$x=1; 

while($x<=5) {
  echo "这个数字是：$x <br>";
  $x++;
} 
?>
```

2、PHP do...while 循环。do...while 循环首先会执行一次代码块，然后检查条件，如果指定条件为真，则重复循环。

```php
do {
  要执行的代码;
} while (条件为真);
```

下面的例子首先把变量 \$x 设置为 1（\$x=1）。然后，do while 循环输出一段字符串，然后对变量 \$x 递增 1。随后对条件进行检查（\$x 是否小于或等于 5）。只要 \$x 小于或等于 5，循环将会继续运行：

```php
<?php 
$x=1; 

do {
  echo "这个数字是：$x <br>";
  $x++;
} while ($x<=5);
?>
```

请注意，do while 循环只在执行循环内的语句之后才对条件进行测试。这意味着 do while 循环至少会执行一次语句，即使条件测试在第一次就失败了。下面的例子把 \$x 设置为 6，然后运行循环，随后对条件进行检查：

```php
<?php 
$x=6;

do {
  echo "这个数字是：$x <br>";
  $x++;
} while ($x<=5);
?>
```

3、PHP for 循环。PHP for 循环执行代码块指定的次数。如果您已经提前确定脚本运行的次数，可以使用 for 循环。

```php
for (init counter; test counter; increment counter) {
  code to be executed;
}
```

参数：1）init counter：初始化循环计数器的值；2）test counter：评估每个循环迭代。如果值为 TRUE，继续循环。如果它的值为 FALSE，循环结束；3）increment counter：增加循环计数器的值。下面的例子显示了从 0 到 10 的数字：

```php
<?php 
for ($x=0; $x<=10; $x++) {
  echo "数字是：$x <br>";
} 
?>
```

4、PHP foreach 循环。foreach 循环只适用于数组，并用于遍历数组中的每个键 / 值对。

```php
foreach ($array as $value) {
  code to be executed;
}
```

每进行一次循环迭代，当前数组元素的值就会被赋值给 \$value 变量，并且数组指针会逐一地移动，直到到达最后一个数组元素。下面的例子演示的循环将输出给定数组（\$colors）的值：

```php
<?php 
$colors = array("red","green","blue","yellow"); 

foreach ($colors as $value) {
  echo "$value <br>";
}
?>
```

1『对应于 python 里的「for in」以及 JS 里的「for(let item of itemData) {}」。』

### 1.13 PHP 函数

PHP 的真正力量来自它的函数：它拥有超过 1000 个内建的函数。PHP 用户定义函数：1）除了内建的 PHP 函数，我们可以创建我们自己的函数。2）函数是可以在程序中重复使用的语句块。3）页面加载时函数不会立即执行。4）函数只有在被调用时才会执行。

1、在 PHP 创建用户定义函数。用户定义的函数声明以单词 "function" 开头：

```php
function functionName() {
  被执行的代码;
}
```

注释：函数名能够以字母或下划线开头（而非数字）。函数名对大小写不敏感。提示：函数名应该能够反映函数所执行的任务。

1『内置函数这方面，PHP 的确占优，毕竟有 1000 多个内置函数。所以遇到要实现的功能，第一反应应该去找内置函数，看看能否直接实现或者组合一下也可实现。（2020-06-05）』

在下面的例子中，我们创建名为 "writeMsg()" 的函数。打开的花括号 { 指示函数代码的开始，而关闭的花括号 } 指示函数的结束。此函数输出 "Hello world!"。如需调用该函数，只要使用函数名即可。

2、PHP 函数参数。可以通过参数向函数传递信息。参数类似变量。参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。下面的例子中的函数有一个参数（\$fname）。当调用 familyName() 函数时，我们同时要传递一个名字（例如 Bill），这样会输出不同的名字，但是姓氏相同。

3、PHP 默认参数值。下面的例子展示了如何使用默认参数。如果我们调用没有参数的 setHeight() 函数，它的参数会取默认值：

```php
<?php
function setHeight($minheight=50) {
  echo "The height is : $minheight <br>";
}

setHeight(350);
setHeight(); // 将使用默认值 50
setHeight(135);
setHeight(80);
?>
```

4、PHP 函数 —— 返回值。如需使函数返回值，请使用 return 语句：

```php
<?php
function sum($x,$y) {
  $z=$x+$y;
  return $z;
}

echo "5 + 10 = " . sum(5,10) . "<br>";
echo "7 + 13 = " . sum(7,13) . "<br>";
echo "2 + 4 = " . sum(2,4);
?>
```

### 1.14 PHP 数组

数组能够在单独的变量名中存储一个或多个值。数组在单个变量中存储多个值：

```php
<?php
$cars=array("porsche","BMW","Volvo");
echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";
?>
```

什么是数组？数组是特殊的变量，它可以同时保存一个以上的值。如果您有一个项目列表（例如汽车品牌列表），在单个变量中存储这些品牌名称是这样的：

```php
$cars1="porsche";
$cars2="BMW";
$cars3="Volvo";
```

不过，假如您希望对变量进行遍历并找出特定的那个值？或者如果您需要存储 300 个汽车品牌，而不是 3 个呢？解决方法是创建数组！数组能够在单一变量名中存储许多值，并且您能够通过引用索引号来访问某个值。在 PHP 中创建数组。在 PHP 中，array() 函数用于创建数组。

在 PHP 中，有三种数组类型：1）索引数组 —— 带有数字索引的数组；2）关联数组 —— 带有指定键的数组；3）多维数组 —— 包含一个或多个数组的数组。

1、PHP 索引数组。有两种创建索引数组的方法，索引是自动分配的（索引从 0 开始）：

    $cars=array("porsche","BMW","Volvo");

或者也可以手动分配索引：

```php
$cars[0]="porsche";
$cars[1]="BMW";
$cars[2]="Volvo";
```

获得数组的长度 —— count() 函数。count() 函数用于返回数组的长度（元素数）：

```php
<?php
$cars=array("porsche","BMW","Volvo");
echo count($cars);
?>
```

遍历索引数组。如需遍历并输出索引数组的所有值，您可以使用 for 循环，就像这样：

```php
<?php
$cars=array("porsche","BMW","Volvo");
$arrlength=count($cars);

for($x=0;$x<$arrlength;$x++) {
  echo $cars[$x];
  echo "<br>";
}
?>
```

1『这是最原始的遍历，不推荐，用 foreach 要比它好，应该还有比 foreach 更好的实现方式，脑子里得有这根弦。（2020-06-05）』

2、PHP 关联数组。关联数组是使用您分配给数组的指定键的数组。有两种创建关联数组的方法：

1『关联数据对应于字典的概念。php 里关联数组的声明要用胖箭头 =>。』

    $age=array("Bill"=>"35","Steve"=>"37","Elon"=>"43");

或者：

```php
$age['Bill']="63";
$age['Steve']="56";
$age['Elon']="47";
```

1『 php 7 里还可以用中括号结合胖箭头来构建数组，用这个方法好。（2020-06-05）』

遍历关联数组。如需遍历并输出关联数组的所有值，您可以使用 foreach 循环，就像这样：

```php
<?php
$age=array("Bill"=>"63","Steve"=>"56","Elon"=>"47");

foreach($age as $x=>$x_value) {
  echo "Key=" . $x . ", Value=" . $x_value;
  echo "<br>";
}
?>
```

3、多维数组。我们将在 PHP 高级教程中讲解多维数组。如需完整的数组函数参考手册，请访问我们的 PHP 数组参考手册。该参考手册包含每个函数的简要描述、使用示例：[PHP Array 函数](https://www.w3school.com.cn/php/php_ref_array.asp)。

3『

[ PHP 中的符号 ->、=> 和 :: 分别表示什么意思？以及 this, self, parent 三个关键字的理解](https://segmentfault.com/a/1190000008600674)

### ->, => 和 :: 的区别

-> 前面的变量是一个对象：

```php
// 取对象的 friends_count 属性
$user -> friends_count

// 调用对象的 homeTimeline 方法，方法中传入一个参数 $p
t -> homeTimeline(p)
```

1『 -> 是用来调对象属性用的。对象和类的概念一定要弄的明明白白。（2020-06-05）』

如果你有 C++，Perl 基础，你会发现这些家伙和他们里面的一些符号功能是差不多的。-> 符号是「插入式解引用操作符」（infix dereference operator）。换句话说，它是调用由引用传递参数的子程序的方法（当然，还有其它的作用）。正如我们上面所提到的，在调用 PHP 的函数的时候，大部分参数都是通过引用传递的。PHP 中的 -> 功能就和它们在 Perl 或 C++ 中一样。

在 PHP 的脚本中 => 操作符时很常见的。因为 php 数组函数很丰富，我们要经常用到数组，因为它操作数据很方便。顺便说一下，如果你需要用数字「大于等于」的符号，你应该用「>=」而不是「=>」。

在 PHP 中「::」这个叫范围解析操作符，又名域运算符。「::」符号可以认为是与 C 语言中的「.」相似的，而它更像 C++ 中（Perl）的：类范围操作符。php 调用类的内部静态成员，或者是类之间调用就要用「::」符号。

```php
class A
{
    static $count = 0;
    static function haha()
    {
        //
    }  
    function diaoyoug()
        {
            self::haha();
            self::$count;
        }
}
a.b.c; /* C语言中的 */
a::b::c(); // C++ 中的函数
$a::b::c; # Perl 5中的标量
```

官方文档信息：[PHP: 范围解析操作符 （::） - Manual](https://www.php.net/manual/zh/language.oop5.paamayim-nekudotayim.php)

范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问静态成员，类常量，还可以用于覆盖类中的属性和方法。当在类定义之外引用到这些项目时，要使用类名。自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 self，parent 和 static）。把 Paamayim Nekudotayim 选作双冒号操作符的名字似乎有些奇怪。然而，这是 Zend 开发小组在写 Zend Engine 0.5（被用于 PHP 3 中）时所作出的决定。事实上这个词在希伯莱文就是双冒号的意思。

### this, self, parent 

三个关键字从字面上比较好理解，分别是指这、自己、父亲。1）this 是指向当前对象的指针（姑且用 C 里面的指针来看吧）。\==>this 是指向当前对象实例的指针，不指向任何其他对象或类。2）self 是指向当前类的指针。\==>self 是指向类本身，也就是 self 是不指向任何已经实例化的对象，一般 self 使用来指向类中的静态变量。3）parent 是指向父类的指针。（我们这里频繁使用指针来描述，是因为没有更好的语言来表达）

1、this。

```php
1 <?php
2
3 class UserName
4 { 
5     //定义成员属性 
6     private $name;
7 
8     //定义构造函数
9     function __construct( $name )
10     {
11          $this->name = $name; //这里已经使用了this指针
12     }
13 
14     //析构函数
15     function __destruct(){}
16
17     //打印用户名成员函数
18     function printName()
19     {
20          print( $this->name ); //又使用了this指针
21     }
22 }
23
24 //实例化对象
25 $nameObject = new UserName("heiyeluren");
26
27 //执行打印
28 $nameObject->printName(); //输出: heiyeluren
29
30 //第二次实例化对象
31 $nameObject2 = new UserName( "PHP5" );
32
33 //执行打印
34 $nameObject2->printName(); //输出：PHP5
35 ?>
```

我们看，上面的类分别在 11 行和 20 行使用了 this 指针，那么当时 this 是指向谁呢？其实 this 是在实例化的时候来确定指向谁，比如第一次实例化对象 的时候（25 行），那么当时 this 就是指向 nameObject 对象。那么执行 18 行打印的时候就把 print(\$this->name) 变成 print(\$nameObject->name)，输出的打印是 "heiyeluren"。第二次的实例化雷同。所以说，this 就是指向当前对象实例的指针，不指向任何其他对象或类。

1『通过构造函数创建的对象，this 绑定值跟 JS 里的一样，绑定到该创建的对象上（实例化的对象）。』

2、self。首先我们要明确一点，self 是指向类本身，也就是 self 是不指向任何已经实例化的对象，一般 self 使用来指向类中的静态变量。

```php
1 <?php
2
3     class Counter
4     {
5         //定义属性，包括一个静态变量
6         private static $firstCount = 0;
7         private $lastCount;
8
9         //构造函数
10         function __construct()
11         {
12              $this->lastCount = ++selft::$firstCount; //使用 self 来调用静态变量，使用 self 调用必须使用 ::（域运算符号）
13         }
14
15         //打印最次数值
16         function printLastCount()
17         {
18              print( $this->lastCount );
19         } 
20     }
21
22 //实例化对象
23 $countObject = new Counter();
24
25 $countObject->printLastCount(); //输出 1
26
27 ?>
```

我们这里只要注意两个地方，第 6 行和第 12 行。我们在第 6 行定义了一个静态变量 firstCount，我们的静态变量与下面对象的实例无关，它只是跟类有关，那么我调用类本身的，那么我们就无法使用 this 来引用，可以使用 self 来引用，因为 self 是指向类本身，与任何对象实例无关。换句话说，假如我们的类里面静态的成员，我们也必须使用 self 来调用。

3、parent。我们知道 parent 是指向父类的指针，一般我们使用 parent 来调用父类的构造函数。

```php
1 <?php
2
3 //基类
4 class Animal
5 {
6     //基类的属性
7     public $name; //名字
8
9     //基类的构造函数
10     public function __construct( $name )
11     {
12          $this->name = $name;
13     }
14 }
15
16 //派生类
17 class Person extends Animal //Person类继承了Animal类
18 {
19     public $personSex; //性别
20     public $personAge; //年龄
21
22     //继承类的构造函数
23     function __construct( $personSex, $personAge )
24     {
25          parent::__construct("heiyeluren"); //使用parent调用了父类的构造函数
26          $this->personSex = $personSex;
27          $this->personAge = $personAge;
28     }
29
30     function printPerson()
31     {
32          print( $this->name. " is " .$this->personSex. ",this year " .$this->personAge );
33      }
34 }
35
36 //实例化Person对象
37 $personObject = new Person( "male", "21");
38
39 //执行打印
40 $personObject->printPerson(); //输出：heiyeluren is male,this year 21
41
42 ?>
```

我们注意这么几个细节：成员属性都是 public 的，特别是父类的，是为了供继承类通过 this 来访问。我们注意关键的地方，第 25 行： parent::__construct ("heiyeluren")，这时候我们就使用 parent 来调用父类的构造函数进行对父类的初始化，因为父类的成员都是 public 的，于是我们就能够在继承类中直接使用 this 来调用。

总结：this 是指向对象实例的一个指针，self 是对类本身的一个引用，parent 是对父类的引用。

』

1『

```php
<?php
$a = array(
  'a'=>'dalong',
  3=>23,
  345,
  'name'=>'xiaoming',
  2367,
  'test',
  'haha',
);
echo $a[6];

?>
```

输出的是「test」，a[7] 输出的是「haha」。传入键的和没传入键的索引分开的，有键的之间通过键定位，比如 a['name']，没键的按整数索引来，a[3] 是「23」，a[4] 是「345」，a[5] 是「2367」，a[6] 是「test」，a[7] 是「haha」。

回复自己：之前这么理解也是没错的，但遗漏了一个关键点：如果构建时没有索引，系统会自动分配一个整数索引，该整数索引是在原数组中存在的最大索引加 1。上面例子里，已有的最大索引是 3，所以当遇到「345」时，系统分配的索引是 4，依次类推。

』

### 1.15 PHP 数组排序

数组中的元素能够以字母或数字顺序进行升序或降序排序。PHP 数组排序函数：1）sort() —— 以升序对数组排序。2）rsort() —— 以降序对数组排序。3）asort() —— 根据值，以升序对关联数组进行排序。4）ksort() —— 根据键，以升序对关联数组进行排序。5）arsort() —— 根据值，以降序对关联数组进行排序。6）krsort() —— 根据键，以降序对关联数组进行排序。

如需完整的数组函数参考手册，请访问我们的 PHP 数组参考手册。该参考手册包含每个函数的简要描述、使用示例：[PHP Array 函数](https://www.w3school.com.cn/php/php_ref_array.asp)。

### 1.16 PHP 全局变量 —— 超全局变量

超全局变量在 PHP 4.1.0 中引入，是在全部作用域中始终可用的内置变量。PHP 全局变量 —— 超全局变量。PHP 中的许多预定义变量都是「超全局的」，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global \$variable; 就可以访问它们。这些超全局变量是：

```php
$GLOBALS
$_SERVER
$_REQUEST
$_POST
$_GET
$_FILES
$_ENV
$_COOKIE
$_SESSION
```

本节会介绍一些超全局变量，并会在稍后的章节讲解其他的超全局变量。

1、\$GLOBALS —— 引用全局作用域中可用的全部变量。\$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。PHP 在名为 \$GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。下面的例子展示了如何使用超级全局变量 \$GLOBALS：

```php
<?php 
$x = 75; 
$y = 25;
 
function addition() { 
  $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; 
}
 
addition(); 
echo $z; 
?>
```

在上面的例子中，由于 z 是 \$GLOBALS 数组中的变量，因此在函数之外也可以访问它。

2、\$_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息。下面的例子展示了如何使用 \_SERVER 中的某些元素：

```php
<?php 
echo $_SERVER['PHP_SELF'];
echo "<br>";
echo $_SERVER['SERVER_NAME'];
echo "<br>";
echo $_SERVER['HTTP_HOST'];
echo "<br>";
echo $_SERVER['HTTP_REFERER'];
echo "<br>";
echo $_SERVER['HTTP_USER_AGENT'];
echo "<br>";
echo $_SERVER['SCRIPT_NAME'];
?>
```

下表列出了您能够在 \$_SERVER 中访问的最重要的元素：

3、PHP \$_REQUEST 用于收集 HTML 表单提交的数据。

下面的例子展示了一个包含输入字段及提交按钮的表单。当用户通过点击提交按钮来提交表单数据时，表单数据将发送到 \<form> 标签的 action 属性中指定的脚本文件。在这个例子中，我们指定文件本身来处理表单数据。如果您需要使用其他的 PHP 文件来处理表单数据，请修改为您选择的文件名即可。然后，我们可以使用超级全局变量 \$_REQUEST 来收集 input 字段的值：

```php
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = $_REQUEST['fname']; 
echo $name; 
?>

</body>
</html>
```

1『语句 echo \$_SERVER['PHP_SELF']; 表示指定文件本身来处理表单数据。』

4、PHP \$_POST 广泛用于收集提交 method="post" 的 HTML 表单后的表单数据。\_POST 也常用于传递变量。

下面的例子展示了一个包含输入字段和提交按钮的表单。当用户点击提交按钮来提交数据后，表单数据会发送到 \<form> 标签的 action 属性中指定的文件。在本例中，我们指定文件本身来处理表单数据。然后，我们可以使用超全局变量 \$_POST 来收集输入字段的值：

```php
<html>
<body>

<form method="post" action="<?php echo $_SERVER['PHP_SELF'];?>">
Name: <input type="text" name="fname">
<input type="submit">
</form>

<?php 
$name = $_POST['fname'];
echo $name; 
?>

</body>
</html>
```

5、PHP \$_GET 也可用于收集提交 HTML 表单 (method="get") 之后的表单数据。\_GET 也可以收集 URL 中的发送的数据。假设我们有一张页面含有带参数的超链接：

```html
<html>
<body>
<a href="test_get.php?subject=PHP&web=W3school.com.cn">测试 $GET</a>
</body>
</html>
```

当用户点击链接 "测试 \$GET"，参数 "subject" 和 "web" 被发送到 "test_get.php"，然后您就能够通过 \$_GET 在 "test_get.php" 中访问这些值了。下面的例子是 "test_get.php" 中的代码：

1『关键信息。如果 url = "test_get.php?subject=PHP&web=W3school.com.cn"，那么表示参数 "subject" 和 "web" 被发送到 "test_get.php"。』

```php
<html>
<body>

<?php 
echo "在 " . $_GET['web'] . " 学习 " . $_GET['subject'];
?>

</body>
</html>
```

### 1.17 PHP EOF(heredoc) 使用说明

PHP EOF(heredoc) 是一种在命令行 shell（如 sh、csh、ksh、bash、PowerShell 和 zsh）和程序语言（像 Perl、PHP、Python和Ruby）里定义一个字符串的方法。

使用概述：1）必须后接分号，否则编译通不过。2）EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。3）结束标识必须顶格独自占一行（即必须从行首开始，前后不能衔接任何空白和字符）。4）开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。5）当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与 q 和 qq 的用法。

```php
<?php
echo <<<EOF
        <h1>我的第一个标题</h1>
        <p>我的第一个段落。</p>
EOF;
// 结束需要独立一行且前后不能空格
?>
```

注意：1）以 <<<EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。2）开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个（也可以用：JSON、HTML等），只要保证开始标记和结束标记不在正文中出现即可。3）位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在 heredoc 中，变量不需要用连接符 . 或 , 来拼接，如下：

```php
<?php
$name="runoob";
$a= <<<EOF
        "abc"$name
        "123"
EOF;
// 结束需要独立一行且前后不能空格
echo $a;
?>
```

3『

PHP 定界符 EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在 PHP 定界符 EOF 中的任何特殊字符都不需要转义。

补充一下上一个笔记的内容，EOF 中是会解析 html 格式内容的，并且在双引号内的内容也有转义效果。具体见下面例子:

```php
<?php
$name="变量会被解析";
$a=<<<EOF
$name<br><a>html格式会被解析</a><br/>双引号和Html格式外的其他内容都不会被解析
"双引号外所有被排列好的格式都会被保留"
"但是双引号内会保留转义符的转义效果,比如table:\t和换行：\n下一行"
EOF;
echo $a;
?>  
```

加不加引号转义字符都有效。

』

1『目前还是不理解 EOF 的具体使用场景。（2020-06-05）』

### 1.18 PHP 魔术常量

PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 \_\_LINE__ 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下：

1『扩展库的概念类似于 Python 的包？』

1、\_\_LINE__，文件中的当前行号。

```php
<?php
echo '这是第 " '  . __LINE__ . ' " 行';
?>
```

以上实例输出结果为：

    这是第 “ 2 ” 行

2、\_\_FILE\_\_，文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，\_\_FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。

```php
<?php
echo '该文件位于 " '  . __FILE__ . ' " ';
?>
```

以上实例输出结果为：

    该文件位于 “E:\wamp\www\test\index.php”

3、\_\_DIR\_\_，文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(\_\_FILE\_\_)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）

```php
<?php
echo '该文件位于 " '  . __DIR__ . ' " ';
?>
```

以上实例输出结果为：

    该文件位于 “E:\wamp\www\test”

4、\_\_FUNCTION__，函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。

```php
<?php
function test() {
    echo  '函数名为：' . __FUNCTION__ ;
}
test();
?>
```

以上实例输出结果为：

    函数名为：test

5、\_\_CLASS\_\_，类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。

注意自 PHP 5.4 起 \_\_CLASS__ 对 trait 也起作用。当用在 trait 方法中时，\_\_CLASS__ 是调用 trait 方法的类的名字。

```php
<?php
class test {
    function _print() {
        echo '类名为：'  . __CLASS__ . "<br>";
        echo  '函数名为：' . __FUNCTION__ ;
    }
}
$t = new test();
$t->_print();
?>
```

以上实例输出结果为：

```php
类名为：test
函数名为：_print
```

6、\_\_TRAIT__，Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。Trait 名包括其被声明的作用区域（例如 Foo\Bar）。从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。

```php
<?php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}
 
trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}
 
class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
?>
```

以上例程会输出：

    Hello World!

7、\_\_METHOD__，类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。

```php
<?php
function test() {
    echo  '函数名为：' . __METHOD__ ;
}
test();
?>
```

以上实例输出结果为：

    函数名为：test

8、\_\_NAMESPACE__，当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。

```php
<?php
namespace MyProject;
 
echo '命名空间为："', __NAMESPACE__, '"'; // 输出 "MyProject"
?>
```

以上实例输出结果为：

    命名空间为："MyProject"

### 1.19 PHP 命名空间（namespace）

PHP 命名空间（namespace）是在 PHP 5.3 中加入的，如果你学过 C# 和 Java，那命名空间就不算什么新事物。 不过在 PHP 当中还是有着相当重要的意义。命名空间可以解决以下两类问题：1）用户编写的代码与 PHP 内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。2）为很长的标识符名称（通常是为了缓解第一类问题而定义的）创建一个别名（或简短）的名称，提高源代码的可读性。

1、定义命名空间。默认情况下，所有常量、类和函数名都放在全局空间下，就和 PHP 支持命名空间之前一样。命名空间通过关键字 namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。语法格式如下；

```php
<?php  
// 定义代码在 'MyProject' 命名空间中  
namespace MyProject;  
 
// ... 代码 ...  
```

你也可以在同一个文件中定义不同的命名空间代码，如：

```php
<?php  
namespace MyProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }

namespace AnotherProject;

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
?>  
```

不建议使用这种语法在单个文件中定义多个命名空间。建议使用下面的大括号形式的语法。

```php
<?php
namespace MyProject {
    const CONNECT_OK = 1;
    class Connection { /* ... */ }
    function connect() { /* ... */  }
}

namespace AnotherProject {
    const CONNECT_OK = 1;
    class Connection { /* ... */ }
    function connect() { /* ... */  }
}
?>
```

将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如：

```php
<?php
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。

```php
<?php
declare(encoding='UTF-8'); //定义多个命名空间和不包含在命名空间中的代码
namespace MyProject {

const CONNECT_OK = 1;
class Connection { /* ... */ }
function connect() { /* ... */  }
}

namespace { // 全局代码
session_start();
$a = MyProject\connect();
echo MyProject\Connection::start();
}
?>
```

以下代码会出现语法错误：

```php
<html>
<?php
namespace MyProject; // 命名空间前出现了“<html>” 会致命错误 -　命名空间必须是程序脚本的第一条语句
?>
```

2、子命名空间。与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：

```php
<?php
namespace MyProject\Sub\Level;  //声明分层次的单个命名空间

const CONNECT_OK = 1;
class Connection { /* ... */ }
function Connect() { /* ... */  }

?>
```

上面的例子创建了常量 MyProject\Sub\Level\CONNECT_OK，类 MyProject\Sub\Level\Connection 和函数 MyProject\Sub\Level\Connect。

3、命名空间使用。PHP 命名空间中的类名可以通过三种方式引用：

1）非限定名称，或不包含前缀的类名称，例如 \$a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为 foo。警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。

2）限定名称，或包含前缀的名称，例如 \$a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为 subnamespace\foo。

3）完全限定名称，或包含了全局前缀操作符的名称，例如， \$a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名 (literal name)currentnamespace\foo。

下面是一个使用这三种方式的实例：

file1.php 文件代码

```php
<?php
namespace Foo\Bar\subnamespace; 

const FOO = 1;
function foo() {}
class foo
{
    static function staticmethod() {}
}
?>
```

file2.php 文件代码

```php
<?php
namespace Foo\Bar;
include 'file1.php';

const FOO = 2;
function foo() {}
class foo
{
    static function staticmethod() {}
}

/* 非限定名称 */
foo(); // 解析为函数 Foo\Bar\foo
foo::staticmethod(); // 解析为类 Foo\Bar\foo ，方法为 staticmethod
echo FOO; // 解析为常量 Foo\Bar\FOO

/* 限定名称 */
subnamespace\foo(); // 解析为函数 Foo\Bar\subnamespace\foo
subnamespace\foo::staticmethod(); // 解析为类 Foo\Bar\subnamespace\foo,
                                  // 以及类的方法 staticmethod
echo subnamespace\FOO; // 解析为常量 Foo\Bar\subnamespace\FOO
                                  
/* 完全限定名称 */
\Foo\Bar\foo(); // 解析为函数 Foo\Bar\foo
\Foo\Bar\foo::staticmethod(); // 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod
echo \Foo\Bar\FOO; // 解析为常量 Foo\Bar\FOO
?>
```

注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 \strlen() 或 \Exception 或 \INI_ALL。在命名空间内部访问全局类、函数和常量：

```php
<?php
namespace Foo;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('hi'); // 调用全局函数strlen
$b = \INI_ALL; // 访问全局常量 INI_ALL
$c = new \Exception('error'); // 实例化全局类 Exception
?>
```

4、命名空间和动态语言特征。PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。

example1.php 文件代码：

```php
<?php
class classname
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function funcname()
{
    echo __FUNCTION__,"\n";
}
const constname = "global";

$a = 'classname';
$obj = new $a; // prints classname::__construct
$b = 'funcname';
$b(); // prints funcname
echo constant('constname'), "\n"; // prints global
?>
```

必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。动态访问命名空间的元素。

```php
<?php
namespace namespacename;
class classname
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function funcname()
{
    echo __FUNCTION__,"\n";
}
const constname = "namespaced";

include 'example1.php';

$a = 'classname';
$obj = new $a; // 输出 classname::__construct
$b = 'funcname';
$b(); // 输出函数名
echo constant('constname'), "\n"; // 输出 global

/* 如果使用双引号，使用方法为 "\\namespacename\\classname"*/
$a = '\namespacename\classname';
$obj = new $a; // 输出 namespacename\classname::__construct
$a = 'namespacename\classname';
$obj = new $a; // 输出 namespacename\classname::__construct
$b = 'namespacename\funcname';
$b(); // 输出 namespacename\funcname
$b = '\namespacename\funcname';
$b(); // 输出 namespacename\funcname
echo constant('\namespacename\constname'), "\n"; // 输出 namespaced
echo constant('namespacename\constname'), "\n"; // 输出 namespaced
?>
```

5、namespace 关键字和 \_\_NAMESPACE__常量。

PHP 支持两种抽象的访问当前命名空间内部元素的方法，\_\_NAMESPACE__  魔术常量和 namespace 关键字。常量 \_\_NAMESPACE__ 的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。

\_\_NAMESPACE__ 示例，在命名空间中的代码：

```php
<?php
namespace MyProject;

echo '"', __NAMESPACE__, '"'; // 输出 "MyProject"
?>
```

\_\_NAMESPACE__ 示例，全局代码：

```php
<?php

echo '"', __NAMESPACE__, '"'; // 输出 ""
?>
```

常量  \_\_NAMESPACE__ 在动态创建名称时很有用，例如：

使用 \_\_NAMESPACE__ 动态创建名称。

```php
<?php
namespace MyProject;

function get($classname)
{
    $a = __NAMESPACE__ . '\\' . $classname;
    return new $a;
}
?>
```

关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。namespace 操作符，命名空间中的代码:

```php
<?php
namespace MyProject;

use blah\blah as mine; // see "Using namespaces: importing/aliasing"

blah\mine(); // calls function blah\blah\mine()
namespace\blah\mine(); // calls function MyProject\blah\mine()

namespace\func(); // calls function MyProject\func()
namespace\sub\func(); // calls function MyProject\sub\func()
namespace\cname::method(); // calls static method "method" of class MyProject\cname
$a = new namespace\sub\cname(); // instantiates object of class MyProject\sub\cname
$b = namespace\CONSTANT; // assigns value of constant MyProject\CONSTANT to $b
?>
```

namespace 操作符，全局代码：

```php
<?php

namespace\func(); // calls function func()
namespace\sub\func(); // calls function sub\func()
namespace\cname::method(); // calls static method "method" of class cname
$a = new namespace\sub\cname(); // instantiates object of class sub\cname
$b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
?>
```

6、使用命名空间：别名/导入。PHP 命名空间支持，有两种使用别名或导入方式：1）为类名称使用别名，2）或为命名空间名称使用别名。在 PHP 中，别名是通过操作符 use 来实现的。下面是一个使用所有可能的三种导入方式的例子：

1）使用 use 操作符导入 / 使用别名。

```php
<?php
namespace foo;
use My\Full\Classname as Another;

// 下面的例子与 use My\Full\NSname as NSname 相同
use My\Full\NSname;

// 导入一个全局类
use \ArrayObject;

$obj = new namespace\Another; // 实例化 foo\Another 对象
$obj = new Another; // 实例化 My\Full\Classname　对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象
// 如果不使用 "use \ArrayObject" ，则实例化一个 foo\ArrayObject 对象
?>
```

2） 一行中包含多个 use 语句。

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 对象
NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func
?>
```

导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。

3）导入和动态名称。

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化一个 My\Full\Classname 对象
$a = 'Another';
$obj = new $a;      // 实际化一个 Another 对象
?>
```

另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。

4）导入和完全限定名称。

```php
<?php
use My\Full\Classname as Another, My\Full\NSname;

$obj = new Another; // 实例化 My\Full\Classname 类
$obj = new \Another; // 实例化 Another 类
$obj = new Another\thing; // 实例化 My\Full\Classname\thing 类
$obj = new \Another\thing; // 实例化 Another\thing 类
?>
```

1『

```
namespace App\Logic;

use App\Model\ProjectModel;
use App\Model\MonomerModel
```

原来后面的 use 语句都是为了导入其他命名空间，之前竟然没有意识到。（2020-06-05）

』

7、使用命名空间：后备全局函数 / 常量。在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称，例如：

1）在命名空间中访问全局类。

```php
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hi'); // $a 是类 A\B\C\Exception 的一个对象
$b = new \Exception('hi'); // $b 是类 Exception 的一个对象

$c = new ArrayObject; // 致命错误, 找不到 A\B\C\ArrayObject 类
?>
```

对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。

2）命名空间中后备的全局函数 / 常量。

```php
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // 输出 "45"
echo INI_ALL, "\n"; // 输出 "7" - 使用全局常量 INI_ALL

echo strlen('hi'), "\n"; // 输出 "1"
if (is_array('hi')) { // 输出 "is not array"
    echo "is array\n";
} else {
    echo "is not array\n";
}
?>
```

8、全局空间。如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。使用全局空间说明如下：

```php
<?php
namespace A\B\C;

/* 这个函数是 A\B\C\fopen */
function fopen() { 
     /* ... */
     $f = \fopen(...); // 调用全局的fopen函数
     return $f;
} 
?>
```

9、命名空间的顺序。自从有了命名空间之后，最容易出错的该是使用类的时候，这个类的寻找路径是什么样的了。

```php
<?php
namespace A;
use B\D, C\E as F;

// 函数调用

foo();      // 首先尝试调用定义在命名空间"A"中的函数foo()
            // 再尝试调用全局函数 "foo"

\foo();     // 调用全局空间函数 "foo" 

my\foo();   // 调用定义在命名空间"A\my"中函数 "foo" 

F();        // 首先尝试调用定义在命名空间"A"中的函数 "F" 
            // 再尝试调用全局函数 "F"

// 类引用

new B();    // 创建命名空间 "A" 中定义的类 "B" 的一个对象
            // 如果未找到，则尝试自动装载类 "A\B"

new D();    // 使用导入规则，创建命名空间 "B" 中定义的类 "D" 的一个对象
            // 如果未找到，则尝试自动装载类 "B\D"

new F();    // 使用导入规则，创建命名空间 "C" 中定义的类 "E" 的一个对象
            // 如果未找到，则尝试自动装载类 "C\E"

new \B();   // 创建定义在全局空间中的类 "B" 的一个对象
            // 如果未发现，则尝试自动装载类 "B"

new \D();   // 创建定义在全局空间中的类 "D" 的一个对象
            // 如果未发现，则尝试自动装载类 "D"

new \F();   // 创建定义在全局空间中的类 "F" 的一个对象
            // 如果未发现，则尝试自动装载类 "F"

// 调用另一个命名空间中的静态方法或命名空间函数

B\foo();    // 调用命名空间 "A\B" 中函数 "foo"

B::foo();   // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法
            // 如果未找到类 "A\B" ，则尝试自动装载类 "A\B"

D::foo();   // 使用导入规则，调用命名空间 "B" 中定义的类 "D" 的 "foo" 方法
            // 如果类 "B\D" 未找到，则尝试自动装载类 "B\D"

\B\foo();   // 调用命名空间 "B" 中的函数 "foo" 

\B::foo();  // 调用全局空间中的类 "B" 的 "foo" 方法
            // 如果类 "B" 未找到，则尝试自动装载类 "B"

// 当前命名空间中的静态方法或函数

A\B::foo();   // 调用命名空间 "A\A" 中定义的类 "B" 的 "foo" 方法
              // 如果类 "A\A\B" 未找到，则尝试自动装载类 "A\A\B"

\A\B::foo();  // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法
              // 如果类 "A\B" 未找到，则尝试自动装载类 "A\B"
?>
```

名称解析遵循下列规则：1）对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。2）所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。3）在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。

4）非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。5）在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：1）在当前命名空间中查找名为 A\B\foo() 的函数。2）尝试查找并调用 全局(global) 空间中的函数 foo()。6）在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。

下面是调用 new C() 及 new D\E() 的解析过程： new C() 的解析：1）在当前命名空间中查找 A\B\C 类。2）尝试自动装载类A\B\C。new D\E() 的解析:1）在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。2）尝试自动装载类 A\B\D\E。为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。

可以把非限定名称类比为文件名（例如 comment.php）、.限定名称类比为相对路径名（例如 ./article/comment.php）、完全限定名称类比为绝对路径名（例如 /blog/article/comment.php），这样可能会更容易理解。再添一例：

```php
<?php 
//创建空间Blog
namespace Blog;
class Comment { }
//非限定名称，表示当前Blog空间
//这个调用将被解析成 Blog\Comment();
$blog_comment = new Comment();
//限定名称，表示相对于Blog空间
//这个调用将被解析成 Blog\Article\Comment();
$article_comment = new Article\Comment(); //类前面没有反斜杆\
//完全限定名称，表示绝对于Blog空间
//这个调用将被解析成 Blog\Comment();
$article_comment = new \Blog\Comment(); //类前面有反斜杆\
//完全限定名称，表示绝对于Blog空间
//这个调用将被解析成 Blog\Article\Comment();
$article_comment = new \Blog\Article\Comment(); //类前面有反斜杆\

//创建Blog的子空间Article
namespace Blog\Article;
class Comment { }
?>
```

### 1.20 PHP 面向对象

在面向对象的程序设计（英语：Object-oriented programming，缩写：OOP）中，对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。在现实世界里我们所面对的事情都是对象，如计算机、电视机、自行车等。

对象的主要三个特性：1）对象的行为：可以对对象施加那些操作，开灯，关灯就是行为。2）对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。3）对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。比如 Animal（动物）是一个抽象类，我们可以具体到一只狗跟一只羊，而狗跟羊就是具体的对象，他们有颜色属性，可以写，可以跑等行为状态。

1『对象的 3 元素：标识 ID、状态和行为。』

1、面向对象内容。

1）类 —— 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。2）对象 —— 是类的实例。3）成员变量 —— 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。4）成员函数 —— 定义在类的内部，可用于访问对象的数据。5）继承 —— 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。

6）父类 —— 一个类被其他类继承，可将该类称为父类，或基类，或超类。7）子类 —— 一个类继承其他类称为子类，也可称为派生类。8）多态 —— 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。9）重载 —— 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

10）抽象性 —— 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。11）封装 —— 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。12）构造函数 —— 主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与 new 运算符一起使用在创建对象的语句中。13）析构函数 —— 析构函数（destructor）与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做「清理善后」的工作（例如在建立对象时用 new 开辟了一片内存空间，应在退出前在析构函数中用 delete 释放）。

下图中我们通过 Car 类创建了三个对象：Mercedes、Bmw 和 Audi。

```php
$mercedes = new Car();
$bmw = new Car();
$audi = new Car();
```

2、PHP 类定义。PHP 定义类通常语法格式如下：

```php
<?php
class phpClass {
  var $var1;
  var $var2 = "constant string";
  
  function myfunc ($arg1, $arg2) {
     [..]
  }
  [..]
}
?>
```

解析如下：1）类使用 class 关键字后加上类名定义。2）类名后的一对大括号 {} 内可以定义变量和方法。3）类的变量使用 var 来声明，变量也可以初始化值。4）函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。

1『类里面的成员变量用 var 声明的话默认是 public，还有另外 2 个类型：protected 和 private。』

```php
<?php
class Site {
  /* 成员变量 */
  var $url;
  var $title;
  
  /* 成员函数 */
  function setUrl($par){
     $this->url = $par;
  }
  
  function getUrl(){
     echo $this->url . PHP_EOL;
  }
  
  function setTitle($par){
     $this->title = $par;
  }
  
  function getTitle(){
     echo $this->title . PHP_EOL;
  }
}
?>
```

变量 \$this 代表自身的对象。PHP_EOL 为换行符。

1『 \$this 是指实例化时的对象，\$this->url 是指实例化时该对象的 url 属性。』

3、PHP 中创建对象。类创建后，我们可以使用 new 运算符来实例化该类的对象；以上代码我们创建了三个对象，三个对象各自都是独立的，接下来我们来看看如何访问成员方法与成员变量。调用成员方法。在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量：

```php
// 调用成员函数，设置标题和URL
$runoob->setTitle( "菜鸟教程" );
$taobao->setTitle( "淘宝" );
$google->setTitle( "Google 搜索" );

$runoob->setUrl( 'www.runoob.com' );
$taobao->setUrl( 'www.taobao.com' );
$google->setUrl( 'www.google.com' );

// 调用成员函数，获取标题和URL
$runoob->getTitle();
$taobao->getTitle();
$google->getTitle();

$runoob->getUrl();
$taobao->getUrl();
$google->getUrl();
```

1『调用对象的属性（值或方法），用细箭头 ->。』

4、构造函数是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。PHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下：

```php
void __construct ([ mixed $args [, $... ]] )
```

在上面的例子中我们就可以通过构造方法来初始化 \$url 和 \$title 变量：

```php
function __construct($par1, $par2) {
   $this->url = $par1;
   $this->title = $par2;
}
```

现在我们就不需要再调用 setTitle 和 setUrl 方法了：

```php
$runoob = new Site('www.runoob.com', '菜鸟教程');
$taobao = new Site('www.taobao.com', '淘宝');
$google = new Site('www.google.com', 'Google 搜索');

// 调用成员函数，获取标题和URL
$runoob->getTitle();
$taobao->getTitle();
$google->getTitle();

$runoob->getUrl();
$taobao->getUrl();
$google->getUrl();
```

5、析构函数。析构函数 (destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，其语法格式如下：

```php
void __destruct (void)
```

```php
<?php
class MyDestructableClass {
   function __construct() {
       print "构造函数\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "销毁 " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
```

执行以上代码，输出结果为：

```php
构造函数
销毁 MyDestructableClass
```

6、继承。PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式如下：

```php
class Child extends Parent {
   // 代码部分
}
```

实例中 Child_Site 类继承了 Site 类，并扩展了功能：

```php
<?php 
// 子类扩展站点类别
class Child_Site extends Site {
   var $category;

    function setCate($par){
        $this->category = $par;
    }
  
    function getCate(){
        echo $this->category . PHP_EOL;
    }
}
```

7、方法重写。如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。实例中重写了 getUrl 与 getTitle 方法：

```php
function getUrl() {
   echo $this->url . PHP_EOL;
   return $this->url;
}
   
function getTitle(){
   echo $this->title . PHP_EOL;
   return $this->title;
}
```

8、访问控制。PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。1）public（公有）：公有的类成员可以在任何地方被访问。2）protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。3）private（私有）：私有的类成员则只能被其定义所在的类访问。

属性的访问控制。类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // 这行能被正常执行
echo $obj->protected; // 这行会产生一个致命错误
echo $obj->private; // 这行也会产生一个致命错误
$obj->printHello(); // 输出 Public、Protected 和 Private

/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 可以对 public 和 protected 进行重定义，但 private 而不能
    protected $protected = 'Protected2';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj2 = new MyClass2();
echo $obj2->public; // 这行能被正常执行
echo $obj2->private; // 未定义 private
echo $obj2->protected; // 这行会产生一个致命错误
$obj2->printHello(); // 输出 Public、Protected2 和 Undefined

?>
```

方法的访问控制。类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    // 声明一个公有的构造函数
    public function __construct() { }

    // 声明一个公有的方法
    public function MyPublic() { }

    // 声明一个受保护的方法
    protected function MyProtected() { }

    // 声明一个私有的方法
    private function MyPrivate() { }

    // 此方法为公有
    function Foo()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate();
    }
}

$myclass = new MyClass;
$myclass->MyPublic(); // 这行能被正常执行
$myclass->MyProtected(); // 这行会产生一个致命错误
$myclass->MyPrivate(); // 这行会产生一个致命错误
$myclass->Foo(); // 公有，受保护，私有都可以执行

/**
 * Define MyClass2
 */
class MyClass2 extends MyClass
{
    // 此方法为公有
    function Foo2()
    {
        $this->MyPublic();
        $this->MyProtected();
        $this->MyPrivate(); // 这行会产生一个致命错误
    }
}

$myclass2 = new MyClass2;
$myclass2->MyPublic(); // 这行能被正常执行
$myclass2->Foo2(); // 公有的和受保护的都可执行，但私有的不行

class Bar 
{
    public function test() {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic() {
        echo "Bar::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Bar::testPrivate\n";
    }
}

class Foo extends Bar 
{
    public function testPublic() {
        echo "Foo::testPublic\n";
    }
    
    private function testPrivate() {
        echo "Foo::testPrivate\n";
    }
}

$myFoo = new foo();
$myFoo->test(); // Bar::testPrivate 
                // Foo::testPublic
?>
```

9、接口。使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。

1『接口中定义的函数必须是公共的。接口是为了解决什么问题而产生的？（2020-06-05）』

```php
<?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}

// 实现接口
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}
```

10、常量。可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 \$ 符号。常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。

```php
<?php
class MyClass
{
    const constant = '常量值';

    function showConstant() {
        echo  self::constant . PHP_EOL;
    }
}

echo MyClass::constant . PHP_EOL;

$classname = "MyClass";
echo $classname::constant . PHP_EOL; // 自 5.3.0 起

$class = new MyClass();
$class->showConstant();

echo $class::constant . PHP_EOL; // 自 PHP 5.3.0 起
?>
```

1『常量的命名养成习惯，全用大写。』

11、抽象类。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。定义为抽象的类不能被实例化。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。

```php
<?php
abstract class AbstractClass
{
 // 强制要求子类定义这些方法
    abstract protected function getValue();
    abstract protected function prefixValue($prefix);

    // 普通方法（非抽象方法）
    public function printOut() {
        print $this->getValue() . PHP_EOL;
    }
}

class ConcreteClass1 extends AbstractClass
{
    protected function getValue() {
        return "ConcreteClass1";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass1";
    }
}

class ConcreteClass2 extends AbstractClass
{
    public function getValue() {
        return "ConcreteClass2";
    }

    public function prefixValue($prefix) {
        return "{$prefix}ConcreteClass2";
    }
}

$class1 = new ConcreteClass1;
$class1->printOut();
echo $class1->prefixValue('FOO_') . PHP_EOL;

$class2 = new ConcreteClass2;
$class2->printOut();
echo $class2->prefixValue('FOO_') . PHP_EOL;
?>
```

执行以上代码，输出结果为：

```
ConcreteClass1
FOO_ConcreteClass1
ConcreteClass2
FOO_ConcreteClass2
```

此外，子类方法可以包含父类抽象方法中不存在的可选参数。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。

```php
<?php
abstract class AbstractClass
{
    // 我们的抽象方法仅需要定义需要的参数
    abstract protected function prefixName($name);

}

class ConcreteClass extends AbstractClass
{

    // 我们的子类可以定义父类签名中不存在的可选参数
    public function prefixName($name, $separator = ".") {
        if ($name == "Pacman") {
            $prefix = "Mr";
        } elseif ($name == "Pacwoman") {
            $prefix = "Mrs";
        } else {
            $prefix = "";
        }
        return "{$prefix}{$separator} {$name}";
    }
}

$class = new ConcreteClass;
echo $class->prefixName("Pacman"), "\n";
echo $class->prefixName("Pacwoman"), "\n";
?>
```

输出结果为：

```
Mr. Pacman
Mrs. Pacwoman
```

12、Static 关键字。声明类属性或方法为 static（静态），就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。由于静态方法不需要通过对象即可调用，所以伪变量 \$this 在静态方法中不可用。静态属性不可以由对象通过 -> 操作符来访问。自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。

```php
<?php
class Foo {
  public static $my_static = 'foo';
  
  public function staticValue() {
     return self::$my_static;
  }
}

print Foo::$my_static . PHP_EOL;
$foo = new Foo();

print $foo->staticValue() . PHP_EOL;
?>   
```

执行以上程序，输出结果为：

```
foo
foo
```

13、Final 关键字。PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。以下代码执行会报错：

```php
<?php
class BaseClass {
   public function test() {
       echo "BaseClass::test() called" . PHP_EOL;
   }
   
   final public function moreTesting() {
       echo "BaseClass::moreTesting() called"  . PHP_EOL;
   }
}

class ChildClass extends BaseClass {
   public function moreTesting() {
       echo "ChildClass::moreTesting() called"  . PHP_EOL;
   }
}
// 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()
?>
```

14、调用父类构造方法。PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。

```php
<?php
class BaseClass {
   function __construct() {
       print "BaseClass 类中构造方法" . PHP_EOL;
   }
}
class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();  // 子类构造方法不能自动调用父类的构造方法
       print "SubClass 类中构造方法" . PHP_EOL;
   }
}
class OtherSubClass extends BaseClass {
    // 继承 BaseClass 的构造方法
}

// 调用 BaseClass 构造方法
$obj = new BaseClass();

// 调用 BaseClass、SubClass 构造方法
$obj = new SubClass();

// 调用 BaseClass 构造方法
$obj = new OtherSubClass();
?>
```

执行以上程序，输出结果为：

```
BaseClass 类中构造方法
BaseClass 类中构造方法
SubClass 类中构造方法
BaseClass 类中构造方法
```
