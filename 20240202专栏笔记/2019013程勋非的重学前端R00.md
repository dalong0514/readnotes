## 记忆时间

## 卡片

### 0201. 术语卡 —— 变量申明句法的解释

void 运算可以把任意一个表达式变成 undefined 值。任何变量在赋值前是 Undefined 类型、值为 undefined。所以申明变量的句法是 void 加上变量名，应为都是赋值前做的声明，相当于占了一个坑位在那，赋值的时候根据具体的值再更改为指定的类型。

### 0202. 术语卡 —— 装箱操作

运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。

### 0203. 术语卡 —— JavaScript 中的对象

实际上 JavaScript 对象的运行时是一个「属性的集合」，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下 "a" 是 key。`{writable:true, value:1, configurable:true, enumerable:true}` 是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。

### 0204. 术语卡 —— JavaScript 里函数是一种特殊的对象

关于对象的第二个和第三个特征「状态和行为」，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为「成员变量」和「成员函数」，Java 中则称它们为「属性」和「方法」。在 JavaScript 中，将状态和行为统一抽象为「属性」，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。

JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了「具有 `[[call]]` 私有字段的对象」，就可以被 JavaScript 函数调用语法支持。`[[call]]` 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换。

任何对象只需要实现 `[[call]]`，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 `[[construct]]`，它就是一个构造器对象，可以作为构造器被调用。对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。

当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。对于宿主和内置对象来说，它们实现 `[[call]]`（作为函数被调用）和 `[[construct]]`（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串。而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。值得一提的是，在 ES6 之后 => 语法创建的函数仅仅是函数，它们无法被当作构造器使用。

在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。函数对象的定义是：具有 `[[call]]` 私有字段的对象，构造器对象的定义是：具有私有字段 `[[construct]]` 的对象。

### 0205. 术语卡 —— 调用函数时使用的引用，决定了函数执行时刻的 this 值

我们对 this 的解释已经非常清晰了：调用函数时使用的引用，决定了函数执行时刻的 this 值。实际上从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。这个设计来自 JavaScript 早年，通过这样的方式，巧妙地模仿了 Java 的语法，但是仍然保持了纯粹的「无类」运行时设施。如果，我们把这个例子稍作修改，换成箭头函数，结果就不一样了。

关于 this，Kyle Simpson 有四条总结：1）由 new 调用？绑定到新创建的对象。2）由 call 或者 apply（或者 bind）调用？绑定到指定的对象。3）由上下文对象调用？绑定到那个上下文对象。4）默认：在严格模式下绑定到 undefined，否则绑定到全局对象。例外：箭头函数不适用以上四条规则，它会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。

### 0206. 术语卡 —— 文法

文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。词法规定了语言的最小语义单元：token，可以翻译成「标记」或者「词」，在我的专栏文章中，我统一把 token 翻译成词。从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行。

### 0207. 术语卡 —— 通过构造器创建对象

[[construct]] 的执行过程如下：1）以 Object.protoype 为原型创建一个新对象；2）以新对象为 this，执行函数的 [[call]]；3）如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现「私有」。

### 0208. 术语卡 —— css 排版过程

在 CSS 标准中，规定了如何排布每一个文字或者盒的算法，这个算法依赖一个排版的「当前状态」，CSS 把这个当前状态称为「格式化上下文」（formatting context）。我们可以认为排版过程是这样的：格式化上下文 + 盒 / 文字 = 位置（formatting context + boxes/charater = positions）。我们需要排版的盒，是分为块级盒和行内级盒的，所以排版需要分别为它们规定了块级格式化上下文和行内级格式化上下文。

### 0209. 术语卡 —— Flex 布局

Flex 排版的核心是 display: flex 和 flex 属性，它们配合使用。具有 display:flex 的元素我们称为 flex 容器，它的子元素或者盒被称作 flex 项。flex 项如果有 flex 属性，会根据 flex 方向代替宽 / 高属性，形成「填补剩余尺寸」的特性，这是一种典型的「根据外部容器决定内部尺寸」的思路，也是我们最常用的 Windows 和 Apple 窗口系统的设计思路。

Flex 排版三个步骤：分行、计算主轴、计算交叉轴。

### 0301. 人名卡 —— Brendan Erich

JavaScript 之父。

### 0401. 金句卡 —— 对象是一个属性的索引结构（一种数据结构）

### 0402. 金句卡 —— 根据 id 选单个元素、class 和 class 的组合选成组元素、tag 选择器确定页面风格

此为使用选择器的原则。

### 0403. 金句卡 —— margin 是一个元素规定了自身周围至少需要的空间

### 0501. 任意卡 —— JS 里执行时的学习思路

从大到小的思维，从「宏观任务/微观任务」到「函数」（闭包）到「语句」。

### 0502. 任意卡 —— 页面里表格居中的 css 语法

```css
table {
    margin: 0 auto;            
}​
```

### 0503. 任意卡 —— 链接的类型

两大类：超链接型标签和外部资源链接。link 标签一般用于看不见的链接，它可能产生超链接或者外部资源链接，a 和 area 一般用于页面上显示的链接，它们只能产生超链接。

### 0504. 任意卡 —— 凡是替换型元素，都是使用 src 属性来引用文件的

凡是替换型元素，都是使用 src 属性来引用文件的，而我们之前的课程中已经讲过，链接型元素是使用 href 标签的。虽然我不知道当初是怎么设计的，但是 style 标签并非替换型元素，不能使用 src 属性，这样，我们用 link 标签引入 CSS 文件，当然就是用 href 标签。

### 0505. 任意卡 —— 编程语言的实现

用规定的文法，去表达特定的语义，去操作运行时。运行时包含类型（数据结构）和执行过程（算法）。

### 0505. 任意卡 —— JavaScript 对象的特征

在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。1）对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。2）对象有状态：对象具有状态，同一对象可能处于不同状态之下。3）对象具有行为：即对象的状态，可能因为它的行为产生变迁。

### 0506. 任意卡 —— 切换上下文最主要的场景是函数调用

信息源自「0107JavaScript执行3你知道现在有多少种函数吗.md」

认识了 ES2018 中规定的各种函数，我一共简单介绍了 8 种函数。我们围绕 this 这个中心，介绍了函数的执行上下文切换机制。同时我们还讲解了 this 中的一些相关知识。包括了操作 this 的内置函数。任何语句的执行都会依赖特定的上下文。一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。在 JavaScript，切换上下文最主要的场景是函数调用。

1-2『切换上下文，指不同的执行上下文「EC」进栈和出栈，这里的栈是 JS 里的调用栈。（2020-05-19）补充：切换上下文最主要的场景是函数调用，做一张任意卡片。（2021-05-05）』—— 已完成

## 总纲

总结：前端的学习分四大核心模块：JavaScript；HTML 和 CSS；浏览器 API；综合应用。任何编程语言要实现的过程：用规定的文法，去表达特定的语义，去操作运行时。运行时包含类型（数据结构）和执行过程（算法）。

2006 年那时候，谷歌刚刚基于 Ajax 发布的 Gmail 也没多久，虽然这项伟大的技术标志着 Web 1.0（静态网页）到 Web 2.0（动态网页）的迈进，但在国内依然少有人懂，如果当时谁可以对这项技术侃侃而谈，那简直就是大神的级别了。

2008 年，我加入了盛大做电子书，负责电子书的文本排版工作，这个工作是一个既写底层又写 JavaScript 的岗位，同时排版引擎也是浏览器的重要组成部分，也让我对浏览器的工作原理有了更深入的理解。在盛大后期，我加入了 WebOS 项目，负责前端框架，我开始基于移动的角度思考前端交互和框架，这份工作让我离前端又近了一步。回过来看，那几年，前端技术开始了它的大踏步发展，那一段时间，可以说是前端的 「白银时代」。最直观的表现之一就是前端逐步从后端分离了出来，它的代码也变得复杂了起来，还需要保存数据、处理数据、生成视图等等。

在手机淘宝，前端团队的各种基础设施也逐渐建立了起来，从最开始的多屏适配方案、基础库、工具链到页面搭建平台和性能体系，最后到客户端融合方案 Weex，我随着团队一起经历了业务发展、团队自身成长和行业变革。与此同时，在我加入阿里巴巴后的这段时间里，随着移动时代的到来，前端也开启了自己的 「黄金时代」，它的职责变得更加重要，有了独立的发布权限，技术也变得更加复杂。一些传统软件开发和互联网服务端的方法论逐步移植到前端开发中，并形成了前端自己的工程体系，诸如持续集成、前后端分离、线上监控……架构方面，前端架构的任务也从简单的解决兼容和风格问题，逐步过渡到提倡组件化和 UI 架构模式，最后形成了新一代的前端框架 React、Vue 和 Angular，他们也在竞争和互相学习中成长。

1『前端的青铜、白银和黄金时代。』

关于前端工程师成长，我认为需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。

前端知识分成了四个模块：1）JavaScript；2）CSS 和 HTML；3）浏览器实践；4）前端综合应用。前三个模块是前端的基础知识，是个人的前端能力提升，而模块四则是前端团队发展相关的内容，有助于你和团队的整体提高。

1）在 JavaScript 部分中，我主要会从文法和运行时的角度去讨论 JavaScript 语言。它们是互相关联的，而语义就是文法到运行时之间的桥梁；它们分别又是完备的，任何语言特性都离不开两者，所以从语法和运行时的角度，我们都可以了解完整的 JavaScript。2）CSS 和 HTML 部分，会侧重从语言和设计思想的角度来讲解，我们同样可以对两者的全貌建立一些认知。3）浏览器部分，包含了浏览器工作的原理和一些重要的 API，包括 BOM、DOM、CSSOM 和其他一些内容。了解了这些知识，你才能把 JavaScript 和 HTML、CSS 连接起来，用 JavaScript 来实现功能。4）前端综合应用部分，主要是我的一些工作经验，我会选择我在手淘和淘宝工作中的一些案例来辅助讲解。

前端是一个非常年轻的职业，但我仍然认为前端具有很多空间和机会，一些基础设施仍然简陋，前端的能力可以带来更多的业务场景，这些有待于我们去发掘。前端工程师也会面临技术发展问题带来的挑战。前端社区高度活跃，前端标准也在快速更新，这样蓬勃发展对技术来说无疑是好事，但是副作用也显而易见，它使得前端工程师的学习压力变得很大。我们就拿 JavaScript 标准来说，ES6 中引入的新特性超过了过去十年的总和，新特性带来的实践就更多了，仅仅是一个 Proxy 特性的引入，就支持了 VueJS 从 2.0 到 3.0 的内核原理完全升级。缺少系统教育 + 技术快速革新，在这样的大环境下，前端工程师保持自学能力就显得尤其重要了。

 0 基础入门的同学，你可以读几本经典的前端教材，比如《JavaScript 高级程序设计》《精通 CSS》等书籍，去阅读一些参考性质的网站也是不错的选项，比如 [MDN Web 文档](https://developer.mozilla.org/zh-CN/)。在这个专栏中，我希望传达的不仅仅是具体的知识点，还有体系架构和学习方法。我希望达到三个目标：1）带你摸索出适合自己的前端学习方法；2）帮助你建立起前端技术的知识架构；3）让你理解前端技术背后的核心思想。
 
 2『已下载书籍「2019105JavaScript高级程序设计3Ed」、「2019106精通CSS3Ed」。』

对于任何计算机语言来说，必定是 「用规定的文法，去表达特定语义，最终操作运行时的」 一个过程。这样，JavaScript 的任何知识都不会出现在这个范围之外，这是知识架构的完备性。我们再往下细分一个层级，就变成了这个样子：1）文法：词法、语法。2）语义。3）运行时：类型、执行过程。

2『任何编程语言要实现的过程：用规定的文法，去表达特定的语义，去操作运行时。运行时包含类型（数据结构）和执行过程（算法）。做一张任意卡片。』——已完成

文法可以分成词法和语法，这来自编译原理的划分，同样是完备的。语义则跟语法具有一一对应关系，这里暂时不区分。对于运行时部分，这个划分保持了完备性，我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。

当我们再往下细分的时候，就会看到熟悉的概念了，词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等……比如在 JavaScript 标准中，有完整的文法定义，它是具有完备性的，所以我们可以根据它来完成，我们还可以根据语法去建立语义的知识架构。实际上，因为 JavaScript 有一份统一的标准，所以相对来说不太困难。

如果是浏览器中的 API，那就困难了，它们分布在 w3c 的各种标准当中，非常难找。但是我们要想找到一些具有完备性的线索，也不是没有办法。我喜欢的一个办法，就是用实际的代码去找：for in 遍历 window 的属性，再去找它的内容。 我想，学习的过程，实际上就是知识架构不断进化的过程，通过知识架构的自然延伸，我们可以更轻松地记忆一些原本难以记住的点，还可以发现被忽视的知识盲点。

1『构建知识体系的方法论。』

有一些知识，背后有一个很大的体系，例如，我们对比一下 CSS 里面的两个属性：opacity；display。虽然都是 「属性」，但是它们背后的知识量完全不同，opacity 是个非常单纯的数值，表达的意思也很清楚，而 display 的每一个取值背后都是一个不同的布局体系。我们要讲清楚 display，就必须关注正常流（Normal Flow）、关注弹性布局系统以及 grid 这些内容。

3『弹性布局，flex 之类的，学爬虫的时候得到一个概念，各个网页的布局大不相同，很难写一个通用的爬虫。「2020061Website-Scraping-with-R01」』

还有一些知识，涉及的概念本身经历了各种变迁，变得非常复杂和有争议性，比如 MVC，从 1979 年至今，概念变化非常大，MVC 的定义几乎已经成了一段公案，我曾经截取了 MVC 原始论文、MVP 原始论文、微软 MSDN、Apple 开发者文档，这些内容里面，MVC 画的图、箭头和解释都完全不同。这种时候，就是我们做一些考古工作的时候了。追本溯源，其实就是关注技术提出的背景，关注原始的论文或者文章，关注作者说的话。操作起来也非常简单：翻翻资料（一般 wiki 上就有）找找历史上的文章和人物，再顺藤摸瓜翻出来历史资料就可以了，如果翻出来的是历史人物（幸亏互联网的历史不算悠久），你也可以试着发封邮件问问。

这个过程，可以帮助我们理解一些看上去不合理的东西，有时候还可以收获一些趣闻，比如 JavaScript 之父 Brendan Eich 曾经在 Wikipedia 的讨论页上解释 JavaScript 最初想设计一个带有 prototype 的 scheme，结果受到管理层命令把它弄成像 Java 的样子（如果你再挖的深一点，甚至能找到他对某位 「尖头老板」 的吐槽）。根据这么一句话，我们再去看看 scheme，看看 Java，再看看一些别的基于原型的语言，我们就可以理解为什么 JavaScript 是现在这个样子了：函数是一等公民，却提供了 new this instanceof 等特性，甚至抄来了 Java 的 getYear 这样的 Bug。

1『认识中前端就是 html 负责骨架，css 负责外表和 js 负责行为。』

在开始列框架之前，我想先来谈谈我们的目标。实际上，我们在网上可以找到很多参考资料，比如 MDN 这样的参考手册，又比如一份语言标准，但是我们的课程既不是一本参考手册，也不是一份语言标准。参考手册希望做到便于查阅、便于理解和全面，语言标准的目标是严谨、无遗漏、无歧义。而我们的课程有什么不同呢？我认为，作为一个课程，有两个目标：一个是把无法通过查阅解决的原理和背景讲清楚，另一个是把不方便查阅和记忆的内容整理好。我会尽量避免像前面提到的两种文档一样逐条目罗列知识点和细节，当然，这不是在说两种文档没有价值，而是我们各有分工，参考手册和语言标准做的事情，我们没必要重复去做，即使做了也不一定能做得更好。

在这个课程里，我希望能和你一起打造一个前端知识的框架，再把知识点做个遍历，这其中，有原理和背景的部分，我去讲解知识的原理和背景。如果没有的话，我们就去讲整理和记忆这部分知识的方法，这样，即使你遇见无法一下子记住的知识，也可以很容易地查阅参考手册和标准来解决。

如果让我做一个划分，前端的知识在总体上分成基础部分和实践部分，基础部分包含了 JavaScript 语言（模块一）、CSS 和 HTML（模块二）以及浏览器的实现原理和 API（模块三），这三个模块涵盖了一个前端工程师所需要掌握的全部知识。学完这三个部分，你再结合基本的编程能力，就可以应对基本的前端开发工作了。实践部分（模块四）重点会介绍我在工作过程中遇到的问题和解决方案，希望这块内容能够帮助你和你的前端团队找到可能的发展方向和着力点。

在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的一般规律：用一定的词法和语法，表达一定语义，从而操作运行时。接下来，我们又按照程序的一般规律，把运行时分为数据结构和算法部分：数据结构包含类型和实例（JavaScript 的类型系统就是它的 7 种基本类型和 7 种语言类型，实例就是它的内置对象部分）。所谓的算法，就是 JavaScript 的执行过程。

类型部分中，对象比其它所有类型加起来都要更为复杂，所以我们会用较长的篇幅来讲解对象，包括它的一些历史和设计思路。执行过程我们则需要按照从大结构到小结构的角度讲解，从最顶层的程序与模块、事件循环和微任务，到函数、再到语句级的执行。我们从粗到细地了解执行过程。实例部分，对 JavaScript 来说类似基础库，JavaScipt 的内置对象多达 150 以上，考虑到我们即使逐次讲解也必定不如 MDN 更加细致全面，所以我们会从应用和机制的角度，挑选其中几个体系来讲解。

文法中的语法和语义基本是一一对应关系，在 JavaScript 标准中有一份语法定义表，它同样不适合一一讲解，我们会从 JavaScript 语法中特别的地方，以及与日常开发比较相关的地方来重点讲解，剩下的内容和词法部分，我们会带领大家做一些数据挖掘工作，从这份表格中找到一些和我们日常开发息息相关的内容。语义的大部分内容我们会在运行时的讲解中透出，同时它又跟语法有对应的关系，所以我们不再单独拿出来讲解。

在 HTML 的部分，我们会按照功能和语言来划分它的知识，HTML 的功能主要由标签来承担，所以我们首先会把标签做一些分类，并对它们分别进行讲解。我们都知道 HTML 的标签可以分为很多种，head 里面的我们称为元信息类标签，诸如 title、meta、style、link、base 这些，它们用来描述文档的一些基本信息。还有一类是一些诸如 section、nav 的标签，它们在视觉表现上跟 div 并没有区别，但是各有各的适用场景，我们把它们称作语义类标签。另外一类是 img、video、audio 之类的替换型媒体类标签，用来引入外部内容，平常开发中你也会经常用到。再有就是表单类的，比如 input、button。所以，基于这样的分类，我把标签分成下面几种。

1）文档元信息：通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息；2）语义相关：扩展了纯文本，表达文章结构、不同语言要素的标签；3）链接：提供到文档内和文档外的链接；4）替换型标签：引入声音、图片、视频等外部元素替换自身的一类标签；5）表单：用于填写和提交信息的一类标签；6）表格：表头、表尾、单元格等表格的结构。

我们的重点会放在前四种标签上，表单和表格较少用到，而且基本以查阅型知识为主，这里就不拿出来讲解了。除了标签之外，我们还应该把 HTML 当作一门语言来了解下，当然，标记语言跟编程语言不太一样，没有编程语言那么严谨，所以，我们会简要介绍 HTML 的语法和几个重要的语言机制：实体、命名空间。最后我们会介绍下 HTML 的补充标准：ARIA，它是 HTML 的扩展，在可访问性领域，它有至关重要的作用。

3『

[标记语言 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80)

标记语言是一种将文本（Text）以及文本相关的其他信息（包括例如文本的结构和表示信息等，这些信息通过标记来标识）结合起来，展现出关于文档结构和数据处理细节的计算机文字编码。当今广泛使用的标记语言是超文本置标语言（HyperText Markup Language，HTML）和可扩展置标语言（eXtensible Markup Language，XML）。标记语言广泛应用于网页和网络应用程序。标记最早用于出版业，是作者、编辑以及出版商之间用于描述出版作品的排版格式所使用的。标识（markup）这个词来源自传统出版业的「标记」一个手稿，也就是在原稿的边缘加注一些符号来指示打印上的要求。长久以来，这个工作都是由专门的人（markup men）以及校对人来进行，对原稿标志出使用什么样的字体，字体以及字号，然后再将原稿交给其它人进行手工的排版工作。

』

CSS 部分，按照惯例，我们也会从语言和功能两个角度去介绍。在语言部分，我们会从大到小介绍 CSS 的各种语法结构，比如 @rule、选择器、单位等等。功能部分，我们大致可以分为布局、绘制和交互类。在布局类我们介绍两个最常用的布局：正常流和弹性布局。绘制类我们则会分成图形相关的和文字相关的绘制。最后我们会介绍动画和其它交互。

浏览器部分我们会先介绍下浏览器的实现原理，这是我们深入理解 API 的基础。我们会从一般的浏览器设计出发，按照解析、构建 DOM 树、计算 CSS、渲染、合成和绘制的流程来讲解浏览器的工作原理。接着是 API 部分，我们会从 W3C 零散的标准中挑选几个大块的 API 来详细讲解，主要有：事件、DOM、CSSOM 几个部分，它们分别覆盖了交互、语义和可见效果，这是我们工作中用到的主要内容。其他的 API 怎么办呢，别着急，在最后，我会给出一份 Chrome 已经实现的 API 跟 W3C 标准的对应关系和它的生成过程，来覆盖其它部分。

最后一个模块是前端工程实践。我们在掌握了前面的基础知识之后，也就基本掌握了做一个前端工程师的底层能力。在这个模块中，我选择了性能、工具链、持续集成、搭建系统、架构与基础库这几个方向的前端工程实践案例。

首先我们会谈谈性能。对任何一个前端团队而言，性能是它价值的核心指标，从早年 「重构」 的实践开始，前端有通过性能证明自己价值的传统。但是性能并非细节的堆砌，也不是默默做优化，所以，我会从团队的角度来跟你一起探讨性能的方法论和技术体系。

下一个案例是工具链。这一部分，我将会探讨企业中工具链的建设思路。对一个高效又合作良好的前端团队来说，一致性的工具链是不可或缺的保障，作为开发阶段的入口，工具链又可以和性能、发布、持续集成等系统链接到一起，成为团队技术管理的基础。

接下来还会给大家介绍前端的持续集成，持续集成并非一个新概念，但是过去持续集成概念和理论都主要针对软件开发，而对前端来说，持续集成是一个新的课题（当然对持续集成来说，前端也是一个新课题），比如 daily build 就完全不适用前端，前端代码必须是线上实时可用的。这一部分内容将会针对前端的持续集成提出一些建设的思路。

接下来的案例是搭建系统，前端工作往往多而繁杂，针对高重复性、可模块化的业务需求，传统的人工开发不再适用，搭建系统是大部分大型前端团队的选择。这一部分内容我将会介绍什么是搭建系统，以及一些常见的搭建系统类型。

最后一个部分，会给大家介绍前端架构和基础库的知识。软件架构师主要解决功能复杂性的问题，服务端架构师主要解决高流量问题，而前端是页面间天然解耦，分散在用户端运行的系统，但是前端架构也有自己要解决的问题。前端需求量大、专业人才稀缺，更因为前端本身运行在浏览器中，有大量兼容工作要做。所以前端架构的主要职责是兼容性、复用和能力扩展。这一部分文章我将会介绍前端架构工作的一些思路和切入点。上面的这些案例来自我在领导手淘前端团队时的经验，和我在阿里巴巴工作参与晋升面试时听到的案例，这些内容几乎是每一个年轻的前端团队成长过程中都会需要的基础设施。

基于这份知识框架图，我们的课程主要采用两种讲述形式：一种是重点讲解的课程，一种是知识图谱型的课程。重点讲解的课程我们会从技术的背景、原理和设计出发，把知识的内容呈现出来。这种形式适用于有体系和源流的知识，比较适合系统学习和理解，比如 JavaScript 中的对象、CSS 的排版。知识图谱型的课程则提供一些方法，用表格或者脑图的形式来整理知识的结构。这种形式适用于零散的知识，比较适合记住大概，用到时去查阅，比如 JavaScript 的词法、HTML 中的所有标签、以及浏览器中的 API 就十分适合这样的讲解方式。

### 尾声

1、教育是知识的展现形式。现在有一个特别火爆的概念叫做知识付费，其实我不太喜欢这个说法。「重学前端」所讲的知识点，没有一条是我发明或原创的知识，这么说的原因是：知识就在那里，每个人都可以获得它。你可以在各种文档和标准中找到它们或者它们的变体。有一些工程领域相关的知识，来自我工作中的实践，有一些也算是首创，但是我不认为这些知识属于我，我只是发现了它们。所以我认为，知识是免费的，承载它们的教育产品才是收费的。在整个课程写作中，我致力于在知识之间建立关系。我不希望把我的课程变成抄写文档。我从排版追溯到活字印刷，我从渲染追溯到中国画的技法，还有面向对象的起源。在这个过程中，我自己也颇有收获。我期望这样的一种组织形式能够帮助你更好地理解和记忆知识。我有时候会觉得，这个把「知识变成课程」的过程，特别像前端工程师把数据变成可见的页面的过程，所以，从某种意义上讲，我做的事情还是前端。

1『前端做的事，把数据变成可视的页面呈现给人。』

2、教育的重点在于能力提升而不是知识积累。不过，我也不希望「重学前端」这个课程仅仅是「更容易记忆的知识」。因为在我看来，知识量并非衡量一个工程师优秀与否的因素，能力才是。一点小小的奢望是：「重学前端」这个课程，能给你带来一些建立知识体系的能力。我在「重学前端」的课程中，穿插了大量的「用代码读标准」的实验。这个小系列，算是我的一种「独门武功」。我刚开始关注前端的 2007 年左右，国内还少有程序员知道 Web 标准这件事，想要找到资料就更难了，我也经历了最初看标准如同天书的过程。但是我发现，其实标准中佶屈聱牙、晦涩难懂的那些概念，有着内在的联系，又因为标准文本中用词非常严谨，所以尝试用代码去理解，反而是个快捷的路径，还能找出不少边边角角的冷知识。通过类似这样的线索，我建立了自己最初的知识体系，我开始对前端的体系的全貌有了粗浅的认知，现在，我希望通过「重学前端」课程，让你也来体会一下这个过程。

1『研读标准的一个有效方法论，用代码去读标准。』

3、教育是一种服务，我们做得显然还不够好。作为老师，我希望这个课程能够真正帮助到你们每一个人，但是其实我们可以看到，每一节课都有一些放弃的同学。可能有人会说，对平台方和老师来说并无所谓呀，反正付过钱了。但是在我和「极客时间」看来，这正是我们做得不够好的地方。今天「重学前端」这个课程，可能以这样的产品形态呈现出来，凭学员的自觉性来完成学习，实属一种无奈。不论对我，还是对「极客时间」而言，培养更多优秀的工程师，潜在的价格远远高于卖一些课程得到收入。我认为，教育是一种服务，理想的教育产品卖的应该是服务的结果，而不是服务的过程。

### 黑板墙

粗鄙认为前端知识架构可以分为渲染层和网络层两方面，不论前端如何发展变化，比如 react，vue，ng，还是 flutter，小程序等等，本质上脱离不了这两方面，另外前端工程师在接触一个新语言或新框架，最难不是学习语言本身（官方文档可以解决），反而棘手的是如何去工程化（更好组织代码，打包工程）和去优化，这是做前端两年的感受。作者回复：渲染层和网络层这个分法听起来是有一定思考了，不过可以再想想，是不是还有别的层？另外就是，如何定义渲染层呢？

在 JavaScript 中，「类型」和「实例」就是数据结构，而「执行过程」就是算法。之前从来没有从这个角度看待过 JavaScript 语言，写代码的思路就不一样了。这是第一大收获。第二个收获是明确自己问题所处的分支。比如，JavaScript 大部分的问题都存在于「运行时」这个分支中。又比如，发现自己疲于奔命，总是 「感觉」 学不完的内容，其实是处于「持续集成」这个分支中。核对了一下自己已经掌握，和计划学习的前端知识，都能在这份知识框架中找到落脚点，再次体会到完备性的重要。

1『上面说的实例指的就是对象。』

前端自动化测试方面是都也可以讲解下，除了工具，最重要的是怎么造自动化测试用例，这个用例感觉比后端复杂，工作量也非常大，所以很多项目会放弃自动化测试。怎么才能做好自动化测试？作者回复：自动化测试，非一线大厂大型团队不建议搞，目前还没见过靠谱的方案。

在阅读这篇文章之前，我对于前端知识结构的划分是基于「语言」：前端 = HTML + CSS + JavaScript。每种语言下，又混杂了基础知识以及相关的工具。比如我之前认为的 JavaScript 包括：1）JavaScript 基础。2）Package Manager (NPM、Yarn)。3）Build tools (NPM Scripts、ESLint、Webpack...)。4）Frameworks (React、Vue.js、Angular)。5）Testing tools (Jest ...)。现在知道自己的认识有两个误区：1）这个知识架构没有完备性，这样划分，总有在这个结构之外的知识；2）学习的时候会疲于奔命，总想 「完整」 的学完所有的知识，却走了弯路。作者回复：我觉得你不妨思考下，如果我要讲 Package Manager、Build tools，你猜我会放到哪个部分？读者：package manager 和 build tools 属于工程化中的内容吧？大前端的一个必备前提，我认为就是工程化。可以模块化组织和管理，并提高模块重用性。

大家都觉得 HTML 容易，非常简单。就算不会，坐下来花一天时间看看 MDN 几乎都能写出来了。我们都知道写 HTML 要语义化，但是 HTML5 的语义我感觉非常复杂。有多少人能保证写出来的网页完完全全遵循了正确的语义？能达到屏幕阅读器理解的程度？我们想写语义正确的网页，但是也不想被语义复杂性所拖累。（本来读的也不是文科，div 一分钟能写出来的东西在语义上要纠结好久）程老师，我的问题是，作为一名前端工程师，平常工作的时候写 HTML 究竟要语义化到哪种程度呢？作者回复：这是个好问题，在语义化部分我有讲这个问题。

## 加餐总结

1、图形学，前端工作层会慢慢下沉；包管理，NPM 的革新；智能研发，前端有责。机械性的劳动最终一定会被机器取代。

2、通过写作建立自己的知识架构体系，同时提高自身的表达能力，通过正反馈机制和锻炼保证我长久的坚持下去并最终养成习惯，习惯这一模式之后变成优秀的人也只是时间问题罢了。

5、前端工程师级别：助力工程师 -> 前端工程师 -> 资深前端工程师 -> 前端专家 -> 高级前端专家。

## 0501有哪些前端技术值得关注.md

1、图形学。在淘宝工作的后期，我也有很大一部分精力放在了图形学上面，我是深刻地感觉到，在未来，图形学会和前端结合的更紧密。这是由于我觉得图形实际上是 UI 最重要的一部分计算机科学，同时它也是计算机领域里面的一个非常关键的学科。我们的前端就是做 UI 的这样的一个职能，在未来，我觉得随着前端的工作层级逐渐地下沉，前端能够做到越来越多的事情。我们的图形也会逐渐的成为前端的一个基本的技能。

我在 2018 年已经可以看到很多 2D 和 3D 领域的应用了，我们会用 2D 的东西去做图片的渲染，我们会用 3D 的东西去做一些 3D 场景的呈现，在不同的公司我都会看到很多这样的案例。另外，我觉得图形学也会大量地吸收以前在 PS 中由设计师做的功能，很多以前我们做得这种效果，包括半透明，包括模糊等等都是在 PS 里面，用图片来实现的。但我认为在未来，随着图形学技术逐渐地发展，前端可以用代码来实现这样的效果，这样我们就可以不用设计师产出的图片了，而是设计师告诉我们用什么样的效果，我们来写代码把它实现。

这种下沉其实有个好处，我认为当前端工作层下沉到一定的程度，我们就不会有「做不出来这样的效果」这件事发生了。这件事是很有意义的，今天你去问一个 C++ 的工程师，这个东西能不能做，他只会说这个东西我不能做，他不会说，C++ 不能做，那在我们前端这样的情况往往是刚好相反的，所以说，我觉得未来下沉，技术下沉会给我们前端带来更多的职责，也同时是一种责任。

2、包管理的救赎。我觉得前端第二个会非常重要的发展趋势就是：包管理。我们都知道，NPM 是一个非常好的包管理。但是实际上，我们的 NPM 生态里也有很多的问题，包括安全问题，包括依赖太多造成的性能问题。我觉得目前到了一个重要的时间点了，那么 NPM 的这种问题，一定会有人解决。但这种解决方案，到底是 NPM 的竞争对手会产生一个新的这样的包管理的平台；还是我们的 NPM 生态里面诞生一些更好的方案，最终把问题解决呢？这个就是我没有办法去预测的事情了。

3、智能研发，前端有责。另一个技术是我比较关注的是 AI 领域和前端的结合，我们的 AI 领域，今天虽然炒得非常火热，但是在我看来，真正应用的比较好的场景，就是视觉和推荐这两个领域。我觉得智能研发的领域是整个学术界非常少关注的，那么我们的前端应该把这个责任背起来。我在淘宝已经看到很多这个方面的努力了，我觉得在业界，这个东西在 2019 年产量应该也会越来越成熟，毕竟切图工作是一个机械性的劳动，机械性的劳动最终一定会被机器取代。所以，我认为未来，我们前端的工作是不应该包含切图这项工作的。我也比较期待这方面能够尽快地产生一些成绩。

其他的技术在 2019 年，应该会是一个稳定发展的状态，包括大家特别关心的三大框架，Vue、Angular、React。我认为应该是「继续繁荣发展，继续稳定发展，最后生态越来越成熟」这样的一个状态。

### 黑板墙

前些年在天猫互动团队做了很多图形学相关的项目，各种游戏和营销工具，当年兴致高昂啊，移民后这块基本就搁置了，回归了传统的全栈开发。跪求寒冬大神推荐一些图形学的学校资源啊，我要把它捡回来。作者回复：计算机图形学的课程可以看看。还有 WebGL 相关的东西可以学起来。

2018 年，首先是前端在图形学方面越来越强大；其次，看到有些大学研究项目和一些公司的 lab 部门，已经在前端自动化这块有了初步成果，非常惊喜。我自己在 2018 年的项目中采用了一些新前端技术，让设计师同伴也惊呼 PS 的很多效果可以直接在网页上实现了，比如图层混合模式。2019 我非常期待 Houdini 的进展。

## 0502那些你与重学前端的不解之缘.md

### 01

不过，我没想到的是，前端的学习曲线到后面是如此陡峭，并且前端发展的速度如此之快，让人目不暇接，也让很多人产生了「技术焦虑」。在这样的环境中，我也产生了迷茫，作为一名前端开发人员，我到底应该学什么，怎么学。毕业后两年多的时间里，我从使用原生的 HTML/CSS/JavaScript，到现在流行的视图库 Vue/React，看似我好像学会了很多，但是离开这些库，或者说将来这些库被淘汰了，我又剩下了什么呢？

我逐渐意识到，我需要的可能是一些更「底层」的东西。那么，什么是「底层」的东西呢，这里可不是指计算机底层，而是指不会被淘汰的东西，永远有用的东西。我认为对于任何程序员来说，最重要的就是：迅速获取某项知识的能力以及动手解决问题的能力。

前者需要我们建立自己的知识体系，也就是 winter 老师在第一讲中提到的，我们需要完善的知识架构。我们不需要也不可能记住整个架构的知识，但我们却可以在需要的时候想起来这块知识的位置，是干什么的，能帮我们解决什么样的问题，可以通过什么关键词检索到，这就够了。其实你让我回忆 winter 老师这么多节课的所有内容，我也是好多想不起来的，但多少都留下了印象。我们的大脑容量是有限的，所以「按需加载」也许对人脑也是个不错的策略。

后者其实就归功于 winter 老师精心设计的课后题，光看这些课文总归是差了点什么，只有你动手去做，才能真正理解这节课所讲的内容。在做的过程中，你多半会遇到困难（这其实也是 winter 老师的本意），如果你通过努力解决掉了，这个提升才是最大的。你的方案不一定是最好的，或者你可能实在没什么头绪，这时候也可以利用搜索引擎去看看别人的方案。

### 02

对于框架的使用没必要花太多时间，应该多研究一下三大框架背后的设计思想。当一个程序员对算法、语言标准、底层、原生、英文文档这些词汇产生恐惧感的时候，他的技术生命已经走到尽头。前端架构主要解决的是高复用性，架构能力提升方向主要是组件库开发、前端框架实现等。

对于前端进阶这个问题，其实看书的作用和意义已经不太明显，需要寻找好的平台和合适的项目，在项目中不断克服难题并挑战自己，遇到问题再去查资料总结。如果只是闭门看书那很难成为高手，书只是基础而已，真正的应用还是在项目中。

寒冬中能做的只有提升自己，但是光靠技术是不行的。推荐 TensorFlow、可视化切图、PWA、WebGL。1）TensorFlow 可以了解使用并做点东西出来，原理很难但不影响使用。2）PWA 有望进一步发展。3）WebGL 在未来会是一个很好的方向，它可以实现任何你想要的界面效果，但重点需要多掌握图形学的基础知识，它和算法，数据结构一样重要。Weex 和 RN 虽然都叫 Hybird 但不太一样，前者适合大厂主要是嵌入 APP 中使用，后者更适合创业公司。

不推荐 SSR、TypeScript、函数式编程。1）SSR 不太看好，其主要是用于 SEO，不太建议用做服务端渲染，其能够使用的场景不多，而且成本代价太大。2）TypeScript 是好东西，是很有前景的语言，但适用于十万行以上代码级别的大型项目，小项目并不适合，反而徒增复杂。3）用 JavaScript 做函数式编程并不靠谱，Map/Reduce/Redux/Hooks 等并不是函数式编程，只是长得像而已。

1『说 JS 不适合函数式编程，这个观点待验证。直觉上感觉不对。』

### 03

听完 winter 老师直播后对其观点很是赞同，但因为是面对所有人讲解，所以内容有点多范围有些广，但对个人来说还是找适合自己的方向，在自己相对熟悉的领域再去扩展去突破。横向只是拓宽你的眼界，纵向才是你的核心竞争力。

对我来说感触最大的就是 3、4、5 这几点，因为我一直在思考以下的几个问题。我现在是高级前端，但又感觉自身很弱，那我如何才能夯实我高级的地基然后成为资深前端呢？项目迭代节奏快日常加班又多，那我如何做才能平衡工作和学习？单单提升技术好像还是有很大瓶颈，那我如何提升我的职场核心竞争力？

结合 winter 老师的专栏和最近看的几篇文章，说说我对这几个问题的思考。对于第一个问题，在 2 个多月前我还是不会写文章的小白，那个时候受到一些文章的触动，尝试把我的前端之路记录下来。我的想法很简单，就是把前端进阶 28 期的重难点知识全部讲完，目前已经进行到第 4 期了，通过写作把知识通俗易懂的介绍给别人，在这个过程自己肯定会收获很多很多。这就是我目前在尝试的学习方式，通过写作建立自己的知识架构，并且在这个架构上不断地进行优化，时间到了自然就进阶了。

对于第二个问题，刚开始写作时精力充沛时间也很多，每天都会更新技术文章，但随着项目迭代压力增大，文章更新速度相应就变慢了一些。虽然文章质量提升了很多，但更新速度从日更变成了周更再变成了双周更，这个说实话我自身已经很难接受了，因为速度变慢导致我年初的计划要打折扣。所以说做项目和自我学习要如何权衡，是否说我要减少项目难度和时间并在工作中摸鱼去学习呢？

我的结论是不，因为一句话，「最好的学习就是在项目中锻炼自己」。既然我有这么好的项目去锻炼，那为什么还要摸鱼去学习呢，这不就是南辕北辙嘛，道理很简单但不是所有人都懂。我最近在执行的方法是专注 + 锻炼 + 利用周末。专注即工作时专注于工作，努力做好每次迭代，遇到难题迎难而上，工作时不开微信，勤用笔记安排日常工作并整理文档。锻炼即一周抽出三天时间每次去健身房锻炼 1 小时，强壮的体魄才能撑住高强度的工作和学习。利用周末即加大周末和平常晚上熬夜的时间去写文章，减少娱乐的时间，正所谓时间挤一挤总会有的，但这件事情比较反人性，所以重在坚持。公众号写文章更容易坚持，原因在于文章发布后有正反馈，比如粉丝的增长，留言和鼓励，赞赏等等，这些都更能促使你坚持下去，时间长了自然就养成了习惯。

对于第三个问题，winter 老师也说了，寒冬中光靠技术是不行的，那应该靠什么呢？幸好在最近看到的一篇文章中找到了答案，那就是表达能力。表达能力是形成自己的框架系统，有理有据并且逻辑清晰，而且能让外人听懂，大部分优秀的人都具备这样的能力。反观自己并没有这样的能力，所以我要努力提升这块，其中最重要的方法就是写作训练。兜兜转转那么多，其实我一直在尝试的进阶方法就是通过写作建立自己的知识架构体系，同时提高自身的表达能力，通过正反馈机制和锻炼保证我长久的坚持下去并最终养成习惯，习惯这一模式之后变成优秀的人也只是时间问题罢了。

### 黑板墙

今天看到一篇推文，vue 和 react 已不是你的优势，而是前端的必备项。确实，在框架盛行的今天，我们都过于注重使用库去开发，一些基础的东西已经捡不起来，（月初二面问得很多基础性的东西已经答不上来，突然担心有一天离开库不会开发）不知道如何去梳理，总觉得那哪儿也懂点，自己表达起来吧还有些说不清楚。这个专栏就帮我们做了这样一件事情。重构自己的前端知识架构。脑子里要有一张基本的图，顺着分支捋下去。

## 0504加餐前端交互基础设施的建设.md

Vue、React 等现代前端框架很好地解决了组件化和数据视图解耦问题。而对前端来说，新交互永远是花费时间最多的工作，新交互也是前端团队的自然价值和核心竞争力之一。在这次话题中，我会分享在交互的基础设施的建设上的一些思考和实践，包括图形图像基础、事件机制与视图层架构模式、交互管理框架等内容。

首先我们要了解一下历史。1）在 70 年代，大概是 70 年代的尾巴，1979 年左右，有了特别有名的，MVC 架构。2）MVC 之后，经过了差不多十几年的发展，到了 90 年代，准确地说应该是 95 年左右的时候，这个有一个公司的 CTO，叫 Mike，Mike 在 MVC 的基础上，提出来了 MVP。3）到了 2005 年，2005 年微软的一个架构师，做 WPF 的，提出了 MVVM 模式。4）2014 年左右的时候，出现了 FLUX，这个是 Facebook 为了它的 JSX 和 React 提出的一种模式。5）后来隔了短短的一年，2015 年，同样是在 React 社区，出现了 REDUX。

对于前端来说，我们为用户创造价值才是特别回答的一个问题，这么多年过去了，前端到底为用户创造了什么价值呢？1）这是 70 年代，施乐公司做的一个软件管理的流程图软件，那个时代，整个的界面就是这个样子，施乐已经算比较先进的了。2）再到 90 年代，当时这个画面还是很惊艳，按钮键是立体的。现在来看这个东西就有不那么美观了。3）2006 年左右的时候，Vista 的界面已经开始有了一个非常大的变化了，这时已经是设计师在主导这个界面的了，但是性能并不佳。4）再之后，手机出现了，比如 iPhone 的界面，这时不但交互模式发生了巨大的改变，而且屏幕也变了，甚至我们熟悉的鼠标不见了，变成了触屏。虽然两者之间操作上有一定的相似，但是变化还是非常的。

视图的职责也在演变。1）70 年代，视图的职责是：任何一个视图，永远不应该知道用户的输入。2）我们这个时代的视图则既负责输入，也负责输出，并且与 Model 之间有一个交互。

计算机的功能也在演变。70 年代，计算机主要用来计算。我们今天计算机主要用来上网，基本上，大家的计算机都是 24 小时联网的，你的手机也是 24 小时联网的，所以计算机的职责在发生变化。

这个变化对于 UI 有很大的影响，1970 年的那个 MVC 那篇论文里的图，model 很大，view 很小，而到了 2018 年，今天我们很多的 model，都是放在服务端的，而今天 model 的大小已经不是说一台机器上能去存的，你存在本地的只是视图展现一点点的 model，这个是很小的一部分的东西。而同时 view 却越来越重要了。

我们来看一下视图的技术。1）从最底层的有很多人是做显卡和 drivers，有这样的大佬人才。2）还有现在非常流行的 OpenGL 等的 GL 层，做这一层的人非常专业，基本上都集中在各种大公司，最近苹果和安卓还竞争，推出了新一代的这个 GL 架构。3）还有一个这个 Draw 层，这一层的内容非常多，基本上就爆发了，skia 是安卓的底层绘制系统，graphics.h 是最早的 C 语言带的一个图形库，基本上相当于一个基础库，还有很多 3D 引擎。4）UI Framework 这一层，它提供了一套基本的 UI 结构，有了绘制层，一般人都不会在绘制层直接去工作，需要有些控件，这层有我们比较熟悉的 Dom。GJI 是 Windows 的图形系统，WPF 也是 Windows 的图形系统。5）最上面其实会有一些 DSL，这是描述图形的语言，WPF 对应的就是 XAML，JSX 对应的是 React，HTML 大家都知道了，想说这个视图技术变得越来越复杂，

那么我们的主战场是怎么样的，我们可以看一下淘宝终端技术在各层上的分布状况。

交互体系其实是这里面的一部分，但它不是这里面的全部，我觉得我们要讲这个交互呢，我们还是要做一下抽象的，我们要认识到，交互的本质是什么。交互的本质是什么呢，我画了一个手和一个眼睛，其实无非是操作和看。1）操作最常见的一个抽象的模式就是事件。这个比如说这个 touch-screen 事件，陀螺仪事件，或者是时钟芯片触发的持续事件，这些作为输入。2）输出一定是通过属性的形式体现的，在任何一个现在的 UI 框架下，都是通过属性的方式反映出来的。transform 是变形，opacity 是透明度，color 是颜色，这就是一个比较完整的抽象了。你在任意的输入和输出连成一条线后，它都会产生一种效果。

不过直接把陀螺仪得到的参数输入到 transform 里肯定是不行的，它需要有个关系，我们在这里面选择了 Expression。我们可以用 JavaScript 去做计算。我觉得这是一个完备的抽象。

不过这里还有一个坑是需要迈过去的，对计算机理解的输入跟人类理解的输入有非常大的偏差，对计算机来说呢，有多少种硬件，就有多少种输入。

我们发现输入非常复杂，在做基础设施建设的时候，我们在输入上面其实投入了很大的精力，最后出来的是一个更接近于人脑概念的一系列的输入。

比如说，touch 和 gesture，我们知道触屏其实是触屏事件，触屏事件其实非常简单，只有四个，touch start，touch  move，touch  end，touch cancel 则不太常用。

比如我想摁或者点一个东西，它都是是 touch start，touch  move，touch  end，如果你要监听这些事件，中间的判断很繁琐，作为交互的基础设施，我们不可能提供这些给我们的前端工程师使用，我们肯定做一些操作。

比如手指移动 10px，我们就认为这个 touch  start 到了 pan  start，这个后面就是 pan  move，pan  end 这样，手指很快离开，那么它就会产生一个 tap 事件。

如果超过 1.5 秒那就一个 press start，如果手指没移呢，就会产生一个 press end，如果手指移了，它还会产生一个 pan start。所以 gesture 已经比 touch 复杂了很多了。

scroll 就在 gesture 的基础上又复杂了一层，它不但手指在屏幕的时候响应，手指离开屏幕的时候它也响应，比如说轮播，它是一个变形的轮播，它在轮播的过程中，不但产生位移，还会产生大小的变化，这就让用户更舒服一些。

还有一个滚动导航，一边滚动出来一个导航，近年来还有一个交互设计，不是滚动到某个位置导航出来，而是一直再往下滚动的时候它不出来，突然往上滚动一下，导航就出来。这个部分还有更难的设计交互，所以我们还需要在 scroll 的基础上再做一层。

我们再来看陀螺仪，它只提供了三个分量，并且它是 0 到 360 度，所以如果不经过任何处理，前端工程师基本上是没有办法用的，比如在某个角度，它可能会突然从 0 跳变成 360 度，这个在数据计算时候非常可怕。

所以我们建立这样一个模型，我们把手机看作这样一个立方体，去计算在空间中对立方体产生的旋转效果，我们拿着立方体上面的一个点呢，去做我们定位的一个依据。

因为我们在用 Weex，所以有一个 Native 跟 JS 通讯的问题，比如说从 gesture 事件到 gesture handler，这一步就会到 JS 去执行，图中我们可以看到这个线，跨过中间 JS 和 Native 的分界线，跨越地非常频繁。

假如一个 Touch  move 事件或者 Pan  move 事件，你手指每移动一小点它都会触发一次 JS 跟 Native 的一个跨语言通讯，所以说整个的性能会非常差，最后基本上会有 5 毫秒到 10 毫秒左右的一个延迟，有 60 帧的话，每一秒钟有 300 毫秒被占掉了，帧率就下去了。

这就是我们最初开始做 Binding 模式的原因。我们的 Binding 模式，expression 传递一次给 Native，然后它会去做大量的绑定，所有的过程都是由 Native 来完成的，Native 做完了以后，还需要再更新一下 VDOM，所以这操作就完全由 Native 完成，通讯次数就降下来了。除此之外，我们还额外收获了性能上的收益。

我们的结论，其实淘宝一个交互体系是这样的，是以 Binding 为核心，下面的平台支持了 weex，Web，React Native。DSL 上面，我们支持了 View 和 Rax 两种，在上面，是由我们自己建的 Components 体系。

最后，还有一个展望，我们用绘制层相结合，会有更多的想象空间，我们通过各种各样的输入、手势、时间、陀螺仪，我们其实可以去控制矢量图，也可以去控制绘制，这些都是前端未来的想象空间。

## 0505加餐一个前端工程师到底需要掌握哪些技能.md

自从开了「重学前端」这门课程，总会遇到同学反复问我这几个问题：1）学这门课需要什么样的基础？2）为什么你不讲 Vue？3）有必要学习 Node.js / Flutter / 函数式吗？

这几个问题看似毫无关联，但是其实它们本质上都是同一个问题，这个问题就是「一个前端工程师到底需要掌握哪些技能？」其实在行业里面，对前端工程师的能力模型有一个基本的认知，不同公司的定义可能有细微差别，但是它的内核是一致的。这里我给出一张图，是我自己理解的前端工程师的技能模型。

为了方便你理解，我把这些技能具体放进前端工程师的不同级别里，你可以对照着找到一条符合自己实际情况的前端进阶之路。下面我就一部分一部分地详细讲讲前端技能树是如何发展的。

### 5.1 助理工程师

首先来说说助理前端工程师，对标的是阿里的 P4 级别。它的要求是基本的编程能力。什么叫基本的编程能力呢？我认为就是熟练地用计算机编程语言表达任何逻辑的能力。一般来说，在大学学习过计算机专业的学生应该具备编程能力。

我举一个具体的例子，我们用自然语言说「从 1 打印到 100」，在多数编程语言里的表述，是一个变量从 1 开始，每次循环加 1，每次打印，到变量值为 100 时循环结束。理论上只要掌握了循环、分支逻辑，能组合出一切逻辑，这是图灵可计算理论决定的。但是理论是一回事，真想要熟练掌握，是需要经过一定训练的。这个训练，就是对助理工程师的要求。

在面试中考察这部分知识的问题往往被称作「算法题」。其实广义上的算法指我们一切完成问题的步骤，而狭义的算法则是指算法课本上几种经典的算法如分治、贪心、动态规划等。面试中考察基本编程能力，其实题目出难了就是所谓的「算法题」，出简单了就是「写段代码看看」，并没有一个明确的分界线。

助理工程师的定义是「能够在辅助下完成工作」，因此不是所有公司都会招聘助理工程师的，因为严格来说，助理工程师不具备独立工作的能力，他的工作产出可能是负数。但是招聘助理工程师的公司，一般都是看重应聘人的潜力，期望能快速成长。

### 5.2 工程师

接下来我们说说前端工程师，对标阿里 P5 级别。它的要求是掌握基本的前端技能，这样说也许有点模糊，但是换个说法就很明白了，基本前端技能就是「综合运用 HTML、JavaScript、CSS 完成任何界面和交互需求」。这个「任何界面和交互需求」，看似要求很高，但是如果你写过前端就知道，这是任何前端的基本技能 —— 大不了用图片呗。

其实这个级别的工程师，水平跨度非常大，界面写出来了，但是兼容性如何、代码可维护性如何、离了框架能不能写出来、语义表现分离能做到吗、开发过程中能不能做到有效沟通… 还会有很多问题。而这些问题，决定了一个前端工程师的潜力，一些好一点的公司招聘这个级别的工程师，除了「基本的前端技能」之外，还会对我上面提到的这些问题有所要求。

关于助理前端工程师和前端工程师，能力方面主要的要求是编程能力，知识方面的要求是一个「可用」的最小集合。

### 5.3 资深工程师

我们接着往下讲，资深前端工程师，对标阿里 P6 级别。到了这个阶段，我们可以看到图上开始出现不同的区块了，这意味着，对资深前端工程师的要求，也是多元化的。

我们用一句话来概括，资深前端工程师，要求开始关注并且解决项目中的问题。什么样的问题呢？可能是别人做不出来的技术难题，也可能是容易出错的代码，或者说无意义的重复劳动，或者是业务上想不出来合适的交互……等等。

其实对资深前端工程师的要求是很自由的，我上面的图中给出的仅仅是几个例子，比如组件化可以解决重复劳动问题和开发耦合问题；工具可以解决的问题有很多，生成代码的工具提高效率，代码检查工具提高质量；性能优化则会带来业务价值，这些都是资深前端工程师可以做的事情，并且只要把其中一两项做好，就可以达到资深前端工程师的水平。

再有就是这个级别开始对架构能力和工程能力有所要求了，但还处于萌芽阶段，一些天赋好的同学可以凭感觉达到这个水平。

### 5.4 技术专家

下面说说前端专家，对标阿里 P7 级别。到了这个级别，我们从图上可以看到，要求又不一样了，比如组件变成了组件体系，工具变成了工具链和持续集成体系，性能优化变成了性能体系。这些东西变得不仅仅是称呼，还有工作的内容，这个级别跟资深工程师的主要区别是，从解决单点问题变成系统性方法，从服务自己变成服务团队，从一次性发挥变成持续性输出。

比如，资深工程师可能做一些组件，然后在项目里面用，自己的代码可维护性提升了，复用也做得更好了。但是前端专家要考虑制定组件规范推广到团队，还要做培训，考虑组件如何开发、管理和下线。资深工程师做性能，把自己的页面优化好了就可以了，但是前端专家就需要考虑采集数据、做报表和监控、总结 checklist、跟工具结合、定性能指标等等。

由于这个级别对架构能力、工程和软技能要求很高，所以算是比较难以跨越的。

### 5.5 高级技术专家

最后来说高级前端专家，对标阿里的 P8 级别。我们从图上看，这个级别分开的发展方向又聚合到了一起。高级前端专家做事的关键是审时度势，需要在前面讲的前端专家所掌握的各个领域里，组合出一套适合自己所在团队的方案。比如做企业内部系统的前端团队，可能对性能要求就没那么高，但电商前端团队因为运营活动频繁，就需要很好的组件体系，这里很难有一定的规则，全靠人来把握。

到这个级别，对工程能力的要求就很高了，而且即使不带人的高级前端专家，也必定涉及一些管理能力。

### 5.6 前端进阶的核心要素

讲完了各个级别的前端技能模型，我们回到最开始的问题「一个前端工程师到底需要掌握哪些技能」。要回答这个问题，你要先根据自己的情况对号入座。梳理出自己掌握的前端知识程度，定位出自己的级别。再根据更高层级所需的知识，有的放矢，循序渐进，不断精进、完善自己的前端知识水平。

我们现在学习的「重学前端」这门课程，最重要的作用首先是构建出一个完整的前端知识架构，让你可以把自己的前端能力梳理清晰，让你意识到自己「会什么，不会什么」。如果后面再遇见了拿不准的知识点，你也可以定位好属于哪部分的哪个知识点。

有同学会问：自己对照专栏的知识架构后，好多知识点都不会，比较模糊，感觉会影响岗位的晋升，很焦虑，怎么办？不要急，我们可以看到，在前端的技能模型里，对「知识」是没有任何硬性要求的，具体到各个公司的不同岗位，可能会有一些特殊要求，但市场是巨大的，所以大家可以不必对学什么知识不学什么知识感到那么焦虑。

现在大部分同学会更为注重前端岗位的晋升，我认为想要真正实现前端岗位的晋升，更多还是要看你的能力，尤其是在工作中非常重要的编程能力、架构能力和工程能力，这些都是前端工程师必备的「内功」。而且「前端知识」应该是一个垂直的模块，它不能直接帮助你进阶下一个更高的级别，但是它能提升你的潜力，使你未来能走得更远。

我现在也在从教育的视角，结合自己多年的前端一线经验，尝试一种更为直接有效的课程形式，帮助大家提升能力、实现进阶。去年，我和极客大学联合举办了第 0 期线下的「前端训练营」，得到了同学们很好的反馈，也恰恰验证了我的观点，「前端能力是可以培养的，这比单纯学习框架要重要得多」。

今年我和极客大学又重新设计了线上版的「前端进阶训练营」 ，课程设计深度对标阿里 P6 技能模型，延用班主任、助教、作业、评分、毕业、研讨等多种学习形式和服务。针对不同基础的同学，课程增加了前端基础知识的讲解，以及组件化、工具链、发布与持续集成这三条大厂进阶的关键路径。我依然会把重点放在前端工程师能力培养上，希望教你知识怎么学，并且通过线上刻意练习的方式，帮助你提高编程、架构和工程能力。

## 0601期中答疑name两种写法有什么区别吗.md

随着专栏进度过半，我们专栏的评论区留言量也日渐上涨。除了大家的小作业和学习心得，我还看见很多同学们在学习过程中提出了不少问题。这其实是一种很好的学习方式，通过问题，我们可以对这部分知识记得更为牢固。所以，我鼓励你在阅读文章之外，多思考，多提问，把自己不懂的地方暴露出来，及时查缺补漏，这样可以更好地吸收知识。同时，你也可以通过回答别人的问题来检验自己对知识的掌握情况。

我们一起来看看，大家都提出什么问题。

1、老师你好！我语义化标签用得很少，多数用到的是 header、footer、 nav 等语义化标签，想问老师 section 和 div 混合使用，会不会效果不好呢？答：不会效果不好的，因为本来就是这么用的。遇到不确定的情况，请千万不要乱用标签，用 div 和 span 就好。

2、我一直看见闭包这个词，但是一直也没有弄清楚它是什么东西，老师可以简单概括一下什么是闭包吗？答：你可以这样理解，闭包其实就是函数，还是能访问外面变量的函数。

3、事实上，JavaScript 中的「类」仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。文中说「类」是私有属性，可以具体表现是什么，不是很能理解具体含义？答：私有属性当然是你无法访问的属性了，但是具体表现的话，还是有的，那就是 Object.prorotype.toString.call(x) 的行为。

无法自定义类型？请问如下编码是属于什么操作，应该怎么理解这个「类」？

```js
function Person（）｛｝
var person = new Person（）；
```

答：这个代码是定义类的操作，这里注意一下，你千万不要把类和类型的概念混淆。

4、请教老师在对象中 name(){} 等同于 name: function() {} ，这两个写法有什么区别呢？

答：这两个写法在使用上基本没什么区别。只有一点区别，就是函数的 name 属性不一样。可以看下这段代码：

```js
var o = {
   myfunc(){}
}
console.log(o.myfunc.name)
```

我们这里按照你的第一种方法定义了方法，然后输出它的 name 属性，我们看到 name 属性是 "myfunc"。

值得一提的是，如果我们给你的第二种方法添加了名字，行为还是不一样，区别在于能否在函数内用名字递归，我们看看代码：

```js
var o2 = {
    myfunc(){
        consoe.log(myfunc); //error
    }
}
var o1 = {
    myfunc: function myfunc(){
        consoe.log(myfunc); //function myfunc
    }
}
o1.myfunc();
o2.myfunc();
```

这段代码中，我们试着在用两种方式定义的方法中输出函数自身的名字变量，结果是不一样的。不过现实中，我们几乎不会关心函数的 name 属性，所以不用太在意两种定义方式的区别。

5、我对于 JavaScript 中 Number 安全整数有个疑问。MDN 中是（-(2^53-1)-(2^53-1)）, 犀牛书中是（-2^53~2^53）感觉都有道理。JavaScript 中采用 IEEE754 浮点数标准进行存储，1 个符号位，11 位指数位，52 位尾数位。按照分析，不考虑符号位，尾数位取值 52 个 1 就是表示的最大值了，不会有精度损失，此时指数位代表数值是 52+1023=1075，此时即为 (-(2^53-1)-(2^53-1))。

但是 2^53 这个值，存储的时候尾数是 52 个 0，指数位为 53+1023=1076，这个值也是刚好没有精度损失的，这时表示的就是（-2^53-2^53）。用 Math.isSafeInteger() 判断安全数范围和 MDN 中描述一样。所以被问到这个的时候，感觉两个都是有道理的吧！老师你说对吗？

答：你分析得非常好，我觉得我都没啥可补充的了。这个地方 JavaScript 标准写得也非常模糊，我简单瞄了一下，似乎是用实验的方式来给出的安全数范围。考虑到犀牛书的时效性肯定不如 MDN，应该是参考了某一版本旧引擎给出来的数据。所以，这类行为我们还是以实测为准吧，我们不必纠结。

6、老师您好，下面这个自己练习的例子希望您能帮解答：

```js
console.log('sync1');

setTimeout(function () {
    console.log('setTimeout1')
}, 0);

var promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log('setTimeoutPromise')
    }, 0);
    console.log('promise');
    resolve();
});


promise.then(() => {
    console.log('pro_then');
    setTimeout(() => {
        console.log('pro_timeout');
    }, 0)
})

setTimeout(function () {
    console.log('last_setTimeout')
}, 0);
console.log('sync2');
```

答：这个例子挺经典的，虽然我觉得这样设计面试题非常不合适，但是我们可以以它为例，学习一下分析异步的方法。

首先我们看第一遍同步执行，这是第一个宏任务。第一个宏任务中，调用了三次 setTimeout（Promise 中的代码也是同步执行的），调用了一次 resolve，打印了三次。所以它产生了三个宏任务，一个微任务，两次打印。

那么，首先显示的就是 sync1、promise 和 sync2。这时，setTimeout1，setTimeoutPromise，last_setTimeout 在宏任务队列中，pro_then 在微任务队列中。

接下来，因为微任务队列没空，第一个宏任务没有结束，继续执行微任务队列，所以 pro_then，被显示出来，然后又调用了一次 setTimeout，所以 pro_timeout 进入宏任务队列，成为第 5 个宏任务。

然后，没有微任务了，执行第二个宏任务，所以接下来顺次执行宏任务，显示 setTimeout1，setTimeoutPromise，last_setTimeout，pro_timeout。

最终显示顺序是这样的。

```
宏任务 1
微任务 1
sync 1
promise
sync 2
微任务 2
pro_then

宏任务 2
setTimeout1

宏任务 3
setTimeoutPromise

宏任务 4
last_setTimeout

宏任务 5
pro_timeout
```

7、为什么 promise.then 中的 settimeout 是最后打印的？不用管是宏任务依次执行吗？答：因为 then 是第一个宏任务中最后执行的微任务，所以它发起的宏任务是最后入队的，依次执行就是最后。

8、怎么确定这个微任务属于一个宏任务呢，JavaScript 主线程跑下来，遇到 setTImeout 会放到异步队列宏任务中，那下面的遇到的 promise 怎么判断出它是属于这个宏任务呢？答：resolve 在哪个宏任务中调用，对应的 then 里的微任务就属于哪个宏任务。宏任务没有从异步队列中取出，中间所碰到的所有微任务都属于这个宏任务。

9、为什么要设计微任务（micro task），我知道这样 JavaScript 引擎可以自主地执行任务，但这样的好处是什么？提高性能吗？答：不是，微任务是 JavaScript 引擎内部的一种机制，如果不设计微任务，那么 JavaScript 引擎中就完全没有异步了呀，所以必须要设计微任务。

10、现在浏览器多数实现是从右往左匹配的，那么无法保证选择器在 DOM 树构建到当前节点时，已经可以准确判断当前节点是否被选中。现在浏览器又是怎么实现在生成 DOM 树，同时进行 CSS 属性计算？答：其实现代浏览器已经为 :empty、:last 等伪元素写了很多例外了，不过你说的从右往左匹配，左边的要么是当前节点的父元素，要么是前置元素，所以是可以保证准确判断的呀。

11、请问老师，页面资源的预加载是不是可以用 link 标签实现，还有其他的方式吗？答：预加载的方法就多啦，还可以用 JavaScript 代码预加载，甚至用本地存储缓存。

12、老师，我有一个疑问：「词法环境」和「词法作用域」这两个概念的区别是什么？希望你能帮我解惑。答：词法环境是运行时概念，词法作用域是语言概念，就是说，作用域指的是变量生效的那段代码，而词法环境是指运行起来之后，你这段代码访问的存储变量的内存块。

13、想问一个问题：import 进来的引用为什么可以获取到最新的值，是类似于 getter 的机制吗？答：这个地方略微有些复杂，我们在运行时并没有讲 import 的运行时机制，这里涉及了一个叫做 ImportEntry Record 的机制，它比 getter 的实现更底层。我想这个地方我们没有必要去深究模块的运行时机制，它很复杂而且并不是经常要用到。你如果想了解的话，可以查阅一下。

14、请问老师，JavaScript 的 call stack size 是多少，这个 size 的单位是啥，是调用栈中函数的个数，还是一个存储单位，比如 MB 之类的。如果调用栈中就一个函数，这个函数的参数有 100 万个，浏览器端依然会溢出，看起来是存储单位，但是没得到验证。答：这个似乎并没有什么特别规定，我知道 JSC 里面这个东西是可以用 C++ 代码来调整的，至于浏览器调用 JavaScript 引擎的时候会怎么做，还真不好说。不过，从编码风格上建议，不要把这种事情用函数解决啦，真要干这样的事，数组可能都不合适了，请老老实实写 ArrayBuffer 吧。

15、老师您好，我一直有一个困惑，浏览器的鼠标事件是怎么识别到的，是碰撞检测的吗？答：这个问题很不错，我后面在浏览器 API 的事件部分会详细讲，可以先简单说一下，这里的检测方式是从外到内，逐级分配给子元素，所以我们的事件会有捕获过程。

16、有个问题，如果我 javaScript 代码改变了 DOM 树元素的位置，需要启动重新排版（位置改变的元素只会影响其他部分元素的位置，甚至不影响其他元素的位置。），这时会导致这棵 DOM 树的所有元素都需要重新排版、绘制和渲染吗？答：排版应该是会重新排的，但是如果有些元素的尺寸没有改变，那么它内部不需要重排，当然也就更不需要重新渲染了，但是绘制应该是要重绘的，目前来看，浏览器还没有那么智能。

17、我是 12 年左右踏进半只脚到前端领域的，后来考研就放弃了，觉得前端不够高深，和传统工程师来说觉得门槛低很多，甚至前期我都觉得自己不是个程序员。直到研究生毕业，才又选择前端，这是三大框架风靡，我却有点迷惘，感觉和自己认知的前端不一样，直到现在工作了差不多两年，才悟出了点道道。作为工程师，我始终觉得前端也应该熟练算法和数据结构、数据库这些所谓的后端知识，但是平时工作场景中用到又少，不知如何学习？答：算法和数据结构可不是什么后端知识呀，是所有程序员的基本技能。算法主要是靠大量练习提高，数据结构可以一个一个学习，不要指望工作中用到恰巧就学了，毕竟学习要教学费而工作是领工资的，哪里会有这样的好事呢，所以还是自己多多练习呀。

18、重学前端是夯实前端基础，那前端进阶方向在哪里？还是一定要修一门后端语言扩展服务端，希望老师可以指点迷津。答：我觉得任何编程相关岗位的进阶方式都是做出某某东西，而不是学会某某东西。我会在专栏课程的第四模块会讲到一些进阶可能的方向，你可以关注一下。

19、我主业是后端，工作中也会带着做前端，自认还是能完美还原设计师的设计。但是现在感觉很多时候提前端就是 vue 等，而我还是在用 jQuery，想请老师说说看，我是不是落伍了？答：落伍的问题不是你用什么框架，而是你在做什么东西，学什么东西。框架不是赶时髦，追潮流，每个框架都有解决的问题，我觉得你该焦虑的不是你用的框架为什么这么老，而是你该知道这些新框架要解决什么问题，以及这些问题为什么在你的工作中不存在。

最后，我们来看看我在 JavaScript 类型那一篇中给你留的实践问题。如果我们不用原生的 Number 和 parselnt，用 JavaScript 代码实践 String 到 Number，该怎么做呢？答：其实这个问题我在后台没看到特别满意的答案，好像大家都很喜欢偷懒啊。我这里给你留个例子，处理十进制整数。

```js
function atoi(a){
    let chars = a.split("").map(e => e.charCodeAt(0) - "0".charCodeAt(0));
    let n = 0;
    for(var char of chars) {
        n *= 10;
      n += char;
    }
    return n;
}
atoi("1001")
```

我比较期待大家有人能写出来带小数，甚至带科学计数法的代码，你可以尝试一下。

### 黑板墙

我知道答案了。在 promise 出现之前，javascript 并没有异步，有异步的是宿主环境。作者回复：对的。2019-04-04

为什么说没有了微任务就没有了异步？不是还有 setTimeout 的吗？作者回复：因为那是宿主的东西呀，不在 JS 引擎里。2019-04-03

好像对异步任务的分类又多了一点理解。异步中任务分为宏任务和微任务，微任务是后来出现的，它其实是 JS 引擎内部的机制，而宏任务是宿主环境下的异步。老师，这么理解对吗？那么设计微任务的初衷仅仅就是为了让 JS 引擎内部有异步么？2020-05-12

## 0602答疑小众知识到底对我有什么帮助.md

课程进展至今，我已经把大部分困难的知识点都讲完了。我在后台收到了一些留言，有的同学针对前端专栏的学习方法和学习方向提出了一些问题，在本期文章中，为了让同学们更好地理解我们专栏的重点，最大程度地吸收知识，在今天的文章中，我会逐一回答同学们在学习方法上的困惑。

1、老师讲的内容是不是工作中用不到的，对掌握前端的实际工作有什么帮助呢，我们有必要掌握这些比较偏的内容吗？

回复：我自己一直奉行着一个观点，不要执着于知识的「临时」实用性。因为我总是感觉，掌握知识越多的人，更喜欢花费时间学习一些暂时可能无法变现的知识，原因有两点：一是其实学知识花费的时间比想象中的要少，这边在纠结它有没有用，那边可能都学完了；二是知识的实用性其实不怎么好判定，比如当年黎曼搞出非欧几何的时候，全世界都觉得纯粹是数学的思维游戏，直到黎曼死了很多年后，相对论出世，黎曼几何有了实际用途。

不过，这里我还是希望讲清楚，我想通过我们的课程传达一些什么样知识内容。我们的每一节课标题中，都会带一个有点「小众」的问题，但是，实际上，这个标题主要是引起你学习兴趣的一个引子，解决问题只是我们学习课程的一个自然结果。

我希望的是，通过这个有点偏的问题，引起你对这部分知识领域的关注，知道这部分知识的边界在哪里，从而形成一个完备的知识网络。让你在遇见不会的问题时候，可以快速定位到知识点，达成有效学习。并且，你也可以通过自己之前没有关注过的不同视角，来重新学习一遍这部分的知识。

比如在 JavaScript 课程中，我提供了几个不同的视角来讲解 JavaScript 语言，每一个视角下，都是完整的 JavaScript 知识。比如说，当我们写下 1+1 的时候，我们从词法的角度看，这是两个数字直接量和一个加法符号，我们从类型的角度看，两个 Number 类型相加得到的也是 Number 类型，我们从语法的角度看，这是一个加法表达式。

我们从不同的维度去认识了 JavaScript 语言，这些视角，远比你记住我们课上讲的细节更重要。如果你记住了「数字直接量可以用科学计数法，E 还可以小写」，却没有学会从词法的角度去分析 JavaScript 语言，那可谓是「入宝山空手而归了」。

2、我从业时间不长，文章看得迷迷糊糊，是我的基础不够吗？该怎么办？

回复：有一种说法，世界上的知识分成「我知道的」「我知道自己不知道的」和「我不知道自己不知道的」。重学前端定位是有一定经验的前端工程师，所以它最重要的作用之一，就是帮助前端工程师发现问题，找出知识盲点。课程设计上，我的主要思路也是「帮助」大家形成自己的体系，而不是「替」大家形成自己的体系。我在前言部分就讲到过，若论丰富全面，有 MDN 文档；若论准确权威，有标准文本，但是，我们课程的作用是传达思路，如果有知识上的缺失，你其实可以通过阅读 MDN 来补全。

3、如果阅读文章时候有的内容看不懂，该如何学习，如何定位这块的知识呢？

回复：这个问题比较抽象，我认为这个课程设计其实也是一种定位了。比如，对 JavaScript 问题，先搞清楚看不懂的是词法问题、语法问题、还是运行时问题？定位清楚了问题，你已经距离解决问题前进了一大步。在这里，我想跟大家说一下：如果你看不懂文章里的某一块知识，你可以给我留言，把具体的位置和知识点告诉我，这样我们可以进行更好的沟通和反馈，从而解决这个问题。如果你只是说不懂，我可能会一头雾水，也无从下手去帮助你解决问题。多做实时、有效的反馈，会让知识吸收的效果更好。

4、为什么文章里有那么多的术语和英文呢，为什么不换成更通俗的名字呢？

回复：其实，在我们的课程中，有很多次讨论到术语问题，比如「排版」，我们讲了中国古代的活字印刷，比如「渲染」，我们讲到了国画的技法。恰当地使用术语，对于传达知识是非常关键的。翻译是一项很专业的工作，文学类的翻译讲究信、达、雅，对于技术类的名词，或许「雅」这方面可以稍微打点折扣，但是表意清晰，字句通达仍然是必须的。很多术语有约定俗成的翻译，当我们阅读不同的文档时，可以快速地通过术语建立联系。并且，有的时候翻译本身也会造成一部分信息的丢失，所以，我有时会直接把英文也写出来，这样有助于你通过原文去理解和对照。

而为什么我不把术语换成更通俗的名字呢？我们所讲的多数技术，跟现实生活联系不大，这种情况下，「通俗」的名字往往意味着误导。有时候，我们确定术语时，反而会尽量使它远离已有的概念。当然，确定术语并非是我的工作与专长，我们课程中的绝大多数术语，都不是我的发明创造。

5、标准里有些东西还是看不太懂，如果可以的话，希望老师可以稍微讲解一下如何看懂标准？

回复：我并不推荐每一个前端工程师都去阅读标准，标准一半是写给实现者，一半是写给使用者，这里本来就有很多知识上的落差，多数时候，MDN 是更好的选择。如果一定要阅读标准，建议从自己做一个极简实现开始，我在浏览器部分，有讲解浏览器相关的知识，在 JavaScript 部分，我还设计了编译原理实验。我想，把它们落到代码上会是一个很好的开始。

6、接手了一个新项目，怎么对前端合理规划，老师能不能提供一些这方面的指导和建议？

回复：这个问题其实跟前端学习关系不大，但是我可以讲讲。1）任何规划其实都差不多，得有背景、目标、方案、计划、预期结果。其实在我看来，「项目」是规划的最小单位，在项目中拆出前端来做规划，是不太合适的。2）背景和目标通常来自公司的业务，方案跟具体的技术相关，计划是项目管理的领域，最后根据这些来给出预期结果。3）再往下细说，一个完整的方案可能包括产品、运营、市场、技术，不同的项目，各个职能的难度不一样，有些项目可能干脆不需要某些方案 —— 比如多数淘宝的产品，首页开个入口就有访问量了，不需要独立去做市场。4）具体到技术方案，前端、后端和公司的基础设施都有一定影响，有些公司会找一个架构师来做整体方案，有些公司则是哥几个商量一下边做边出，其实因地制宜最重要，能达到目标的方案都是好方案。5）有了整体方案，到前端的一亩三分地上，技术选型、工程规范是绕不开的，有些公司有统一的前端团队，框架和工具都定好了，那么项目里面，就剩下分工和代码设计问题了，也有些公司有些项目具有特殊性，需要特别定制。

实际上，我很难给出具体的「框架选 Vue」，工具用「webpack」这样的建议，因为工程领域本来就是需要很多妥协和权衡的。不过，在我们课程的最后一部分，我选择了几个典型的基础设施和体系来讲，会给你分享这几个领域中我的认知。

## 0603期末答疑1前端代码单元测试怎么做.md

我们专栏课程的知识部分已经告一段落了。今天，我来集中解决一下大家在学习中遇到的问题，我争取用快问快答的形式，咱们多回答一些问题。

1、前端代码单元测试还是非常有必要的，不知道老师这一块是怎么做的，能否分享一下？

答：关于单元测试这件事，虽然在业务代码我没做成功过，但是它在框架和基础库开发中起到了非常积极的作用。我们平时写代码也肯定写一部分就要运行一下试试，其实这种行为就是单元测试，只是我们把很多自动化的内容，用人肉执行了，并且没有保存和管理 case，也没有统计 code coverage。

只要选择一个好的单元测试框架，单元测试成本其实不高，尤其是比较复杂的底层库，引入单元测试不但不会消耗时间，还会提高效率。所以我认为单元测试要实行，有两个关键点你要格外注意：一是出一套好的单元测试方案，二是在基础库和框架开发中引入单元测试。

2、关于 Undefined ，如果一个变量没有赋值后面又赋值，这个过程就是「变量会被篡改」的意思么？而 null 为什么又不会被篡改？一个变量开始定义为 null 然后赋值其他数据这个过程不算篡改吗？

答：undefined 是个全局变量，null 是个关键字，在一些版本比较旧的浏览器上，你可以试试：

```js
undefined = 1;
```

但是你在任何版本的浏览器上，都不能这么干：

```js
null = 1; 
```

这样的话，上面这个代码就会报错了。

3、winter 老师你好，我们公司的前端是 Node.js 写的，如何做性能监控呢，如何做页面加载优化呢，我对您的页面性能打分系统很感兴趣，能详细讲一讲吗？谢谢了。

答：首先，Node.js 写的是服务端代码跟前端性能没有任何关系，Node.js 的性能监控比前端性能监控复杂得多，你可以了解下 alinode。

前端性能打分可能主要包含几个部分。1）图片：检查图片数量和图片大小，比如单个超过 50k，总量超过 400k 的图片就要注意了，如果检查到小图片，也可以建议用 data uri 内联。2）请求数：检查请求数，检查是否有独立的 JS、CSS 请求，这些都是潜在的优化点。3）域名：检查域名是否有在 http dns 的范围内，检查域名数量是否过多，检查资源文件域名是否属于 CDN。4）实际加载时间：如果测试环境加载时间过程，也可能说明一些问题。5）缓存：检查静态资源是否设置了正确的缓存。你可以自己动手试试。

4、有一个疑惑是，大小写的两个属性有什么区别呢，比如：

```js
Screen，screen
Event，event
```

答：这里面大写的是类，小写的是对象。

5、我还是比较认同，从左往右匹配的规则，这样就像老师讲的可以在构建 DOM 树的同时来进行匹配 CSS 规则，相当于同时构建渲染树了，而不必等到 DOM 构建完毕再进行 CSS 的规则匹配。进行构建渲染树，虽然从右向左匹配对于复杂的选择器更优，但是这里面浪费了等待 DOM 构建完毕，才能使用的 CSS 匹配规则。而且相对于同为 id 等单一选择器而言，明显从左向右更具有优势！这是我的一点想法，望老师指正！

答：其实我在之前的分享中做过一个试验，当时的 Chrome 确实是从右往左，如果 #id 在最左，速度会更快，但是那个过程是后添加 CSS 的情况。

6、程老师你好。我在很多地方看到的说法是：CSS 会阻塞 DOM 渲染，但不会阻塞 DOM 的解析，且 CSS 文件的请求是异步请求。那么如果按照您所说，DOM 的构建和 CSS 属性的计算是同步的话，head 中 CSS 文件的下载以及 CSSOM 的 rule 部分的构建，应该会阻塞 HTML 的解析和 DOM 的构建。好像这两种说法之间就有了冲突。麻烦程老师有空的时候可以帮忙解释一下，万分感谢。

答：其实你误解了我的意思，DOM 构建的结果到 CSS 属性计算是个流水线，所以 CSS 会阻塞 CSS 计算，不会阻塞 DOM 构建。

7、老师，我记得有的书上或者是资料上说超过五次的 if else 就最好用 switch case 来替换。这样效率更好。您这里为什么说不用这个呢？

答：我在性能部分讲了，「凡是不做 profiling 的性能优化都是耍流氓」。具体的话，你可以看一看「43 | 性能：前端的性能到底对业务数据有多大的影响」这一篇。

8、函数调用和函数执行有什么区别？ 有没有相应的标准？

答：我们一般讲「A 函数调用了 B 函数」「浏览器执行了 B 函数」，所以你看，两者的区别是主语不同，你可以感受一下区别。它们对应的标准都是 ECMA262。

9、请问下老师，为什么 flexible 布局方案不再维护了呢？这个方案本身存在问题吗？

答：不存在问题，但是 rem 计算是个历史方案，现在，我比较推荐大家使用 vw。

10、有的工业软件，3D 建模的也可以用浏览器来实现了，用的是 ThreeJS WebGL，老师了解这些嘛？怎么看待这个发展前景。

答：挺好的，但是我觉得这件事由本来做 3D 的工程师转型更方便。

11、最近出于好奇，我 clone 了 github 上 chrome 的源码仓库，发现竟然有 12G 多，貌似比 linux 内核的源码还多。个人特别想探索一下浏览器源码，但面对如此庞大的代码，不禁望而生畏，也不知从何下手。请问老师，浏览器内核源码该如何去研究，skia 渲染引擎是最先进吗，svg，canvas，WebGL 该如何选择，怎样深入地学习和掌握它们呢？

答：你先编译通过吧，然后试着跑起来打断点这样子，其实这件事没有捷径，多花些时间就可以。skia 引擎是不是最先进，这事我也不好说，其实在工程领域我们一般不追求「最先进」，我们只需要它「足够先进」。关于如何选择，我收到了很多问题，不过我其实都不做回答，毕竟我没法替你决定你自己的职业发展道路，这个责任实在是有些重大了。

12、看完老师列出的表格更迷茫了，比如，为什么 transform 属于 level 1，transform 不是 CSS3 里的属性么？level4 是什么？是 CSS4 么？为什么 color 这种常用属性属于 level4? 不应该属于 level1 么？好迷茫哦。

答：我先解释一下你的问题，一方面，level4 里有不等于 level3 里没有，另一个是，W3C 定 level 并不是十分严谨，有从 1 开始，也有从 3 开始的。除此之外，我想提醒一下，这个表格并不是给你去看 level 的，而是告诉你标准在哪里，让你去读标准的。

13、请问老师，我后台用的是 Tomcat 服务器，前端用 ajax 请求静态资源时会间隔会报 412，也就是一次成功进入后台，一次报 412，这该怎么解决呢？答：理论上 412 意思是你浏览器的问题。从你提供的信息我没法给你解决方案，建议你可以搞一个最小复现环境去 Tomcat 社区问。

14、老师好，有个疑问： WHATWG 和 W3C 标准以哪个为准，这两个标准有什么区别？是不是相互不认可的。

答：这个问题比较复杂，WHATWG 最初是几家不满 W3C，出走搞出来的，后来被招安了把 HTML5 带回了 W3C，不过两边出标准的思路还是不太一样，WHATWG 是 living standard，就是随时更新标准，没有版本的概念，我是个人会倾向于 WHATWG 版本，因为比较新，而且 Chrome 跟得比较紧。

15、winter 老师好，可以给我讲一下那个 presentational attributes ，有些看不懂。

```js
function showThis(){
console.log(this);
}

var o = {
showThis: showThis
}

showThis(); // global
o.showThis(); // o
```

我知道函数中的 this 是由调用函数的对象决定的，但这种理解总感觉是由结论推原因；老师能不能讲解下。

答：this 是由调用函数的对象决定，这完全是个规定，没有什么原因。（你后面的问题我节选掉了，我其实没太理解到你想表述的意思，你看到了可以再给我留言）。

16、喜欢使用 let 和 const，看很多库里面，他们都喜欢使用 const，并且推荐使用 const，比如声明一个数组。老师能讲解下声明一个数组用 let 和 const 有什么区别吗？在操作数组时，都是往数组中 push 值，原先的变量并物理地址并没有发生变化，如果用 let，和用 const 有什么区别，为什么 const 的性能会好一点？

答：性能好一些完全是乱说的，用 const 的话，可以避免你误把数组整个赋值掉，比较有安全感吧。

1『看了郑烨的讲解，用 const 是借鉴了「函数式编程」范式里「不变性」的思想，所以以后能用 const 就用 const。』

17、老师我有几个问题希望你回答：1）老师讲到：「注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。」缓存的是什么东西，位图吗？如何减少重新渲染的？是不是所有的元素都有对应的位图？

文中你举了两个例子，说如果只有一个位图，任何改变都会引起所有重新渲染。这个好理解，一个大位图就是一个单元，任何的改动相当于这个单元被变了，所以要重新创建这个，这样理解对吗？但是你下面又说如果不合并，每次还是所有的重新渲染。感觉说的很矛盾啊。希望老师能回答一下我的疑问。

答：缓存的是位图，父子元素位置变化时，因为子元素的位图被缓存，子元素不需要重新渲染，因为父元素的位图也被缓存，父元素也不需要重新渲染，只有父子元素合成起来的位图需要被渲染。你这样理解是对的，如果不合并，每次改点什么东西，都要重新逐级合成最终的大位图，也相当于重新渲染。

18、老师，「当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。」这个能不能给个例子，不明白什么意思。

答：比如你在中文中插入几个阿拉伯语字符，阿拉伯语字符就会形成一个双向文字盒。

19、看了您的流式数据的解释，是不是可以理解当看到页面渲染的时候，DOM 是不是有可能都还没构建完成呢？即使是理论上，有这种可能吗？

答：渲染不但发生在 DOM 构建之前，甚至可能发生在你下载网页完成之前，比如你上个 XX 软件下载站，是不是下载链接还没见到，就看到广告了（你提到的网上的那段是别人写错了。我节选掉了）。

20、footer 也可以和 aside，nav，section 相关联 (header 不存在关联问题)，不存在关联问题是什么意思啊，不应该在 header 中使用吗？下面又说 header 中可以使用 nav，老师的「关联」是什么意思啊？

答：因为 footer 有自己的语义，footer 必须要指明是谁的 footer，这样 footer 中的作者、地址才有意义，所谓的关联就是这个意思了。

21、子元素的事件委托给父元素时，添加事件监听的第三个参数直接设置为 true，在捕获过程就判断父元素上的事件目标会比冒泡好些嘛？

答：对，但是你需要在捕获阶段想办法知道事件具体发生在哪个子元素上。

22、如果我想更深入的了解移动端的兼容问题，有没有好的学习路线呢？

答：兼容问题不是学出来的，你想在山中苦修，自出洞来无敌手？手机早就更新好几代了。所以兼容问题必须靠实践，在一个需要兼容性的业务上，不断积累和更新兼容性知识。

23、老师，我在理解 SICP 这本书的过程抽象和数据抽象的时候，代入到前端，比如生命周期、事件处理等更多是过程的抽象，能提出一些公用的过程，而数据抽象更多指的是组件内的数据定义、api 的设计、高阶组件等。

请问我这样理解对吗？或者说老师对过程抽象和数据抽象在前端中怎么理解的？如果理解得不对，有什么好的书或者文章帮助理解？

答：SICP 讲的是很实在的编程技巧，在前端中对应的是变量、循环、条件这些东西，SICP 是一本好书，你应该更认真地去阅读它。

1-2『原来 SICP 这本书籍之前已经下载过，1996 年出的第一版，2002 年出的第二版，第二版中译本是 2004 年出的，而且 2019 年还出了一本 JS 版的，大赞。列入必读经典书籍里。已下载书籍「2020167计算机程序的构造和解释 | 2020167Structure-and-Interpretation-of-Computer-Programs | 2020168Structure-and-Interpretation-of-Computer-Programs-JS」。（2021-04-14）』

24、通过这个课程老师对于前端的划分为 JavaScript、HTML 和 CSS、浏览器、工程实践几个部分。疑问 1：现在前端基本把 Node 也包括进来了，对于 Node 的知识应该怎么定位？疑问 2：Node 属于后端的范畴了，是否应该去学习下 java 相关的后端体系？学习了后端的体系是否会反过来促进前端知识的学习呢。

答：Node 属于后端，electron 属于客户端，不论你学哪个体系，肯定对前端都有促进作用。但是，你不能认为懂了 Node 就懂了后端，懂了 electron 就懂了客户端，每个领域都可以很深入，知识本来就是学不完的，你能掌握多少只跟投入的时间有关，这道理是很简单的，与其困惑，不如把困惑的时间拿来学习，相信你会有所收获的。

1-3『太意外了，这里竟然有 Electron，最开始学专栏的时候因为没 Electron 的知识，没概念。现在数智设计客户端迁移到 Electron，超级有感觉。（2021-04-14）』

25、老师，CSS 是如何依附在 DOM 树上的？是通过前面讲得 Node 实例来实现的？

答：在 Node 实例上添加属性，我在「12 | 浏览器：一个浏览器是如何工作的（阶段三）」讲到了，你可以返回去看看。

26、清楚为什么要使用语义化标签，是否有必要使用之前，很难让自己有动机去应用每个标签。另外标签新推出如何保持实时掌握最新的标签呢，如何解决浏览器兼容的问题？

答：对语义化标签，我是建议不必追求全部掌握，现有需求再找标签即可。

27、老师您好，有个疑问想请教一下，为啥基于对象关联风格的面向对象并不是像模拟类的行为的面向对象那么流行呢？原型委托这种的不是应该更符合 JavaScript 语言本身的设计嘛？类似这种：

```js
var father = {
a: 1,
fn(): {
  return 123;
}
}
var child = Object.create(father);
child.fn(); // 123
```

答：大部分人在学校学的都是 C++ 和 Java，我就没见过教原型的，这是现实，没办法。

29、老师，可否稍加解释一下执行上下文的分类？网络上的文章说「JavaScript 中可执行的代码可分为三种类型：全局代码、函数代码、eval 代码，对应三种执行上下文（全局执行上下文、函数执行上下文、eval 执行上下文）。在 ECMAScript 2018 中没有找到这种说法的依据。我的意思是，我不太清楚这些文章的说法是否正确，是否不够全面。

答：这个说法倒不能说不正确，但是严重过时了。现在 ECMAScript 2018 里面执行上下文非常复杂，你可以看看各种 Record，重学前端课程里面也没有讲全。

1-3『 Medium 上有一篇文章把三种执行上下文讲的很通透，详见「2020007MediumR00.md => 20200501Understanding-Execution-Context-and-Execution-Stack-in-Javascript.md」。（2021-04-14）』

30、老师，在 ES5 之前版本规范中，会提及 JavaScript 的可执行代码分为全局、函数、Eval。但是在 ES6 之后版本规范中，再也不提及可执行代码的概念了，这是为什么呢？

答：其实这里是重构了一下表达方式，新加入了模块什么的。

31、试过好多次，找了很多方法 flex 兼容 IE9 以下，每次都失败，有什么好的解决办法吗？

答：如果真有 IE9 兼容需求，我想只能单独写一份 CSS 了。

31、请问大佬，如何冻结对象，一般什么样的场景可以用到？

答：Object.freeze 函数可以冻结对象。一般都是写底层库，希望避免篡改。

32、两者到底有什么区别，想不明白，求教。

```js

new Promise(function(resovle, reject) {
  setTimeout(resovle, duration);
})
setTimeout(resovle, duration);

和

setTimeout(() => {resovle()}, duration);
```

答：这个区别不大的，第二种写法一般都是为了给 resolve 传参数，不过如果你不想给 resolve 传特定参数，为什么还要多写一个函数呢。

33、我听 JavaScript 像听天书，怎么办，是不是要从 0 重新学起呀？

答：理论上，我的课程是把 JavaScript 的内容重新组织了一下，如果平时就在用 JavaScript，我认为问题不大。如果这部分完全听不懂，可能说明确实基础薄弱，建议你从 0 学起。

## 0604期末答疑2每个逻辑页面如何可以做到独立发布呢.md

上一期的答疑文章发布之后，同学们的热情很高，我在后台又收到了一批新的问题，今天我们继续来答疑。

1、请问前端架构中，每个逻辑页面如何可以做到独立发布呢？

答：首先，我们要知道发布是什么意思，我们平时开发好一个网页，把它放到线上真实对用户服务的机器上，这个过程叫做发布。正常来讲，前端工程师发布的原材料是 HTML，产出是一个线上的 URL 地址。各个公司的发布系统差异非常的大，有的是前端发 HTML，有的是前端把代码给服务端同学，改成 JSP 之类的代码，再一起发布。

对于逻辑页面而言，我们需要发布的从 HTML 变成了 JavaScript，这个 JavaScript 代码的作用就是渲染一个页面的内容。同时我们线上还需要一个公共的 HTML 文件来运行这些 JavaScript。最后这些 JavaScript 文件只要能够做到独立发布，我们就可以认为逻辑页面是独立发布了。

2、对于一个后端开发者来说，前端最困难的东西永远是 CSS 布局而不是 JavaScript，我们对 CSS 有很大畏惧和恐慌在于：CSS 没有很好的调试工具能解决问题，即使 chrome dev 这样的顶级 debug 工具，有时候也很难解释诸如「为什么页面上的这个盒子在这个地方」这样的问题。感觉 CSS 完全不符合编程的思路，老师有没有办法缓解一下这个问题？

答：其实我在课程中已经解释过了，早期的 CSS 从思路上来说就很别扭，任何人都会觉得别扭，现在有了 Flex 布局，我认为这个问题基本可以算解决了。

3、最近一直在研究前端性能优化和线上错误收集，收效甚微，老师可以讲解一下大厂是怎么处理的吗？

答：这一部分，首先你需要一个比较通用的日志服务，能接受前端用 HTTP 请求的方式打一些日志进去，一般公司都会有这样的系统，如果没有，就需要新建一个，这部分比较麻烦，需要一定的专业知识。有了这个日志服务，剩下的就是在每个前端页面插入一个 JavaScript 代码，监听 Window.onerror 可以得到错误，取 window.performance 可以得到性能，拿到以后，打日志就行了。至于后续怎么去展示，展示了以后又怎么去推动执行，这块就需要你自己根据公司实际情况去找到解决方案了。

4、老师，想问一下用 float 排版的时候 margin 值在不同的浏览器中会显示不同，是什么原因导致的呢？

答：我是从 IE6 时代过来，我还真没听说过 margin 值有什么兼容问题，你可以拿具体的案例来，我们一起看一看。不过我建议早日切到 flex，我们不要在没价值的事情上浪费生命。

5、把链接分为超链接类和外部资源类是您自己的理解么，还是官方有这种分类呀，我没找到。老师可以说一下么？

答：不是，链接这个概念来自 HTML 标准（4.6.1 位置）。https://html.spec.whatwg.org/

我在 HTML 的部分都在讲这个问题，你可以关注一下。

6、老师，关于线上监控的数据采集和数据显示您有好的插件或者方案推荐？

答：这个其实没有现成的，这个东西，如果公司从数据安全的角度考虑，一般都不让用第三方的。

7、老师提到原生构造器无法继承。而阮一峰老师表示，es6 已经可以继承原生构造函数，并且能定义子类。以我的理解来看，阮一峰老师的说法没有问题。不知道老师怎么看？

答：我查了一下，你说的没错，还真是这样，这块我理解错了，我后面会迭代一下。

8、活动页面样式风格多变，并且有些活动页面是存在交互和购买流程等交互，这些交互怎么做成模板化？

答：这个答案很简单，只要能传参数，就能做成模板化。

9、DOM 树就是一种嵌套的数据结构吗？然后是渲染引擎将这个数据结构处理成我们看到的网页吗 ？

答：DOM 树是嵌套的树形结构，渲染过程是把它变成位图，绘制过程是把它画到显示器上。关于这部分内容，你可以回顾一下浏览器原理部分的几节课。

10、浏览器中大多数的对象都原型继承自 Object，是否可以根据原型继承关系将 Window 上面的 api 绘制成一颗树？有了这些继承关系是否更容易理清这些全局属性呢？

答：API 不止有类，也有很多函数呀。所有的函数 API 的原型都是 Function.prototype，这不就没意义了么。

11、「宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。」但是下面对宿主对象的解释又是：「实际上，这个全局对象 windows 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境」。这并不像上面说的完全由宿主环境决定，这个怎么理解呢？

答：请注意看了，我这里讲宿主对象有个「们」字。所以，这里可不是对宿主对象的解释，这是对 Window 对象的解释。Window 对象比较复杂，这块我没有详细讲，从 JavaScript 的 Global Object 的角度可以讲，浏览器部分还有个 Window Proxy 机制，我是觉得复杂又没什么实际意义就没有讲，你可以这样感性地理解一下：全局对象和 Window 对象合成了一个东西。

12、winter 老师，我看到淘宝用了 iframe 标签，能给我讲一下这个标签的使用场景和注意点吗？

答：我可以简单告诉你一个口诀：手机上不要用，PC 上除了历史包袱不要用。

13、请问下，link preload 解析执行时机和构建 CSSOM 一样吗，HTML 从上往下解析到 link preload 才会解析执行？还是说并行解析 HTML 和 preload？

答：从标准来看应该是可以并行，但是具体怎样这块需要看浏览器源代码确定。

14、老师，在 ES5 之前版本规范中，会提及 JavaScript 的可执行代码分为全局、函数、Eval。但是在 ES6 之后版本规范中，再也不提及可执行代码的概念了，这是为什么呢？

答：它们还在，只是现在执行过程更复杂了，没法这么简单分类了。

15、winter 老师，你提倡多继承吗？还是说尽量用聚合来解决问题？我看着 ES6 里面要实现多继承的方式也挺别扭的。

答：我不提倡多继承，Java 也不支持多继承啊。如果你想抽象可以用接口来代替，想复用可以用 Mixin 来代替。

16、我这里还有个问题，使用 figureCaption 标签后，img 标签的 alt 属性可以缺失么？我一直觉得 alt 与 src 情同手足，什么都不应该把彼此拆散的。

答：不可以缺失，这是两个意思，figureCaption 可能是「图 1」这种东西，可不一定在描述图片内容。

17、老师，style 既然也可以这么用 `\<style>css 规则 \</style>`，为什么没有 `\<style src="">\</style>`？

答：你这个设计得不错，但是估计有了 link 以后，HTML 懒得把 style 改成 replacement 了吧。

18、老师好，想请问下，业务场景中需要嵌入公司其他行业线的页面，这种不使用 iframe 该怎么办？

答：理论上应该让他们给你做个组件出来，但是如果实在没别的办法，就使用 iframe 吧。

19、老师，目前有办法通过脚本反射的方式获取所有 JavaScript 原生对象吗？还是只能查文档？通过 for. in 遍历全局对象是不可以的，因为这些 JavaScript 原生对象虽然挂到了全局，但是属于不可枚举成员。

答：我们现在可以用 Object.getOwnPropertyNames，但是你 symbol 还是拿不到。

20、老师，jquery ajax 同步请求的原理是？目前用 axios 库，不支持同步请求，如果希望执行同步请求有什么解决办法？

答：原理是 XMLHttpRequest 这个可以传第三个参数，但是我不建议你用同步请求，会把 JS 执行线程卡住。

21、老师您好，把 JavaScript 代码缓存在 localStorage 中，从 localStorage 取出后怎么执行？ 如果缓存的是 CSS 呢？

答：执行 JavaScript 用 eval，执行 CSS 用 `document.createElement ("style")`。

22、请问：var、let 和 const 在 babel 中都会被编译为 var，那怎么区分 const 是常量呢？

答：如果你用 babel 的话，就不要管编译后的代码。

23、DOM 树构建与 CSSOM 构建有先后关系吗？CSS 计算与 DOM 树流式构建同步进行是不是意味着 DOM 树流式构建之前，CSSOM 已经构建完成呢？

答：我这里说的确实有点歧义，我在这里再厘清一下。CSSOM 是有 rule 部分和 view 部分的，rule 部分是在 DOM 开始之前就构件完成的，而 view 部分是跟着 DOM 同步构建的。

24、老师能解释下这个么？

```js
var b = 10;
(function b(){
  b = 20;
  console.log(b); // [Function: b]
})();
```

答：这个地方比较特殊，「具有名称的函数表达式」会在外层词法环境和它自己执行产生的词法环境之间，产生一个词法环境，再把自己的名称和值当作变量塞进去。所以你这里的 b = 20 并没有改变外面的 b，而是试图改变一个只读的变量 b。这块儿的知识有点偏，你仅做理解掌握就好。

25、关于状态机这一块，我觉得是不是可以先讲一节正则的知识点呢。理解了正则，那么大家对状态机的概念就有了更加直观的理解了。

答：一般正则都是状态机实现的，讲正则对理解它底层的状态机并没有多少意义。

当然了，词法分析也可以用正则来实现，我这里没有这么做而已，我写过一个 JavaScript 的词法分析是用正则做的，你可以参考这里：[JSinJS/LexicalParser.js at master · wintercn/JSinJS](https://github.com/wintercn/JSinJS/blob/master/source/LexicalParser.js)。