## 记忆时间

2020-08-09

## 目录

0101当谈论面向对象的时候我们到底在谈论什么.md

0102封装抽象继承多态分别可以解决哪些编程问题.md

0103面向对象相比面向过程有哪些优势.md

0104哪些代码设计看似是面向对象实际是面向过程的.md

0105接口vs抽象类的区别.md

0106为什么基于接口而非实现编程.md

0107为何说要多用组合少用继承.md

## 0101当谈论面向对象的时候我们到底在谈论什么.md

1、什么是面向对象编程？面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

2、什么是面向对象编程语言？面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

3、如何判定一个编程语言是否是面向对象编程语言？如果按照严格的的定义，需要有现成的语法支持类、对象、四大特性才能叫作面向对象编程语言。如果放宽要求的话，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

4、面向对象编程和面向对象编程语言之间有何关系？面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

5、什么是面向对象分析和面向对象设计？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。

考虑到各个水平层次的同学，并且保证专栏内容的系统性、全面性，我会循序渐进地讲解跟设计模式相关的所有内容。所以，专栏正文的第一个模块，我会讲一些设计原则、设计思想，比如，面向对象设计思想、经典设计原则以及重构相关的知识，为之后学习设计模式做铺垫。

在第一个模块中，我们又首先会讲到面向对象相关的理论知识。提到面向对象，我相信很多人都不陌生，随口都可以说出面向对象的四大特性：封装、抽象、继承、多态。实际上，面向对象这个概念包含的内容还不止这些。所以，今天我打算花一节课的时间，先大概跟你聊一下，当我们谈论面向对象的时候，经常会谈到的一些概念和知识点，为学习后面的几节更加细化的内容做一个铺垫。

特别说明一下，对于今天讲到的概念和知识点，大部分我都是点到为止，并没有展开详细讲解。如果你看了之后，对某个概念和知识点还不是很清楚，那也没有关系。在后面的几节课中，我会花更多的篇幅，对今天讲到的每个概念和知识点，结合具体的例子，一一做详细的讲解。

### 1.1 什么是面向对象编程和面向对象编程语言？

面向对象编程的英文缩写是 OOP，全称是 Object Oriented Programming。对应地，面向对象编程语言的英文缩写是 OOPL，全称是 Object Oriented Programming Language。面向对象编程中有两个非常重要、非常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在 1960 年，在 Simula 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 Smalltalk 这种编程语言中。Smalltalk 被认为是第一个真正意义上的面向对象编程语言。

1980 年左右，C++ 的出现，带动了面向对象编程的流行，也使得面向对象编程被越来越多的人认可。直到今天，如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言，比如 Java、C++、Go、Python、C#、Ruby、JavaScript、Objective-C、Scala、PHP、Perl 等等。除此之外，大部分程序员在开发项目的时候，都是基于面向对象编程语言进行的面向对象编程。

以上是面向对象编程的大概发展历史。在刚刚的描述中，我着重提到了两个概念，面向对象编程和面向对象编程语言。那究竟什么是面向对象编程？什么语言才算是面向对象编程语言呢？如果非得给出一个定义的话，我觉得可以用下面两句话来概括。

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲，面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。这里听起来是不是有点绕？不过没关系，我们在后面的第 7 节课中，会详细讲解这个问题。

除此之外，从定义中，我们还可以发现，理解面向对象编程及面向对象编程语言两个概念，其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。不过，关于面向对象编程的特性，也有另外一种说法，那就是只包含三大特性：封装、继承、多态，不包含抽象。为什么会有这种分歧呢？抽象为什么可以排除在面向对象编程特性之外呢？关于这个问题，在下一节课详细讲解这四大特性的时候，我还会再拿出来说一下。不过，话说回来，实际上，我们没必要纠结到底是四大特性还是三大特性，关键还是理解每种特性讲的是什么内容、存在的意义以及能解决什么问题。

而且，在技术圈里，封装、抽象、继承、多态也并不是固定地被叫作「四大特性」（features），也有人称它们为面向对象编程的四大概念（concepts）、四大基石（cornerstones）、四大基础（fundamentals）、四大支柱（pillars）等等。你也发现了吧，叫法挺混乱的。不过，叫什么并不重要。我们只需要知道，这是前人进行面向对象编程过程中总结出来的、能让我们更容易地实现各种设计思路的几个编程套路，这就够了。在之后的课程讲解中，我统一把它们叫作「四大特性」。

### 1.2 如何判定某编程语言是否是面向对象编程语言？

如果你足够细心，你可能已经留意到，在我刚刚的讲解中，我提到，「如果不按照严格的定义来说，大部分编程语言都是面向对象编程语言」。为什么要加上「如果不按照严格的定义」这个前提呢？那是因为，如果按照刚刚我们给出的严格的面向对象编程语言的定义，前面提到的有些编程语言，并不是严格意义上的面向对象编程语言，比如 JavaScript，它不支持封装和继承特性，按照严格的定义，它不算是面向对象编程语言，但在某种意义上，它又可以算得上是一种面向对象编程语言。我为什么这么说呢？到底该如何判断一个编程语言是否是面向对象编程语言呢？

还记得我们前面给出的面向对象编程及面向对象编程语言的定义吗？如果忘记了，你可以先翻到上面回顾一下。不过，我必须坦诚告诉你，那个定义是我自己给出的。实际上，对于什么是面向对象编程、什么是面向对象编程语言，并没有一个官方的、统一的定义。而且，从 1960 年，也就是 60 年前面向对象编程诞生开始，这两个概念就在不停地演化，所以，也无法给出一个明确的定义，也没有必要给出一个明确定义。

实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。

比如，我们在面向对象编程的过程中，经常会遇到 is-a 这种类关系（比如狗是一种动物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时候就开始摒弃继承特性，比如 Go 语言。但是，我们并不能因为它摒弃了继承特性，就一刀切地认为它不是面向对象编程语言了。

实际上，我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。基于此，我们才有了前面的说法，按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。

所以，多说一句，关于这个问题，我们一定不要过于学院派，非要给面向对象编程、面向对象编程语言下个死定义，非得对某种语言是否是面向对象编程语言争个一清二白，这样做意义不大。

### 1.3 什么是面向对象分析和面向对象设计？

前面我们讲了面向对象编程（OOP），实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析（OOA）和面向对象设计（OOD）。面向对象分析英文缩写是 OOA，全称是 Object Oriented Analysis；面向对象设计的英文缩写是 OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。

关于什么是面向对象编程，我们前面已经讲过了。我们现在再来讲一下，什么是面向对象分析和设计。这两个概念相对来说要简单一些。面向对象分析与设计中的「分析」和「设计」这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。不过，你可能会说，那为啥前面还加了个修饰词「面向对象」呢？有什么特殊的意义吗？

之所以在前面加「面向对象」这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。

看到这里，你可能会问，那面向对象分析、设计、编程到底都负责做哪些工作呢？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。今天，我们只是简单介绍一下概念，不展开详细讲解。在后面的面向对象实战环节中，我会用两节课的时间，通过一个实际例子，详细讲解如何进行面向对象分析、设计和编程。

### 1.4 什么是 UML？我们是否需要 UML？

讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 UML（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。

实际上，UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序图、活动图、状态图、组件图等。在我看来，即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。

要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。

所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。

所以，我这里特别说明一下，专栏中的很多类图我并没有完全遵守 UML 的规范标准。为了兼顾图的表达能力和你的学习成本，我对 UML 类图规范做了简化，并配上了详细的文字解释，力图让你一眼就能看懂，而非适得其反，让图加重你的学习成本。毕竟，我们的专栏并不是一个讲方法论的教程，专栏中的所有类图，本质是让你更清晰地理解设计。

### 黑板墙

今天我们要讨论的话题有两个：1）在文章中，我讲到 UML 的学习成本很高，沟通成本也不低，不推荐在面向对象分析、设计的过程中使用，对此你有何看法？2）有关面向对象的概念和知识点，除了我们今天讲到的，你还能想到其他哪些吗？

在这篇文章中，「面向对象编程」一词多义，不同的场景、语境下，解释不同。文章中没有点到这一点，我这里稍微补充说明一下：1）文章前半部分，面向对象编程指的是一种编程风格或者范式。2）文章后半部分，在讲到面向对象分析、设计、编程的时候，面向对象编程是一种行为。2019-11-11

UML 中定义了类之间的关系：泛化、实现、关联、聚合、组合、依赖，试问下小伙伴们，你们都能搞清楚这几个的区别吗？能否准确的用不同的箭头、图线来画出来吗？即便你能画出来，团队里的小伙伴都能看懂吗？ 不过，关于类之间的关系，我后面会在实战篇中讲到的，但是，我会简化成四种关系，更好理解。2019-11-11

关于 UML 推荐一本书《Java Modeling In Color With UML》和一个神器：[ZenUML - Workspace](https://app.zenuml.com/)。2019-11-11

我理解的是要因场景而异，但是最终的目的都是降低沟通的成本。场景 1：在大多数人对 UML 不是很熟练的情况下，如果采用 UML 来进行沟通，大家在理解上一定会存在 Gap，无形之中会提高学习和沟通的成本，在这种情况下，建议不使用 UML。举个例子，《实现领域驱动》的作者一开始是使用 UML 和领域专家沟通，作者认为 UML 很简单，但是许多领域专家或开发人员并不能很好地理解，最后又出现了 ES（事件风暴）的形式来替代。场景 2：如果需要准确传达设计意图，还是需要 UML 这样的通用设计工具的，目的也是降低沟通的成本。例如，架构师的设计理念想准确传达给工程师，如果使用 UML 工具，可以避免模糊意图，带来额外的沟通成本。敏捷宣言的第一条就是「个体和沟通」高于「流程和工具」。所以要因人而异，因场景而异，在专栏里「很多类图我并没有完全遵守 UML 的规范标准」的策略，我想是一个不错的折中。2019-11-11

对于 UML（统一建模语言），我个人觉得它的作用还是很大的，因为它可以帮助开发人员更好的去分析一个软件的设计过程，通过它的哪些表示的方法吗，会让人的思路更加的清晰，如果是一个软件的负责人，那么使用 UML 来分析问题，我觉得再好不过。软件开发是一个工程问题，就好比盖房子，只有每一步都规划好，分析好，设计好，盖出来的房子才好，总之，我个人觉得值得花时间去学 UML！2019-11-12

确实很多公司使用 UML 的频率比较低，大厂也是这样。另外我自己对 Google 的了解是对代码要求很高，那么代码交付还有文档的要求想必也很高，不知道 Google 公司在文档上面会不会大量使用 UML，如果不用的话，有没有更好的方式或语言来维护高质量的文档。作者回复：好像没有多少人画 uml，文档主要还是聚焦于业务和更上层的架构设计、技术难点说明，实现直接看代码。2019-11-12

我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。曾经面试的时候被问到，领域驱动设计和数据表驱动设计有什么区别，我觉得王老师的这句话总结的很到位。2019-11-11

汇总：1）对 uml，真正掌握确实有难度，很容易忘记，原因可能是自己并没有真正的理解设计这件事，比如说 uml 中是用泛化还是实现不是问题的本质，本质是对于一个特定问题，要如何设计才是尽可能最好的；这中间有两层：将自己的想法转成可表达的设计和将可表达的设计让别人也能理解你的意图，而 uml 就是一种可表达的方式，至于是不是 uml 并不重要；但是 uml 有一套规范，而且知名度高，大家多少都有一些了解，所以就成了一种大家相互沟通的通用语言，所以学 uml 是需要的。我现在是傻傻分不清泛化、实现、关联、聚合、组合、依赖和他们的表达形式。2）想到了编程范式，虽然不是它不是面向对象独有的东西，OO 只是众多范式中的一种。2019-11-11

不是来挑刺的，发现有更好的论述与大家分享。下面内容总结自邵维忠和杨芙清院士的著作《面向对象的系统设计（第 2 版）》，主要看第 20 页，解答了我当年的疑惑：面向对象分析不能简单说是要搞清楚做什么，系统分析！= 需求分析。面向对象分析是指系统分析，它既是对「做什么」问题的进一步明确，也是相当程度上涉及到「怎么做」的问题。重点来了，OOA 产生的系统模型与实现条件无关，OOD 产生的系统模型针对具体的实现平台。2020-05-13

UML 确实很复杂，我认为使用 UML 表达出设计的意思即可，没有必要完全遵从 UML 的规范。比如我目前的工作中，用到的 UML 好像只有类图、时序图、用例图三种。对于类图，也只用到过继承、实现、依赖三种关系。时序图刚刚使用时恨不得将每个类的每个方法的调用关系都画出来，结果不仅使得时序图看上去很复杂，连自己过段时间再看也觉得太复杂了，结果是辛苦半天却事倍功半，后来时序图也是越画越简单，只要能表达出调用关系即可。2020-02-26

## 0102封装抽象继承多态分别可以解决哪些编程问题.md

1、关于封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

2、关于抽象特性。封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

3、关于继承特性。继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。

4、关于多态特性。多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

上一节课，我简单介绍了面向对象的一些基本概念和知识点，比如，什么是面向对象编程，什么是面向对象编程语言等等。其中，我们还提到，理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。所以，今天我就花一节课的时间，针对每种特性，结合实际的代码，带你将这些问题搞清楚。

这里我要强调一下，对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。所以，今天，我们在讲解四大特性的时候，并不与具体某种编程语言的特定语法相挂钩，同时，也希望你不要局限在你自己熟悉的编程语言的语法思维框架里。

### 2.1 封装（Encapsulation）

首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。

下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。对于虚拟钱包的业务背景，这里你只需要简单了解一下即可。在面向对象的实战篇中，我们会有单独两节课，利用 OOP 的设计思想来详细介绍虚拟钱包的设计实现。

```java
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

从代码中，我们可以发现，Wallet 类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。

```java
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)
```

之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。

1『透明的意思就是不知道细节。』

对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。

封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中「偷偷地」重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。

### 2.2 抽象（Abstraction）

讲完了封装特性，我们再来看抽象特性。封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

这里我稍微说明一下，在专栏中，我们把编程语言提供的接口语法叫作「接口类」而不是「接口」。之所以这么做，是因为「接口」这个词太泛化，可以指好多概念，比如 API 接口等，所以，我们用「接口类」特指编程语言提供的接口语法。对于抽象这个特性，我举一个例子来进一步解释一下。

```java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。

之所以这么说，那是因为，类的方法是通过编程语言中的「函数」这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。

除此之外，在上一节课中，我们还提到，抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供「函数」这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的「特异性」，有时候并不被看作面向对象编程的特性之一。

抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？

实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl ()，那即便内部存储方式修改了，我们也不需要修改命名。

### 2.3 继承（Inheritance）

学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 <。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

为什么有些语言支持多重继承，有些语言不支持呢？这个问题留给你自己去研究，你可以针对你熟悉的编程语言，在留言区写一写具体的原因。继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？

继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看「父类、父类的父类……」的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。

所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到「多用组合少用继承」这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。

### 2.4 多态（Polymorphism）

学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。

```java
public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) { //保证数组中的数据有序
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。1）第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。2）第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。3）第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。

1『醍醐灌顶，多态对应于「子类替换父类」，哈哈。（2020-07-30）』

对于多态特性的实现方式，除了利用「继承加方法重写」这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码。

```java
public interface Iterator {
  String hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、hasNext() 实现。

具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候，print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。

刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。我们还是先来看一段代码。这是一段 Python 代码。

```py
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。

2『实现多态的 3 个手段，基于继承、基于接口、基于 duck-typing，多使用后两种。做一张术语卡片。』——已完成

多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？

多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator 的例子）。在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print (Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。

### 黑板墙

1、你熟悉的编程语言是否支持多重继承？如果不支持，请说一下为什么不支持。如果支持，请说一下它是如何避免多重继承的副作用的。

2、你熟悉的编程语言对于四大特性是否都有现成的语法支持？对于支持的特性，是通过什么语法机制实现的？对于不支持的特性，又是基于什么原因做的取舍？

争哥对面向对象的总结完美符合 What/How/Why 模型，我按照模型作下梳理。1）封装：隐藏信息，保护数据访问；暴露有限接口和属性，需要编程语言提供访问控制的语法；提高代码可维护性、降低接口复杂度、提高类的易用性。2）抽象：隐藏具体实现，使用者只需关心功能，无需关心实现；通过接口类或者抽象类实现，特殊语法机制非必须。提高代码的扩展性、维护性，降低复杂度，减少细节负担。3）继承：表示 is-a 关系，分为单继承和多继承；需要编程语言提供特殊语法机制。例如 Java 的「extends」，C++ 的「:」；解决代码复用问题。4）多态：子类替换父类，在运行时调用子类的实现；需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing；提高代码扩展性和复用性。3W 模型的关键在于 Why，没有 Why，其它两个就没有存在的意义。从四大特性可以看出，面向对象的终极目的只有一个：可维护性、易扩展、易复用，降低复杂度等等都属于可维护性的实现方式。2019-11-14

Java 不支持多重继承的原因。多重继承有副作用：钻石问题（菱形继承）。假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从 JDK1.8 之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。2019-11-13

封装就是让代码遵守开闭原则的重要手段。当调用类，关注过多实施类的细节时，一个需求的变化，可能引发多个依赖模块都发生了级联的改动，而一但调用类过度的知道了实施类的细节（然后各种调用类代码再一散落），这时程序也相应地变得出各种毛病出来，既然这样，把实现的方法封装起来多好，让调用端少操点心。Law of Demeter 有个别名，就叫最少知道原则，争哥说的第二个意义，感觉就是在描述遵守迪米特法则的好处。

再乱想一下，人体，不就是最好的的封装么，给你物料的入口（吃），出口（拉），还给你调节增强的接口（训练） 有多少人，并不知道其内部细节，不照样过着精彩的一生。还有，调用类，总想知道更多被调用类的信息，以期更精准的控制，这种代码风格，就是完美主义病，而完美主义的并发症就是拖延症，以及极高的复杂度造成项目越写越混乱。

抽像讲的是如何隐藏信息，而抽像讲的是隐藏方法的具体实现，让调用者只关心方法提供了哪些功能即可。通常借 interface 和 abstract class 来实现抽像这一特性。当 implement 某接口时，只要知道接口干了啥，即可，无需要关心实施类的细节实现。

个人理解：（抽象处理的复杂度是人月神话里描述的本质复杂度（Essential Complexity），也是尊重人脑的认知学的 ，大脑的特性是很烂的（ 抽像的工具包记重点，归纳特性，忽视细节）。再瞎想一下，抽像是将很多的知道点给封装起来了（encoding 成为一个模型），归纳法便是抽象的重要实现套路，也是支撑及发展文明的利器。抽像在开发中的意义 ，是让具体的实施类，在合适的场所下编写 （最好满足 sru）, 然后通过合理的 ood，去调用或运行时 create 具体的子类对象，去实现。拜抽象所赐，一种各有分工，又能有序协同的场景就出来了。其三，个人套路包，我沟通时，当和建议相同方向时，就往抽像了说，当想有差异时，就很细节说。（套路是双韧剑，就看你如何用了），我个人发现很多营销大的套路，抽像来看和传销是一至的，有些技术大牛的工作套路，和某著名贪官一模一样。（例如，把话说明白了再干，明确职责）

继续用来表示类之间是 is -a 关系。猫是动物，于是就拥有的动物的自带属性行为。（移动速度，移动距离） 进一步的，动物属生物（于是） 有了生命的共有属性，年龄。有些语言单继续，有些多继承。

意义和解决问题。1）符合认知美感 。2）减少重复 coding。问题：重要隐患，父子类，大量方便藕合。个人理解：继续和不停的复杂粘贴代码是两个极度，复制代码虽散但各管各的，继续父一改，子跟着改，而复制代码这事，是问题是，实现一个细节后，其它的相联代码，都要不停的改。而继随相反，一改全刷了，除非你子类完全重写了，而一些不成熟的开发，前期的父类往往考虑不周，后期一折腾，悲剧从此开场。再者复制粘贴代码，两段代码关联太轻，基本上就是要一处一处的改，而复制这事，就关联得太重了。一但重了，就往往产生大量的不必要的负担。我学设计模式最开心的就是，基于原则，而不是基于规则，不同场景就用不同的套路。基于职责太重这事，我是很反感用多重继续的。需要啥，再组合一个类多好。多关联一个类，死不了人的。搞出菱形继随这种蛋疼的东西，又要不停的去关注细节，活着会很累的。

1『需要啥，再去组合一个类。』

多态。（个人觉得 oo 中最有趣的一块）多态指子类替代父类。三种语法机制。（父可以）实现多态，除继续外，还有利用接口类语法，duck-typing。个人理解：理解不深。有感觉描述不出来，就觉得，继续把事搞死了，多态就要死的东西搞活。于是支持这种把事搞活的套路出来。2019-11-14

c 语言通过结构体来实现封装，只是 c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外 C 中通过 void*+ 结构体 + 函数指针也是可以实现多态的。Linux 内核代码好多都是用了面向对象编程思想。C++ 中引入 public protected private 关键字来进行访问控制权管理。C++ 中没有 Java 中的 interface 关键字来描述接口类，但也是可以通过虚函数基类来进行的 Java 中的接口类的。C++ 是直接支持多继承的，但这个特性也被好多人诟病。2019-11-13

JavaScript 不支持多继承，多继承理论上都存在「菱形问题」，也就是说如果 class D 继承了 class B 和 class C，class B 和 class C 都继承了 class A，class A 中有一个方法 add，B 和 C 都重写了 add 方法，当 D 去调用 add 方法时就会出问题，不知道调用哪个方法了。理论上是可以通过 Mixin 的方式来实现多继承。通过一些「合并」算法来「部分」解决「菱形问题」。参考 [JavaScript 中的多继承 - 前端 - 掘金](https://juejin.im/entry/5ac46b6c5188255570063b71)。

3『0121附件JavaScript中的多继承.md

JavaScript 很容易模拟一个「类」，并且可以一定程度上做到面向对象中的三大特性：封装、继承、多态。从最初去模拟一个「类」，到 ES5 提供更便捷的原型操控 API，到 ES6 中提供更多「类」相关的关键字，都是在帮我们减小 JavaScript 中面向对象的使用成本。

虽然 JavaScript 中的「继承」并不是真正的继承，「类」也不是真正的「类」，相比 Java 肯定还有很多实现不了的地方，比如 abstract class、Interface 等，只能通过一些 tricky 的办法去模拟。因此 JavaScript 中所谓的「继承」，是为了方便程序员用面向对象的方式来组织代码。

为什么不建议继承。说了那么多，笔者的体会是不要想着继承，不要想着继承，不要想着继承。JavaScript 本身就不是面向对象的语言，干嘛要让它做它不擅长的事情。虽然语法糖已经提供了「类」的支持，那是照顾有面向对象想法的人，但它本质上不同于其他语言中的继承。不要把他人的宽容当作放任的理由，能模拟继承就不错了，就别再惦记「多继承」了。

再回过头来想一想，我们为什么需要继承？继承是一种强耦合关系，到底是否有必要用继承，可以考虑下在应用场景中是否需要用父类型去接收子类型的实例，即子类向父类的向上转型。在 JavaScript 中不会出现这样的需求，应该更多使用组合的方式以代替继承，以及函数式编程也许是更好的方案。

本文从 JavaScript 语言机制出发，回顾了随着语言的进步，「类」与「继承」在 JavaScript 中变得越来越方便。然后讨论了「多继承」时需要考虑的问题，介绍了 Method Resolution Order（MRO）和 C3 算法，并尝试在 JavaScript 中模拟「多继承」。然而，JavaScript 本质上不存在「类」的概念，也不存在真正意义上的继承。这种通过 prototype 模拟出来的「多继承」必然不会太完美，体验上比原生支持继承的语言要差的多。因此不要想着多继承，JavaScript 中也不建议频繁使用继承。

』

JavaScript 支持封装、抽象、继承、多态。封装 ES6 的话，通过 public protected private 等关键字来实现，ES5 的话通过「函数作用域」，this，原型链来实现，ES6 的 class 本质上也是 function 的语法糖。抽象可以通过 this 指针和原型链的形式来实现。继承通过原型链来实现，或者说基于封装的特性来实现。多态通过原型链的方式，子类覆写父类的方法来实现。2019-11-15

Python 相关：1）抽象：抽象是编程语言的共有特点，甚至是计算机科学的特点，从变量、函数、类、模块，包等概念都是不同层次的抽象。抽象和把大象装进冰箱分三步是一个道理，它给出了思路，指明了方向，省略了细节。我们用层层抽象来应对计算机系统的复杂性。Python 主要的抽象工具是函数和类，模块和包也算吧，毕竟也是隐藏了细节。2）封装：Python 不支持严格意义上的封装，没有 private、protected 等访问修饰符，这样做是为了保证动态语言最大的灵活性，同时 Python 里很多理念都是约定大于定义的，私有的属性需要大家守约，不要去随意访问，这也是 Python 被吐槽的地方吧，大型项目约束力不够。3）继承：Python 支持多重继承，主要是因为它没有类似于 Java 的「接口类」的语法吧，用多重继承可以定义一些纯功能性的类，减少类的层级。4）多态：Python 的多态就是鸭子类型了，鸭子类型的背后是所谓「协议」，协议是非正式的接口，是一种特性，表现为一个或多个相关的方法，比如迭代器协议，序列协议。实现了迭代器协议就和 Java 中实现了 Iterator 接口一样。2019-11-13

请问 c++ 的 template 算不算 duck-typing？ 比如定义一个模版，A\<T>，用到函数 T.Load()。然后有类 B 和 C 都有成员函数 Load()。那么都可以通过使用 A\<B> 和 A\<C> 来使用模版，而 B、C 之间不需要继承关系。作者回复：从你的描述来看，有点类似的。2019-11-17

Python 是支持多继承的，对于多继承的二义性问题，有一套 MRO（Method Resolution Order）机制来解决，简单说就是排序。目前是采用 C3 算法，对继承关系建树后，使用拓扑排序得到序列；在 python2.2 之前也有用 DFS 去获取继承序列，但 DFS 会出现继承不到子类对于父类的重写，而后更新为 C3 算法，解决了本地优先级及单调性的问题。2019-11-12

Python 支持多重继承，带来钻石继承问题主要是两点：一是父类方法的调用顺序，二是父类方法会被执行多次。对问题一，python 使用了 C3 算法，在避免同一类被调用多次的前提下，使用广度优先和从左到右的原则寻找需要属性和方法，使用 funcitonname.\_\_mro\_\_可以查看调用顺序。对问题二，python 在子类重写方法时，使用 super().methodname() 语句，super 本质上是一个类，内部记录着 MRO 信息，也是用 C3 算法保证一个类只会被搜寻一次。2019-11-15

最近在探索 DDD 的时候有个问题，当涉及 db 或 api 时该怎么设计。比如你上面提到的账户调增，理论上有个人的账户都会有个新的对象，但假如调增要调用 api，那这个 api 需要这个账户类持有么？那每次创建对象还要 set 进去？感觉不是很舒服。作者回复：感觉还是一种数据驱动或者 db 驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db 中数据的读和存只是很小的一部分。2019-11-15

Swift 不支持多重继承，原因应该和其他不支持多重继承的原因一样，为了避免多重继承额外引入的复杂度。Swift 支持封装、抽象、继承、多态：对封装的语法支持是通过 fileprivate 关键字隐藏不暴露的变量和方法；对抽象的支持是通过 protocol 关键字；对继承的支持是 class A: Class B，对多态的支持是子类重写父类的方法。2019-11-14

ava 不支持多继承，弊端之一的菱形问题就不赘述了，我认为多继承带来的另外一个问题就是复杂性的增加，我们在写程序之前，常常会按照「接口 -> 抽象类 -> 实现类 -> 拓展实现类」这样的模式，这样设计出来的一组类是与某一个「业务」强相关的，如果可以多继承，以上流程就可以在任一环节继承其他一组类，这样的设计会造成更高的复杂性与耦合性，之后理解与维护的成本会更高。2019-11-13

## 0103面向对象相比面向过程有哪些优势.md

在上两节课中，我们讲了面向对象这种现在非常流行的编程范式，或者说编程风格。实际上，除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前还没有被广泛接受。在专栏中，我不会对函数式编程做讲解，但我会花两节课的时间，讲一下面向过程这种编程范式。你可能会问，既然面向对象已经成为主流的编程范式，而面向过程已经不那么推荐使用，那为什么又要浪费时间讲它呢？

那是因为在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。

所以，我打算详细对比一下面向过程和面向对象这两种编程范式，带你一块搞清楚下面这几个问题（前三个问题我今天讲解，后三个问题我放到下一节课中讲解）：1）什么是面向过程编程与面向过程编程语言？2）面向对象编程相比面向过程编程有哪些优势？3）为什么说面向对象编程语言比面向过程编程语言更高级？4）有哪些看似是面向对象实际是面向过程风格的代码？5）在面向对象编程中，为什么容易写出面向过程风格的代码？6）面向过程编程和面向过程编程语言就真的无用武之地了吗？

### 3.1 什么是面向过程编程与面向过程编程语言？

如果你是一名比较资深的程序员，最开始学习编程的时候，接触的是 Basic、Pascal、C 等面向过程的编程语言，那你对这两个概念肯定不陌生。但如果你是新生代的程序员，一开始学编程的时候，接触的就是面向对象编程语言，那你对这两个概念可能会比较不熟悉。所以，在对比面向对象与面向过程优劣之前，我们先把面向过程编程和面向过程编程语言这两个概念搞清楚。

实际上，我们可以对比着面向对象编程和面向对象编程语言这两个概念，来理解面向过程编程和面向过程编程语言。还记得我们之前是如何定义面向对象编程和面向对象编程语言的吗？1）面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。2）面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

类比面向对象编程与面向对象编程语言的定义，对于面向过程编程和面向过程编程语言这两个概念，我给出下面这样的定义。1）面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。2）面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

不过，这里我必须声明一下，就像我们在之前讲到的，面向对象编程和面向对象编程语言并没有官方的定义一样，这里我给出的面向过程编程和面向过程编程语言的定义，也并不是严格的官方定义。之所以要给出这样的定义，只是为了跟面向对象编程及面向对象编程语言做个对比，以方便你理解它们的区别。

定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&age&gender（比如，小王&28& 男）。我们希望写一个程序，从 users.txt 文件中逐行读取用户信息，然后格式化成 name\tage\tgender（其中，\t 是分隔符）这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted\_users.txt 中。针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 C 语言这种面向过程的编程语言来编写的。

```c
struct User {
  char name[64];
  int age;
  char gender[16];
};

struct User parse_to_user(char* text) {
  // 将text(“小王&28&男”)解析成结构体struct User
}

char* format_to_text(struct User user) {
  // 将结构体struct User格式化成文本（"小王\t28\t男"）
}

void sort_users_by_age(struct User users[]) {
  // 按照年龄从小到大排序users
}

void format_user_file(char* origin_file_path, char* new_file_path) {
  // open files...
  struct User users[1024]; // 假设最大1024个用户
  int count = 0;
  while(1) { // read until the file is empty
    struct User user = parse_to_user(line);
    users[count++] = user;
  }
  
  sort_users_by_age(users);
  
  for (int i = 0; i < count; ++i) {
    char* formatted_user_text = format_to_text(users[i]);
    // write to new file...
  }
  // close files...
}

int main(char** args, int argv) {
  format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
}
```

然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 Java 这种面向对象的编程语言来编写的。

```java
 public class User {
  private String name;
  private int age;
  private String gender;
  
  public User(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  public static User praseFrom(String userInfoText) {
    // 将text(“小王&28&男”)解析成类User
  }
  
  public String formatToText() {
    // 将类User格式化成文本（"小王\t28\t男"）
  }
}

public class UserFileFormatter {
  public void format(String userFile, String formattedUserFile) {
    // Open files...
    List users = new ArrayList<>();
    while (1) { // read until file is empty 
      // read from file into userText...
      User user = User.parseFrom(userText);
      users.add(user);
    }
    // sort users by age...
    for (int i = 0; i < users.size(); ++i) {
      String formattedUserText = user.formatToText();
      // write to new file...
    }
    // close files...
  }
}

public class MainApplication {
  public static void main(String[] args) {
    UserFileFormatter userFileFormatter = new UserFileFormatter();
    userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
  }
}
```

从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。看完这个例子之后，你可能会说，面向对象编程和面向过程编程，两种风格的区别就这么一点吗？当然不是，对于这两种编程风格的更多区别，我们继续往下看。

1『面向对象，数据和方法绑定在一个类里。』

### 3.2 面向对象编程相比面向过程编程有哪些优势？

刚刚我们介绍了面向过程编程及面向过程编程语言的定义，并跟面向对象编程及面向对象编程语言做了一个简单对比。接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？

#### 3.2.1 OOP 更加能够应对大规模复杂程序的开发

看了刚刚举的那个格式化文本文件的例子，你可能会有这样的疑问，两种编程风格实现的代码貌似差不多啊，顶多就是代码的组织方式有点区别，没有感觉到面向对象编程有什么明显的优势呀！你的感觉没错。之所以有这种感觉，主要原因是这个例子程序比较简单、不够复杂。

对于简单程序的开发来说，不管是用面向过程编程风格，还是用面向对象编程风格，差别确实不会很大，甚至有的时候，面向过程的编程风格反倒更有优势。因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。

面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。

除此之外，面向对象编程还提供了一种更加清晰的、更加模块化的代码组织方式。比如，我们开发一个电商交易系统，业务逻辑复杂，代码量很大，可能要定义数百个函数、数百个数据结构，那如何分门别类地组织这些函数和数据结构，才能不至于看起来比较凌乱呢？类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

你可能会说，像 C 语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求。这也算是面向对象编程相对于面向过程编程的一个微创新吧。

实际上，利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。而且，面向过程编程和面向对象编程并非完全对立的。很多软件开发中，尽管利用的是面向过程的编程语言，也都有借鉴面向对象编程的一些优点。

#### 3.2.2 OOP 风格的代码更易复用、易扩展、易维护

在刚刚的那个例子中，因为代码比较简单，所以只用到到了类、对象这两个最基本的面向对象概念，并没有用到更加高级的四大特性，封装、抽象、继承、多态。因此，面向对象编程的优势其实并没有发挥出来。

面向过程编程是一种非常简单的编程风格，并没有像面向对象编程那样提供丰富的特性。而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。为什么这么说呢？还记得我们在上一节课中讲到的封装、抽象、继承、多态存在的意义吗？我们再来简单回顾一下。

首先，我们先来看下封装特性。封装特性是面向对象编程相比于面向过程编程的一个最基本的区别，因为它基于的是面向对象编程中最基本的类的概念。面向对象编程通过类这种组织代码的方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程编程那样，数据可以被任意方法随意修改。因此，面向对象编程提供的封装特性更有利于提高代码的易维护性。

其次，我们再来看下抽象特性。我们知道，函数本身就是一种抽象，它隐藏了具体的实现。我们在使用函数的时候，只需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上，不管面向过程编程还是是面向对象编程，都支持抽象特性。不过，面向对象编程还提供了其他抽象特性的实现方式。这些实现方式是面向过程编程所不具备的，比如基于接口实现的抽象。基于接口的抽象，可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。

再次，我们来看下继承特性。继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，避免了代码重复写多遍，提高了代码的复用性。

最后，我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就遵从了「对修改关闭、对扩展开放」的设计原则，提高代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。

1『几个关键点：1）多态是子类可以替换父类。2）新的功能可以通过增加一个子类覆写掉原来父类里的方法，然后子类替换父类，这样就实现了不在源代码上修改而是通过新增代码实现新功能，也就是「开闭原则」，对修改关闭对扩展开放。终于把「多态 -> 开闭原则」的逻辑链打通了，哈哈。3）利用多态，子类替换父类，可以把不同的类对象传递给相同的方法，从而执行不同的逻辑代码。这应该就是「组合代替 if 句」。2020-08-09』

所以说，基于这四大特性，利用面向对象编程，我们可以更轻松地写出易复用、易扩展、易维护的代码。当然，我们不能说，利用面向过程风格就不可以写出易复用、易扩展、易维护的代码，但没有四大特性的帮助，付出的代价可能就要高一些。

#### 3.2.3 OOP 语言更加人性化、更加高级、更加智能

人类最开始跟机器打交道是通过 0、1 这样的二进制指令，然后是汇编语言，再之后才出现了高级编程语言。在高级编程语言中，面向过程编程语言又早于面向对象编程语言出现。之所以先出现面向过程编程语言，那是因为跟机器交互的方式，从二进制指令、汇编语言到面向过程编程语言，是一个非常自然的过渡，都是一种流程化的、面条式的编程风格，用一组指令顺序操作数据，来完成一项任务。

从指令到汇编再到面向过程编程语言，跟机器打交道的方式在不停地演进，从中我们很容易发现这样一条规律，那就是编程语言越来越人性化，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。实际上，在面向过程编程语言之后，面向对象编程语言的出现，也顺应了这样的发展规律，也就是说，面向对象编程语言比面向过程编程语言更加高级！

跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，越高级的编程语言离机器越「远」，离我们人类越「近」，越「智能」。

这里多聊几句，顺着刚刚这个编程语言的发展规律来想，如果一种新的突破性的编程语言出现，那它肯定是更加「智能」的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，只需要把需求文档写清楚，就能自动生成我们想要的软件了。

### 黑板墙

在文章中我讲到，面向对象编程比面向过程编程，更加容易应对大规模复杂程序的开发。但像 Unix、Linux 这些复杂的系统，也都是基于 C 语言这种面向过程的编程语言开发的，你怎么看待这个现象？这跟我之前的讲解相矛盾吗？

使用任何一个编程语言编写的程序，最终执行上都要落实到 CPU 一条一条指令的执行（无论通过虚拟机解释执行，还是直接编译为机器码），CPU 看不到是使用何种语言编写的程序。对于所有编程语言最终目的是两种：提高硬件的运行效率和提高程序员的开发效率。然而这两种很难兼得。

C 语言在效率方面几乎做到了极致，它更适合挖掘硬件的价值，如：C 语言用数组 char a[8]，经过编译以后变成了（基地址＋偏移量）的方式。对于 CPU 来说，没有运算比加法更快，它的执行效率的算法复杂度是 O (1) 的。从执行效率这个方面看，开发操作系统和贴近硬件的底层程序，C 语言是极好的选择。

C 语言带来的问题是内存越界、野指针、内存泄露等。它只关心程序飞的高不高，不关心程序猿飞的累不累。为了解脱程序员，提高开发效率，设计了 OOP 等更「智能」的编程语言，但是开发容易毕竟来源于对底层的一层一层又一层的包装。完成一个特定操作有了更多的中间环节，占用了更大的内存空间，占用了更多的 CPU 运算。从这个角度看，OOP 这种高级语言的流行是因为硬件越来越便宜了。我们可以想象如果大众消费级的主控芯片仍然是单核 600MHz 为主流，运行 Android 系统点击一个界面需要 2 秒才能响应，那我们现在用的大部分手机程序绝对不是使用 JAVA 开发的，Android 操作系统也不可能建立起这么大的生态。2019-11-16

我们以历史的时间线看看这两种语言的演进过程。1）1969 年贝尔实验室提出 Unix 操作系统。2）1972 年贝尔实验室的 Dennis Ritchie 开发 C 语言。3）1973 年他用 C 语言重写了 Unix。4）1991 年 Linus Torvalds 提出 Linux。另外一条线面向对象语言的发展：1）1972 年第一个面向对象的编程语言是 Simula 发布。2）1996 年，Java1.0 发布，流行的主要原因是 jvm，Write Once, Run Anywhere（编写一次，到处安装 JRE）。

从时间上看，面向对象概念的提出晚于面向过程。C 语言因商业应用成熟要比面相对象的编程语言早。C 语言的流行主要是因为 Unix 和 Linux 操作系统的实现基于 C 语言。类 Unix 系统可以运行在服务器，嵌入式设备，移动设备上。一个东西的好坏要综合考虑：面向过程和面向对象各有各的优缺点。一门编程语言的提出是为了解决某些特定的问题。面向对象和面向过程在应用上各有各的位置。2019-11-15

操作系统虽然是用面向过程的 C 语言实现的 但是其设计逻辑是面向对象的。C 语言没有类和对象的概念，但是用结构体（struct）同样实现了信息的封装，内核源码中也不乏继承和多态思想的体现。面向对象思想，不局限于具体语言。2019-11-15

读过 linux 内核源码和 python 解释器源码的应该都明白，所谓面向过程的 C 语言照样可以实现面向对象的思想，有很多设计都是非常优雅的，付出的代价并不高，我并不认为面向对象编程语言做相同的事情付出的代价会更低。编程思想、设计模式跟语言是没有关系的，编程思想和设计模式是指导我们编程的，而编程语言只是一种实现工具罢了。2019-11-17

操作系统的源码一直没读过，但我认为如此复杂的系统设计，（站在现在的时间点）用面向对象风格（或实现相同目的其他方式）来编写代码是更合适的，而且从 Linux 的模块化分来看，推测有类似的实践。老话说，机器能读懂所有代码，但人不一定。对于机器来说，每一次业务调用流程都是序列化的，机器并不在乎面向对象，但人在乎。正如本文所讲，编程语言离机器越来越远，离人越来越近。为了迁就人，我们使用了执行效率更低的语言，有了更多的中间环节，占用了更大的内存空间，换来的是这个行业的蓬勃发展以及让人类的便捷生活和能力延伸。2019-11-15

老师举的文件那个例子，使用面向对象编程那个，不是封装了函数，用函数对操作过程进行了抽象了吗，为什么老师说没有用到封装、抽象这些特性？C 语言虽然是面相过程语言，但是面向过程语言也可以写面向对象的，另外，C 语言更贴近底层一些，写操作系统的话还是有性能上的优势。作者回复：你指出的这点很好。关于封装，有两种理解，一种是狭义的面向对象特性：封装是一种信息隐藏，需要把数据和方法放到一起，而 c 语言实现的代码，数据和方法是分离的。封装的另一种广义的理解，可以包含你指的封装函数。抽象实际上我们前面章节中也讲到过，比较没有特异性，有的时候不看做面向对象的特性。2019-11-15

我理解 C++ 的出现主要是为了 C 语言中的泛型编程问题。而 Java 的出现是为了抽象对计算机的依赖，更专注于业务。对于计算机底层 C/C++ 可能更适合，而 C 的对于程序员来说自由度是最大的。再看 Linux 的发展，1991 年，林纳斯基于 Unix 的编写的，可能他更善于这个语言，他编写 git 的时候也是用的 C。Unix 选择 C 也是由于自己擅长的原因。2019-11-15

OOP 更能应付复杂流程的程序开发，自己是深有体会。去年做了一个功能，第一版着急上线，就照着流程图翻译，最后就是一组顺序执行的方法集。if 分支特别多。上线后有空，自己重构了一版。这次是翻译了泳道图：data\_provider、rule\_filter\_chain、data\_consumer 和 data\_writer。

data\_provider 提供 3 种类型的数据。每种类型数据有 2 种规则。匹配规则后，会有一些数据处理，如与订单绑定、返佣记录等。最后是将这些数据持久化到数据库。处理过程还使用了多态特性，因此在调用 rule\_filter\_chain、data\_consumer、data\_writer 处的代码都特别精简，都是从 Map 获取处理对象，然后直接调用方法。

现在回看，重构时自己关注最多也是思考最多的是每个阶段的类对象，它的职责是什么。如入参是什么，业务逻辑处理，处理后的出参是什么。实现完这些类后，就真的是像搭积木一样将这些类串起来就可以了。就跟文章说的一样：业务建模、翻译需求为类、类之间交互。重构后的代码逻辑清晰了，也更简洁了。整个业务也更容易理解了。但是有一点，重构之后，类文件也增加了挺多。但是相比一个类几百上千行代码，我更喜欢简短的类。适当的增加一些类文件，也是能接受的。2020-01-09

我的理解不矛盾，理由如下：1）操作系统更多的是和硬件打交道，需要考虑到语言本身翻译成机器语言的成本和执行效率，尤其总要。2）如 linux 内核、总线、文件系统网络等的设计，也是具有面向对象过程的思想，很好的支持了常见的文件系统的挂在、内核的升级和对硬件的热插拔、网络等的处理，常见的服务器多数都是 linux，为啥不用 window，我的理解和设计实现有很大的关系，尤其是网络、安全、权限、标准等等。3）linux 操作系统，本身就是一个大的抽象，属于一个硬件和高级软件连接的桥梁。2019-11-16

go 语言的函数式编程算面向过程吗？作者回复：不算，是一种新的编程范式。2020-01-07

老师没讲函数编程，但我看了一下相关的优点，感觉函数式编程的优点是除了继承 oop 的优点外还有并发和无状态这两个特点，而这种特点和现在云服务切合度很高，但现在问题是对人的要求高。2019-11-17

思考，其实用什么语言来做什么软件，和几个方面有关系。1）软件诞生的时代，在它产生的时候，面向对象编程思想不是主要的趋势；2）发布软件的方式，如以开源的方式发布，它的成熟也要和其他开发者的水准相关，在当时的时代，太过超前的思想，没有很多人的参与，也诞生不了出名的软件；3）适用性，操作系统，更多的还是和计算机打交道，虽然思想上面向对象更适合人的思维，但是操作系统这一层，符合计算机思想的编程语言更适用，面向对象编程语言更适合开发应用软件，符合一般程序员的思维，更多的是跟操作系统打交道，等于中间有一种层级的关系。操作系统更像一个抽象的中间层。2019-11-15

面向过程编程范式是先考虑数据和处理数据的函数，函数和数据是分离的，main 函数开始初始化数据调用 func 处理数数据。面向对象编程范式：先根据需求抽象出类，粒度大的名词是类，粒度小的名称划分到类的属性，类的行为是方法，通过数据访问权限 private 和 public 保护属性的可见性和 get、set 方法保护数据的赋值和输出；先抽象出接口不用想实现就可以写代码，抽象出基类用继承实现代码复用。然后再用类「组合」和「依赖」进行搭积木完成现在业务逻辑。同时可以方便的利用多态实现扩展。范式是完成需求的思考过程和组织代码的方式，跟用什么语言关系不是很大。2020-05-11

在思想上：面向对象最重要的优势，他是以解决描述真实世界的需求为出发点的。而面向过程是以命令计算机如何执行为出发点的。所以，面向对象语言相对而言，比面向过程语言解决真实世界的问题效率更高。（当然，对于计算机则不同）

在技术上：面向对象晚于面向过程诞生，吸收并加强了前者的优秀特性，如抽象，面向过程的抽象是方法，函数的抽象。而面向对象则通过「类」这一特性提供更高纬度的抽象。可以帮助开发人员，先将复杂问题拆解为小的模块问题，在将主要的问题明确后，在专注于业务细节。

面向对象还基于类这一概念，提供了封装特性，将方法和数据绑定，实现了将数据访问权限控制，提高了数据安全性和可维护性。面向对象的继承概念还是要依托于类的概念，可以将多处的相同代码归集到一个类中，在其他要使用的地方通过继承就能获得相同能力。多态，一个函数，可以有多种实现方法。这就像我们生活中，做晚餐这件事，可以做多种做法，煎炒烹炸都行。只有遵照基本的条件就行。2020-05-05

也算是经历了从汇编到 c 到 c++ 再到 java 的过程。确实像作者所说，从偏向机器的思维慢慢过渡到了偏向人类的思维，这似乎也顺应了这个时代的发展潮流。写 c 的时代，我们要非常关注内存的分配，占用，释放，指针是否越界，程序会不会跑飞等问题。现在还记得研究生时候写过一段代码，一运行电脑就自动关机（然而代码的目的不是为了关机！）工作后越来越多的用了 java，有了 jvm，似乎只有在性能调优的时候才会想想堆栈情况，其余时候真的不用再考虑太多，按照业务模块分解功能，专注业务实现就可以了。也因此，程序员越来越高产，门槛也越来越低。然而，知其然而也知其所以然的程序员越来越少了，这样虽然看上去写了不少代码，堆砌了很多新的框架组建，但根基并不牢靠。所以真的需要多一些作者这样的课程，来帮助大家慢下节奏，沉下心多思考。2019-12-23

说白了其实还是要弄清楚 3 点：1）面向对象编程与面向对象编程语言是不是一样的。2）面向过程编程与面向过程编程语言是不是一个东西。3）是不是使用了面向对象语言写出的代码就是面向对象编程 、是不是使用了面向过程语言编程就体现不了面向对象编程的思想。这几点在前几节课讲基础的时候，老师讲的很明白了，在此自己举例子自己总结说明以下：

第一：Java 是一门面向对象的语言，封装、继承、多态、抽象是面向对象语言的特性，当然 Java 在语法上面对这四大特性也很好的支持，但是是不是我们用 Java 写代码了，我们就会面向对象的编程思想了，我感觉不是，在很多 Java 的代码中，完全没有用到这几大特性，因为没用到，所以对开闭、里氏替换、依赖倒置等设计原则没有体现过，反过来讲，我们为什么写代码需要有设计原则，为什么需要有好的设计原则，是因为业务代码的逻辑几乎不会是一成不变的，所以在变化的时候，我们应该变化仅仅需要变化的部分，而不是推倒重来，所以我们需要设计原则来建立基础的模型，需要封装、继承、多态、抽象这些支持设计原则的最基本特性。第二：C 语言是一门面向过程的编程语言，但是使用 C 语言编程的 Unix 系统，我感觉体现了面向对象编程的思想比如 Unix 系统的驱动设计，就是面向对象编程思想的体现。

1『很有感触，一个好的软件必定是随着需求不断在迭代更新的，否者这个软件就没啥价值了。那么就要学会分离关注点，变与不变的东西分割清楚，迭代更新的时候只需要关系「变」的那部分内容，不用全部推倒重新来做。2020-08-09』

最后总结来看：选用什么样的语言来实现产品，来实现业务，跟很多因素有关，个人的能力，接入的快慢，公司的要求等等。境界到了，语言对模型建立的影响应该很小了，这句话不知道说的对不对？因为我还远远没到这个境界，自己认为的。2019-11-16

为什么 Unix、Linux 是使用 C 这种面向过程编程语言开发的？1）历史原因。从二进制指令、汇编语言、面向过程编程语言、面向对象编程语言的发展历程来看，二进制指令和汇编语言由于不具备可移植性，并且不适用于开发大规模复杂程序，而 OOPL 比 POPL 出现得要晚。2）Unix/Linux 具备硬件管理的功能，而硬件运行的特点就是指令化、流程化，这一点与面向过程编程不谋而合。

我对未来编程语言的畅想：更加人性化、更加高级、更加智能，这一定是编程语言的发展方向，现在就已经出现了 AI 助力编程的消息了。对于小争哥所想象的，根据需求规格说明书直接生成代码的编程方式。我觉得有一种方式更容易落地实现。由人类描述代码的设计思路，然后由智能化的编译器生成相应的代码。比如，人类描述 23 种设计模式，然后编译器实现。当然，由于 23 种设计模式只在一些经典问题中才会使用，所以对于一些不需要使用设计模式的编码场景，会需要使用类似的东西进行描述。我把这种编程风格称为面向思路编程。其实，需求规格说明书也是一种表达，但是这种表达太过于接近业务。我不太相信几十年里能够做到。然而，面向思路编程是一种对于具体代码编码的描述，这种描述与业务需求描述无关。2019-11-15

我觉得面向对象是一种思维方式，之前学习 DDD 和 \<Thinking in uml>，吸收到的一点就是拿到业务需求的时候，原来是脑子里面构建出来，并且还要思考业务顺序的前后影响。

```c
if (业务规约 1){
    A do something;
} else if (业务规约 2){
    B do something;
}
```

现在的思维方式是，看到上面的业务描述，拿出本子记录。这个业务里面有 A 对象，有一个功能 say()，哪些数据是归 A 管理的；这个业务里面有 B 对象，有一个功能 hello()，哪些数据是归 B 管理的。所以我觉得面向对象思维，和你用什么语言写是太直接的关系。当然会限制你的实现。比如说虚拟文件系统，我觉得就是面向对象的一种体现，可以支持 ext、fat32 等等，就是一种继承的体现。

有一个问题想问一下老师：目前我接触的项目实体都是贫血模型，虽然分析业务的时候，会努力向面向对象靠近，但是业务代码实现的时候。基本是每个分析的对象，功能包装进一个 service，但是数据还是在贫血实体内。有点类似 DDD 的聚合根（和实际 DDD 思想差的比较远），但是所有实体方法都是以服务的形式提供。但是一下子换成充血模型的话，对团队整体代码和一些跨 n 个实体的业务方法，实现起来又有问题。也没太想明白这个阶段怎么样比较合适。想听听老师是怎么看待这个问题的。2019-11-15

操作系统底层虽然是使用面向过程编程语言开发的，但是面向对象的思想却深入其中。像是 Linux Kernel，它又分成各个子系统，同时又有分离、分层的概念。比如开发一个设备的驱动，只需要分配一个对应的核心层的结构体，对结构体的成员做出该设备特定的设置即可，而设备驱动的很多方法都可以使用核心层的代码；这个过程其实就类似于面向对象编程的继承。可见对于复杂的系统的开发，面向对象的风格还是远胜于面向过程的。操作系统底层为何需要使用 C 语言，我觉得一方面是基于其效率考虑，另一方面则是为了增强在不同体系架构之间的可移植性吧，因为不同的体系架构其汇编指令是不同的，而 C 代码在底层可以很好的和汇编代码结合。2019-11-15

## 0104哪些代码设计看似是面向对象实际是面向过程的.md

你要掌握的重点内容是三种违反面向对象编程风格的典型代码设计。1）滥用 getter、setter 方法。在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合内部数据被修改的风险。2）Constants 类、Utils 类的设计问题。对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极大地提高类的内聚性和代码的可复用性。3）基于贫血模型的开发模式。关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程的弊端？有没有更好的可替代的开发模式？相关的更多问题，我们在面向对象实战篇中会一一讲解。

1『已经在实践了，在数据流开发中，按 DDD 的思想，公共领域模型里有很多小的 Utils 类，比如根据工作参数获取设计参数（DesignDataUtils）、根据管道号匹配管道相关信息（PipeDataUtils）等等。』

上一节课，我们提到，常见的编程范式或者说编程风格有三种，面向过程编程、面向对象编程、函数式编程，而面向对象编程又是这其中最主流的编程范式。现如今，大部分编程语言都是面向对象编程语言，大部分软件都是基于面向对象编程这种编程范式来开发的。不过，在实际的开发工作中，很多同学对面向对象编程都有误解，总以为把所有代码都塞到类里，自然就是在进行面向对象编程了。实际上，这样的认识是不正确的。有时候，从表面上看似是面向对象编程风格的代码，从本质上看却是面向过程编程风格的。

所以，今天，我结合具体的代码实例来讲一讲，有哪些看似是面向对象，实际上是面向过程编程风格的代码，并且分析一下，为什么我们很容易写出这样的代码。最后，我们再一起辩证思考一下，面向过程编程是否就真的无用武之地了呢？是否有必要杜绝在面向对象编程中写面向过程风格的代码呢？

### 4.1 哪些代码设计看似是面向对象，实际是面向过程的？

在用面向对象编程语言进行软件开发的时候，我们有时候会写出面向过程风格的代码。有些是有意为之，并无不妥；而有些是无意为之，会影响到代码的质量。下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。我也希望你通过对这三个典型例子的学习，能够做到举一反三，在平时的开发中，多留心一下自己编写的代码是否满足面向对象风格。

#### 4.1.1 滥用 getter、setter 方法

在之前参与的项目开发中，我经常看到，有同事定义完类的属性之后，就顺手把这些属性的 getter、setter 方法都定义上。有些同事更加省事，直接用 IDE 或者 Lombok 插件（如果是 Java 项目的话）自动生成所有属性的 getter、setter 方法。当我问起，为什么要给每个属性都定义 getter、setter 方法的时候，他们的理由一般是，为了以后可能会用到，现在事先定义好，类用起来就更加方便，而且即便用不到这些 getter、setter 方法，定义上它们也无伤大雅。

实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话。

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();
  
  public int getItemsCount() {
    return this.itemsCount;
  }
  
  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }
  
  public double getTotalPrice() {
    return this.totalPrice;
  }
  
  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }
  
  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
  // ...省略其他方法...
}
```

在这段代码中，ShoppingCart 是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于 itemsCount、totalPrice 两个属性，我们定义了它们的 getter、setter 方法。对于 items 属性，我们定义了它的 getter 方法和 addItem() 方法。代码很简单，理解起来不难。那你有没有发现，这段代码有什么问题呢？

我们先来看前两个属性，itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。

而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。

看完了前两个属性，我们再来看 items 这个属性。对于 items 这个属性，我们定义了它的 getter 方法和 addItem() 方法，并没有定义它的 setter 方法。这样的设计貌似看起来没有什么问题，但实际上并不是。

对于 itemsCount 和 totalPrice 这两个属性来说，定义一个 public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：

```java
ShoppingCart cart = new ShoppCart();
...
cart.getItems().clear(); // 清空购物车
```

你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致 itemsCount、totalPrice、items 三者数据不一致。我们不应该将清空购物车的业务逻辑暴露给上层代码。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用。ShoppingCart 类的 clear() 方法的具体代码实现如下：

```java
public class ShoppingCart {
  // ...省略其他代码...
  public void clear() {
    items.clear();
    itemsCount = 0;
    totalPrice = 0.0;
  }
}
```

你可能还会说，我有一个需求，需要查看购物车中都买了啥，那这个时候，ShoppingCart 类不得不提供 items 属性的 getter 方法了，那又该怎么办才好呢？

如果你熟悉 Java 语言，那解决这个问题的方法还是挺简单的。我们可以通过 Java 提供的 Collections.unmodifiableList() 方法，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类重写了 List 容器中跟修改数据相关的方法，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改。具体的代码实现如下所示。

```java
public class ShoppingCart {
  // ...省略其他代码...
  public List<ShoppingCartItem> getItems() {
    return Collections.unmodifiableList(this.items);
  }
}

public class UnmodifiableList<E> extends UnmodifiableCollection<E> implements List<E> {
  public boolean add(E e) {
    throw new UnsupportedOperationException();
  }
  public void clear() {
    throw new UnsupportedOperationException();
  }
  // ...省略其他代码...
}

ShoppingCart cart = new ShoppingCart();
List<ShoppingCartItem> items = cart.getItems();
items.clear();//抛出UnsupportedOperationException异常
```

不过，这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据。听起来有点绕，看看下面这几行代码你就明白了。

```java
ShoppingCart cart = new ShoppingCart();
cart.add(new ShoppingCartItem(...));
List<ShoppingCartItem> items = cart.getItems();
ShoppingCartItem item = items.get(0);
item.setPrice(19.0); // 这里修改了item的价格属性
```

这个问题该如何解决呢？我今天就不展开来讲了。在后面讲到设计模式的时候，我还会详细地讲到。当然，你也可以在留言区留言或者把问题分享给你的朋友，和他一起讨论解决方案。

getter、setter 问题我们就讲完了，我稍微总结一下，在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。

#### 4.1.2 滥用全局变量和全局方法

我们再来看，另外一个违反面向对象编程风格的例子，那就是滥用全局变量和全局方法。首先，我们先来看，什么是全局变量和全局方法？如果你是用类似 C 语言这样的面向过程的编程语言来做开发，那对全局变量、全局方法肯定不陌生，甚至可以说，在代码中到处可见。但如果你是用类似 Java 这样的面向对象的编程语言来做开发，全局变量和全局方法就不是很多见了。

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

1『静态变量和静态方法，分离了数据和方法，破坏了封装特性，是典型的面向过程风格。』

在刚刚介绍的这些全局变量和全局方法中，Constants 类和 Utils 类最常用到。现在，我们就结合这两个几乎在每个软件开发中都会用到的类，来深入探讨一下全局变量和全局方法的利与弊。我们先来看一下，在我过去参与的项目中，一种常见的 Constants 类的定义方法。

```java
public class Constants {
  public static final String MYSQL_ADDR_KEY = "mysql_addr";
  public static final String MYSQL_DB_NAME_KEY = "db_name";
  public static final String MYSQL_USERNAME_KEY = "mysql_username";
  public static final String MYSQL_PASSWORD_KEY = "mysql_password";
  
  public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
  public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
  public static final int REDIS_DEFAULT_MAX_IDLE = 50;
  public static final int REDIS_DEFAULT_MIN_IDLE = 20;
  public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
  
  // ...省略更多的常量定义...
}
```

在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。不过，定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说呢？原因主要有以下几点。

首先，这样的设计会影响代码的可维护性。如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率。

其次，这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率。

最后，这样的设计还会影响代码的复用性。如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中。

那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴。第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。

1『赞同作者给的第二种方案。把这些常量放到使用它的各个「类」里面。』

讲完了 Constants 类，我们再来讨论一下 Utils 类。首先，我想问你这样一个问题，我们为什么需要 Utils 类？Utils 类存在的意义是什么？希望你先思考一下，然后再来看我下面的讲解。

实际上，Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？

我们在讲面向对象特性的时候，讲过继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。

既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以把它定义为只包含静态方法的 Utils 类了。

1『这里作者对 Utils 类的定义是只包含静态方法的类，其实可以做延伸，公共的类都可以用 Utils 收尾来命名。』

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。

在定义 Utils 类之前，你要问一下自己，你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？如果在回答完这些问题之后，你还是觉得确实有必要去定义这样一个 Utils 类，那就大胆地去定义它吧。因为即便在面向对象编程中，我们也并不是完全排斥面向过程风格的代码。只要它能为我们写出好的代码贡献力量，我们就可以适度地去使用。

除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计一个过于大而全的 Utils 类。

#### 4.1.3 定义数据和方法分离的类

我们再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁会这么写呢？实际上，如果你是基于 MVC 三层结构做 Web 方面的后端开发，这样的代码你可能天天都在写。

传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。

实际上，这种开发模式叫作基于贫血模型的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式。看到这里，你内心里应该有很多疑惑吧？既然这种开发模式明显违背面向对象的编程风格，为什么大部分 Web 项目都是基于这种开发模式来开发呢？关于这个问题，我今天不打算展开讲解。因为它跟我们平时的项目开发结合得非常紧密，所以，更加细致、全面的讲解，我把它安排在面向对象实战环节里了，希望用两节课的时间，把这个问题给你讲透彻。

在面向对象编程中，为什么容易写出面向过程风格的代码？我们在进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？

你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。我们在上一节课讲到了，这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。

除此之外，面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。所以，基于这两点原因，很多工程师在开发的过程，更倾向于用不太需要动脑子的方式去实现需求，也就不由自主地就将代码写成面向过程风格的了。

面向过程编程及面向过程编程语言就真的无用武之地了吗？前面我们讲了面向对象编程相比面向过程编程的各种优势，又讲了哪些代码看起来像面向对象风格，而实际上是面向过程编程风格的。那是不是面向过程编程风格就过时了被淘汰了呢？是不是在面向对象编程开发中，我们就要杜绝写面向过程风格的代码呢？

前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？

除此之外，面向对象和面向过程两种编程风格，也并不是非黑即白、完全对立的。在用面向对象编程语言开发的软件中，面向过程风格的代码并不少见，甚至在一些标准的开发库（比如 JDK、Apache Commons、Google Guava）中，也有很多面向过程风格的代码。

不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。

### 黑板墙

今天课堂讨论的话题有两个，你可以选择一个熟悉的来发表观点。1）今天我们讲到，用面向对象编程语言写出来的代码，不一定是面向对象编程风格的，有可能是面向过程编程风格的。相反，用面向过程编程语言照样也可以写出面向对象编程风格的代码。尽管面向过程编程语言可能没有现成的语法来支持面向对象的四大特性，但可以通过其他方式来模拟，比如在 C 语言中，我们可以利用函数指针来模拟多态。如果你熟悉一门面向过程的编程语言，你能聊一聊如何用它来模拟面向对象的四大特性吗？2）看似是面向对象实际上是面向过程编程风格的代码有很多，除了今天我讲到的这三个，在你工作中，你还遇到过哪些其他情况吗？

不想往下看的请看第一句就好：贫血模型流行的原因是，实现简单和上手快。具体解释慢慢看，贫血模型的开发模式为什么会流行？1）实现简单。Object 仅仅作为传递数据的媒介，不用考虑过多的设计方面，将核心业务逻辑放到 service 层，用 Hibernate 之类的框架一套，完美解决任务。2）上手快。使用贫血模式开发的 web 项目，新来的程序员看看代码就能「照猫画虎」干活了，不需要多高的技术水平。所以很多程序员干了几年，仅仅就会写 CURD。3）一些技术鼓励使用贫血模型。例如 J2EE Entity Beans，Hibernate 等。总结：各种模型的好坏讨论一直不断，企业需要的是使用合适的技术把任务完成，从这个角度来说当下管用模型就是好模型。当然我们也要持开放的心态接受新的技术和思想，并结合业务的实际需要选择合适的技术。

概念解释：贫血模型（Anemic Domain Model 由 Matin Fowler 提出）又称为失血模型，是指 domain object 仅有属性的 getter/setter 方法的纯数据类，将所有类的行为放到 service 层。原文他是这么说的「By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring.」他的原文我放上来了，英文好的同学可以看看：[AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)。我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don't know why this anti-pattern is so common）。2019-11-18

2『老马的这篇文章作为附件去消化吸收。』——未完成

1、用 shell 实现自动化脚本做的服务编排，一般都是面向过程，一步一步的。而 k8s 的编排却是面向对象的，因为它为这个顺序流抽象出了很多角色，将原本一步一步的顺序操作转变成了多个角色间的轮转和交互。

2、从接触 ddd 才走出 javaer 举面向对象旗，干面向过程勾当的局面。所谓为什么「充血模型」不流行，我认为不外呼两个。1）规范的领域模型对于底层基础架构来说并不友好（缺少 set、get），所以会导致规范的领域模型与现有基础架构不贴合，很难开发出完全贴合的基础架构，进而引深出，合理的业务封装却阻碍关于复用通用抽象的矛盾。2）合理的业务封装，需要在战略上对业务先做合理的归类分割和抽象。而这个前置条件很少也不好达成。进而缺少前置设计封装出来的「充血模型」，会有种四不像的味道，反而加剧了业务的复杂性，还不如「贫血模型」来得实用。事实上快节奏下，前置战略设计往往都是不足的，所以想构建优秀的「充血模型」架构，除了要对业务领域和领域设计有足够的认知，在重构手法和重构意愿上还要有一定讲究和追求，这样才能让项目以「充血模型」持续且良性的迭代。

3、「充血模型」相对于「贫血模型」有什么好处？从我的经验来看，可读性其实可能「贫血模型」还好一点，这也可能有思维惯性的原因在里面。但从灵活和扩展性来说「充血模型」会优秀很多，因为好的「充血模型」往往意味着边界清晰（耦合低），功能内敛（高内聚）。这一块老师怎么看？2019-11-18

文中没有举封装或抽象不完全的例子，这里举一个。比如一个实现某种业务需求（如与某种类型设备通讯的应用协议）的 tcp 或 udp 服务器；实例化后还需要自己管理其协议相关的就绪状态（ready 属性）；使你不得不对其再封装一层，并抽象其连接、断开等方法使其自动进行就绪状态的管理；每个继承都这么封装一遍，就会有大量重复的代码，而且其实类的实例化者或继承者并不需要也不应该关心就绪状态的管理，所以没有达到就绪状态管理的封装。这就是一种不完全的封装。2019-11-18

1『上面的信息目前还没能力消化吸收。2020-08-09』

个人觉得，MVC 这种框架模式本质上与面向对象并不冲突。当我们在讨论面向对象的时候，我们究竟应该怎样去定义一个对象，究竟什么才能被我们看成是对象，是不是只有像某种物体，比如说一只鸟或者一只狗我们才能去把他定义为对象？我认为，MVC 里面的三个部分 Model 、Controller 、View 我们都能把他们单独的看成一个对象，比如说 Model，本来它是数据单元，但是如果我们把他看做一个对象的话，里面存储的数据不就是我们对象里的属性么，而对于数据的二次加工处理等等操作不就是对象里的方法么？同理，对于 View 而言，里面小的 view 组件或者是其他的 view 不就是我们对象里面的属性，而对于不同的 view 组件或其他 view 的组合或者其他的处理操作不就是对象里面的方法么？所以说，不必死抠定义，数据就一定要和业务逻辑组成一个类云云。我们最后写出来的代码的目的就是：1）要解决问题；2）代码有可扩展性，可读性；3）代码解耦。作者回复：说的没错，MVC 跟贫血模型没直接关系。我后面在实战篇会讲到的。你的观点我基本都赞同。2019-11-18

先说问题 2：看似面向对象实际面向过程的例子真是数不胜数了，工作语言 C/C++，90% 是 C++，大体上老师在文中已经提到了，其他的我暂时也没想起来，但是滥用面向对象继承特性的代码我真是看到了太多。问题 1：C 中可以用 struct 来实现 class，只是访问控制权限都是 public。类中的成员函数可以通过指向操作结构体的函数指针来实现，实现封装，需要绑定数据、函数、函数指针。可以创建函数指针表，构造函数设置函数指针指向正确的操作函数，函数指针表作为对象访问函数的接口。操作结构体的这些函数（成员函数）不像 C++ 中能直接访问数据成员，需要显示的传递操作对象给成员函数。1）继承：在派生类中维护一个基类对象的指针。这样派生类可以访问基类对象的数据。2）多态：在基类中维护一个派生类对象的指针。这样基类可以访问派生类对象的数据。C++ 中的多态，有一个对象销毁的问题。基类的析构函数必须是虚函数。在 C 中，这可以通过使基类的删除函数指针指向派生类的删除函数，因为派生类的删除函数清楚派生类的数据和基类的数据。2019-11-18

1-2『哈哈，又挖到金子了。继承和多态的底层实现原理：继承是在子类里维护一个父类对象的指针，这样子类可以访问父类对象的数据；多态是在父类里维护多个子类的对象的指针，这样父类可以访问子类对象的数据。继承是从子类的角度往上看父类，多态是从父类的角度往下看子类（推荐这种视角）。继承和多态这 2 个视角做一张金句卡片。』——已完成

思考汇总：1）现在因为使用封装好的框架，没有提供 set 方法，类的序列化会成为一个问题。2）从理论上来说，数据和逻辑应该放在一起，但是数据的赋值往往可能依赖其他的 service 提供的数据，如果这样的话数据属性和纯粹依赖的 service 就会导致一个类的成员属性特别的多。3）对于一个具体现实对象而言，不同场景下可能关心的字段稍微有些不一样，对于此又该怎么处理呢？多个小对象，他们之间有无相关关系，有的话如何阐述，还是全部赋值完毕，都完整返回。当然可能具体场景具体分析，那是否有一个稍微通用的指导纲领。2019-11-18

3『作者的微信：wangzheng0822。』

习惯了从前端的参数直接使用 BeanUtils.copyProperties 映射到具体实体类，如果不直接提供 set 方法，有啥好的方法去组装数据呢。作者回复：给类本身提供一个 copy 方法呢。2019-11-21

1『给类本身提供一个 copy 方法，目前无法理解作者的思路。下面有一个评论里提到：如果数据量不大，返回一个拷贝对象即可。应该对理解有帮助。（2020-08-09）』

思考：1）get set 这个很好理解，但是我有很多疑问，比如有的属性理论上来讲不该添加 set 方法，那我怎么对他进行属性拷贝？比如两个 vo 进行拷贝属性值，还有作为接口参数，spring 又怎么给他赋值？2）看完贫血模式那个知识点后，我懵了，我甚至不知道怎么才能写出面向对象的代码了，如果数据和业务不分离的话，那比如我多个业务接口需要同一份数据，难道要定义多份吗？我有点懵了。作者回复：1）并没有说一定不能定义 set 方法，文章中说不要滥定义用不上的 set 方法。2）多个业务接口需要同一份数据？这个怎么理解呢？2019-11-18

添加对象公有方法方法要注意两点：1）避免过多的访问内部数据的方法，只有在确定需要的时候再增加。2）避免返回内部引用（数组，对象，方法等），这些引用会无意间暴露修改内部状态的方法，导致数据不一致，也违反封装原则。这种情况如果数据量不大，返回一个拷贝对象即可。如果有效率考量，就要具体问题具体分析。2019-11-18

对于用 C 来模拟面向对象，曾经看到过一篇非常好的文章，[C 语言：春节回家过年，我发现只有我没有对象](https://mp.weixin.qq.com/s/2ivQ9hcRvZnhk89jzAppSg)。2020-02-02

老师这一讲，解我多年困惑。仍有一事困惑：前端传数据到后端，我要是不定义一个开放了所有属性的 POJO，那么数据如何反序列化成类呢？作者回复：前端跟后端交互的那个叫 dto 可以定义为之包含数据的类，后面会讲到。2019-12-02

C 语言可以通过结构体加函数，函数第一个参数为该结构体指针的方式来实现方法和数据结构结合，但无法实现访问权限控制。通过在结构体中包含结构体的方式可以实现继承。通过函数指针实现多态。每个类有一个共同的虚函数表，每个对象都有一个指向虚函数表的指针，通过指向不同的虚函数表来实现多态。

get、set 方法老师以前在讲的时候，也不讲为啥，上来就是直接设置。现在才知道封装的作用。工具类、配置类的细分对后期维护起来方便多了，有时候把控适合细分的度挺重要的，要多些项目经验会把控好这个度。2019-11-18

面向对象是把数据和方法打包，隐藏内部状态，暴露外部需要的方法。这种把数据和方法并列处理的方法也有一个弊端，那就是很多情况下，数据和方法的体量并不对等，例如 String，数据很少，对应的方法却很多，如果把数据和方法放到一个类里，势必方法数目巨大，数据基本淹没在方法中，而且对这么多方法不分类来处理也带来维护负担，这和全局方法过多是一个道理。Kotlin 语言采用的是 extension methods 来处理这种情况，简而言之就是数据被多个方法群调用，然后调用的时候可以根据 import 来分类。请问王老师，还有其他更好的方法来处理这种情况吗。2019-11-18

我是 technical animator 转学 untiy3D C# 编程的，选这门课程作为提高程序设计的能力途径。之前项目里经常用多态做扩展，算是典型面向对象应用。但是采用的 MVC 构建在数据方面又类似贫血模型的面向过程风格。现在 Unity 官方开始革新的 DOTS 技术 ，又开始鼓励大家从面向对象改成面向数据编程，某种程度似乎又回到了面向过程的一些精神。2020-06-20

接手一个项目，分享判断全部写的 if else ，花了一整天改成策略模式了。2020-05-05

数据处理相关的程序，比如数据分析，数据预处理，数据清洗，etl 这些，就是拿到一批数据先干什么，然后再干什么，最后输出数据，这是典型的需要流程化思考模式的需求。面向过程编程和函数式编程更加适合这种场景。为什么是函数式呢，因为所谓的「以算法为主」，就可以把一个个算法操作开发成一个个小函数（称为算子），就可以通过函数式编程把这些算子应用在数据上。2020-03-29

关于滥用 getter、setter 方法，这让我想起了 Spring 中 BeanFactory 类的设计。Spring BeanFactory 只允许查找，不允许修改数据，它提供了一个子类，ConfigurableListableBeanFactory 类则提供了大量的配置方法，如果 setBeanExpressionResolver 等。Spring 中一般提供 BeanFactory 给用户使用，ConfigurableListableBeanFactory 则提供给开发者使用，这样设计避免了滥用 getter、setter 方法，同时也符合单一职能原则。2020-02-26

其实我觉得之所以用面向对象的编程语言写出面向过程的代码主要是对 OOP 理解的不到位，正如文章所说面向过程编程如何人脑的思考方式，也就是第一部干什么第二步干什么自然而然就写成了面向过程的代码，前面提到两者的区别组织方式的不同，其实写代码的时候多考虑一点，我可以怎么分「块」，每块的职责是什么，每块有哪些内容构成（属性和方法，只要职责明确了这两点也就清楚了）块之间是怎么交互的，这些问题思考清楚才算得上面向对象编程。你想想啊，小到工具类的命名、类的命名，大到现在的若干个微服务，不都是一个个「块」么，所以啊，还是想想清楚到底什么才是面向对象编程以及面向对象编程的四大特性才能在实际的开发中运用自如。扩展一下，为什么很多公司那么注重编程规范其中一个原因是代码的易读性会更好，易读性怎么体现不就落实到这一个个「块」中么。比如大一统的 Constants 类为什么不好，最大的问题就是职责不清晰，你让你一个保安去干财务你觉得合适么，你知道他是保安还是财务呢？！2020-02-20

滥用 getter setter 的情况确实挺常见，不过这个问题相对来说是比较容易发现和修正的。购物车那个例子中，数据需要外部访问的情况，作为一个前端工程师，常见的处理思路就是将数据深拷贝，供外部使用，即时恶意修改也不会对原来的逻辑造成影响。不过由于基本没写过服务端的代码，不确定此思路是否适用于服务端，会不会内层占用的问题。面向对象的语言及代码组织形式，却完全写的是面向过程的情况，值得反思。2019-12-31

1『数据需要外部访问的情况，作为一个前端工程师，常见的处理思路就是将数据深拷贝，供外部使用，即时恶意修改也不会对原来的逻辑造成影响。』

## 0105接口vs抽象类的区别.md

1、抽象类和接口的语法特性。抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

2、抽象类和接口存在的意义。抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

3、抽象类和接口的应用场景区别。什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种 is-a 的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。

在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等等。

不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++ 这种编程语言只支持抽象类，不支持接口；而像 Python 这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以通过一些手段来模拟实现这两个语法概念。

这两个语法概念不仅在工作中经常会被用到，在面试中也经常被提及。比如，「接口和抽象类的区别是什么？什么时候用接口？什么时候用抽象类？抽象类和接口存在的意义是什么？能解决哪些编程问题？」等等。你可以先试着回答一下，刚刚我提出的几个问题。

### 5.1 什么是抽象类和接口？区别在哪里？

不同的编程语言对接口和抽象类的定义方式可能有些差别，但差别并不会很大。Java 这种编程语言，既支持抽象类，也支持接口，所以，为了让你对这两个语法概念有比较直观的认识，我们拿 Java 这种编程语言来举例讲解。

首先，我们来看一下，在 Java 这种编程语言中，我们是如何定义抽象类的。下面这段代码是一个比较典型的抽象类的使用场景（模板设计模式）。Logger 是一个记录日志的抽象类，FileLogger 和 MessageQueueLogger 继承 Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger 和 MessageQueueLogger 两个子类复用了父类 Logger 中的 name、enabled、minPermittedLevel 属性和 log() 方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法。

```java
// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }
  
  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }
  
  protected abstract void doLog(Level level, String message);
}
// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath); 
  }
  
  @Override
  public void doLog(Level level, String mesage) {
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 抽象类的子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    super(name, enabled, minPermittedLevel);
    this.msgQueueClient = msgQueueClient;
  }
  
  @Override
  protected void doLog(Level level, String mesage) {
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

通过上面的这个例子，我们来看一下，抽象类具有哪些特性。我总结了下面三点。1）抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger (…); 会报编译错误）。2）抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作抽象方法。3）子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法。

刚刚我们讲了如何定义抽象类，现在我们再来看一下，在 Java 这种编程语言中，我们如何定义接口。

```java
// 接口
public interface Filter {
  void doFilter(RpcRequest req) throws RpcException;
}
// 接口实现类：鉴权过滤器
public class AuthencationFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...鉴权逻辑..
  }
}
// 接口实现类：限流过滤器
public class RateLimitFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //...限流逻辑...
  }
}
// 过滤器使用demo
public class Application {
  // filters.add(new AuthencationFilter());
  // filters.add(new RateLimitFilter());
  private List<Filter> filters = new ArrayList<>();
  
  public void handleRpcRequest(RpcRequest req) {
    try {
      for (Filter filter : fitlers) {
        filter.doFilter(req);
      }
    } catch(RpcException e) {
      // ...处理过滤结果...
    }
    // ...省略其他处理逻辑...
  }
}
```

上面这段代码是一个比较典型的接口的使用场景。我们通过 Java 中的 interface 关键字定义了一个 Filter 接口。AuthencationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能。

代码非常简洁。结合代码，我们再来看一下，接口都有哪些特性。我也总结了三点。1）接口不能包含属性（也就是成员变量）。2）接口只能声明方法，方法不能包含代码实现。3）类实现接口的时候，必须实现接口中声明的所有方法。

前面我们讲了抽象类和接口的定义，以及各自的语法特性。从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。除了语法特性，从设计的角度，两者也有比较大的区别。

抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种 is-a 的关系，那抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

### 5.2 抽象类和接口能解决什么编程问题？

刚刚我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义，让你知其然知其所以然。

首先，我们来看一下，我们为什么需要抽象类？它能够解决什么编程问题？刚刚我们讲到，抽象类不能实例化，只能被继承。而前面的章节中，我们还讲到，继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码。

不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？

我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代码中，Logger 不再是抽象类，只是一个普通的父类，删除了 Logger 中 log()、doLog() 方法，新增了 isLoggable() 方法。FileLogger 和 MessageQueueLogger 还是继承 Logger 父类，以达到代码复用的目的。具体的代码如下：

```java
// 父类：非抽象类，就是普通的类. 删除了log(),doLog()，新增了isLoggable().
public class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    //...构造函数不变，代码省略...
  }

  protected boolean isLoggable() {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    return loggable;
  }
}
// 子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
// 子类: 输出日志到消息中间件(比如kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;
  
  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    //...构造函数不变，代码省略...
  }
  
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。像下面这样编写代码，就会出现编译错误，因为 Logger 中并没有定义 log() 方法。

```java
Logger logger = new FileLogger("access-log", true, Level.WARN, "/users/wangzheng/access.log");
logger.log(Level.ERROR, "This is a test log message.");
```

你可能会说，这个问题解决起来很简单啊。我们在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己的记录日志的逻辑，不就可以了吗？

```java
public class Logger {
  // ...省略部分代码...
  public void log(Level level, String mesage) { // do nothing... }
}
public class FileLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到日志文件
    fileWriter.write(...);
  }
}
public class MessageQueueLogger extends Logger {
  // ...省略部分代码...
  @Override
  public void log(Level level, String mesage) {
    if (!isLoggable()) return;
    // 格式化level和message,输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因。

1、在 Logger 中定义一个空的方法，会影响代码的可读性。如果我们不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候，就可能对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、MessageQueueLogger 之间的继承关系，才能弄明白其设计意图。

2、当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。你可能会说，我既然要定义一个新的 Logger 子类，怎么会忘记重新实现 log() 方法呢？我们举的例子比较简单，Logger 中的方法不多，代码行数也很少。但是，如果 Logger 有几百行，有 n 多方法，除非你对 Logger 的设计非常熟悉，否则忘记重新实现 log() 方法，也不是不可能的。

3、Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法。这也增加了类被误用的风险。当然，这个问题可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅。

其次，我们再来看一下，我们为什么需要接口？它能够解决什么编程问题？

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

1『接口的主要目的是为了解耦，实现约定和实现的分离，相当于加一个「中间的」把接口和实现隔开，只要保证接口不变，里面的实现可以随意换，调用接口的那个上层压根不用管接口里的实现换不换。』

实际上，接口是一个比抽象类应用更加广泛、更加重要的知识点。比如，我们经常提到的「基于接口而非实现编程」，就是一条几乎天天会用到，并且能极大地提高代码的灵活性、扩展性的设计思想。关于接口这个知识点，我会单独再用一节课的时间，更加详细全面的讲解，这里就不展开了。

### 5.3 如何模拟抽象类和接口两个语法概念？

在前面举的例子中，我们使用 Java 的接口语法实现了一个 Filter 过滤器。不过，如果你熟悉的是 C++ 这种编程语言，你可能会说，C++ 只有抽象类，并没有接口，那从代码实现的角度上来说，是不是就无法实现 Filter 的设计思路了呢？实际上，我们可以通过抽象类来模拟接口。怎么来模拟呢？这是一个不错的面试题，你可以先思考一下，然后再来看我的讲解。

我们先来回忆一下接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段 C++ 代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是策略模式中的一段代码）。

```java
class Strategy { // 用抽象类模拟接口
  public:
    ~Strategy();
    virtual void algorithm()=0;
  protected:
    Strategy();
};
```

抽象类 Strategy 没有定义任何属性，并且所有的方法都声明为 virtual 类型（等同于 Java 中的 abstract 关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。

不过，如果你熟悉的既不是 Java，也不是 C++，而是现在比较流行的动态编程语言，比如 Python、Ruby 等，你可能还会有疑问：在这些动态语言中，不仅没有接口的概念，也没有类似 abstract、virtual 这样的关键字来定义抽象类，那该如何实现上面的讲到的 Filter、Logger 的设计思路呢？实际上，除了用抽象类来模拟接口之外，我们还可以用普通类来模拟接口。具体的 Java 代码实现如下所示。

```java
public class MockInteface {
  protected MockInteface() {}
  public void funcA() {
    throw new MethodUnSupportedException();
  }
}
```

我们知道类中的方法必须包含实现，这个不符合接口的定义。但是，我们可以让类中的方法抛出 MethodUnSupportedException 异常，来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候，都去主动实现父类的方法，否则就会在运行时抛出异常。那又如何避免这个类被实例化呢？实际上很简单，我们只需要将这个类的构造函数声明为 protected 访问权限就可以了。

刚刚我们讲了如何用抽象类来模拟接口，以及如何用普通类来模拟接口，那如何用普通类来模拟抽象类呢？这个问题留给你自己思考，你可以留言说说你的实现方法。实际上，对于动态编程语言来说，还有一种对接口支持的策略，那就是 duck-typing。我们在上一节课中讲到多态的时候也有讲过，你可以再回忆一下。

### 5.4 如何决定该用抽象类还是接口？

刚刚的讲解可能有些偏理论，现在，我们就从真实项目开发的角度来看一下，在代码设计、编程开发的时候，什么时候该用抽象类？什么时候该用接口？

实际上，判断的标准很简单。如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

### 黑板墙

你熟悉的编程语言，是否有现成的语法支持接口和抽象类呢？具体是如何定义的呢？前面我们提到，接口和抽象类是两个经常在面试中被问到的概念。学习完今天的内容之后，你是否对抽象类和接口有一个新的认识呢？如果面试官再让你聊聊接口和抽象类，你会如何回答呢？

如果让我聊聊接口和抽象类，我会这么聊：定义、区别（是什么），存在意义（从哪来），应用（到哪去）。1）定义。抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、default 方法；类实现接口时，必须实现抽象方法。2）意义。抽象类：解决复用问题，适用于 is-a 的关系。接口：解决抽象问题，适用于 has-a 的关系。3）应用。例如，解决复用问题：java 中的子类 FileInputStream 和 PipeInputStream 等继承抽象类 InputStream。重写了 read(source) 方法，InputStream 中还包含其他方法，FileInputStream 继承抽象类复用了父类的其他方法。解决抽象问题：抽象类 InputStream 实现了 Closeable 接口，该接口中包含 close() 抽象方法。Closeable 这个接口还在很多其他类中实现了，例如 Channel，Socket 中都有 close() 关闭这个功能，但具体实现每个类又各有不同的实现，这个就是抽象。4）补充知识点（语法）：Java 接口中可以定义静态方法、default 方法，枚举类型，接口中还可以定义接口（嵌套）。2019-11-20

Java 使用 abstract 表示抽象类，interface 表示接口。我补充一下使用：1）java 中抽象类是类，而 java 不支持多继承，当想要实现多继承的时候只能使用表示 has-a 的接口来实现。2）在 java8 之前，定义的接口不能有具体实现，这会导致在后续维护的时候如果想要在接口中新增一个方法，必须在所有实现类中都实现一遍，并且只有几个新的实现类可能要去具体实现，其他的都只是加上默认实现，这样比较麻烦。在 java8 中接口可以用使用关键字 default，来实现一个默认方法，这样就解决了上述的麻烦。2019-11-20

小弟给大家初学设计模式以及刚刚接触项目的同学一些建议，其实在学这一章更以及往后正式的 20 多种设计模式时候更加锻炼的是一种抽象思维，以我个人的一点经验，就像老师一开始说的，在学习的时候，不要总是类比生活中的一些阿猫啊狗的例子，没错初次是很好理解，而且你会感觉好像懂了，但是实际上你还是不懂（可能是以为我笨），建议大家没学习一种模式的时候，思考一下现在在做的项目中那些业务可以进行优化，如果可以的话，可以进行重构，这样对你的学习才有很大的帮助；举个栗子，例如策略模式，我们在代码是不是经常调用第三方接口，每个接口都有它的规范之类的，如果你按照 low 的方式就是按照规范组织一些报文请求，但是这个时候，你可以用的你的抽象思维，比如，在这类业务中，无外乎就是：1）构建报文。2）请求结构。3）解析返回，那么我就可以这样设计：

```java
/**
 * 请求统一接口
 */
public interface Fun<T> {
    /**
     * 发送请求报文
     */
    String constructionRequest();
    /**
     * 请求报文
     */
    String doPost(String request);
    /**
     * 解析回执报文
     */
    T resolveResponse(String responseText);
}
```

然后再写一个策略的算法簇（应该是这么叫）。

```java
public class DealWithHandle {
    
    /**
     * 描述 create.
     *
     * @param <T> the type parameter
     * @param fun the fun
     * @return the t
     */
    public static <T> T handle(Fun<T> fun) {
        String request = fun.constructionRequest();
        String response = fun.doPost(request);
        T t = fun.resolveResponse(response);
        return t;
    }
}
```

这个时候，假设你做支付宝扫码支付的时候（或者微信以及第三方支付），是不是可以这么调用：

```java
public class OfficialAliScan {
    private static Logger logger = LoggerFactory.getLogger(OfficialAliScan.class);

    public static ApiTradeResultDto operate(final TradeOrderDO orderDO, final SubMerchatAuthDO subMerchatAuthDO, final String authCode) {
        return DealwithHandle.handle(new DealwithHandle.Fun<ApiTradeResultDto>() {
            @Override
            public String constructionRequest() {
                  ///todo
            }

            @Override
            public String doPost(String bizContent) {
                ///todo
            }

            @Override
            public ApiTradeResultDto resolveResponse(String responseTxt) {
                ///todo
            }
        });
    }
}
```

这样的话，你的业务代码组织的就很清晰，也便于调试维护。2019-11-21

go 和 java 都有接口设计，但 go 的设计是飞入侵入性（duck type），而 java 必须显式实现该借口，这一点 go 做的真的好了。2019-11-20

举个例子吧，附件上传服务端实现。需求：支持上传、下载、删除以及文件的存储，存储的话需要支持存本地和云端，涉及附件上传的业务点有十几个。设计思路：1）接口设计：上传、下载、删除是公共行为，抽象到接口中。2）存储方法是一大块公共代码，写到抽象类里面。3）每个业务的附件上传子类实现接口、继承抽象类。2019-11-20

谈谈 c 吧，linux 内核的设备驱动总线模型，就但说设备吧。1）抽象类。首先来个通用设备结构体，到了具体设备把通用设备结构体包含了，这是典型的抽象类思想，提炼公共部分做基类，提高复用度。2）接口，接口实现就是函数指针，不管你的驱动如何实现，接口不变，你就按照函数指针的定义实现函数，任何人都要受控这个函数定义协议。2019-11-20

关于抽象类和接口的理解，从本质上说：1）抽象类。编程中自下向上的需要，如果用其他方式模拟不是不行，而是维护成本高。因此对于这样常见的编程范式来说，添加语法支持（约束），能够大大的使用范式的成本。本质上是语法糖。2）接口。同理，提供一个语法糖，方便低成本的实现 has-a 的问题。总的说，编程语言的大部分特性，或者是设计模式，都是从编程实际需求出发而演变出来的。理解熟悉这些演变过程，能够让我们举一反三。另外，很多动态语言犹豫缺乏大量的这些特性：接口、抽象类、抽象方法等。使得开发成本。维护成本是相对高的。这也就导致了动态需要开发大型项目艰难的问题。可以看看 js 社区这几年的激烈演进，ts 的大流行，也是因为有了大型项目的需求，尝到了 ts 的各项语法特性的甜头。设计模式也大抵如此，放在小型项目的时候，并不能体现出多大作用。因为设计模式的出现，就是为了对抗，处理复杂度的。2020-05-15

其实我们可以换个角度思考一下：当我们在说抽象类和接口到底在说什么？以 Java 为例，为什么要支持抽象类，自然是为了表示面向对象编程中 is-a 的关系，即 A 是 B，那么 B 自然也是一个 Object，那么自然就有属性和方法（行为）。再来，为什么要支持接口，是为了表示面向对象编程中 has-a 的关系，就是你拥有什么能力，能力对应行为（方法），那么自然就只有方法，当然也可以有属性，但是一定是常量，想下为什么只能是常量而不能是变量呢？如果有变量那就意味着实现 A 和实现 B 是可以互相修改的，这违反了接口的定义。继续延伸下，为什么 jdk8 要支持默认方法呢？举个例子你就知道了，A 和 B 都需要 C 的能力 z，但 C 还提供能力 y，但是只有 A 是需要 y 的，那么 B 只需要默认的 y 能力就好了。2020-02-21

接口和抽象类的相同点和不同点。1）相同点： 都是抽象机制，都可以存在抽象方法，都不能被实例化。2）不同点： 抽象类中可以存在成员变量，接口中不允许，抽象类中可以存在具体的方法实现，接口中不允许。抽象类的设计原则是 is-a，接口的设计原则是 has-a 或者是 can-do。反思：SSM 的这种三层结构横行多年，造成的结果就是设计模式几乎没有用武之地，基于贫血模型的面条代码，没有任何面向对象的设计元素可言，抽象类，接口的意义很多时候就停留在了面试中。2019-11-20

## 0106为什么基于接口而非实现编程.md

1、「基于接口而非实现编程」，这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

2、我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

3、「基于接口而非实现编程」这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的「接口」设计、类库的「接口」设计。

在上一节课中，我们讲了接口和抽象类，以及各种编程语言是如何支持、实现这两个语法概念的。今天，我们继续讲一个跟「接口」相关的知识点：基于接口而非实现编程。这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。

为了让你理解透彻，并真正掌握这条原则如何应用，今天，我会结合一个有关图片存储的实战案例来讲解。除此之外，这条原则还很容易被过度应用，比如为每一个实现类都定义对应的接口。针对这类问题，在今天的讲解中，我也会告诉你如何来做权衡，怎样恰到好处地应用这条原则。

### 6.1 如何解读原则中的「接口」二字？

「基于接口而非实现编程」这条原则的英文描述是：「Program to an interface, not an implementation」。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的「接口」语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。

实际上，理解这条原则的关键，就是理解其中的「接口」两个字。还记得我们上一节课讲的「接口」的定义吗？从本质上来看，「接口」就是一组「协议」或者「约定」，是功能提供者提供给使用者的一个「功能列表」。「接口」在不同的应用场景下会有不同的解读，比如服务端与客户端之间的「接口」，类库提供的「接口」，甚至是一组通信的协议都可以叫作「接口」。刚刚对「接口」的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，「基于接口而非实现编程」这条原则中的「接口」，可以理解为编程语言中的接口或者抽象类。

前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

1-2『分离关注点。将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。基于接口而非实现编程，做一张术语卡片。』——已完成

实际上，「基于接口而非实现编程」这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

### 6.2 如何将这条原则应用到实战中？

对于这条原则，我们结合一个具体的实战案例来进一步讲解一下。假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：

```java
public class AliyunImageStore {
  //...省略属性、构造函数等...
  
  public void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket代码逻辑...
    // ...失败会抛出异常..
  }
  
  public String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
  
  public String uploadToAliyun(Image image, String bucketName, String accessToken) {
    //...上传图片到阿里云...
    //...返回图片存储在阿里云上的地址(url）...
  }
  
  public Image downloadFromAliyun(String url, String accessToken) {
    //...从阿里云下载图片...
  }
}

// AliyunImageStore类的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...; //处理图片，并封装为Image对象
    AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/);
    imageStore.createBucketIfNotExisting(BUCKET_NAME);
    String accessToken = imageStore.generateAccessToken();
    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
  }
  
}
```

整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。

不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？

我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，「细节是魔鬼」。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的「魔鬼细节」，我们一块来看看都有哪些。

新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点。

首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含「aliyun」字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。

其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。

那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从「基于接口而非实现编程」的原则，具体来讲，我们需要做到下面这 3 点。1）函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()。2）封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。3）为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。我们按照这个思路，把代码重构一下。重构后的代码如下所示：

```java
public interface ImageStore {
  String upload(Image image, String bucketName);
  Image download(String url);
}

public class AliyunImageStore implements ImageStore {
  //...省略属性、构造函数等...

  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    String accessToken = generateAccessToken();
    //...上传图片到阿里云...
    //...返回图片在阿里云上的地址(url)...
  }

  public Image download(String url) {
    String accessToken = generateAccessToken();
    //...从阿里云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }

  private String generateAccessToken() {
    // ...根据accesskey/secrectkey等生成access token
  }
}

// 上传下载流程改变：私有云不需要支持access token
public class PrivateImageStore implements ImageStore  {
  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    //...上传图片到私有云...
    //...返回图片的url...
  }

  public Image download(String url) {
    //...从私有云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ...创建bucket...
    // ...失败会抛出异常..
  }
}

// ImageStore的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...;//处理图片，并封装为Image对象
    ImageStore imageStore = new PrivateImageStore(...);
    imagestore.upload(image, BUCKET_NAME);
  }
}
```

除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。

总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。

### 6.3 是否需要为每个类定义接口？

看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？做任何事情都要讲求一个「度」，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。

前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。

2『何时抽象出接口，做一张任意卡片。』——已完成

### 黑板墙

在今天举的代码例子中，尽管我们通过接口来隔离了两个具体的实现。但是，在项目中很多地方，我们都是通过下面第 8 行的方式来使用接口的。这就会产生一个问题，那就是，如果我们要替换图片存储方式，还是需要修改很多类似第 8 行那样的代码。这样的设计还是不够完美，对此，你有更好的实现思路吗？

```java
// ImageStore的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //...省略其他无关代码...
  
  public void process() {
    Image image = ...;//处理图片，并封装为Image对象
    ImageStore imageStore = new PrivateImageStore(/*省略构造函数*/);
    imagestore.upload(image, BUCKET_NAME);
  }
```

其实这篇和上一篇可以讲的更好的。首先，我反对接口是 has-a 的说法，我坚持接口的语义是 behaves like（这个其实我也是在某一本书上看的）。咱们看下哪个更通顺和达意，A AliyunImageStorage has a DataStorage. or A AliyunImageStorage behaves like a DataStorage? 除非你在第一句加上 A AliyunImageStorage has some behaviors of DataStorage. 但这基本也就是 behaves like 的意思了。

第二，我觉得咬文嚼字的确没有什么意义，但为什么说上述话题，难道讲接口的例子不用出现接口多重继承么，引用我之前留言：拿一个 C++ 中举的多重继承例子来说，吸血鬼分别继承自蝙蝠和人，那么吸血鬼 is a 蝙蝠么？吸血鬼 is a 人么？所以其实两个都不是，这就是设计上的语义问题。这里缺失了除了 is a 的另一个概念，behaves like，也就是多重继承的真义实际上是 behaves like，也就是接口的意义。A vampire behaves like humans and bats. 而这是接口能多重的原因，一个类可以具有多重行为，但是不能是多种东西。所以其实也就是说，只有当前模块涉及到抽象行为的时候，才有必要设计接口，才有可能利用接口多重继承的特性来更好的将各种行为分组。2019-11-22

关于思考题我想出两种方法改进：简单工厂方法和使用反射。

1、简单工厂方法。

```java
ImageStore imageStore = ImageStoreFactory.newInstance(SOTRE_TYPE_CONFIG);
```

config 文件可以写类似 properties 的文件，使用 key-value 存储。缺点：再新增另一种存储手段时，需要修改工厂类和添加新的类。修改工厂类，违反了开放 - 封闭原则。那有没有更好一点的方法呢？

2、使用反射。在配置文件中定义需要的 image store 类型。在 ProcessJob 中：

```java
ImageStore store = (ImageStore) Class.forName(STORE_CLASS).newInstance();
```

缺点：使用反射，在大量创建对象时会有性能损失。关于减少 ProcessJob 中的修改，还有没有更好的方法呢？我只是抛砖引玉，希望和大家一起讨论。具体实现：[Algorithms4/geekbang/designpattern/u009 at master · gdhucoder/Algorithms4](https://github.com/gdhucoder/Algorithms4/tree/master/geekbang/designpattern/u009)。补充，关于 access token：Aliyun 的 AccessToken 时有 expireTime 时限的。不需要每次重新获取，过期时重新获取即可。2019-11-22

依赖注入，从外部构建具体类的对象，传入使用的地方。2019-11-22

我个人的解决方案是这种情况不要去直接 new，而是用工厂类去管理这个对象，然后名字可以起成 getInstance 这类不包含某个具体实现的含义的抽象名称。将来修改直接修改工厂类的 getInstance 方法即可，这种方式可取吗？还有其他更好的方式吗？2019-11-22

这节既然讲的是依赖于抽象而不是依赖于具体，那比较得瑟的玩儿法恐怕应该是直接在 ImageProcessingJob 类和 ImageStore 接口这两个类型关系上充分体现出依赖倒置的思路，把最后一点执行创建 ImageStore 类型实例的痕迹彻底关在 ImageProcessingJob 的门外，虽然必然得有人去考虑实际至少调一下 ImageStore 具体类型实例的这个创建过程，但 ImageProcessingJob 这爷是不打算操心这事了，它只需要留个口子，让别人把 ImageProcessingJob 放到自己锅里，自己就可以开始炒菜了。也就是从形式上，ImageProcessingJob 这个类只需要保留对 ImageStore 接口的依赖就可以了，具体留口子的手段则要考虑依赖注入，形式上有两种：

1、一种是可能更 OO 样子的一点，即声明一个 ImageStore 的 field 在 ImageProcessingJob 类里面。1）如果说有什么好处，恩，可以理解为能对客户程序隐藏了 ImageStore 类型的信息，是的，连类型信息都隐藏掉；好吧，还是得关心别人，毕竟这世界上不是仅有自己一个。2）具体操作起来，由于不能声明 field 时候直接 new，要不又变回去了，但又不能 NPE 吧，所以不考虑创建，我还是得考虑怎么把实例请进来，就是上面说的至少留个口子。3）这时候可能不得不借助依赖注入的帮助了（否则就是依赖查找，还是工厂），即通过 ImageProcessingJob 的构造函数注入或者利用 field 注入来获取 ImageStore 接口的实例，或者 ImageProcessingJob 如果依赖项多，Builder 一下也很好。毕竟 ImageProcessingJob 这个类型在我们讨论的上下文里面是如此具体的一个类，就不过分追溯它的创建责任及执行在哪里了。

2、另一种，表面粗暴直接看似问题多多，但是细品也有点意思的，那就是 process 方法直接增加一个 ImageStore 的参数就完了。1）没有 B 方案的设计自身无法证明自己更好。相对于上面的，直接的问题是会对 process 方法直接依赖的客户程序会和 ImageStore 这个类型产生耦合。2）如果客户程序是一个类（还能是什么？），要么有一个 field 等着 inject 进来，要么是通过调用 process 的 method 传进来，要么就是无中生有（直接 new 了或用创建型模式）。这都可能造成没有充分的设计隔离，至少让客户程序造成信息冗余，承担了不必要的职责等问题。但事实上也不是完全没好处，这种灵活性体现在它没有把 ImageStore 的逻辑固化在任一个 ImageProcessingJob 实例里面。3）考虑上面第三类无中生有的方式，假设是创建型的工厂方法或类似手段，则可以提供对 method 参数（业务层面的动态输入，例如最终操作用户的提供的值）的响应能力。这和，执行排序算法骨架确定，但是需要给定两个元素（复杂对象）比较规则这种思路有相似之处，毕竟我需要的是对方的能力而不是对方的数据或者数据视图，这时候这么做还是很有诱惑力的。4）如果脱离开场景，实际上这种动态性还更强，但问题就在于这种动态性会不会对于具体场景有价值。从这个实例上看，也许没这么明显，因为不同的对象存储后端更有可能是环境（测试、生产？但 12 factor 让我们... 好歹测试环境还是也上云吧）不同造成的，而非基于动态的用户信息输入。但，事无绝对吧，假设，用户有选择我要针对具体这一张，我特么上传那一刻选择一个存储后端的需求。然后为了方便用户，用户竟然可以勾选，以后使用同样地选择。我觉得除了脑子进水的犬类应该没人会干这种没问题制造问题也要上的方案吧。

所以综上所属，还是 field 一个 ImageStore 接口来搞吧。2019-11-22

考虑使用工厂模式生成 ImageStore 实例。这样就可以将调用者和具体 ImageStore 解耦。

```java
public class ImgStoreFactory {

    private ImgStoreFactory(){

    }

    public static ImageStore create(Class<?> clz){
        if (clz == AliyunStore.class){
            return new AliyunStore();
        }else if (clz == PrivateYunStore.class){
            return new PrivateYunStore();
        }else {
            throw new IllegalStateException("..");
        }
    }

    public static void main(String[] args) {
        ImageStore store = ImgStoreFactory.create(AliyunStore.class);
        store.dosth();
    }
}
```

另外有一点不太同意作者的说法：上节课作者将 Contract 翻译为「协议」，我认为是不恰当的。在计算机领域，通常使用 Protocol 代表协议，个人认为 Contract 更恰当的翻译是「契约」。2019-11-22

使用策略模式，在建一个 Context 类，使用聚合持有这个接口实例引用，其它所有地方都用这个 context 类，变动的时候，只变这个 context 类就行了，其它不动。2019-11-23

2『上面的策略模式自己去实现以下。』

对于思考题，想到了两种方法：1）简单工厂 + 反射 + 配置。2）通过使用控制反转 / 依赖注入方式，类似于 Spring。2020-02-03

那现在的 MVC 代码，要求 service 先写接口，然后再写实现，有必要嘛？说实话，我一直没看懂这种行为的意义何在。作者回复：确实意义不大。2019-11-25

关于什么时候定义接口的一些拙见。当方法会有其他实现，或者不稳定的时候需要定义接口：1）不稳定的方法一般能事先确定，用接口能提高可维护性。2）但在开发时往往不确定是否需要其他实现，我的原则是等到需要使用接口的时候再去实现。所以根据 kiss 原则一般我会先用方法实现，如果有一天真的需要有新的实现的时候再重新抽象出接口对代码进行小重构。就老师的例子进行一下说明：刚开始只需要阿里云进行图片上传下载功能，我就先只实现阿里云的图片上传下载方法。后期发现需要有私有云的上传下载方法的话，那就对这个功能通过接口进行抽象。但是你永远不知道到底是新的图片上传下载功能先来到还是其他阿里接口先来到，如果是新的阿里接口，也是用的这一套 token 方法，那就用抽象方法或接口对 token 部分实现抽象。课后问题：简单工厂，工厂模式可以提高可扩展性，维护性。java spring 项目可以使用注入的方式。2019-11-22

我是搞 Java 的，关于思考题，个人感觉主要依靠控制反转，即把对象的构造权交给容器，而非代码中直接写死。像 Spring 那种依赖注入的方式就可以，或者不使用 Spring，可以把具体的实现类全路径名配置到配置文件中，代码中以 Class.forName 的方式得到 Class，然后再用 Class 的 newInstance 方法得到实例并缓存起来以便后面使用避免重复构造实例。以后替换实现的时候只需要替换配置文件中的类全路径名即可。当然前提是这个 Class 需要实现统一抽象出来的接口，使用逻辑中也是。2019-11-22

基于抽象而非具体体现了信息隐藏和分离代码中稳定性不同的部分。在一个上传图片的部分不需要知道图片是如何上传的，阿里云以及 token 就属于过多的信息，有必要隐藏这些信息。另外一方面上传图片这件事比阿里云实现要稳定的多，不上传图片的概率低于不用阿里云上传图片的概率。这里有必要分离图片上传这个接口和用阿里云上传这个实现。不过原来的实现也没什么问题，毕竟谁也不能未卜先知，将来一定会替换阿里云。如果我拿到这个变更需求，我会先用同名接口替换原来的实现（原来的阿里类实现清晰，功能单一，只是不适合直接调用），然后用 adapter 来转接口，然后一步一步实现接口和实现的分离，目标是接口能够隐藏信息，实现能够清晰明了，每一步都能用 IDE 工具重构，每一步都能编译和测试。2019-11-22

可以用策略模式试试，将图片的存储方式抽象成一个策略类，然后创建两个实现策略类，比如 aliyun 存储，私有云存储，腾讯云存储，再创建一个使用策略的类 Context（Strategy strategu），executeStrategy（img,arg....）。当使用哪种存储方式的时候，就直接调用 Context 的 executeStrategy。2020-04-05

思考题：我觉得可以采用依赖倒置的原则。简单的版本可以基于工厂模式实现。但是在一般的项目中可以直接使用成熟的 ioc 框架实现依赖倒置。如 java spring 中自带的依赖注入，或者 c# 中的 autofac，这些都是「器」级别的。2020-04-02

编程依赖抽象而不是实现的前提条件是行为的变化，比如将毫秒时间戳换算为年月日就不存在行为的变化，那么直接用一个「实现类」，或者说普通类就可以了，反之如果文中提到的上传图片和下载图片的行为未来就是有可能变化的，比如图片存储从阿里云换成私有云就是变化，这就要求编程设计的时候多思考变化点，具备抽象思维。前面也提到接口是行为的抽象，是一组协议或者说契约，那么就决定了接口的行为必然是比较稳定的，比如就不能在图片存储的接口上加上获取日期这样的行为因为这是不相关的，也不能加上获取图片链接的行为，因为有些图片存储可能压根就没有获取图片链接的功能，因为这是关联性没那么大的行为。关于思考题我想的是实现上可以通过一个 map 初始化不同实现的图片存储，key 是类型，value 是具体的实现，需要哪个就从 map 的 type 拿就好了，本质上这就是 Spring 控制反转的原理，这也是各种 @Autowired 直接用起来贼爽的原因。2020-02-22

Spring 框架提供了很好的依赖注入特性，可以让实际的实现类并不在编写的时候和调用方挂钩，而是由容器来决定注入，于是我给出的解决方案是，利用工厂类和依赖注入来进行解决，在一个工厂类中保证生产出的实现类是具有单例式的，然后调用者注入这个工厂类获取到生产出的实现类，在需要修改的时候，只需要修改这个工厂类产生的实现类就可以了，调用者不需要任何改变，即可获取到工厂类生产出的新实现类。2020-02-19

## 0107为何说要多用组合少用继承.md

1、为什么不推荐使用继承？继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

2、组合相比继承有哪些优势？继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

3、如何判断该用组合还是继承？尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。

### 7.1 为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。

假设我们要设计一个关于鸟的类。我们将「鸟类」这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有「飞」这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：

```java
public class AbstractBird {
  //...省略其他属性和方法...
  public void fly() { //... }
}

public class Ostrich extends AbstractBird { //鸵鸟
  //...省略其他属性和方法...
  public void fly() {
    throw new UnSupportedMethodException("I can't fly.'");
  }
}
```

这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？具体的继承关系如下图所示：

从图中我们可以看出，继承关系变成了三层。不过，整体上来讲，目前的继承关系还比较简单，层次比较浅，也算是一种可以接受的设计思路。我们再继续加点难度。在刚刚这个场景中，我们只关注「鸟会不会飞」，但如果我们还关注「鸟会不会叫」，那这个时候，我们又该如何设计类之间的继承关系呢？

是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。

如果我们还需要考虑「是否会下蛋」这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码…… 一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。

总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？

### 7.2 组合相比继承有哪些优势？

实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。我们前面讲到接口的时候说过，接口表示具有某种行为特性。针对「会飞」这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：

```java
public interface Flyable {
  void fly();
}
public interface Tweetable {
  void tweet();
}
public interface EggLayable {
  void layEgg();
}
public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  //... 省略其他属性和方法...
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
public class Sparrow impelents Flayable, Tweetable, EggLayable {//麻雀
  //... 省略其他属性和方法...
  @Override
  public void fly() { //... }
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
```

不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：

```java
public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
```

我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。

### 7.3 如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：

```java
public class Url {
  //...省略属性和方法
}

public class Crawler {
  private Url url; // 组合
  public Crawler() {
    this.url = new Url();
  }
  //...
}

public class PageAnalyzer {
  private Url url; // 组合
  public PageAnalyzer() {
    this.url = new Url();
  }
  //..
}
```

还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。

```java
public class FeignClient { // Feign Client框架代码
  //...省略其他代码...
  public void encode(String url) { //... }
}

public void demofunction(FeignClient feignClient) {
  //...
  feignClient.encode(url);
  //...
}

public class CustomizedFeignClient extends FeignClient {
  @Override
  public void encode(String url) { //...重写encode的实现...}
}

// 调用
FeignClient client = new CustomizedFeignClient();
demofunction(client);
```

尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以「多用组合少用继承」这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。

### 黑板墙

我们在基于 MVC 架构开发 Web 应用的时候，经常会在数据库层定义 Entity，在 Service 业务层定义 BO（Business Object），在 Controller 接口层定义 VO（View Object）。大部分情况下，Entity、BO、VO 三者之间的代码有很大重复，但又不完全相同。我们该如何处理 Entity、BO、VO 代码重复的问题呢？

我的观点比较极端，用接口、组合和委托代替继承。原因如下：1）人无法预知未来，现在比较稳定的类继承关系将来未必稳定。2）两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。3）相对于接口 + 组合 + 委托增加的复杂度，代码统一成接口 + 组合 + 委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。4）新的编程语言让接口 + 组合 + 委托变得容易，例如 Kotlin 就有专门的语法糖支持，消除了很多模板代码。5）接口 + 组合 + 委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。2019-11-25

课堂讨论 answer：Entity，Bo，Vo 三者之间，显然并不存在 is-a 关系，首先排除使用继承。其次三者间也并非是严格的 has-a 关系，half measure 之一是考虑使用组合（composition） + 委托（delegation）的方式解决代码重复的问题，但并不是我心中的最佳答案。我的答案是不解决三者间的代码重复问题。Value Class 就只是 Value Class，代码重复并不是业务上的代码重复，那就让它重复吧。2019-11-25

VO、BO、DO 表示什么前面都说过了，我觉得得换一个思路去看待这种模型转换的问题。这里我们将 BO 看做 ddd 里面的核心域中的实体。那么这个对象的变化应该对 VO 或者 DO 隐藏起来，VO 是对外的模型，为什么需要感知到内部业务的变化，DO 是具体的存储方式，这是由实现决定的，在业务逻辑中也不应该关心。重要的是隔离，让这三者独立变化。所以我的结论是，既不应该用继承，也不应该使用组合，使用防腐层，模型转换层隔离这种变化才是最好的。但是实际上在很多业务中 BO 和 DO 是差不多的，于是就混用了，在业务不复杂的时候，也没太大关系。业务运行的很好，也不难理解。追求完美，却不可能处处完美。2019-11-26

看下来对组合跟委托两个概念表示不太明白，看了代码后才，以及网上查阅后才明白。1）继承 (Inheritance)：利用 extends 来扩展一个基类。is-a 的关系。2）组合 (composition)：一个类的定义中使用其他对象。has-a 的关系。3）委托 (delegation)：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。有 uses-a、owns-a、has-a 三种关系。2019-11-25

理解或总结如下：1）「比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代」，我的理解为：is-a 意味着 has-muilti-a's 或者 has-all-needed-a's。故而需要实现多个接口，而接口抽象的是操作或者方法而非数据（数据和方法的抽象由抽象类来完成），所以具体的操作要由被组合进来的类对象来完成，站在类间关系的角度来看，外部类和被组合类之间的关系被称为「委托」。2）这里面，被组合类的代码被抽象到了接口中，或者反过来说接口的具体操作下沉到了被组合类中，这就是「代码复用我们可以通过组合和委托来实现」的含义，代码被不同的被组合类「分门（类）别类」的复用了。3）「多态特性我们可以利用接口来实现」，因为接口代表了某种契约，而多态就是用子类代替父类。只要实现了某种接口，按照契约，自然就可以在某些方面或某种程度上代替父类。所以我觉得接口是「更细粒度更多控制的更有节制的继承」。

回到本课的问题。之前的课说到 VO、BO、Entity 是典型的面向过程的编码，里面基本都是数据，没有方法。那么自然不可以用接口来减少代码的重复，只能用继承了。但是 MVC 的结构，我理解它是一种分层客户端服务器架构，Layered Client-Server，每一层为其之上的层服务，并使用其之下的层所提供的服务。为了减少层之间的耦合，必要的重复是可以的。2019-11-25

汇总：1）VO、BO、Entity 三个命名在现在面向服务而非页面的后端编程，并不合适。2）这里最好用组合。entity 是最小的实体单元，bo 可能面对多个 entity 聚合，vo 可能面对多个 bo 聚合，这种场景下，显然组合更适合。虽然也存在 entity 和 bo 一对一的场景，或者 bo 中只有一个主 entity 的场景，这种场景用继承倒也不为过。但是，为了套路单一，减少阅读思考，统一组合便是，没必要再引入继承。3）老项目里面，代码已经高度耦合，而且不是面相接口写的代码，那么整体改动成本会很大。这种情况下用继承实现多态我觉得挺合适。4）Java1.8 提供接口的方法默认实现后，我觉得继承的处境真的挺尴尬，新项目反正能用继承实现的用组合也可以。所以除非父子关系特别明显（继承不深其实比组合直观），不然没什么必要用继承了。2019-11-25

目前一项目中使用 SpringBoot 开发，其中对象定义为入参为 DTO，数据库实现为 Entity，业务返回结果为 VO，三者对象完全独立，其中大部分属性相同，在 DTO 对象添加 convertToEntity 方法，Entity 添加 convertToVO 方法，实现对象属性拷贝。同时在 DTO 和 VO 中使用组合方式，有很少数的继承。2019-11-28

VO 就是用来指定对外暴露的字段，跟 DO 不算是 is-a 关系，稳定性也不高，所以个人认为不需要处理和 DO 的重复代码。2019-11-26

可以使用组合 + 继承来解决代码重复的问题，但实际项目中我更倾向于不同层次之间的冗余（前提是 MVC 框架），因为我理解的优秀的代码是服务于优秀的设计架构的，也就是说不通层次之间的代码中肯定会有冗余，因为数据是在不同层次中流转的。不过在同一个层次中的代码冗余就有优化的必要了。2019-11-27

我们现在采用 entity 实现，VO 和 BO 都去继承它，减少代码重复。看了专栏后，我认为可以通过讲 VO 和 BO 组合成 Entity 实现，不知道这样做，是不是合适？作者回复：好像不合适，怎么通过 vo 和 bo 组合成 entity 呢？2019-11-25

个人观点：我们变成是围绕着数据打桩的，BO、VO、Entity，核心是需要持久化的 Entity，BO 为了更好的进行业务处理在 VO 上进行扩展，VO 则是为了展示在 Entity 上的扩展。当然 VO、BO 各自也有属于自己层面的属性，需要做到暴露「共有」属性，隐藏「特有」属性。BO、VO 可以扩展（继承）Entity，又各自「特有」属性。可以借鉴组合的思路，BO、VO 各自一些属于自己逻辑层的特有属性。2020-03-21

Entity、BO、VO 这个重复代码问题也纠结过，BO，VO 不需要 Entity 的所有属性，所以继承不大合适。用组合的话要套个其他实例单独写方法，麻烦。现在都是直接单独写，重复就重复了，而且一般也不会有复杂的逻辑，就重复属性和 getter/setter。特别想知道这个问题合适的做法。希望老师能在下节讲下上一节的问题，再布置下下节的问题，个人感觉这种方式比放到统一答疑章节要好很多。2019-11-26

因为 Entity，BO，VO 都是描述对象的，只不过是用于不同目的的对象，这些对象之间会有很多重复的元素定义，针对这样的重复定义，我倒是感觉可以使用继承，将重复的那些元素都提取出来作为父类，然后 entity，VO，BO 去继承这个父类，在实现自己独有的元素。而接口主要是针对不同能能的复用，用在 E，B，V 身上并不合适。2019-11-25

继承的优点是可以提高代码的复用，但过渡复杂的继承会影响代码可读性和维护性。组合的优点是提高代码的复用，降低业务结构的复杂度，但会增加分支结构导致需要更细粒度的设计。继承类似于多线程的 synchronized 关键字，不能细粒度控制可能导致性能问题。组合类似于 Lock 锁，可以进行更细粒度的控制，但使用复杂度可能会提高。所以我们应该根据具体的业务选择合适的方案。2020-03-17

今天主要讲组合和继承的使用，总结一下就是结构稳定继承层次浅（不超过两层）可以使用继承，否则使用组合 + 接口 + 委托单位方式。我的倾向是有共同结构或者业务上是同一类的优先使用继承，否则使用组合的方式。仍然回归定义，接口是行为的抽象，与行为相关的代码逻辑优先使用组合，在定义接口的时候要考虑得行为的通用性，也就是符合单一职责。下面说下思考题，entity、vo、bo 本身就是不同层面的业务对象，entity 是数据层对象，vo 是展示层对象，bo 是业务层对象，如果三者之间有通用的属性就各自定义好了，如果多种业务都有一些公共的属性则可以单独定义这么个 bo、vo，然后使用组合的方式拿过来就好了。而且从业务看这不是重复代码，感觉问题可以更具体点。2020-02-23

对于这个问题，在实际开发中，我们经常使用 Beans 这个工具类其中的 copproperties() 方法去解决代码重复赋值问题，但是经过了这几天的学习，发现经常使用的 mvc 是一个面向过程的贫血模型，所以我给出的解决答案是使用接口、组合以及委托这种方式去替换它，这是我学完这节课的一个设想，但这三者之间并没有什么直接的关系，我认为这三者没必要去解决他们的代码重复问题，他们三个本身来说就应该是相对独立的，不然有这么多代码重复，我们为什么不将其放到一个对象里面了？在整个 MVC 三层之间都共用一个对象。2020-02-19

老师，我理解继承的核心目标是提供一种更符合人类思维模式的代码组织手段，除了代码复用也可以提高代码的可读性。只不过这个技术很难运用得恰当，容易造成过度设计或者结构腐化，所以需要慎重使用。您举的鸟的例子就能体现，其实鸟类概念的定义本身就没有飞翔的属性，所以不能提供 fly 方法。这种场景就像在代码开发中很多人最开始对一个类的边界理解有些许偏差导致设计问题，后续调整继承关系的成本很高。所以说与其说继承一无是处，不如说使用继承特性十分危险。2020-02-14

个人认为，那些 xO 还是各自独立的好，因为属于不同层面的对象，从建模角度讲，他们之间不是相同领域的对象，只是恰好大部分字段相同，如果数据转换时有太多 target.setXxx (source.getXxx ())，仅仅为了方便和减少代码量，可以考虑采用小工具的方式，如 copyProperties、字段 mapping 等手段来实现。2020-01-12

关于思考的问题，DO、VO、BO、DTO 等，属于不同领域，各自的职责不一样，所以无所谓相同的属性。比如 DTO 做为参数的入参对象，会在属性上加一些校验注解或者在加一些 swagger API 接扣文档注解，而其他的 O 并不需要，尊从单一职责原则。2020-01-09

VO、BO、Entity 我最近在重写一个 mvc web 项目，（原有项目结构是 Bo extends Entity 在后台数据层 mybatis 和 controller 共用了 Bo） 我改的策略是废弃了 bo extends Bo 增加了 Vo 以及复杂查询的 Query ，query 与 Vo 不关心后续结构只关心定制化内容，前端小伙伴完全对照参数录入。Bo 层可能有一些特殊处理与定制。我没有完全去想集成或者组合，我的目标只是想把他们职责更清晰一点，干净一点。改完之后就是感觉许多出要 transform 比较多但可以借助一些 copy 技术的机制。我也不知道有没有更好的办法来处理这些，设计模式没怎么学过，DDD 只听说过。2019-12-05

业务开发常见问题，解决办法看具体场景而定。主要方式：1）继承，适用在 VO、BO 与 ENTITY 很接近，基本对应数据库字段，直接继承可以复用代码。但是需要能够容忍某些冗余的字段出现。2）组合，使用 ENTITY 组合作为 VO、BO 的成员属性，需要能容忍冗余字段。3）继承 + 组合，将 VO 和 BO 公共部分提取成为单独的类，再通过继承或组合完成复用。定义最为准确，业务和 ENTITY 分离，个人最推荐方式。2019-11-29