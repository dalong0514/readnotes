## 记忆时间

## 卡片

### 0101. 主题卡 —— 实现多态的 3 个手段

醍醐灌顶，多态对应于「子类替换父类」，哈哈。基于继承、基于接口、基于 duck-typing，多使用后两种。

多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。1）第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。2）第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。3）第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。对于多态特性的实现方式，除了利用「继承加方法重写」这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。

从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。

### 0102. 主题卡 —— 基于接口而非实现编程

「基于接口而非实现编程」这条原则的英文描述是：「Program to an interface, not an implementation」。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的「接口」语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。

实际上，理解这条原则的关键，就是理解其中的「接口」两个字。还记得我们上一节课讲的「接口」的定义吗？从本质上来看，「接口」就是一组「协议」或者「约定」，是功能提供者提供给使用者的一个「功能列表」。「接口」在不同的应用场景下会有不同的解读，比如服务端与客户端之间的「接口」，类库提供的「接口」，甚至是一组通信的协议都可以叫作「接口」。刚刚对「接口」的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，「基于接口而非实现编程」这条原则中的「接口」，可以理解为编程语言中的接口或者抽象类。

前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

实际上，「基于接口而非实现编程」这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

### 0103. 主题卡 —— SOILD 五大设计原则

1、SOLID 原则 —— SRP 单一职责原则。一个类只负责完成一个职责或者功能。单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：1）类中的代码行数、函数或者属性过多；2）类依赖的其他类过多或者依赖类的其他类过多；3）私有方法过多；4）比较难给类起一个合适的名字；5）类中大量的方法都是集中操作类中的某几个属性。

2、SOLID 原则 —— OCP 开闭原则。如何理解「对扩展开放、修改关闭」？添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为「修改」；在细代码粒度下，可能又被认定为「扩展」。

1『深有感触，同样的操作，在颗粒度大的情况下是「修改」，在颗粒度小的情况下是「扩展」。（2020-12-27）』

如何做到「对扩展开放、修改关闭」？我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

3、SOLID 原则 —— LSP 里式替换原则。子类对象（object of subtype / derived class）能够替换程序（program）中父类对象（object of base / parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

里式替换原则是用来指导继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解「design by contract，按照协议来设计」这几个字。父类定义了函数的「约定」（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数的原有「约定」。这里的「约定」包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

理解这个原则，我们还要弄明白，里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

4、SOLID 原则 —— ISP 接口隔离原则。接口隔离原则的描述是：客户端不应该强迫依赖它不需要的接口。其中的「客户端」，可以理解为接口的调用者或者使用者。理解「接口隔离原则」的重点是理解其中的「接口」二字。这里有三种不同的理解。

接口：1）如果把「接口」理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。2）如果把「接口」理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。3）如果把「接口」理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考的角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

5、SOLID 原则 —— DIP 依赖倒置原则。

控制反转：实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的「控制」指的是对程序执行流程的控制，而「反转」指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员「反转」给了框架。

依赖注入：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或「注入」）给类来使用。

依赖注入框架：我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

依赖反转原则：依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不需要依赖具体实现细节，具体实现细节依赖抽象。

2『五大设计原则，做一张主题卡片。』——已完成

### 0201. 术语卡 —— 代码的可读性

软件设计大师 Martin Fowler 曾经说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。

我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。

既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

### 0301. 任意卡 —— 何时抽象出「接口」

看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢？做任何事情都要讲求一个「度」，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。

前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。

## 0000开篇词.md

作者的 GitHub：[wangzheng0822](https://github.com/wangzheng0822)。

如果说「数据结构与算法之美」是教你写出高效的代码，那这个设计模式专栏就是教你写出高质量的代码。

1、程序员的看家本领你得练好。

写代码可以说是程序员天天要干的事情，要是代码都写不好，最基本的看家本领都练不好，成天堆砌烂代码，写代码还有啥意思呢？那还干啥程序员啊！写出「能用」代码的人比比皆是，但是，并不是每个人都能写出「好用」的代码。只会写能用的代码，我们永远成长不成大牛，成长不成最优秀的那批人。

后来我熟练掌握了各种编写高质量代码的技巧、方法和理论，我发现，实际上，写烂代码和好代码花费的时间是差不多的。当你把写高质量代码培养成一种开发习惯之后，在你在编写代码的时候，自然就有一种代码质量意识，自然而然就可以写出不错的代码。即便在我离开 Google 加入其他公司之后，项目的代码质量因为各种原因有所妥协，但我起码知道什么样的代码是高质量代码，丝毫不影响我具备写出高质量代码的能力。

我相信，很多工程师都很重视代码质量，毕竟谁也不想写被人吐槽的烂代码。但是，就我的了解来看，毫不夸张地讲，很多工程师，甚至一些 BAT 的员工，代码都写得惨不忍睹。一方面，在目前这种快糙猛的开发环境下，很多工程师并没有太多时间去思考如何写高质量代码；另一方面，在烂代码的熏陶下，在没有人指导的环境里，很多工程师也搞不大清楚高质量代码到底长什么样。

这就导致很多工程师写了多年代码，代码功力一点都没长进，编写的代码仍然只是能用即可，能运行就好。平日的工作就是修修补补、抄抄改改，一直在做重复劳动，能力也一直停留在「会干活」的层面，就像高速路上的收银员，只能算是一个「熟练工」。

2、一个人闷头看书效果并不好。

当然，也有一些比较上进的工程师，会去找设计模式、编码规范、重构等类型的书籍去看，学习如何编写高质量的代码。实际上，我也买了很多这类的书籍来看，从这些经典的书籍中，我也学到了很多编程技巧和提高代码质量的方法。

不过，这些书籍都有一个特点，那就是比较偏重理论讲解，喜欢拿猫、狗之类生活中的例子来举例。当然，这样的例子也有优点，那就是能在简短的时间和篇幅内，很好地帮你理解原理。但同时也存在一个严重的问题，那就是过于脱离真实的软件开发。而且例子本身没有难度，你一看就觉得懂了，但是看完之后，可能还是不清楚如何将理论落地到实际的项目编码中。

比如，我们都知道著名的 KISS 原则（Keep It Simple and Stupid）。这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够简单呢？怎样才算不够简单需要优化呢？估计很多人都回答不上来，因为大部分书籍都没有讲清楚。

除此之外，一个人自己闷头看书，在很多时候效果并不好。一方面，每个人的理解能力是不一样的。对于同一本书，不同理解能力的人看完之后收获也是不一样的。跟着有经验的老师学比闷头自己看书要更高效、收获更多、成长更快。另一方面，编码本身就是一门实践课，光闷头看书本理论肯定是不够的，更重要的是在实践中学习如何应用这些理论。

3、一对一手把手指导才最有效。

1『又见学徒模式。』

从我的经验来看，我觉得最有效、最快速提高编码能力的方法就是，找一个比你资深的工程师，一对一、手把手地指导你写代码。你提交代码，他来指出你的问题，你再优化，这样一来一往，要不了多久，你就会发现，自己的代码能力突飞猛进。

但是，理想很丰满，现实很骨感。且不说能不能找到这样有资格指导你的人，即便能找到，他愿不愿意、有没有时间来手把手指导你，还是另外一回事。而我比较幸运，在毕业之后就加入了 Google，得到了顶尖工程师的指导，一对一地给我 review 代码，手把手地指导我如何优化代码。正因如此，在 Google 的那段时间也成为了我编码能力提高最快的一段时间。

所以，在设计专栏的初期，我就在想，如果我能模拟这样一个一对一、手把手、就真实项目代码讲解的场景，是不是就能让专栏有别于千篇一律的书籍，从而能真正提高你的代码能力呢？基于这样一个想法，我们接下来就来看，我是如何设计整个专栏内容的。

## 0001尽早地学习并掌握设计模式相关知识.md

为什么要学习设计模式相关的知识，主要有这样五点：1）应对面试中的设计模式相关问题；2）告别写被人吐槽的烂代码；3）提高复杂代码的设计和开发能力；4）让读源码、学框架事半功倍；5）为你的职场发展做铺垫。

很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发「生产力」仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的 CRUD 业务开发中用不上。实际上，这些基础的知识确实很难直接转化成开发「生产力」。但是，它能潜移默化地、间接地提高你对技术的理解。

不过，我觉得，设计模式和操作系统、组成原理、编译原理等这些基础学科是不一样的。它虽然也算是一门基础知识，但是它和数据结构、算法更像是一道儿的，相比那些更加基础的学科，设计模式能更直接地提高你的开发能力。我在开篇词里也说了，如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。

### 1.2 告别写被人吐槽的烂代码

我们经常说，「Talk is cheap. show me the code. 」实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。

尽管我已经工作近十年，但我一直没有脱离编码一线，现在每天也都在坚持写代码、review 指导同事写代码、重构遗留系统的烂代码。这些年的工作经历中，我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！

当然，在这些年的工作经历中，我也看到过很多让我眼前一亮的代码。每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出。

所以，我的专栏，不仅仅只是讲解设计模式，更加重要的是，我会通过实战例子，手把手教你如何避免刚刚提到的代码问题，告别被人诟病的烂代码，写出令人称道的好代码，成为团队中的代码标杆！而且，写出一份漂亮的代码，你自己也会很有成就感。

### 1.3 提高复杂代码的设计和开发能力

大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，我刚工作的时候，也是做这类事情。相对来说，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。

但是，有一天，我的 leader 让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。

如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？…… 各种问题，一下子挤到了我面前。

而我当时并没有对设计模式相关的知识（包括设计模式、设计原则、面向对象设计思想等）有太多的了解和积累，所以一时间搞得我手足无措。好在因此我意识到了这方面知识的重要性，所以在之后很多年的开发中，我都一直刻意锻炼、积累这方面的能力。面对复杂代码、功能、系统的设计和开发，我也越来越得心应手，游刃有余。写出高质量代码已经成为了我的习惯，不经意间写出来的代码，都能作为同事学习、临摹的范例，这也成为了我职场中最引以为豪的亮点之一。

### 1.4 让读源码、学框架事半功倍

对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。

从我的经验和同事的反馈来看，有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。为什么我会这么说呢？

优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。

实际上，除了看不懂、看不下去的问题，还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前，你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。

因此，学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。

### 黑板墙

作者反复解释了下学好 dp 的重要性。以前重构过一个 p2p 客户投资后奖励活动。刚开始，他们真的是 if else 的去写每一个活动。我去了后。主要就是参考 yii 框架的实现方法。做了以下解藕，把购买后的奖励分为四块。1）通过配置 rules 来确认是否有奖励资格（首次）。2）清算出奖多少，奖给谁（通常会带上推荐人）（固定额，阶梯算法，比例值，vip 等级等）。3）创建出奖励执行类（红包、现金、抽奖券、积分等），并执行奖励。4）发送通知 （站内信、短信、微信、邮件 ） （通知会在通知里挂接广告）。离开那公司时特意查了一下，公司共发布了 1700 条个奖励项，给客户返利约 900 万。2019-11-04

1『原来经常听到的 DP 是设计模式的术语。』

做游戏开发相关的工作，日常用到非常多的设计模式，比如：1）对于游戏的设置，ui 和 scene 等等各种 manager 管理类都要用到单例模式。2）创建游戏中各种角色的各种工厂模式还有对象池。3）处理游戏角色的各种状态的有限状态机要用到状态模式。4）在优化复杂游戏场景时会用到享元模式。5）还有游戏引擎本身就用到的组件模式......2019-11-04

个人认为设计模式主要解决的是扩展和耦合问题。日常使用：1）使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦。a）事务的处理 @Translation。b）系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等。2）使用工厂 + 策略：a）不同优惠种类的计算。b）定制化功能的解耦。3）观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子。a）通过领域事件解耦业务。b）理解 eventloop、epoll 等等。c）通过 watch 实现动态配置、HA 等等。4）责任链模式：pipeline 思想。a）filter。b）理解 netty 中的各种 handler。2019-11-04

单例、工厂、模板、策略。基本的套路就是：单例的工厂类负责创建策略类，但是每个策略类都有共同特性，所以用到了模板模式。类关系就是每个策略类实现策略接口并继承模板类。交由单例的工厂来管理。也有人说这就是模板。跟策略没关，但我认为确实也是策略。场景：医疗系统，药品分为中药、西药、医疗器械等等不同类别，每种类别计算价格方式由相同的算法和不同的算法组成，所以我用了模板和策略。补充：其实最后我发现 spring 有依赖搜索，直接注入 map 就行了。完全不用自己写工厂管理。2019-11-04

老师能不能讲讲函数式编程思想，设计模式都是基于面向对象的，而现在更流行函数式编程。作者回复：函数式编程感觉还是没面向对象流行。2019-11-04

设计模式的重要性看法：1）可以使得代码编写更优雅。2）对学习一些开源框架有很大帮助。3）程序的可扩展性、维护性更好，系统解耦。基于上面的看法结合实际项目说明：1）在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。2）在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上 hook，具体步骤子类实现。3）责任链模式，在网关系统中用到的 filter 就是责任链模式，把一个请求依次的在过滤器链上进行传输。4）装饰器模式，在普通的微服务提供的 restful 接口中，在请求返回的时给对象添加一些额外的职责。5）门面设计模式，对外提供统一的接口，例如在 springcloud 中提供统一的 feinclient 接口，所有外部系统都通过 feinclient 接口进行接入，从而不关心内部接口的调用实现。6）还有命令设计模式，原来在看工作流的时候不知道这个模式，看的云里雾里，后来才知道原来整个框架用到了命令设计模式，一下子就明朗了很多。所以学习设计模式很重要。还有单例模式、工厂模式等，以上大概就是在工作中用到的设计模式，分享一下，如有不对请指正。2019-11-11

用到过模板模式，单例模式。1）模板模式应用场景：在一个项目的规则引擎中，一个规则引擎有一系列规则过滤，这个过滤步骤基本上是确定的，只是某些步骤在不同的场景下需要相互替换，模板方法定义了方法调用顺序，需要用到一个钩子，让子类去实现这个方法。模板模式解决问题：解决了以后可拓展的问题，如果以后需要在新场景下新增规则方法，只需新增一个类，实现钩子方法即可，不需改动既有代码。2）单例模式应用场景：用于加载项目中需要的配置文件的资源类。单例模式解决问题：解决了资源共用，避免创建出大量资源对象，节省了 JVM 内存资源。2019-11-04

使用经验：1）策略模式：解决开发、测试、预发布、生产环境不同的数据来源、不同的数据处理方式，以及不同的图片加载方式。2）建造者模式：网络通信协议，非常规意义上的 http 请求，更多是 Socket 通信，需要处理大量的参数传递、包装、解析。2019-11-05

## 0002从哪些维度评判代码质量的好坏.md

1、如何评价代码质量的高低？代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。

2、最常用的评价标准有哪几个？最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

3、如何才能写出高质量的代码？要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。

1『再加上测试驱动开发、领域驱动开发，哈哈。』

在我的工作经历中，每当同事评论起项目代码质量的时候，听到的最多的评语就是：「代码写得很烂」或者「代码写得很好」。用「好」「烂」这样的字眼来描述，非常地笼统。当我具体问到底如何烂、如何好的时候，尽管大部分同事都能简单地罗列上几个点，但往往都不够全面、非常零碎，也切不中要害。

当然，也有一些工程师对如何评价代码质量有所认识，比如，好代码是易扩展、易读、简单、易维护的等等，但他们对于这些评价的理解往往只停留在表面概念上，对于诸多更深入的问题，比如，怎么才算可读性好？什么样的代码才算易扩展、易维护？可读、可扩展与可维护之间有什么关系？可维护中「维护」两字该如何理解？等等，并没有太清晰的认识。

对于程序员来说，辨别代码写得「好」还是「烂」，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？所以，今天我们就聊一聊关于代码质量评判的相关问题，希望你在学完今天的内容之后，对代码质量的评判有个更加清晰、更加透彻的认识和理解。

### 2.1 如何评价代码质量的高低？

实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。

除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，我们不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值。

不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。比如，怎么样的代码才算可读性好，每个人的评判标准都不大一样。这就好比我们去评价一本小说写得是否精彩，本身就是一个很难量化的、非常主观的事情。

正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。相反，资历比较浅的工程师就常常会觉得，没有一个可执行的客观的评价标准作为参考，很难准确地判断一段代码写得好与坏。有的时候，自己觉得代码写得已经够好了，但实际上并不是。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。

### 2.2 最常用的评价标准有哪几个？

仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。为了做到有的放矢、有重点地学习，我挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。接下来，我们逐一讲解一下。

#### 2.2.1 可维护性（maintainability）

我们首先来看，什么是代码的「可维护性」？所谓的「维护代码」到底包含哪些具体工作？落实到编码开发，所谓的「维护」无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓「代码易维护」就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓「代码不易维护」就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。

我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修 bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。

实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的「好」「坏」「优雅」之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改 bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。

#### 2.2.2 可读性（readability）

软件设计大师 Martin Fowler 曾经说过：「Any fool can write code that a computer can understand. Good programmers write code that humans can understand.」Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。

我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。

既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。

2『提高可读性的方法：代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。可读性做一张术语卡片。』——已完成

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

#### 2.2.3 可扩展性（extensibility）

可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？

代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。关于代码的扩展性，在后面讲到「对修改关闭，对扩展开放」这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。

#### 2.2.4 灵活性（flexibility）

灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：「代码写得很灵活」。那这里的「灵活」该如何理解呢？

尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。1）当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。2）当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。3）当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。

从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。

#### 2.2.5 简洁性（simplicity）

有一条非常著名的设计原则，你一定听过，那就是 KISS 原则：「Keep It Simple，Stupid」。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。

不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。

除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合 KISS 原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到 KISS 原则的时候，我会通过具体的代码实例，详细给你解释，「为什么 KISS 原则看似非常简单、好理解，但实际上用好并不容易」。

#### 2.2.6 可复用性（reusability）

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到「可复用性」这一代码评价标准。比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。

实际上，代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到 DRY 设计原则的时候，我还会讲更多代码复用相关的知识，比如，「有哪些编程方法可以提高代码的复用性」等。

#### 2.2.7 可测试性（testability）

相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。

### 2.3 如何才能写出高质量的代码？

我相信每个工程师都想写出高质量的代码，不想一直写没有成长、被人吐槽的烂代码。那如何才能写出高质量的代码呢？针对什么是高质量的代码，我们刚刚讲到了七个最常用、最重要的评价指标。所以，问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。

比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

### 黑板墙

这块我一直没细分好，经常和同事开玩笑说「代码品味」（尊重大脑的特性，写出可便于维护的代码。程序 = 数据结构 + 算法，算法分 control 相关和 logic 相关。合理的把 control 相关与 logic 相关进行分离就是非常好的套路 ，时间久了，看到违和感重的代码就很敏感了，主要是要求别把代码写死写散，像 dry 等基础原则都没遵守的，烂用全局变量的，创建对象没用框架的 createObj 的，没支持依赖注入的，直接 code review 时会指出 ）。如何才能写出高质量的代码？做中学。我只说我自己，我在每完成一份工作后，都要拿出很大一部分时间来优化重构，自己改自己的代码。「主要套路来源，代码整洁之道，重构 - 改善即有代码设计」这算是我自律的一部分，我很珍惜工作中的开发实践。纯理论的东西学多了，人会飘飘乎乎的，需要实操来落地。2019-11-04

1『分离关注点，学会分离算法中的 control 部分和 logic部分。』

除了小争哥提到的七个评价标准，我认为还有一个评价标准：易 debug。在日常工作中，经常要追查各种线上 case，代码是否易于 debug，会非常影响工程师的追查效率。比如是否有打印详细的日志，是否有 debug 干涉点可以在 debug 模式下打印详细的线上请求信息便于快速定位问题。当然，这一点也可以放在可维护性中。2019-11-05

个人感觉，有的时候为了提高代码的可扩展性和可复用性就会抽象出好多的接口，类和方法。然后代码的简洁性和可读性就降低了。不知道我这样的感觉对不对？作者回复：是的，扩展性和可读性有的时候是相冲突的，后面会讲到的。2019-11-12

怎么感觉您说的可维护性和可拓展性是同一个东西，都是让未来修改某个功能，某个 bug 或者新增功能需求更简单？是不是维护性更针对于现有功能的维护修改，拓展性更针对与未来新增需求的修改？作者回复：扩展主要是指添加功能，维护更广些，添加、修改......可读性和可扩展性都影响到代码的可维护性。除此之外，这些判定标准本身就有点重合，文章中也提到了。2019-11-04

我对好代码理解：1）具备统一的代码规范：类、方法、变量命名达意；代码核心逻辑注释清晰；（可以遵循《阿里巴巴 Java 开发手册》）2）代码模块分层清晰：类似框架层面 controller、service、handler、mapper 各司其职。而在单独的业务开发中也应该借鉴，如争哥说的高内聚、低耦合的特点。3）每个方法代码不易过长，复杂的业务逻辑应该拆分成多个职责单一对方法，进而降低难度，也即保证可读性和灵活性。4）详尽的 wiki 文档和业务主流程图。很多互联网公司最流行的就是「口口相传」，对刚接锅的兄弟简直是场灾难，只能一点点啃代码，极大降低工作效率。5）单元测试 junit test。高质量代码必备，该点与第 2、第 3 点是息息相关。个人觉得能写出好的 junit test case 才能真正显示码代码功力。2019-11-07

## 0003面向对象设计原则设计模式编程规范重构的关系.md

在上一节课中，我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。而我们整个专栏的内容也是围绕着这几块展开讲解的。所以，今天我就先来简单介绍一下这几个概念，并且说一说它们之间的联系。

### 3.1 面向对象

现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

所以，在专栏的最开始，我们会详细地讲解面向对象编程的相关的知识，为学习后面的内容做铺垫。对于这部分内容，你需要掌握下面这 7 个大的知识点：1）面向对象的四大特性：封装、抽象、继承、多态。2）面向对象编程与面向过程编程的区别和联系。3）面向对象分析、面向对象设计、面向对象编程。4）接口和抽象类的区别以及各自的应用场景。5）基于接口而非实现编程的设计思想。6）多用组合少用继承的设计思想。7）面向过程的贫血模型和面向对象的充血模型。

### 3.2 设计原则

设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。

对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则：1）SOLID 原则 —— SRP 单一职责原则。2）SOLID 原则 —— OCP 开闭原则。3）SOLID 原则 —— LSP 里式替换原则。4）SOLID 原则 —— ISP 接口隔离原则。5）SOLID 原则 —— DIP 依赖倒置原则。6）DRY 原则、KISS 原则、YAGNI 原则、LOD 法则。

### 3.3 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。在专栏中，我们会重点讲解 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。

我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。

1、创建型。常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。不常用的有：原型模式。

2、结构型。常用的有：代理模式、桥接模式、装饰者模式、适配器模式。不常用的有：门面模式、组合模式、享元模式。

3、行为型。常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

### 3.4 编程规范

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。

对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的 20 条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。

除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。

### 3.5 代码重构

在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。

而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。

对于重构这部分内容，你需要掌握以下几个知识点：1）重构的目的（why）、对象（what）、时机（when）、方法（how）；2）保证重构不出错的技术手段：单元测试和代码的可测试性；3）两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

### 3.6 五者之间的联系

关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我们前面稍微提到了一些，我这里再总结梳理一下。

1、面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。

2、设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，「开闭原则」是很多设计模式（策略、模板等）的指导原则。

3、设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。

4、编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。

5、重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。

### 黑板墙

今天课堂讨论的话题有两个。1）在今天讲到的内容中，你觉得哪一部分内容对提高代码质量最有效？为什么？2）除了我罗列的这些内容之外，你还知道哪些可以提高代码质量的方法？我们知道，最经典的设计模式书籍是 GoF 的《设计模式》，它的中文全称是《设计模式：可复用面向对象软件的基础》，英文全称是「Design Patterns: Elements of Reusable Object-Oriented Software」。为什么它在标题中会特意提到「面向对象」呢？

函数是相对比较小的可复用单位。面向对象把可复用单位提升到类层次。设计模式把可复用单位提升到框架层次。2019-11-04

我觉得今年对我来说，是重新认识「面向对象」的一年。今年事我工作的第三年了，年初的时候误打误撞的学了一段时间的 DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是 MVC 三层架构的影响，太多人的代码里头只剩下了 pojo 这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。

在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的 java 面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。

在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：1）要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。2）以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。3）关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。4）别滥用继承，继承的作用更多的时候使用多态的特性。

关于 UML ：在工作的过程中，试着画过 UML 图，UML 图有着自己一条完整的语言和生态，学习成本还是相当高的，问题在于，即使用了标准的 UML 图，如果沟通过程中，对方不懂，也依然效果不大，所以我对 UML 的感觉就是：能看懂，会画基本的即可，没必要太追求标准化，虽然如此，但是 UML 还是很重要的，它的意义是提供一种面向对象设计的表达方式，是学习面向对象设计中不可缺少的一部分（个人理解）。2019-11-11

个人认为重构对提高代码质量最有效，原因：1）重构的基础就是面向对象、设计原则、设计模式、编程规范；2）重构是一个持续的过程，能够兼顾项目进度、项目开发效率和项目质量，既可以避免前期的过度设计，又能避免后期代码腐化，从而保证代码的质量不下降以致不断提高代码质量；3）通过单元测试等相关手段，保证重构的正确性。4）重构可从代码层次、项目阶段、开发周期、人员规模等不同纬度进行。其他提高代码质量的方法：1）阅读高质量框架代码，先模仿；2）代码 Review，定期总结；3）技术分享，倒逼输出，看了、做了都不如说给比人听更有效果；4）工具检查（如 lint、leakcanary 等），开发过程中避免常识性错误和隐藏问题。为什么它在标题中会特意提到「面向对象」呢？因为设计原则、设计模式实现大部分都是基于面向对象的特性（封装、抽象、继承、多态）实现的。2019-11-06

面向对象的特征也未必包含「继承」这一点吧，比如 Go 语言就没有提供「继承」这个特性，取而代之的是，推荐使用「组合」。但不能说它不支持面向对象编程。那么我们在探讨「面向对象」这个范式时，需要更深刻的去思考「面向对象」的本质是什么。而不是用 Java 中的概念来一以概之。2019-11-05

再好的理论，应用不到实际中也是白费。所以对于提升代码质量，最有效的是编码规范，其次是设计原则，再次是代码重构，最后才是面向对象和设计模式。整个排序是按照我理解的难易程度来进行的。一般一个项目都是多人开发，多人并行开发中，考虑到团队中技术水平不一，保持代码质量最好的方式就是先制定编码规范，大家最容易达成一致并遵守。其次是设计原则，因为它相对来讲更明确，违反设计原则基本等于硬伤，更容易得到认同。代码重构是需要长期去做的，甚至不是在开发过程中而是在维护过程中去做的，所以排在第三位。后面两项更多的要考虑实际情况，不同水平的人甚至相同水平的人都会有自己不同的理解，比较难以达成统一，项目排期足够还好，一旦排期不足，很可能在当时没那个成本去谈论这些。第二个问题老师已经回答了，因为面向对象的特性是其他的基石。建议老师在后续课程中，除了讨论如何提升自己的代码质量，也讨论一下在一个多人团队中如何提升团队的代码质量，有哪些比较好的手段可以去应用。包括在项目排期比较紧的时候，可以有哪些方式去保证代码质量。作者回复：嗯嗯，加餐里有讲到的。2019-11-15

编码规范和设计原则解决的是可读性和可维护性，而面向对象是一种设计方法或者说是一种抽象思维，更符合人类的思考方式，所以它们的属性偏向于静态的概念；代码重构和设计模式是一种动态的概念，是具体的执行方法，当然代码重构本身就包含了：编码规范，设计原则，设计模式。另外，面向对象和设计模式本身就有着紧密的联系，设计模式是解决特定问题的有效方法，是经验的总结。2019-11-06

从依赖关系上看，设计模式 & 编码规范依赖设计原则，设计原则依赖面向对象 | 面向过程 | 函数式编程，也就是面向对象这种设计思想是基础，作为工程师，我们直接打交道的是设计模式和编码规范，这是我们落地设计原则和面向对象设计思想的地方，看问题抓本质，那么我们讲面向对象编程到底在讲什么呢？我的理解是通过封装、继承、多态和抽象这些特性完整表达一件事情，可以是名词也可以是动词。直观的例子是如何把大象装进冰箱这个案例，面向过程是：1）打开冰箱；2）把大象装进去；3）把冰箱关上，依次完成这些过程就能把大象装进冰箱。好，我们看看面向对象怎么处理这个问题，1）冰箱你给我把门打开；2）冰箱你给我把大象装进去；3）冰箱你给我把门关上。看起来是否没啥区别，这里每个动作都多了执行者，也就是这里的冰箱，也就是冰箱会有三个功能：开门、装大象、关门，也就是每一个动作都必然会有一个执行者，执行者怎么产生呢？不就是对象本身么，冰箱是一个对象，大象也是一个对象，冰箱具有装大象的能力，怎么装呢，开门、装大象和关门啊！发现了么，面向对象隐藏了装大象的细节，冰箱的开门、装大象和关门都是对象本身的功能（方法），理解了面向对象后才能更好理解设计原则设计模式这些东西，这些都是一些写出高质量代码的经验总结，说白了就是套路，我理解设计原则可以帮助我们看懂一些开源框架的代码，学习 Apache 大佬们是怎么写代码的，从而内化为自己的能力。最后想说一点高质量代码的实践，多考虑异常和兜底场景，给代码留出足够的安全边际，所以说健壮性很重要啊。2020-02-14

对于重构，我有话（槽）要说（吐）：我是做企业项目外包的，我们给客户交付的项目大多在客户方面庞杂缺少弹性的 IT 合规性要求和业务快速变动的现实的双重夹击下痛苦地演进着。重构意味着不改变系统已有功能的情况下优化项目代码，但面临着合规性和流程的限制导致这类无业务功能更新的发布不会被甲方 IT 放行；另一方面不断的新需求的变更又不断地劣化着已有代码的系统架构以及业务代码的设计。不知道有没有面临同样问题的同学，在无法改变现有大环境的前提下进行有限的优化？我们现在能做的也就是在每一次追加的新需求变更时进行小幅度的改善，但这无法受到任何工作流程的保护和管理，仅能靠程序员个人的良心来做。另外，如何保证重构不会因为代码结构的变化引入新的 bug 呢？单元测试以及覆盖率较高的自动化测试吗？作者回复：单元测试是一个非常有效的手段，后面的章节中会讲到。2019-11-05

回答：1）针对第一个问题，我觉得重构挺重要的。看过《Head First 设计模式》，以及今天老师也说了，设计模式其实不是滥用，是有需要的时候用，不能过度使用。那这些判断从哪来，就是从一步步的重构而来。程序和功能都是从易到难，从简单到复杂，这就形成大家总结的设计模式，都是无数前人的经验总结。因为编码经验还不够，所以除了老师的这些讲解，我暂时还没想到其他更多的。2）面向对象，真是个神器的东西。因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。所以，很多时候编程就是对面向对象一个深刻运用的过程，我师傅就和我说，Java 开发，一切皆对象，我觉得到现在为止，还是挺在理的。2019-11-15

接口是对行为的抽象，是某一类行为所具有的共性或者需要遵循的标准，比如策略模式，定义了一组不同方式方法的抽象实现，而抽象类是是对公共行为的一种复用，将相同的逻辑，行为复用在抽象类中，比如模板模式，定义了公共实现，不同的实现延迟到子类当中去。个人感觉面向对象是一切设计原则设计模式的基础，依赖倒置与里氏替换依赖的的也是面向对象的抽象与多态，最开始上学的时候其实对编程感觉是懵懂的，也看过设计模式，当时看懂了，其实不会用，后来工作了才发现，当你自己主动的注意自己的代码，自己的逻辑，希望写的代码可复用，简单高效的时候，回过头来，这些已经是设计原则，设计模式了，再读这些文章或者书籍感觉更有味道了。2019-11-10

写单元测试是有效提高代码质量的一种方式。并且你在写出能够可测试，易于测试的代码的时候，已经在不断的修改你的代码。并且在编写各种测试用例的时候，你已经将各种边界条件或者特殊情况已经考虑进去了。最终的代码覆盖率也能提醒你哪些部分是还没有经过测试的。所以，写单元测试吧！2019-11-09

1『测试用例时考虑好边界条件以及各个特例。』

关于编码规范：阿里巴巴 java 开发规范，官方已提供了 idea、eclipse 插件，详情可以访问官方链接：[alibaba/p3c](https://github.com/alibaba/p3c/blob/master/README.md)。此外还有 FindBugs、PMDPlugin、CheckStyle、JavaNCSS、sonarlint，可以多管齐下，为你保驾护航。2019-11-08

2-3『文档的英文版：[Table of Contents | Alibaba-Java-Coding-Guidelines](https://alibaba.github.io/Alibaba-Java-Coding-Guidelines/)。作为本专栏的一个附件消化吸收。』